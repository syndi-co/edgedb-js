module.exports.syntax = {"dts":[{"path":"cardinality.d.ts","content":"import { Cardinality } from \"edgedb/dist/reflection/index\";\nimport type { TypeSet } from \"./typesystem\";\nexport declare namespace cardutil {\n    export type multiplyCardinalities<C1 extends Cardinality, C2 extends Cardinality> = C1 extends Cardinality.Empty ? Cardinality.Empty : C1 extends Cardinality.One ? C2 : C1 extends Cardinality.AtMostOne ? C2 extends Cardinality.One ? Cardinality.AtMostOne : C2 extends Cardinality.AtLeastOne ? Cardinality.Many : C2 : C1 extends Cardinality.Many ? C2 extends Cardinality.Empty ? Cardinality.Empty : Cardinality.Many : C1 extends Cardinality.AtLeastOne ? C2 extends Cardinality.AtMostOne ? Cardinality.Many : C2 extends Cardinality.One ? Cardinality.AtLeastOne : C2 : never;\n    export function multiplyCardinalities(c1: Cardinality, c2: Cardinality): Cardinality;\n    type _multiplyCardinalitiesVariadic<Cards extends [Cardinality, ...Cardinality[]]> = Cards extends [infer Card] ? Card : Cards extends [infer A, infer B, ...infer Rest] ? A extends Cardinality ? B extends Cardinality ? Rest extends Cardinality[] ? multiplyCardinalities<A, B> extends Cardinality ? _multiplyCardinalitiesVariadic<[\n        multiplyCardinalities<A, B>,\n        ...Rest\n    ]> : never : never : never : never : never;\n    export type multiplyCardinalitiesVariadic<Cards extends [Cardinality, ...Cardinality[]]> = _multiplyCardinalitiesVariadic<Cards> extends Cardinality ? _multiplyCardinalitiesVariadic<Cards> : never;\n    export function multiplyCardinalitiesVariadic<Cards extends [Cardinality, ...Cardinality[]]>(cards: Cards): multiplyCardinalitiesVariadic<Cards>;\n    export type mergeCardinalities<A extends Cardinality, B extends Cardinality> = A extends Cardinality.Empty ? B : B extends Cardinality.Empty ? A : A extends Cardinality.AtLeastOne ? Cardinality.AtLeastOne : B extends Cardinality.AtLeastOne ? Cardinality.AtLeastOne : A extends Cardinality.One ? Cardinality.AtLeastOne : B extends Cardinality.One ? Cardinality.AtLeastOne : Cardinality.Many;\n    export function mergeCardinalities<A extends Cardinality, B extends Cardinality>(a: A, b: B): mergeCardinalities<A, B>;\n    type _mergeCardinalitiesVariadic<Cards extends [Cardinality, ...Cardinality[]]> = Cards extends [infer Card] ? Card : Cards extends [infer A, infer B, ...infer Rest] ? A extends Cardinality ? B extends Cardinality ? Rest extends Cardinality[] ? mergeCardinalities<A, B> extends Cardinality ? _mergeCardinalitiesVariadic<[mergeCardinalities<A, B>, ...Rest]> : never : never : never : never : never;\n    export type mergeCardinalitiesVariadic<Cards extends [Cardinality, ...Cardinality[]]> = _mergeCardinalitiesVariadic<Cards> extends Cardinality ? _mergeCardinalitiesVariadic<Cards> : never;\n    export function mergeCardinalitiesVariadic<Cards extends [Cardinality, ...Cardinality[]]>(cards: Cards): mergeCardinalitiesVariadic<Cards>;\n    export type orCardinalities<C1 extends Cardinality, C2 extends Cardinality> = C1 extends C2 ? C1 : C1 extends Cardinality.Many ? C1 : C1 extends Cardinality.AtMostOne ? C2 extends Cardinality.Many ? C2 : C2 extends Cardinality.AtLeastOne ? Cardinality.Many : C1 : C1 extends Cardinality.AtLeastOne ? C2 extends Cardinality.One ? Cardinality.AtLeastOne : Cardinality.Many : C1 extends Cardinality.Empty ? C2 extends Cardinality.AtMostOne ? Cardinality.AtMostOne : C2 extends Cardinality.One ? Cardinality.AtMostOne : Cardinality.Many : C2 extends Cardinality.Empty ? Cardinality.AtMostOne : C2;\n    export function orCardinalities(c1: Cardinality, c2: Cardinality): Cardinality;\n    export type overrideLowerBound<C extends Cardinality, O extends \"One\" | \"Zero\"> = O extends \"One\" ? C extends Cardinality.Many ? Cardinality.AtLeastOne : C extends Cardinality.AtLeastOne ? Cardinality.AtLeastOne : Cardinality.One : C extends Cardinality.Empty ? Cardinality.Empty : C extends Cardinality.Many ? Cardinality.Many : C extends Cardinality.AtLeastOne ? Cardinality.Many : Cardinality.AtMostOne;\n    export function overrideLowerBound<C extends Cardinality, O extends \"One\" | \"Zero\">(card: C, override: O): overrideLowerBound<C, O>;\n    export type overrideUpperBound<C extends Cardinality, O extends \"One\" | \"Many\"> = O extends \"One\" ? C extends Cardinality.Many ? Cardinality.AtMostOne : C extends Cardinality.AtLeastOne ? Cardinality.One : C extends Cardinality.Empty ? Cardinality.AtMostOne : C : C extends Cardinality.One ? Cardinality.AtLeastOne : C extends Cardinality.AtMostOne ? Cardinality.Many : C extends Cardinality.Empty ? Cardinality.Many : C;\n    export function overrideUpperBound<C extends Cardinality, O extends \"One\" | \"Many\">(card: C, override: O): overrideUpperBound<C, O>;\n    export type paramCardinality<P> = [P] extends [TypeSet] ? [\n        Cardinality\n    ] extends [P[\"__cardinality__\"]] ? Cardinality.One : P[\"__cardinality__\"] : Cardinality.One;\n    export type optionalParamCardinality<P> = overrideLowerBound<paramCardinality<P>, \"One\">;\n    type _paramArrayCardinality<T> = {\n        [K in keyof T]: T[K] extends TypeSet ? T[K][\"__cardinality__\"] : Cardinality.One;\n    };\n    export type paramArrayCardinality<T extends [any, ...any[]]> = multiplyCardinalitiesVariadic<_paramArrayCardinality<T>>;\n    export type assignable<C extends Cardinality> = C extends Cardinality.Empty ? Cardinality.Empty : C extends Cardinality.One ? Cardinality.One : C extends Cardinality.AtMostOne ? Cardinality.One | Cardinality.AtMostOne | Cardinality.Empty : C extends Cardinality.AtLeastOne ? Cardinality.One | Cardinality.AtLeastOne | Cardinality.Many : C extends Cardinality.Many ? Cardinality : never;\n    export {};\n}\n"},{"path":"cast.d.ts","content":"import { ExpressionKind, Cardinality } from \"edgedb/dist/reflection/index\";\nimport type { Expression, BaseType, TypeSet, ObjectTypeExpression } from \"./typesystem\";\nimport type { orScalarLiteral } from \"./castMaps\";\nexport declare function cast<Target extends BaseType | ObjectTypeExpression>(target: Target, arg: null): $expr_Cast<Target extends BaseType ? Target : Target extends ObjectTypeExpression ? Target[\"__element__\"] : never, Cardinality.Empty>;\nexport declare function cast<Target extends BaseType, Expr extends TypeSet>(target: Target, expr: orScalarLiteral<Expr>): $expr_Cast<Target, Cardinality extends Expr[\"__cardinality__\"] ? Cardinality.One : Expr[\"__cardinality__\"]>;\nexport type $expr_Cast<Target extends BaseType = BaseType, Card extends Cardinality = Cardinality> = Expression<{\n    __element__: Target;\n    __cardinality__: Card;\n    __kind__: ExpressionKind.Cast;\n    __expr__: TypeSet | null;\n}>;\n"},{"path":"casting.d.ts","content":"import type { Cardinality } from \"edgedb/dist/reflection/index\";\nimport type { ArrayType, BaseType, BaseTypeTuple, BaseTypeToTsType, EnumType, LinkDesc, NamedTupleType, ObjectType, ObjectTypeSet, PrimitiveTypeSet, PropertyDesc, ScalarType, TupleType, TypeSet, RangeType, MultiRangeType } from \"./typesystem\";\nimport type { cardutil } from \"./cardinality\";\nimport type { scalarCastableFrom, scalarAssignableBy } from \"./castMaps\";\nexport type anonymizeObject<T extends ObjectType> = ObjectType<string, T[\"__pointers__\"], any>;\ntype assignableTuple<Items extends BaseTypeTuple> = {\n    [k in keyof Items]: Items[k] extends BaseType ? assignableBy<Items[k]> : never;\n} extends infer NewItems ? NewItems extends BaseTypeTuple ? NewItems : never : never;\nexport type assignableBy<T extends BaseType> = T extends ScalarType ? scalarAssignableBy<T> : T extends ObjectType ? anonymizeObject<T> : T extends EnumType ? T : T extends ArrayType ? ArrayType<assignableBy<T[\"__element__\"]>> : T extends TupleType ? TupleType<assignableTuple<T[\"__items__\"]>> : T extends NamedTupleType ? NamedTupleType<{\n    [k in keyof T[\"__shape__\"]]: assignableBy<T[\"__shape__\"][k]>;\n}> : T extends RangeType ? RangeType<scalarAssignableBy<T[\"__element__\"]> extends ScalarType ? scalarAssignableBy<T[\"__element__\"]> : never> : T extends MultiRangeType ? MultiRangeType<scalarAssignableBy<T[\"__element__\"]> extends ScalarType ? scalarAssignableBy<T[\"__element__\"]> : never> : never;\nexport type pointerToAssignmentExpression<Pointer extends PropertyDesc | LinkDesc, IsSetModifier extends boolean = false> = setToAssignmentExpression<TypeSet<Pointer[\"target\"], Pointer[\"cardinality\"]>, IsSetModifier>;\nexport type setToAssignmentExpression<Set extends TypeSet, IsSetModifier extends boolean> = [Set] extends [PrimitiveTypeSet] ? TypeSet<assignableBy<Set[\"__element__\"]>, cardutil.assignable<cardutil.overrideLowerBound<Set[\"__cardinality__\"], \"Zero\">>> | getAssignmentLiteral<Set, IsSetModifier> : [Set] extends [ObjectTypeSet] ? TypeSet<ObjectType<string, Set[\"__element__\"][\"__pointers__\"]>, cardutil.assignable<cardutil.overrideLowerBound<Set[\"__cardinality__\"], \"Zero\">>> : never;\ntype getAssignmentLiteral<Set extends PrimitiveTypeSet, IsSetModifier extends boolean> = BaseTypeToTsType<Set[\"__element__\"]> extends infer TsType ? TsType | (Set[\"__cardinality__\"] extends Cardinality.Many ? TsType[] : Set[\"__cardinality__\"] extends Cardinality.AtLeastOne ? IsSetModifier extends true ? TsType[] : [TsType, ...TsType[]] : never) : never;\ntype castableTuple<Items extends BaseTypeTuple> = {\n    [k in keyof Items]: Items[k] extends BaseType ? castableFrom<Items[k]> : never;\n} extends infer NewItems ? NewItems extends BaseTypeTuple ? NewItems : never : never;\nexport type castableFrom<T extends BaseType> = T extends ScalarType ? scalarCastableFrom<T> : T extends ObjectType ? anonymizeObject<T> : T extends ArrayType ? ArrayType<castableFrom<T[\"__element__\"]>> : T extends TupleType ? TupleType<castableTuple<T[\"__items__\"]>> : T extends NamedTupleType ? NamedTupleType<{\n    [k in keyof T[\"__shape__\"]]: castableFrom<T[\"__shape__\"][k]>;\n}> : never;\nexport type pointerToCastableExpression<Pointer extends PropertyDesc | LinkDesc> = [Pointer] extends [PropertyDesc] ? {\n    __element__: castableFrom<Pointer[\"target\"]>;\n    __cardinality__: cardutil.assignable<Pointer[\"cardinality\"]>;\n} : [Pointer] extends [LinkDesc] ? TypeSet<ObjectType<string, Pointer[\"target\"][\"__pointers__\"]>, cardutil.assignable<Pointer[\"cardinality\"]>> : never;\nexport {};\n"},{"path":"castMaps.d.ts","content":"export type scalarCastableFrom<T extends any> = any;\nexport type scalarAssignableBy<T extends any> = any;\nexport type orScalarLiteral<T extends any> = any;\nexport type scalarLiterals = any;\nexport type literalToScalarType<T extends any> = any;\ntype literalToTypeSet<T extends any> = any;\nexport type mapLiteralToTypeSet<T> = {\n    [k in keyof T]: literalToTypeSet<T[k]>;\n};\ndeclare function literalToTypeSet(t: any): any;\nexport { literalToTypeSet };\nexport declare function isImplicitlyCastableTo(from: string, to: string): boolean;\nexport declare function getSharedParentScalar(a: any, b: any): any;\nexport type getSharedParentScalar<A, B> = any;\n"},{"path":"collections.d.ts","content":"import { type typeutil } from \"edgedb/dist/reflection/index\";\nimport { cardutil } from \"./cardinality\";\nimport type { $expr_Array, $expr_NamedTuple, $expr_Tuple, ArrayType, BaseType, getPrimitiveBaseType, NamedTupleShape, NamedTupleType, NonArrayType, ObjectTypeExpression, ObjectTypePointers, PropertyDesc, TupleType, TypeSet } from \"./typesystem\";\nimport { type ExpressionRoot } from \"./path\";\nimport type { getCardsFromExprs } from \"./set\";\nimport { type literalToScalarType, type mapLiteralToTypeSet, type orScalarLiteral, type scalarLiterals } from \"./castMaps\";\nexport declare function $arrayLikeIndexify(_expr: ExpressionRoot): any;\nexport declare function array<Element extends NonArrayType>(element: Element): ArrayType<Element>;\nexport declare function array<Expr extends TypeSet<NonArrayType> | scalarLiterals, Exprs extends orScalarLiteral<TypeSet<Expr extends TypeSet ? getPrimitiveBaseType<Expr[\"__element__\"]> : getPrimitiveBaseType<literalToScalarType<Expr>>>>[]>(arg: [Expr, ...Exprs]): $expr_Array<ArrayType<Expr extends TypeSet ? getPrimitiveBaseType<Expr[\"__element__\"]> : getPrimitiveBaseType<literalToScalarType<Expr>>>, cardutil.multiplyCardinalitiesVariadic<getCardsFromExprs<mapLiteralToTypeSet<[Expr, ...Exprs]>>>>;\nexport declare function $tuplePathify(expr: ExpressionRoot): ExpressionRoot;\nexport declare function tuple<Items extends typeutil.tupleOf<BaseType>>(items: Items): TupleType<Items>;\nexport declare function tuple<Item extends TypeSet | scalarLiterals, Items extends typeutil.tupleOf<TypeSet | scalarLiterals>>(items: Items): $expr_Tuple<Items extends typeutil.tupleOf<any> ? mapLiteralToTypeSet<Items> : never>;\nexport declare function tuple<Shape extends NamedTupleShape>(shape: Shape): NamedTupleType<Shape>;\nexport declare function tuple<Shape extends {\n    [k: string]: TypeSet | scalarLiterals;\n}>(shape: Shape): $expr_NamedTuple<mapLiteralToTypeSet<Shape>>;\ntype PropertyNamesFromPointers<Pointers extends ObjectTypePointers> = {\n    [k in keyof Pointers as Pointers[k] extends PropertyDesc ? Pointers[k][\"computed\"] extends true ? never : k : never]: Pointers[k];\n};\nexport declare function $objectTypeToTupleType<Expr extends ObjectTypeExpression>(objectType: Expr): PropertyNamesFromPointers<Expr[\"__element__\"][\"__pointers__\"]> extends infer Pointers ? Pointers extends ObjectTypePointers ? NamedTupleType<{\n    [k in keyof Pointers as k extends \"id\" ? never : k]: Pointers[k][\"target\"];\n}> : never : never;\nexport declare function $objectTypeToTupleType<Expr extends ObjectTypeExpression, Fields extends keyof PropertyNamesFromPointers<Expr[\"__element__\"][\"__pointers__\"]>>(objectType: Expr, includeFields: Fields[]): NamedTupleType<{\n    [k in Fields]: Expr[\"__element__\"][\"__pointers__\"][k] extends PropertyDesc ? Expr[\"__element__\"][\"__pointers__\"][k][\"target\"] : never;\n}>;\nexport {};\n"},{"path":"detached.d.ts","content":"import { ExpressionKind } from \"edgedb/dist/reflection/index\";\nimport type { Expression, TypeSet } from \"./typesystem\";\nexport declare function detached<Expr extends TypeSet>(expr: Expr): $expr_Detached<Expr>;\nexport type $expr_Detached<Expr extends TypeSet = TypeSet> = Expression<{\n    __element__: Expr[\"__element__\"];\n    __cardinality__: Expr[\"__cardinality__\"];\n    __kind__: ExpressionKind.Detached;\n    __expr__: TypeSet;\n}>;\n"},{"path":"external.d.ts","content":"import type { TypeSet, setToTsType } from \"./typesystem\";\nexport { literal } from \"./literal\";\nexport {} from \"./path\";\nexport { set } from \"./set\";\nexport { cast } from \"./cast\";\nexport { ASC, DESC, EMPTY_FIRST, EMPTY_LAST, is, delete, select, } from \"./select\";\nexport { update } from \"./update\";\nexport { insert } from \"./insert\";\nexport { array, tuple, $objectTypeToTupleType as objectTypeToTupleType, } from \"./collections\";\nexport {} from \"./funcops\";\nexport { for } from \"./for\";\nexport { alias, with } from \"./with\";\nexport { optional, params } from \"./params\";\nexport { detached } from \"./detached\";\nexport {} from \"./toEdgeQL\";\nexport type $infer<A extends TypeSet> = setToTsType<A>;\n"},{"path":"for.d.ts","content":"import { Cardinality, ExpressionKind } from \"edgedb/dist/reflection/index\";\nimport { cardutil } from \"./cardinality\";\nimport type { Expression, BaseType, BaseTypeSet } from \"./typesystem\";\nexport type $expr_For<El extends BaseType = BaseType, Card extends Cardinality = Cardinality> = Expression<{\n    __element__: El;\n    __cardinality__: Card;\n    __kind__: ExpressionKind.For;\n    __iterSet__: BaseTypeSet;\n    __forVar__: $expr_ForVar;\n    __expr__: BaseTypeSet;\n}>;\nexport type $expr_ForVar<Type extends BaseType = BaseType> = Expression<{\n    __element__: Type;\n    __cardinality__: Cardinality.One;\n    __kind__: ExpressionKind.ForVar;\n}>;\ndeclare function _for<IteratorSet extends BaseTypeSet, Expr extends BaseTypeSet>(set: IteratorSet, expr: (variable: $expr_ForVar<IteratorSet[\"__element__\"]>) => Expr): $expr_For<Expr[\"__element__\"], cardutil.multiplyCardinalities<IteratorSet[\"__cardinality__\"], Expr[\"__cardinality__\"]>>;\nexport { _for as for };\n"},{"path":"funcops.d.ts","content":"import { Cardinality, type introspect } from \"edgedb/dist/reflection/index\";\nimport type { BaseType, BaseTypeSet, TypeSet, Expression } from \"./typesystem\";\nimport type { ExpressionKind, OperatorKind } from \"edgedb/dist/reflection/index\";\nexport type $expr_Function<El extends BaseType = BaseType, Card extends Cardinality = Cardinality> = Expression<{\n    __element__: El;\n    __cardinality__: Card;\n    __kind__: ExpressionKind.Function;\n    __name__: string;\n    __args__: (BaseTypeSet | undefined)[];\n    __namedargs__: {\n        [key: string]: BaseTypeSet;\n    };\n}>;\nexport type $expr_Operator<El extends BaseType = BaseType, Card extends Cardinality = Cardinality> = Expression<{\n    __element__: El;\n    __cardinality__: Card;\n    __kind__: ExpressionKind.Operator;\n    __name__: string;\n    __opkind__: OperatorKind;\n    __args__: TypeSet[];\n}>;\ninterface OverloadFuncArgDef {\n    typeId: string;\n    optional?: boolean;\n    setoftype?: boolean;\n    variadic?: boolean;\n}\ninterface OverloadFuncDef {\n    kind?: string;\n    args: OverloadFuncArgDef[];\n    namedArgs?: {\n        [key: string]: OverloadFuncArgDef;\n    };\n    returnTypeId: string;\n    returnTypemod?: \"SetOfType\" | \"OptionalType\";\n    preservesOptionality?: boolean;\n}\nexport declare function $resolveOverload(funcName: string, args: any[], typeSpec: introspect.Types, funcDefs: OverloadFuncDef[]): {\n    kind?: string | undefined;\n    returnType: BaseType;\n    cardinality: Cardinality;\n    args: BaseTypeSet[];\n    namedArgs: {\n        [key: string]: BaseTypeSet;\n    };\n};\nexport {};\n"},{"path":"globals.d.ts","content":"import { ExpressionKind, Cardinality } from \"edgedb/dist/reflection/index\";\nimport type { Expression, BaseType } from \"./typesystem\";\nexport declare function makeGlobal<Type extends BaseType, Card extends Cardinality>(name: string, type: Type, card: Card): $expr_Global<Type, Card>;\nexport type $expr_Global<Type extends BaseType = BaseType, Card extends Cardinality = Cardinality> = Expression<{\n    __name__: string;\n    __element__: Type;\n    __cardinality__: Card;\n    __kind__: ExpressionKind.Global;\n}>;\n"},{"path":"group.d.ts","content":"import type { Expression, ObjectType, ObjectTypeSet, TypeSet, BaseType, $scopify, PropertyDesc, LinkDesc } from \"./typesystem\";\nimport { Cardinality, ExpressionKind } from \"edgedb/dist/reflection/index\";\nimport type { $FreeObjectλShape, $str } from \"./modules/std\";\nimport type { normaliseShape, objectTypeToSelectShape } from \"./select\";\ntype SingletonSet = Expression<TypeSet<BaseType, Cardinality.One | Cardinality.AtMostOne>>;\ntype SimpleGroupElements = {\n    [k: string]: SingletonSet;\n};\ntype GroupModifiers = {\n    by: SimpleGroupElements;\n};\ntype NestedGroupElements = {\n    [k: string]: SingletonSet | GroupingSet;\n};\nexport type GroupingSet = {\n    __kind__: \"groupingset\";\n    __settype__: \"set\" | \"tuple\" | \"rollup\" | \"cube\";\n    __elements__: NestedGroupElements;\n    __exprs__: [string, SingletonSet][];\n};\nexport declare function isGroupingSet(arg: any): arg is GroupingSet;\ndeclare const setFuncs: {\n    set: <T extends SimpleGroupElements>(grps: T) => { [k in keyof T]?: T[k] | undefined; };\n    tuple: <T extends SimpleGroupElements>(grps: T) => { [k in keyof T]?: T[k] | undefined; };\n    rollup: <T extends SimpleGroupElements>(grps: T) => { [k in keyof T]?: T[k] | undefined; };\n    cube: <T extends SimpleGroupElements>(grps: T) => { [k in keyof T]?: T[k] | undefined; };\n};\nexport type $expr_Group<Expr extends ObjectTypeSet = ObjectTypeSet, Mods extends GroupModifiers = GroupModifiers, Shape extends object = {\n    id: true;\n}> = Expression<{\n    __element__: ObjectType<\"std::FreeObject\", $FreeObjectλShape & {\n        grouping: PropertyDesc<$str, Cardinality.Many, false, true, true, false>;\n        key: LinkDesc<ObjectType<\"std::FreeObject\", {\n            [k in keyof Mods[\"by\"]]: Mods[\"by\"][k][\"__element__\"] extends ObjectType ? never : PropertyDesc<Mods[\"by\"][k][\"__element__\"], Cardinality.AtMostOne>;\n        }>, Cardinality.One, {}, false, true, true, false>;\n        elements: LinkDesc<Expr[\"__element__\"], Cardinality.Many, {}, false, true, true, false>;\n    }, {\n        grouping: TypeSet<$str, Cardinality.Many>;\n        key: Expression<{\n            __element__: ObjectType<\"std::FreeObject\", $FreeObjectλShape, {\n                [k in keyof Mods[\"by\"]]: Expression<{\n                    __element__: Mods[\"by\"][k][\"__element__\"];\n                    __cardinality__: Cardinality.AtMostOne;\n                }>;\n            }>;\n            __cardinality__: Cardinality.One;\n        }>;\n        elements: Expression<{\n            __element__: ObjectType<Expr[\"__element__\"][\"__name__\"], Expr[\"__element__\"][\"__pointers__\"], normaliseShape<Shape, \"by\">>;\n            __cardinality__: Cardinality.Many;\n        }>;\n    }>;\n    __cardinality__: Cardinality.Many;\n    __modifiers__: Mods;\n    __kind__: ExpressionKind.Group;\n    __expr__: ObjectTypeSet;\n    __scope__: ObjectTypeSet;\n}>;\ntype noUndefined<T> = T extends undefined ? never : T;\ntype groupFunc = <Expr extends ObjectTypeSet, Shape extends {\n    by?: SimpleGroupElements;\n} & objectTypeToSelectShape<Expr[\"__element__\"]>>(expr: Expr, getter: (arg: $scopify<Expr[\"__element__\"]>) => Readonly<Shape>) => $expr_Group<Expr, {\n    by: noUndefined<Shape[\"by\"]>;\n}, normaliseShape<Shape, \"by\">>;\ndeclare const groupFunc: groupFunc;\nexport declare const group: typeof setFuncs & groupFunc;\nexport {};\n"},{"path":"hydrate.d.ts","content":"import type { $ } from \"edgedb\";\nimport type { BaseType, ObjectType, ObjectTypePointers, TupleType } from \"./typesystem\";\nimport type { typeutil } from \"edgedb/dist/reflection/index\";\nexport declare function makeType<T extends BaseType>(spec: $.introspect.Types, id: string, literal: any, anytype?: BaseType): T;\nexport type mergeObjectShapes<A extends ObjectTypePointers, B extends ObjectTypePointers> = typeutil.flatten<{\n    [k in keyof A & keyof B]: A[k] extends B[k] ? B[k] extends A[k] ? A[k] : never : never;\n}>;\nexport type mergeObjectTypes<A extends ObjectType | undefined, B extends ObjectType | undefined> = A extends ObjectType ? B extends ObjectType ? ObjectType<`${A[\"__name__\"]} UNION ${B[\"__name__\"]}`, mergeObjectShapes<A[\"__pointers__\"], B[\"__pointers__\"]>, null> : A : B extends ObjectType ? B : undefined;\nexport declare function $mergeObjectTypes<A extends ObjectType, B extends ObjectType>(a: A, b: B): mergeObjectTypes<A, B>;\nexport declare function $mergeTupleTypes<A extends TupleType, B extends TupleType>(a: A, b: B): TupleType;\n"},{"path":"insert.d.ts","content":"import { Cardinality, ExpressionKind, type typeutil } from \"edgedb/dist/reflection/index\";\nimport type { Expression, LinkDesc, ObjectTypeSet, ObjectTypePointers, PropertyDesc, stripBacklinks, stripNonInsertables, $scopify, stripSet, TypeSet, ObjectType } from \"./typesystem\";\nimport type { pointerToAssignmentExpression } from \"./casting\";\nimport type { $expr_PathNode } from \"./path\";\nimport type { $Object } from \"./modules/std\";\nimport type { scalarLiterals } from \"./castMaps\";\nexport type pointerIsOptional<T extends PropertyDesc | LinkDesc> = T[\"cardinality\"] extends Cardinality.Many | Cardinality.Empty | Cardinality.AtMostOne ? true : false;\nexport type InsertShape<El extends ObjectType> = typeutil.flatten<RawInsertShape<El>>;\nexport type RawInsertShape<El extends ObjectType> = ObjectType extends El ? never : typeutil.stripNever<stripNonInsertables<stripBacklinks<El[\"__pointers__\"]>>> extends infer Shape ? Shape extends ObjectTypePointers ? typeutil.addQuestionMarks<{\n    [k in keyof Shape]: pointerToAssignmentExpression<Shape[k]> | (pointerIsOptional<Shape[k]> extends true ? undefined | null : never) | (Shape[k][\"hasDefault\"] extends true ? undefined : never);\n}> & {\n    [k in `@${string}`]: TypeSet | scalarLiterals;\n} : never : never;\ninterface UnlessConflict {\n    on: TypeSet | null;\n    else?: TypeSet;\n}\ntype InsertBaseExpression<Root extends TypeSet = TypeSet> = {\n    __kind__: ExpressionKind.Insert;\n    __element__: Root[\"__element__\"];\n    __cardinality__: Cardinality.One;\n    __expr__: stripSet<Root>;\n    __shape__: any;\n};\nexport type $expr_Insert<El extends ObjectType = ObjectType> = Expression<{\n    __kind__: ExpressionKind.Insert;\n    __element__: El;\n    __cardinality__: Cardinality.One;\n    __expr__: $expr_PathNode;\n    __shape__: InsertShape<El>;\n    unlessConflict(): $expr_InsertUnlessConflict<El, {\n        on: null;\n    }>;\n    unlessConflict<Conflict extends UnlessConflict>(conflictGetter: (scope: $scopify<El>) => Conflict): $expr_InsertUnlessConflict<El, Conflict>;\n}>;\nexport type $expr_InsertUnlessConflict<El extends ObjectType = ObjectType, Conflict extends UnlessConflict = UnlessConflict> = Expression<{\n    __kind__: ExpressionKind.InsertUnlessConflict;\n    __element__: Conflict[\"else\"] extends TypeSet ? Conflict[\"else\"][\"__element__\"][\"__name__\"] extends El[\"__name__\"] ? El : $Object : El;\n    __cardinality__: Conflict[\"else\"] extends TypeSet ? Conflict[\"else\"][\"__cardinality__\"] : Cardinality.AtMostOne;\n    __expr__: InsertBaseExpression;\n    __conflict__: Conflict;\n}>;\nexport declare function $insertify(expr: Omit<$expr_Insert, \"unlessConflict\">): $expr_Insert;\nexport declare function $normaliseInsertShape(root: ObjectTypeSet, shape: {\n    [key: string]: any;\n}, isUpdate?: boolean): {\n    [key: string]: TypeSet | {\n        \"+=\": TypeSet;\n    } | {\n        \"-=\": TypeSet;\n    };\n};\nexport declare function insert<Root extends $expr_PathNode>(root: Root, shape: InsertShape<Root[\"__element__\"]>): $expr_Insert<Root[\"__element__\"]>;\nexport {};\n"},{"path":"json.d.ts","content":"export declare function jsonifyComplexParams(expr: any, _args: any): any;\n"},{"path":"literal.d.ts","content":"import type { Expression, BaseType, BaseTypeToTsType, ScalarType } from \"./typesystem\";\nimport { Cardinality, ExpressionKind } from \"edgedb/dist/reflection/index\";\nexport type $expr_Literal<Type extends BaseType = BaseType> = Expression<{\n    __element__: Type;\n    __cardinality__: Cardinality.One;\n    __kind__: ExpressionKind.Literal;\n    __value__: any;\n}>;\nexport declare function literal<T extends BaseType>(type: T, value: BaseTypeToTsType<T>): $expr_Literal<T>;\nexport declare const $nameMapping: Map<string, string>;\nexport declare function $getType(id: string): (val: any) => $expr_Literal<ScalarType>;\nexport declare function $getTypeByName(name: string): (val: any) => $expr_Literal<ScalarType>;\n"},{"path":"operators.d.ts","content":"export declare function op(...args: any[]): any;\n"},{"path":"params.d.ts","content":"import type { Executor } from \"edgedb\";\nimport { ExpressionKind, Cardinality } from \"edgedb/dist/reflection/index\";\nimport type { Expression, ParamType, setToTsType, TypeSet, BaseTypeToTsType } from \"./typesystem\";\ntype Param = ParamType | $expr_OptionalParam;\ntype ParamsRecord = Record<string, Param>;\nexport type $expr_OptionalParam<Type extends ParamType = ParamType> = {\n    __kind__: ExpressionKind.OptionalParam;\n    __type__: Type;\n};\nexport declare function optional<Type extends ParamType>(type: Type): $expr_OptionalParam<Type>;\nexport type QueryableWithParamsExpression<Set extends TypeSet = TypeSet, Params extends ParamsRecord = Record<string, never>> = Expression<Set, false> & {\n    run(cxn: Executor, args: paramsToParamArgs<Params>): Promise<setToTsType<Set>>;\n    runJSON(cxn: Executor, args: paramsToParamArgs<Params>): Promise<string>;\n};\nexport type $expr_WithParams<Params extends ParamsRecord = Record<string, never>, Expr extends TypeSet = TypeSet> = QueryableWithParamsExpression<{\n    __kind__: ExpressionKind.WithParams;\n    __element__: Expr[\"__element__\"];\n    __cardinality__: Expr[\"__cardinality__\"];\n    __expr__: Expr;\n    __params__: $expr_Param[];\n}, Params>;\ntype paramsToParamArgs<Params extends ParamsRecord> = {\n    [key in keyof Params as Params[key] extends ParamType ? key : never]: Params[key] extends ParamType ? Readonly<BaseTypeToTsType<Params[key], true>> : never;\n} & {\n    [key in keyof Params as Params[key] extends $expr_OptionalParam ? key : never]?: Params[key] extends $expr_OptionalParam ? Readonly<BaseTypeToTsType<Params[key][\"__type__\"], true> | null> : never;\n};\nexport type $expr_Param<Name extends string | number | symbol = string, Type extends ParamType = ParamType, Optional extends boolean = boolean> = Expression<{\n    __kind__: ExpressionKind.Param;\n    __element__: Type;\n    __cardinality__: Optional extends true ? Cardinality.AtMostOne : Cardinality.One;\n    __name__: Name;\n    __isComplex__: boolean;\n}>;\ntype paramsToParamExprs<Params extends ParamsRecord> = {\n    [key in keyof Params]: Params[key] extends $expr_OptionalParam ? $expr_Param<key, Params[key][\"__type__\"], true> : Params[key] extends ParamType ? $expr_Param<key, Params[key], false> : never;\n};\nexport declare function params<Params extends ParamsRecord = Record<string, never>, Expr extends Expression = Expression>(paramsDef: Params, expr: (params: paramsToParamExprs<Params>) => Expr): $expr_WithParams<Params, Expr>;\nexport {};\n"},{"path":"path.d.ts","content":"import { ExpressionKind, Cardinality, type typeutil } from \"edgedb/dist/reflection/index\";\nimport { cardutil } from \"./cardinality\";\nimport type { BaseType, Expression, LinkDesc, ObjectType, ObjectTypePointers, ObjectTypeSet, PropertyDesc, PropertyShape, TypeSet } from \"./typesystem\";\ntype getChildOfObjectTypeSet<Root extends ObjectTypeSet, ChildKey extends keyof Root[\"__element__\"][\"__pointers__\"]> = TypeSet<Root[\"__element__\"][\"__pointers__\"][ChildKey][\"target\"], cardutil.multiplyCardinalities<Root[\"__cardinality__\"], Root[\"__element__\"][\"__pointers__\"][ChildKey][\"cardinality\"]>>;\nexport interface PathParent<Parent extends ObjectTypeSet = ObjectTypeSet, L extends string = string> {\n    type: Parent;\n    linkName: L;\n}\nexport type $linkPropify<Root extends ObjectTypeSet> = Root extends {\n    __parent__: PathParent<infer Parent, infer L>;\n} ? Parent[\"__element__\"][\"__pointers__\"][L] extends LinkDesc<any, any, infer LinkProps, any, any, any, any> ? pathifyLinkProps<LinkProps, Root, PathParent<Parent, L>> : {} : unknown;\nexport type $pathify<Root extends TypeSet> = Root extends ObjectTypeSet ? ObjectTypeSet extends Root ? {} : pathifyPointers<Root> & pathifyShape<Root> & $linkPropify<Root> : {};\nexport type pathifyPointers<Root extends ObjectTypeSet> = ObjectTypePointers extends Root[\"__element__\"][\"__pointers__\"] ? unknown : {\n    [k in keyof Root[\"__element__\"][\"__pointers__\"] & string]: Root[\"__element__\"][\"__pointers__\"][k] extends PropertyDesc ? $expr_PathLeaf<getChildOfObjectTypeSet<Root, k>, {\n        type: anonymizeObjectTypeSet<Root>;\n        linkName: k;\n    }> : Root[\"__element__\"][\"__pointers__\"][k] extends LinkDesc ? getChildOfObjectTypeSet<Root, k> extends ObjectTypeSet ? $expr_PathNode<getChildOfObjectTypeSet<Root, k>, {\n        type: anonymizeObjectTypeSet<Root>;\n        linkName: k;\n    }> : unknown : unknown;\n};\ntype anonymizeObjectTypeSet<T extends ObjectTypeSet> = typeutil.flatten<{\n    __element__: ObjectType<T[\"__element__\"][\"__name__\"], T[\"__element__\"][\"__pointers__\"], {\n        id: true;\n    }>;\n    __cardinality__: T[\"__cardinality__\"];\n}>;\nexport type pathifyShape<Root extends ObjectTypeSet, Shape extends {\n    [k: string]: any;\n} = Root[\"__element__\"][\"__shape__\"]> = string extends keyof Shape ? {} : {\n    [k in keyof Shape & string]: Shape[k] extends ObjectTypeSet ? $expr_PathNode<TypeSet<Shape[k][\"__element__\"], cardutil.multiplyCardinalities<Root[\"__cardinality__\"], Shape[k][\"__cardinality__\"]>>, {\n        type: Root;\n        linkName: k;\n    }> : Shape[k] extends TypeSet ? $expr_PathLeaf<TypeSet<Shape[k][\"__element__\"], cardutil.multiplyCardinalities<Root[\"__cardinality__\"], Shape[k][\"__cardinality__\"]>>, {\n        type: Root;\n        linkName: k;\n    }> : unknown;\n};\ntype pathifyLinkProps<Props extends PropertyShape, Root extends ObjectTypeSet, Parent extends PathParent | null = null> = {\n    [k in keyof Props & string]: Props[k] extends PropertyDesc ? $expr_PathLeaf<TypeSet<Props[k][\"target\"], cardutil.multiplyCardinalities<Root[\"__cardinality__\"], Props[k][\"cardinality\"]>>, {\n        type: $expr_PathNode<Root, Parent>;\n        linkName: k;\n    }> : unknown;\n};\nexport type getPropsShape<T extends ObjectType> = typeutil.flatten<typeutil.stripNever<{\n    [k in keyof T[\"__pointers__\"]]: T[\"__pointers__\"][k][\"__kind__\"] extends \"property\" ? true : never;\n}>>;\nexport type $expr_PathNode<Root extends ObjectTypeSet = ObjectTypeSet, Parent extends PathParent | null = PathParent | null> = Expression<{\n    __element__: Root[\"__element__\"];\n    __cardinality__: Root[\"__cardinality__\"];\n    __parent__: Parent;\n    __kind__: ExpressionKind.PathNode;\n    \"*\": getPropsShape<Root[\"__element__\"]>;\n}>;\nexport type $expr_TypeIntersection<Card extends Cardinality = Cardinality, Intersection extends ObjectType = ObjectType> = Expression<{\n    __element__: Intersection;\n    __cardinality__: Card;\n    __kind__: ExpressionKind.TypeIntersection;\n    __expr__: TypeSet;\n}>;\nexport type $expr_PathLeaf<Root extends TypeSet = TypeSet, Parent extends PathParent = PathParent> = Expression<{\n    __element__: Root[\"__element__\"];\n    __cardinality__: Root[\"__cardinality__\"];\n    __kind__: ExpressionKind.PathLeaf;\n    __parent__: Parent;\n}>;\nexport type ExpressionRoot = {\n    __element__: BaseType;\n    __cardinality__: Cardinality;\n    __kind__: ExpressionKind;\n};\ndeclare function PathLeaf<Root extends TypeSet, Parent extends PathParent, Exclusive extends boolean = boolean>(root: Root, parent: Parent, exclusive: Exclusive, scopeRoot?: TypeSet | null): $expr_PathLeaf<Root, Parent>;\ndeclare function PathNode<Root extends ObjectTypeSet, Parent extends PathParent | null>(root: Root, parent: Parent, scopeRoot?: TypeSet | null): $expr_PathNode<Root, Parent>;\nexport declare function $pathify<Root extends TypeSet, Parent extends PathParent>(_root: Root): $pathify<Root>;\nexport declare function $assert_single(expr: Expression): any;\nexport declare function $jsonDestructure(_expr: ExpressionRoot): any;\nexport declare function $expressionify<T extends ExpressionRoot>(_expr: T): Expression<T>;\nexport declare function $getScopedExpr<T extends ExpressionRoot>(expr: T, existingScopes?: Set<Expression>): Expression<T>;\nexport { PathLeaf as $PathLeaf, PathNode as $PathNode };\n"},{"path":"query.d.ts","content":"import type * as edgedb from \"edgedb\";\nexport declare const runnableExpressionKinds: Set<edgedb.$.ExpressionKind>;\nexport declare function $queryFunc(this: any, cxn: edgedb.Executor, args: any): Promise<unknown>;\nexport declare function $queryFuncJSON(this: any, cxn: edgedb.Executor, args: any): Promise<string>;\n"},{"path":"range.d.ts","content":"import type { LocalDate, LocalDateTime, Duration } from \"edgedb\";\nimport { Range } from \"edgedb\";\nimport type { cardutil } from \"./cardinality\";\nimport type { RangeType, getPrimitiveBaseType, TypeSet, BaseType } from \"./typesystem\";\nimport type { $expr_Literal } from \"./literal\";\nimport type { $number, $decimal, $datetime, $duration, $bool } from \"./modules/std\";\nimport type { $local_date, $local_datetime } from \"./modules/cal\";\nimport type { literalToScalarType, orScalarLiteral } from \"./castMaps\";\nimport { type $expr_Function } from \"./funcops\";\ntype $anypoint = $number | $local_date | $decimal | $datetime | $local_datetime | $duration;\ndeclare function range<Element extends $anypoint>(element: Element): RangeType<Element>;\ndeclare function range<T extends number | Date | LocalDate | LocalDateTime | Duration>(val: Range<T>): $expr_Literal<RangeType<getPrimitiveBaseType<literalToScalarType<T>>>>;\ndeclare function range<NamedArgs extends {\n    inc_lower?: orScalarLiteral<TypeSet<$bool>>;\n    inc_upper?: orScalarLiteral<TypeSet<$bool>>;\n    empty?: orScalarLiteral<TypeSet<$bool>>;\n}, P1 extends orScalarLiteral<TypeSet<$anypoint>> | undefined, P2 extends orScalarLiteral<TypeSet<BaseType extends literalToScalarType<P1> ? $anypoint : getPrimitiveBaseType<literalToScalarType<P1>>>> | undefined>(namedArgs: NamedArgs, lower?: P1, upper?: P2): $expr_Function<RangeType<literalToScalarType<P1> extends $anypoint ? literalToScalarType<P1> : literalToScalarType<P2> extends $anypoint ? literalToScalarType<P2> : $anypoint>, cardutil.multiplyCardinalities<cardutil.multiplyCardinalities<cardutil.multiplyCardinalities<cardutil.multiplyCardinalities<cardutil.optionalParamCardinality<P1>, cardutil.optionalParamCardinality<P2>>, cardutil.optionalParamCardinality<NamedArgs[\"inc_lower\"]>>, cardutil.optionalParamCardinality<NamedArgs[\"inc_upper\"]>>, cardutil.optionalParamCardinality<NamedArgs[\"empty\"]>>>;\ndeclare function range<P1 extends orScalarLiteral<TypeSet<$anypoint>> | undefined, P2 extends orScalarLiteral<TypeSet<BaseType extends literalToScalarType<P1> ? $anypoint : getPrimitiveBaseType<literalToScalarType<P1>>>> | undefined>(lower?: P1, upper?: P2): $expr_Function<RangeType<literalToScalarType<P1> extends $anypoint ? literalToScalarType<P1> : literalToScalarType<P2> extends $anypoint ? literalToScalarType<P2> : $anypoint>, cardutil.multiplyCardinalities<cardutil.optionalParamCardinality<P1>, cardutil.optionalParamCardinality<P2>>>;\nexport { range as $range };\n"},{"path":"reflection.d.ts","content":"export * from \"edgedb/dist/reflection/index\";\nexport * from \"./typesystem\";\nexport { cardutil } from \"./cardinality\";\nexport type { $expr_Literal } from \"./literal\";\nexport type { $expr_PathNode, $expr_PathLeaf } from \"./path\";\nexport type { $expr_Function, $expr_Operator } from \"./funcops\";\nexport { makeType, $mergeObjectTypes } from \"./hydrate\";\nexport type { mergeObjectTypes } from \"./hydrate\";\n"},{"path":"select.d.ts","content":"import type { $bool, $number } from \"./modules/std\";\nimport { Cardinality, ExpressionKind } from \"edgedb/dist/reflection/index\";\nimport { cardutil } from \"./cardinality\";\nimport type { $expr_PolyShapeElement, $scopify, Expression, LinkDesc, ObjectType, ObjectTypeExpression, ObjectTypePointers, ObjectTypeSet, PrimitiveTypeSet, PropertyDesc, ScalarType, stripSet, TypeSet, BaseType, ExclusiveTuple, orLiteralValue } from \"./typesystem\";\nimport { type $expr_PathLeaf, type $linkPropify, type ExpressionRoot } from \"./path\";\nimport type { anonymizeObject } from \"./casting\";\nimport { type scalarLiterals, type literalToScalarType } from \"./castMaps\";\nexport declare const ASC: \"ASC\";\nexport declare const DESC: \"DESC\";\nexport declare const EMPTY_FIRST: \"EMPTY FIRST\";\nexport declare const EMPTY_LAST: \"EMPTY LAST\";\nexport type OrderByDirection = \"ASC\" | \"DESC\";\nexport type OrderByEmpty = \"EMPTY FIRST\" | \"EMPTY LAST\";\nexport type OrderByExpr = TypeSet<ScalarType | ObjectType, Cardinality>;\nexport type OrderByObjExpr = {\n    expression: OrderByExpr;\n    direction?: OrderByDirection;\n    empty?: OrderByEmpty;\n};\nexport type OrderByExpression = OrderByExpr | OrderByObjExpr | [OrderByExpr | OrderByObjExpr, ...(OrderByExpr | OrderByObjExpr)[]];\nexport type OffsetExpression = TypeSet<$number, Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne>;\nexport type SelectFilterExpression = TypeSet<$bool, Cardinality>;\nexport type LimitOffsetExpression = TypeSet<$number, Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne>;\nexport type LimitExpression = TypeSet<$number, Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne>;\nexport type SelectModifierNames = \"filter\" | \"filter_single\" | \"order_by\" | \"offset\" | \"limit\";\ntype filterSingle<T extends TypeSet> = T extends ObjectTypeSet ? TypeSet<anonymizeObject<T[\"__element__\"]>, T[\"__cardinality__\"]> : orLiteralValue<T>;\nexport type exclusivesToFilterSingle<E extends ExclusiveTuple> = ExclusiveTuple extends E ? never : E extends [] ? never : {\n    [j in keyof E]: {\n        [k in keyof E[j]]: filterSingle<E[j][k]>;\n    };\n}[number];\nexport type SelectModifiers<T extends ObjectType = ObjectType> = {\n    filter?: SelectFilterExpression;\n    filter_single?: exclusivesToFilterSingle<T[\"__exclusives__\"]> | SelectFilterExpression;\n    order_by?: OrderByExpression;\n    offset?: OffsetExpression | number;\n    limit?: LimitExpression | number;\n};\nexport type UnknownSelectModifiers = {\n    [k in keyof SelectModifiers]: unknown;\n};\nexport type NormalisedSelectModifiers = {\n    filter?: SelectFilterExpression;\n    order_by?: OrderByObjExpr[];\n    offset?: OffsetExpression;\n    limit?: LimitExpression;\n    singleton: boolean;\n};\nexport type $expr_Select<Set extends TypeSet = TypeSet> = Expression<{\n    __element__: Set[\"__element__\"];\n    __cardinality__: Set[\"__cardinality__\"];\n    __expr__: TypeSet;\n    __kind__: ExpressionKind.Select;\n    __modifiers__: NormalisedSelectModifiers;\n    __scope__?: ObjectTypeExpression;\n}>;\nexport interface SelectModifierMethods<Root extends TypeSet> {\n    filter<Filter extends SelectFilterExpression>(filter: Filter | ((scope: Root extends ObjectTypeSet ? $scopify<Root[\"__element__\"]> : stripSet<Root>) => Filter)): this;\n    order_by(order_by: OrderByExpression | ((scope: Root extends ObjectTypeSet ? $scopify<Root[\"__element__\"]> : stripSet<Root>) => OrderByExpression)): this;\n    offset(offset: OffsetExpression | number | ((scope: Root extends ObjectTypeSet ? $scopify<Root[\"__element__\"]> : stripSet<Root>) => OffsetExpression | number)): this;\n    limit(limit: LimitExpression | number | ((scope: Root extends ObjectTypeSet ? $scopify<Root[\"__element__\"]> : stripSet<Root>) => LimitExpression | number)): this;\n}\nexport type InferOffsetLimitCardinality<Card extends Cardinality, Modifiers extends UnknownSelectModifiers> = Modifiers[\"limit\"] extends number | LimitExpression ? cardutil.overrideLowerBound<Card, \"Zero\"> : Modifiers[\"offset\"] extends number | OffsetExpression ? cardutil.overrideLowerBound<Card, \"Zero\"> : Card;\nexport type ComputeSelectCardinality<Expr extends ObjectTypeExpression, Modifiers extends UnknownSelectModifiers> = InferOffsetLimitCardinality<undefined extends Modifiers[\"filter_single\"] ? Expr[\"__cardinality__\"] : cardutil.overrideUpperBound<Expr[\"__cardinality__\"], \"One\">, Modifiers>;\nexport declare function is<Expr extends ObjectTypeExpression, Shape extends objectTypeToSelectShape<Expr[\"__element__\"]>>(expr: Expr, shape: Shape): {\n    [k in Exclude<keyof Shape, SelectModifierNames | \"id\">]: $expr_PolyShapeElement<Expr, normaliseElement<Shape[k]>>;\n};\nexport declare function $handleModifiers(modifiers: SelectModifiers, params: {\n    root: TypeSet;\n    scope: TypeSet;\n}): {\n    modifiers: NormalisedSelectModifiers;\n    cardinality: Cardinality;\n    needsAssertSingle: boolean;\n};\nexport type $expr_Delete<Root extends ObjectTypeSet = ObjectTypeSet> = Expression<{\n    __kind__: ExpressionKind.Delete;\n    __element__: Root[\"__element__\"];\n    __cardinality__: Root[\"__cardinality__\"];\n    __expr__: ObjectTypeSet;\n}>;\ndeclare function deleteExpr<Expr extends ObjectTypeExpression, Modifiers extends SelectModifiers<Expr[\"__element__\"]>>(expr: Expr, modifiers?: (scope: $scopify<Expr[\"__element__\"]>) => Readonly<Modifiers>): $expr_Delete<{\n    __element__: ObjectType<Expr[\"__element__\"][\"__name__\"], Expr[\"__element__\"][\"__pointers__\"], {\n        id: true;\n    }>;\n    __cardinality__: ComputeSelectCardinality<Expr, Modifiers>;\n}>;\nexport { deleteExpr as delete };\nexport declare function $selectify<Expr extends ExpressionRoot>(expr: Expr): Expr;\nexport type linkDescToLinkProps<Desc extends LinkDesc> = {\n    [k in keyof Desc[\"properties\"] & string]: $expr_PathLeaf<TypeSet<Desc[\"properties\"][k][\"target\"], Desc[\"properties\"][k][\"cardinality\"]>>;\n};\nexport type pointersToObjectType<P extends ObjectTypePointers> = ObjectType<string, P, object>;\ntype linkDescToShape<L extends LinkDesc> = objectTypeToSelectShape<L[\"target\"]> & objectTypeToSelectShape<pointersToObjectType<L[\"properties\"]>> & SelectModifiers;\ntype linkDescToSelectElement<L extends LinkDesc> = boolean | TypeSet<anonymizeObject<L[\"target\"]>, cardutil.assignable<L[\"cardinality\"]>> | linkDescToShape<L> | ((scope: $scopify<L[\"target\"]> & linkDescToLinkProps<L>) => linkDescToShape<L>);\ntype propDescToSelectElement<P extends PropertyDesc> = boolean | TypeSet<P[\"target\"], cardutil.assignable<P[\"cardinality\"]>> | $expr_PolyShapeElement;\nexport type objectTypeToSelectShape<T extends ObjectType = ObjectType, Pointers extends ObjectTypePointers = T[\"__pointers__\"]> = Partial<{\n    [k in keyof Pointers]: Pointers[k] extends PropertyDesc ? propDescToSelectElement<Pointers[k]> : Pointers[k] extends LinkDesc ? linkDescToSelectElement<Pointers[k]> : any;\n}> & {\n    [k: string]: unknown;\n};\nexport type normaliseElement<El> = El extends boolean ? El : El extends TypeSet ? stripSet<El> : El extends (...scope: any[]) => any ? normaliseShape<ReturnType<El>> : El extends object ? normaliseShape<stripSet<El>> : stripSet<El>;\nexport type normaliseShape<Shape extends object, Strip = SelectModifierNames> = {\n    [k in Exclude<keyof Shape, Strip>]: normaliseElement<Shape[k]>;\n};\nexport declare const $existingScopes: Set<Expression<TypeSet<BaseType, Cardinality>>>;\ndeclare function $shape<Expr extends ObjectTypeExpression, Element extends Expr[\"__element__\"], Shape extends objectTypeToSelectShape<Element> & SelectModifiers<Element>, Scope extends $scopify<Element> & $linkPropify<{\n    [k in keyof Expr]: k extends \"__cardinality__\" ? Cardinality.One : Expr[k];\n}>>(expr: Expr, _shape: (scope: Scope) => Readonly<Shape>): (scope: unknown) => Readonly<Shape>;\nexport { $shape as shape };\nexport declare function select<Expr extends ObjectTypeExpression, Element extends Expr[\"__element__\"], ElementName extends `${Element[\"__name__\"]}`, ElementPointers extends Element[\"__pointers__\"], ElementShape extends Element[\"__shape__\"], Card extends Expr[\"__cardinality__\"]>(expr: Expr): $expr_Select<{\n    __element__: ObjectType<ElementName, ElementPointers, ElementShape>;\n    __cardinality__: Card;\n}>;\nexport declare function select<Expr extends TypeSet>(expr: Expr): $expr_Select<stripSet<Expr>>;\nexport declare function select<Expr extends ObjectTypeExpression, Element extends Expr[\"__element__\"], Shape extends objectTypeToSelectShape<Element> & SelectModifiers<Element>, SelectCard extends ComputeSelectCardinality<Expr, Modifiers>, SelectShape extends normaliseShape<Shape, SelectModifierNames>, Scope extends $scopify<Element> & $linkPropify<{\n    [k in keyof Expr]: k extends \"__cardinality__\" ? Cardinality.One : Expr[k];\n}>, ElementName extends `${Element[\"__name__\"]}`, Modifiers extends UnknownSelectModifiers = Pick<Shape, SelectModifierNames>>(expr: Expr, shape: (scope: Scope) => Readonly<Shape>): $expr_Select<{\n    __element__: ObjectType<ElementName, Element[\"__pointers__\"], SelectShape>;\n    __cardinality__: SelectCard;\n}>;\nexport declare function select<Expr extends PrimitiveTypeSet, Modifiers extends SelectModifiers>(expr: Expr, modifiers: (expr: Expr) => Readonly<Modifiers>): $expr_Select<{\n    __element__: Expr[\"__element__\"];\n    __cardinality__: InferOffsetLimitCardinality<Expr[\"__cardinality__\"], Modifiers>;\n}>;\nexport declare function select<Shape extends {\n    [key: string]: TypeSet;\n}>(shape: Shape): $expr_Select<{\n    __element__: ObjectType<`std::FreeObject`, {\n        [k in keyof Shape]: Shape[k][\"__element__\"] extends ObjectType ? LinkDesc<Shape[k][\"__element__\"], Shape[k][\"__cardinality__\"], {}, false, true, true, false> : PropertyDesc<Shape[k][\"__element__\"], Shape[k][\"__cardinality__\"], false, true, true, false>;\n    }, Shape>;\n    __cardinality__: Cardinality.One;\n}>;\nexport declare function select<Expr extends scalarLiterals>(expr: Expr): $expr_Select<{\n    __element__: literalToScalarType<Expr>;\n    __cardinality__: Cardinality.One;\n}>;\nexport declare function resolveShapeElement(key: any, value: any, scope: ObjectTypeExpression): any;\n"},{"path":"set.d.ts","content":"import type { ExpressionKind, Cardinality } from \"edgedb/dist/reflection/index\";\nimport type { ArrayType, BaseTypeTuple, BaseType, NamedTupleType, ObjectTypeSet, TypeSet, TupleType, Expression, ObjectType, getPrimitiveBaseType, SomeType } from \"./typesystem\";\nimport { type mergeObjectTypes } from \"./hydrate\";\nimport * as castMaps from \"./castMaps\";\nexport declare function getSharedParent(a: SomeType, b: SomeType): SomeType;\nexport { set } from \"./setImpl\";\nexport type $expr_Set<Set extends LooseTypeSet = LooseTypeSet> = Expression<{\n    __element__: Set[\"__element__\"];\n    __cardinality__: Set[\"__cardinality__\"];\n    __exprs__: TypeSet[];\n    __kind__: ExpressionKind.Set;\n}>;\ntype mergeTypeTuples<AItems, BItems> = {\n    [k in keyof AItems]: k extends keyof BItems ? getSharedParentPrimitive<AItems[k], BItems[k]> : never;\n};\nexport type getSharedParentPrimitive<A, B> = A extends undefined ? B extends undefined ? undefined : B : B extends undefined ? A : A extends ArrayType<infer AEl> ? B extends ArrayType<infer BEl> ? ArrayType<castMaps.getSharedParentScalar<AEl, BEl>> : never : A extends NamedTupleType<infer AShape> ? B extends NamedTupleType<infer BShape> ? NamedTupleType<{\n    [k in keyof AShape & keyof BShape]: castMaps.getSharedParentScalar<AShape[k], BShape[k]>;\n}> : never : A extends TupleType<infer AItems> ? B extends TupleType<infer BItems> ? mergeTypeTuples<AItems, BItems> extends BaseTypeTuple ? TupleType<mergeTypeTuples<AItems, BItems>> : never : never : castMaps.getSharedParentScalar<A, B>;\ntype _getSharedParentPrimitiveVariadic<Types extends [any, ...any[]]> = Types extends [infer U] ? U : Types extends [infer A, infer B, ...infer Rest] ? _getSharedParentPrimitiveVariadic<[\n    getSharedParentPrimitive<A, B>,\n    ...Rest\n]> : never;\nexport type getSharedParentPrimitiveVariadic<Types extends [any, ...any[]]> = _getSharedParentPrimitiveVariadic<Types>;\nexport type LooseTypeSet<T extends any = any, C extends Cardinality = Cardinality> = {\n    __element__: T;\n    __cardinality__: C;\n};\nexport type { mergeObjectTypes };\ntype _mergeObjectTypesVariadic<Types extends [ObjectType, ...ObjectType[]]> = Types extends [infer U] ? U : Types extends [infer A, infer B, ...infer Rest] ? A extends ObjectType ? B extends ObjectType ? mergeObjectTypes<A, B> extends BaseType ? mergeObjectTypesVariadic<[mergeObjectTypes<A, B>, ...Rest]> : never : never : never : never;\nexport type mergeObjectTypesVariadic<Types extends [any, ...any[]]> = _mergeObjectTypesVariadic<Types>;\nexport type getTypesFromExprs<Exprs extends [TypeSet, ...TypeSet[]]> = {\n    [k in keyof Exprs]: Exprs[k] extends TypeSet<infer El, any> ? getPrimitiveBaseType<El> : never;\n};\nexport type getTypesFromObjectExprs<Exprs extends [ObjectTypeSet, ...ObjectTypeSet[]]> = {\n    [k in keyof Exprs]: Exprs[k] extends TypeSet<infer El, any> ? El : never;\n};\nexport type getCardsFromExprs<Exprs extends [TypeSet, ...TypeSet[]]> = {\n    [k in keyof Exprs]: Exprs[k] extends TypeSet<any, infer Card> ? Card : never;\n};\n"},{"path":"setImpl.d.ts","content":"export declare function set(...args: any[]): any;\n"},{"path":"syntax.d.ts","content":"import type { TypeSet, setToTsType } from \"./typesystem\";\nexport * from \"./literal\";\nexport * from \"./path\";\nexport * from \"./set\";\nexport * from \"./cast\";\nexport * from \"./select\";\nexport * from \"./update\";\nexport * from \"./insert\";\nexport * from \"./group\";\nexport * from \"./collections\";\nexport * from \"./funcops\";\nexport * from \"./for\";\nexport * from \"./with\";\nexport * from \"./params\";\nexport * from \"./globals\";\nexport * from \"./detached\";\nexport * from \"./toEdgeQL\";\nexport * from \"./range\";\nexport type $infer<A extends TypeSet> = setToTsType<A>;\n"},{"path":"toEdgeQL.d.ts","content":"import { type $expr_Array, type $expr_NamedTuple, type $expr_Tuple, type $expr_TuplePath } from \"./typesystem\";\nimport type { $expr_Literal } from \"./literal\";\nimport type { $expr_PathLeaf, $expr_PathNode, $expr_TypeIntersection } from \"./path\";\nimport type { $expr_Cast } from \"./cast\";\nimport type { $expr_Detached } from \"./detached\";\nimport type { $expr_For, $expr_ForVar } from \"./for\";\nimport type { $expr_Function, $expr_Operator } from \"./funcops\";\nimport type { $expr_Insert, $expr_InsertUnlessConflict } from \"./insert\";\nimport type { $expr_Param, $expr_WithParams } from \"./params\";\nimport type { $expr_Delete, $expr_Select } from \"./select\";\nimport type { $expr_Set } from \"./set\";\nimport type { $expr_Update } from \"./update\";\nimport type { $expr_Alias, $expr_With } from \"./with\";\nimport type { $expr_Group } from \"./group\";\nimport type { $expr_Global } from \"./globals\";\nexport type SomeExpression = $expr_PathNode | $expr_PathLeaf | $expr_Literal | $expr_Set | $expr_Array | $expr_Tuple | $expr_NamedTuple | $expr_TuplePath | $expr_Cast | $expr_Select | $expr_Delete | $expr_Update | $expr_Insert | $expr_InsertUnlessConflict | $expr_Function | $expr_Operator | $expr_For | $expr_ForVar | $expr_TypeIntersection | $expr_Alias | $expr_With | $expr_WithParams | $expr_Param | $expr_Detached | $expr_Group | $expr_Global;\nexport declare function $toEdgeQL(this: any): string;\n"},{"path":"typesystem.d.ts","content":"import type { Executor } from \"edgedb/dist/ifaces\";\nimport type { $expr_PathNode, $expr_TypeIntersection, $pathify } from \"./path\";\nimport type { $expr_Literal } from \"./literal\";\nimport type { $expr_Operator } from \"./funcops\";\nimport type { typeutil, Cardinality, ExpressionKind } from \"edgedb/dist/reflection/index\";\nimport { TypeKind } from \"edgedb/dist/reflection/index\";\nimport type { cardutil } from \"./cardinality\";\nimport type { Range, MultiRange } from \"edgedb\";\nexport interface BaseType {\n    __kind__: TypeKind;\n    __name__: string;\n}\nexport type BaseTypeSet = {\n    __element__: BaseType;\n    __cardinality__: Cardinality;\n};\nexport type BaseTypeTuple = typeutil.tupleOf<BaseType>;\nexport interface ScalarType<Name extends string = string, TsType = any, TsArgType = TsType, TsConstType extends TsType = TsType> extends BaseType {\n    __kind__: TypeKind.scalar;\n    __tstype__: TsType;\n    __tsargtype__: TsArgType;\n    __tsconsttype__: TsConstType;\n    __name__: Name;\n}\nexport type scalarTypeWithConstructor<S extends ScalarType, ExtraTsTypes = never> = S & {\n    <T extends S[\"__tstype__\"] | ExtraTsTypes>(val: T): $expr_Literal<Omit<S, \"__tsconsttype__\"> & {\n        __tsconsttype__: T extends S[\"__tstype__\"] ? T : S[\"__tstype__\"];\n    }>;\n};\ntype $jsonDestructure<Set extends TypeSet> = Set[\"__element__\"] extends ScalarType<\"std::json\"> ? {\n    [path: string]: $expr_Operator<Set[\"__element__\"], Set[\"__cardinality__\"]>;\n} & {\n    destructure<T extends TypeSet<ScalarType<\"std::str\">> | string>(path: T): $expr_Operator<Set[\"__element__\"], cardutil.multiplyCardinalities<Set[\"__cardinality__\"], T extends TypeSet ? T[\"__cardinality__\"] : Cardinality.One>>;\n} : unknown;\nexport interface TypeSet<T extends BaseType = BaseType, Card extends Cardinality = Cardinality> {\n    __element__: T;\n    __cardinality__: Card;\n}\nexport declare function $toSet<Root extends BaseType, Card extends Cardinality>(root: Root, card: Card): TypeSet<Root, Card>;\nexport type Expression<Set extends TypeSet = TypeSet, Runnable extends boolean = true> = Set & (BaseType extends Set[\"__element__\"] ? {\n    run(cxn: Executor): any;\n    runJSON(cxn: Executor): any;\n    toEdgeQL(): string;\n    is: any;\n    assert_single: any;\n} : $pathify<Set> & ExpressionMethods<stripSet<Set>> & (Runnable extends true ? {\n    run(cxn: Executor): Promise<setToTsType<Set>>;\n    runJSON(cxn: Executor): Promise<string>;\n} : {}) & $tuplePathify<Set> & $arrayLikeIndexify<Set> & $jsonDestructure<Set>);\nexport type stripSet<T> = \"__element__\" extends keyof T ? \"__cardinality__\" extends keyof T ? {\n    __element__: T[\"__element__\"];\n    __cardinality__: T[\"__cardinality__\"];\n} : T : T;\nexport type stripSetShape<T> = {\n    [k in keyof T]: stripSet<T[k]>;\n};\nexport type assert_single<El extends BaseType, Card extends Cardinality> = Expression<{\n    __element__: El;\n    __cardinality__: Card;\n    __kind__: ExpressionKind.Function;\n    __name__: \"std::assert_single\";\n    __args__: TypeSet[];\n    __namedargs__: {};\n}>;\nexport type ExpressionMethods<Set extends TypeSet> = {\n    toEdgeQL(): string;\n    is<T extends ObjectTypeSet>(ixn: T): $expr_TypeIntersection<Set[\"__cardinality__\"], ObjectType<T[\"__element__\"][\"__name__\"], T[\"__element__\"][\"__pointers__\"], {\n        id: true;\n    }>>;\n    assert_single(): assert_single<Set[\"__element__\"], Cardinality.AtMostOne>;\n};\nexport interface EnumType<Name extends string = string, Values extends [string, ...string[]] = [string, ...string[]]> extends BaseType {\n    __kind__: TypeKind.enum;\n    __tstype__: Values[number];\n    __name__: Name;\n    __values__: Values;\n}\nexport type ObjectTypeSet = TypeSet<ObjectType, Cardinality>;\nexport type ObjectTypeExpression = TypeSet<ObjectType, Cardinality>;\nexport type ExclusiveTuple = typeutil.tupleOf<{\n    [k: string]: TypeSet;\n}>;\nexport interface ObjectType<Name extends string = string, Pointers extends ObjectTypePointers = ObjectTypePointers, Shape extends object | null = any, Exclusives extends ExclusiveTuple = ExclusiveTuple> extends BaseType {\n    __kind__: TypeKind.object;\n    __name__: Name;\n    __pointers__: Pointers;\n    __shape__: Shape;\n    __exclusives__: Exclusives;\n}\nexport type PropertyTypes = ScalarType | EnumType | ArrayType | TupleType | NamedTupleType;\nexport type SomeType = ScalarType | EnumType | ArrayType | TupleType | ObjectType | NamedTupleType | RangeType | MultiRangeType;\nexport interface PropertyDesc<Type extends BaseType = BaseType, Card extends Cardinality = Cardinality, Exclusive extends boolean = boolean, Computed extends boolean = boolean, Readonly extends boolean = boolean, HasDefault extends boolean = boolean> {\n    __kind__: \"property\";\n    target: Type;\n    cardinality: Card;\n    exclusive: Exclusive;\n    computed: Computed;\n    readonly: Readonly;\n    hasDefault: HasDefault;\n}\nexport type $scopify<Type extends ObjectType> = $expr_PathNode<TypeSet<Type, Cardinality.One>>;\nexport type PropertyShape = {\n    [k: string]: PropertyDesc;\n};\nexport interface LinkDesc<Type extends ObjectType = any, Card extends Cardinality = Cardinality, LinkProps extends PropertyShape = any, Exclusive extends boolean = boolean, Computed extends boolean = boolean, Readonly extends boolean = boolean, HasDefault extends boolean = boolean> {\n    __kind__: \"link\";\n    target: Type;\n    cardinality: Card;\n    properties: LinkProps;\n    exclusive: Exclusive;\n    computed: Computed;\n    readonly: Readonly;\n    hasDefault: HasDefault;\n}\nexport type ObjectTypePointers = {\n    [k: string]: PropertyDesc | LinkDesc;\n};\nexport type stripBacklinks<T extends ObjectTypePointers> = {\n    [k in keyof T]: k extends `<${string}` ? never : T[k];\n};\nexport type omitBacklinks<T extends string | number | symbol> = T extends `<${string}` ? never : T extends string ? T : never;\nexport type stripNonUpdateables<T extends ObjectTypePointers> = {\n    [k in keyof T]: [T[k][\"computed\"]] extends [true] ? never : [T[k][\"readonly\"]] extends [true] ? never : k extends \"__type__\" ? never : k extends \"id\" ? never : T[k];\n};\nexport type stripNonInsertables<T extends ObjectTypePointers> = {\n    [k in keyof T]: [T[k][\"computed\"]] extends [true] ? never : [k] extends [\"__type__\"] ? never : T[k];\n};\ntype shapeElementToTs<Pointer extends PropertyDesc | LinkDesc, Element> = [\n    Element\n] extends [true] ? pointerToTsType<Pointer> : [Element] extends [false] ? never : [Element] extends [boolean] ? pointerToTsType<Pointer> | undefined : Element extends TypeSet ? setToTsType<TypeSet<Element[\"__element__\"], Pointer[\"cardinality\"]>> : Pointer extends LinkDesc ? Element extends object ? computeTsTypeCard<computeObjectShape<Pointer[\"target\"][\"__pointers__\"] & Pointer[\"properties\"], Element>, Pointer[\"cardinality\"]> : never : never;\nexport type $expr_PolyShapeElement<PolyType extends ObjectTypeSet = ObjectTypeSet, ShapeElement extends any = any> = {\n    __kind__: ExpressionKind.PolyShapeElement;\n    __polyType__: PolyType;\n    __shapeElement__: ShapeElement;\n};\nexport type computeObjectShape<Pointers extends ObjectTypePointers, Shape> = typeutil.flatten<keyof Shape extends never ? {\n    id: string;\n} : {\n    [k in keyof Shape]: Shape[k] extends $expr_PolyShapeElement<infer PolyType, infer ShapeEl> ? [k] extends [keyof PolyType[\"__element__\"][\"__pointers__\"]] ? shapeElementToTs<PolyType[\"__element__\"][\"__pointers__\"][k], ShapeEl> | null : never : [k] extends [keyof Pointers] ? shapeElementToTs<Pointers[k], Shape[k]> : Shape[k] extends TypeSet ? setToTsType<Shape[k]> : never;\n}>;\nexport type pointerToTsTypeSimple<El extends PropertyDesc | LinkDesc> = El extends PropertyDesc ? propToTsType<El> : El extends LinkDesc<any, any, any, any> ? {\n    id: string;\n} : never;\nexport type PrimitiveType = ScalarType | EnumType | TupleType | NamedTupleType | ArrayType | RangeType | MultiRangeType;\nexport type PrimitiveTypeSet = TypeSet<PrimitiveType, Cardinality>;\ntype $arrayLikeIndexify<Set extends TypeSet> = Set[\"__element__\"] extends ArrayType | ScalarType<\"std::str\"> | ScalarType<\"std::bytes\"> ? {\n    [index: number]: $expr_Operator<getPrimitiveBaseType<Set[\"__element__\"] extends ArrayType<infer El> ? El : Set[\"__element__\"]>, Set[\"__cardinality__\"]>;\n    [slice: `${number}:${number | \"\"}` | `:${number}`]: $expr_Operator<getPrimitiveBaseType<Set[\"__element__\"]>, Set[\"__cardinality__\"]>;\n    index<T extends TypeSet<ScalarType<\"std::number\">> | number>(index: T): $expr_Operator<getPrimitiveBaseType<Set[\"__element__\"] extends ArrayType<infer El> ? El : Set[\"__element__\"]>, cardutil.multiplyCardinalities<Set[\"__cardinality__\"], T extends TypeSet ? T[\"__cardinality__\"] : Cardinality.One>>;\n    slice<S extends TypeSet<ScalarType<\"std::number\">> | number, E extends TypeSet<ScalarType<\"std::number\">> | number | undefined | null>(start: S, end: E): $expr_Operator<getPrimitiveBaseType<Set[\"__element__\"]>, cardutil.multiplyCardinalities<cardutil.multiplyCardinalities<Set[\"__cardinality__\"], S extends TypeSet ? S[\"__cardinality__\"] : Cardinality.One>, E extends TypeSet<any, infer C> ? C : Cardinality.One>>;\n    slice<E extends TypeSet<ScalarType<\"std::number\">> | number | undefined | null>(start: undefined | null, end: E): $expr_Operator<getPrimitiveBaseType<Set[\"__element__\"]>, cardutil.multiplyCardinalities<Set[\"__cardinality__\"], E extends TypeSet<any, infer C> ? C : Cardinality.One>>;\n} : unknown;\nexport type $expr_Array<Type extends ArrayType = ArrayType, Card extends Cardinality = Cardinality> = Expression<{\n    __kind__: ExpressionKind.Array;\n    __items__: typeutil.tupleOf<TypeSet<Type[\"__element__\"]>>;\n    __element__: Type;\n    __cardinality__: Card;\n}>;\nexport interface ArrayType<Element extends BaseType = BaseType, Name extends string = `array<${Element[\"__name__\"]}>`> extends BaseType {\n    __name__: Name;\n    __kind__: TypeKind.array;\n    __element__: Element;\n}\ntype ArrayTypeToTsType<Type extends ArrayType, isParam extends boolean = false> = BaseTypeToTsType<Type[\"__element__\"], isParam>[];\ntype $tuplePathify<Set extends TypeSet> = Set[\"__element__\"] extends TupleType ? addTuplePaths<Set[\"__element__\"][\"__items__\"], Set[\"__cardinality__\"]> : Set[\"__element__\"] extends NamedTupleType ? addNamedTuplePaths<Set[\"__element__\"][\"__shape__\"], Set[\"__cardinality__\"]> : unknown;\nexport type $expr_TuplePath<ItemType extends BaseType = BaseType, ParentCard extends Cardinality = Cardinality> = Expression<{\n    __kind__: ExpressionKind.TuplePath;\n    __element__: ItemType;\n    __cardinality__: ParentCard;\n    __parent__: $expr_Tuple | $expr_NamedTuple | $expr_TuplePath;\n    __index__: string | number;\n}>;\nexport type baseTupleElementsToTupleType<T extends typeutil.tupleOf<TypeSet>> = {\n    [k in keyof T]: T[k] extends TypeSet ? getPrimitiveBaseType<T[k][\"__element__\"]> : never;\n};\nexport type tupleElementsToTupleType<T extends typeutil.tupleOf<TypeSet>> = baseTupleElementsToTupleType<T> extends BaseTypeTuple ? TupleType<baseTupleElementsToTupleType<T>> : never;\nexport type baseTupleElementsToCardTuple<T> = {\n    [k in keyof T]: T[k] extends TypeSet<any, infer C> ? C : never;\n};\nexport type tupleElementsToCardTuple<T> = baseTupleElementsToCardTuple<T> extends [Cardinality, ...Cardinality[]] ? baseTupleElementsToCardTuple<T> : never;\nexport type $expr_Tuple<Items extends typeutil.tupleOf<TypeSet> = typeutil.tupleOf<TypeSet>> = Expression<{\n    __kind__: ExpressionKind.Tuple;\n    __items__: typeutil.tupleOf<TypeSet>;\n    __element__: tupleElementsToTupleType<Items>;\n    __cardinality__: cardutil.multiplyCardinalitiesVariadic<tupleElementsToCardTuple<Items>>;\n}>;\nexport type indexKeys<T> = T extends `${number}` ? T : never;\ntype addTuplePaths<Items extends BaseType[], ParentCard extends Cardinality> = {\n    [k in indexKeys<keyof Items>]: Items[k] extends BaseType ? $expr_TuplePath<Items[k], ParentCard> : never;\n};\nexport interface TupleType<Items extends BaseTypeTuple = BaseTypeTuple> extends BaseType {\n    __name__: string;\n    __kind__: TypeKind.tuple;\n    __items__: Items;\n}\ntype TupleItemsToTsType<Items extends BaseTypeTuple, isParam extends boolean = false> = {\n    [k in keyof Items]: Items[k] extends BaseType ? BaseTypeToTsType<Items[k], isParam> : never;\n};\ntype literalShapeToType<T extends NamedTupleLiteralShape> = NamedTupleType<{\n    [k in keyof T]: getPrimitiveBaseType<T[k][\"__element__\"]>;\n}>;\ntype shapeCardinalities<Shape extends NamedTupleLiteralShape> = Shape[keyof Shape][\"__cardinality__\"];\ntype inferNamedTupleCardinality<Shape extends NamedTupleLiteralShape> = [\n    Cardinality.Many\n] extends [shapeCardinalities<Shape>] ? Cardinality.Many : [Cardinality.Empty] extends [shapeCardinalities<Shape>] ? Cardinality.Empty : [shapeCardinalities<Shape>] extends [Cardinality.AtMostOne] ? Cardinality.AtMostOne : [shapeCardinalities<Shape>] extends [\n    Cardinality.AtMostOne | Cardinality.One\n] ? Cardinality.One : Cardinality.Many;\nexport type $expr_NamedTuple<Shape extends NamedTupleLiteralShape = NamedTupleLiteralShape> = Expression<{\n    __kind__: ExpressionKind.NamedTuple;\n    __element__: literalShapeToType<Shape>;\n    __cardinality__: inferNamedTupleCardinality<Shape>;\n    __shape__: Shape;\n}>;\ntype addNamedTuplePaths<Shape extends NamedTupleShape, ParentCard extends Cardinality> = {\n    [k in keyof Shape]: Shape[k] extends BaseType ? $expr_TuplePath<Shape[k], ParentCard> : never;\n};\nexport type NamedTupleLiteralShape = {\n    [k: string]: TypeSet;\n};\nexport type NamedTupleShape = {\n    [k: string]: BaseType;\n};\nexport interface NamedTupleType<Shape extends NamedTupleShape = NamedTupleShape> extends BaseType {\n    __name__: string;\n    __kind__: TypeKind.namedtuple;\n    __shape__: Shape;\n}\ntype NamedTupleTypeToTsType<Type extends NamedTupleType, isParam extends boolean = false> = {\n    [k in keyof Type[\"__shape__\"]]: BaseTypeToTsType<Type[\"__shape__\"][k], isParam>;\n};\nexport interface RangeType<Element extends ScalarType = ScalarType, Name extends string = `range<${Element[\"__name__\"]}>`> extends BaseType {\n    __name__: Name;\n    __kind__: TypeKind.range;\n    __element__: Element;\n}\nexport interface MultiRangeType<Element extends ScalarType = ScalarType, Name extends string = `multirange<${Element[\"__name__\"]}>`> extends BaseType {\n    __name__: Name;\n    __kind__: TypeKind.multirange;\n    __element__: Element;\n}\nexport type orLiteralValue<Set extends TypeSet> = Set | (Set[\"__element__\"] extends ObjectType ? never : computeTsType<Set[\"__element__\"], Set[\"__cardinality__\"]>);\nexport type BaseTypeToTsType<Type extends BaseType, isParam extends boolean = false> = Type extends ScalarType ? isParam extends true ? Type[\"__tsargtype__\"] : Type[\"__tsconsttype__\"] : Type extends EnumType ? Type[\"__tstype__\"] : Type extends ArrayType<any> ? ArrayTypeToTsType<Type, isParam> : Type extends RangeType ? Range<Type[\"__element__\"][\"__tsconsttype__\"]> : Type extends MultiRangeType ? MultiRange<Type[\"__element__\"][\"__tsconsttype__\"]> : Type extends TupleType ? TupleItemsToTsType<Type[\"__items__\"], isParam> : Type extends NamedTupleType ? typeutil.flatten<NamedTupleTypeToTsType<Type, isParam>> : Type extends ObjectType ? typeutil.flatten<computeObjectShape<Type[\"__pointers__\"], Type[\"__shape__\"]>> : never;\nexport type setToTsType<Set extends TypeSet> = computeTsType<Set[\"__element__\"], Set[\"__cardinality__\"]>;\nexport type computeTsTypeCard<T extends any, C extends Cardinality> = Cardinality extends C ? unknown : C extends Cardinality.Empty ? null : C extends Cardinality.One ? T : C extends Cardinality.AtLeastOne ? [T, ...T[]] : C extends Cardinality.AtMostOne ? T | null : C extends Cardinality.Many ? T[] : C extends Cardinality ? unknown : never;\nexport type computeTsType<T extends BaseType, C extends Cardinality> = BaseType extends T ? unknown : computeTsTypeCard<BaseTypeToTsType<T>, C>;\nexport type propToTsType<Prop extends PropertyDesc> = Prop extends PropertyDesc<infer Type, infer Card> ? setToTsType<TypeSet<Type, Card>> : never;\nexport type linkToTsType<Link extends LinkDesc> = computeTsType<Link[\"target\"], Link[\"cardinality\"]>;\nexport type pointerToTsType<El extends PropertyDesc | LinkDesc> = El extends PropertyDesc ? propToTsType<El> : El extends LinkDesc<any, any, any, any> ? linkToTsType<El> : never;\nexport type getPrimitiveBaseType<T extends BaseType> = T extends ScalarType ? ScalarType<T[\"__name__\"], T[\"__tstype__\"], T[\"__tsargtype__\"]> : T;\nexport type getPrimitiveNonArrayBaseType<T extends BaseType> = T extends ArrayType ? never : getPrimitiveBaseType<T>;\nexport declare function isScalarType(type: BaseType): type is ScalarType;\nexport declare function isEnumType(type: BaseType): type is EnumType;\nexport declare function isObjectType(type: BaseType): type is ObjectType;\nexport declare function isTupleType(type: BaseType): type is TupleType;\nexport declare function isNamedTupleType(type: BaseType): type is NamedTupleType;\nexport declare function isArrayType(type: BaseType): type is ArrayType;\nexport type NonArrayType = ScalarType | EnumType | ObjectType | TupleType | NamedTupleType | RangeType | MultiRangeType;\nexport type AnyTupleType = TupleType | NamedTupleType;\nexport type AnyObjectType = ObjectType;\nexport type ParamType = ScalarType | EnumType | ArrayType<ScalarType | TupleType<typeutil.tupleOf<ParamType>> | NamedTupleType<{\n    [k: string]: ParamType;\n}> | RangeType | MultiRangeType> | TupleType<typeutil.tupleOf<ParamType>> | NamedTupleType<{\n    [k: string]: ParamType;\n}> | RangeType | MultiRangeType;\nexport {};\n"},{"path":"update.d.ts","content":"import { ExpressionKind, type typeutil, Cardinality } from \"edgedb/dist/reflection/index\";\nimport type { Expression, ObjectTypePointers, TypeSet, ObjectTypeSet, stripBacklinks, stripNonUpdateables, ObjectTypeExpression, ObjectType, $scopify } from \"./typesystem\";\nimport type { pointerToAssignmentExpression } from \"./casting\";\nimport { type SelectModifiers, type NormalisedSelectModifiers, type ComputeSelectCardinality } from \"./select\";\nimport { type pointerIsOptional } from \"./insert\";\nexport type $expr_Update<El extends ObjectType = ObjectType, Card extends Cardinality = Cardinality> = Expression<{\n    __kind__: ExpressionKind.Update;\n    __element__: El;\n    __cardinality__: Card;\n    __expr__: TypeSet;\n    __shape__: any;\n    __modifiers__: NormalisedSelectModifiers;\n    __scope__: ObjectTypeExpression;\n}>;\nexport type UpdateShape<Root extends ObjectTypeSet> = typeutil.stripNever<stripNonUpdateables<stripBacklinks<Root[\"__element__\"][\"__pointers__\"]>>> extends infer Shape ? Shape extends ObjectTypePointers ? {\n    [k in keyof Shape]?: (pointerToAssignmentExpression<Shape[k]> | (Shape[k][\"cardinality\"] extends Cardinality.Many | Cardinality.AtLeastOne ? {\n        \"+=\": pointerToAssignmentExpression<Shape[k], true>;\n    } | {\n        \"-=\": pointerToAssignmentExpression<Shape[k], true>;\n    } : never)) | (pointerIsOptional<Shape[k]> extends true ? undefined | null : never);\n} : never : never;\nexport declare function update<Expr extends ObjectTypeExpression, Shape extends {\n    filter?: SelectModifiers[\"filter\"];\n    filter_single?: SelectModifiers<Expr[\"__element__\"]>[\"filter_single\"];\n    set: UpdateShape<Expr>;\n}>(expr: Expr, shape: (scope: $scopify<Expr[\"__element__\"]>) => Readonly<Shape>): $expr_Update<Expr[\"__element__\"], ComputeSelectCardinality<Expr, Shape>>;\n"},{"path":"with.d.ts","content":"import { ExpressionKind, Cardinality } from \"edgedb/dist/reflection/index\";\nimport type { BaseType, Expression, TypeSet } from \"./typesystem\";\nimport type { $expr_Select } from \"./select\";\nimport type { $expr_For } from \"./for\";\nimport type { $expr_Insert } from \"./insert\";\nimport type { $expr_Update } from \"./update\";\nimport type { $expr_Group } from \"./group\";\nexport type $expr_Alias<El extends BaseType = BaseType, Card extends Cardinality = Cardinality> = Expression<{\n    __element__: El;\n    __cardinality__: Card;\n    __kind__: ExpressionKind.Alias;\n    __expr__: TypeSet;\n}>;\nexport declare function alias<Expr extends Expression>(expr: Expr): $expr_Alias<Expr[\"__element__\"], Expr[\"__cardinality__\"]>;\nexport type WithableExpression = $expr_Select | $expr_For | $expr_Insert | $expr_Update | $expr_Group;\nexport type $expr_With<Expr extends WithableExpression = WithableExpression> = Expression<{\n    __element__: Expr[\"__element__\"];\n    __cardinality__: Expr[\"__cardinality__\"];\n    __kind__: ExpressionKind.With;\n    __expr__: Expr;\n    __refs__: TypeSet[];\n}>;\ndeclare function _with<Expr extends WithableExpression>(refs: Expression[], expr: Expr): $expr_With<Expr>;\nexport { _with as with };\n"},{"path":"__spec__.d.ts","content":"import type { TypeKind } from \"./reflection\";\nexport declare const spec: Map<string, any>;\nexport declare const complexParamKinds: Set<TypeKind>;\n"}],"deno":[{"path":"cardinality.ts","content":"import { Cardinality } from \"edgedb/_src/reflection/index.ts\";\r\nimport type { TypeSet } from \"./typesystem.ts\";\r\n\r\n// Computing cardinality of path\r\n// From base set cadinality and pointer cardinality\r\n// Used in path expressions\r\n// Cardinality  Empty  AtMostOne  One         Many  AtLeastOne\r\n// Empty        0      0          0           0     0\r\n// AtMostOne    0      AtMostOne  AtMostOne   Many  Many\r\n// One          0      AtMostOne  One         Many  AtLeastOne\r\n// Many         0      Many       Many        Many  Many\r\n// AtLeastOne   0      Many       AtLeastOne  Many  AtLeastOne\r\nexport namespace cardutil {\r\n  export type multiplyCardinalities<\r\n    C1 extends Cardinality,\r\n    C2 extends Cardinality\r\n  > = C1 extends Cardinality.Empty\r\n    ? Cardinality.Empty\r\n    : C1 extends Cardinality.One\r\n    ? C2\r\n    : C1 extends Cardinality.AtMostOne\r\n    ? C2 extends Cardinality.One\r\n      ? Cardinality.AtMostOne\r\n      : C2 extends Cardinality.AtLeastOne\r\n      ? Cardinality.Many\r\n      : C2\r\n    : C1 extends Cardinality.Many\r\n    ? C2 extends Cardinality.Empty\r\n      ? Cardinality.Empty\r\n      : Cardinality.Many\r\n    : C1 extends Cardinality.AtLeastOne\r\n    ? C2 extends Cardinality.AtMostOne\r\n      ? Cardinality.Many\r\n      : C2 extends Cardinality.One\r\n      ? Cardinality.AtLeastOne\r\n      : C2\r\n    : never;\r\n\r\n  export function multiplyCardinalities(\r\n    c1: Cardinality,\r\n    c2: Cardinality\r\n  ): Cardinality {\r\n    if (c1 === Cardinality.Empty) return Cardinality.Empty;\r\n\r\n    if (c1 === Cardinality.One) return c2;\r\n    if (c1 === Cardinality.AtMostOne) {\r\n      if (c2 === Cardinality.One) return Cardinality.AtMostOne;\r\n      if (c2 === Cardinality.AtLeastOne) return Cardinality.Many;\r\n      return c2;\r\n    }\r\n    if (c1 === Cardinality.Many) {\r\n      if (c2 === Cardinality.Empty) return Cardinality.Empty;\r\n      return Cardinality.Many;\r\n    }\r\n    if (c1 === Cardinality.AtLeastOne) {\r\n      if (c2 === Cardinality.AtMostOne) return Cardinality.Many;\r\n      if (c2 === Cardinality.One) return Cardinality.AtLeastOne;\r\n      return c2;\r\n    }\r\n    throw new Error(`Invalid Cardinality ${c1}`);\r\n  }\r\n\r\n  type _multiplyCardinalitiesVariadic<\r\n    Cards extends [Cardinality, ...Cardinality[]]\r\n  > = Cards extends [infer Card]\r\n    ? Card\r\n    : Cards extends [infer A, infer B, ...infer Rest]\r\n    ? A extends Cardinality\r\n      ? B extends Cardinality\r\n        ? Rest extends Cardinality[]\r\n          ? multiplyCardinalities<A, B> extends Cardinality\r\n            ? _multiplyCardinalitiesVariadic<\r\n                [multiplyCardinalities<A, B>, ...Rest]\r\n              >\r\n            : never\r\n          : never\r\n        : never\r\n      : never\r\n    : never;\r\n\r\n  export type multiplyCardinalitiesVariadic<\r\n    Cards extends [Cardinality, ...Cardinality[]]\r\n  > = _multiplyCardinalitiesVariadic<Cards> extends Cardinality\r\n    ? _multiplyCardinalitiesVariadic<Cards>\r\n    : never;\r\n\r\n  export function multiplyCardinalitiesVariadic<\r\n    Cards extends [Cardinality, ...Cardinality[]]\r\n  >(cards: Cards): multiplyCardinalitiesVariadic<Cards> {\r\n    if (cards.length === 0) throw new Error(\"Empty tuple not allowed\");\r\n    if (cards.length === 1) return cards[0] as any;\r\n    return cards.reduce(\r\n      (product, card) => multiplyCardinalities(product, card),\r\n      Cardinality.One\r\n    ) as any;\r\n  }\r\n\r\n  // Merging two sets\r\n  // Used in set constructor\r\n  // Cardinality  Empty       AtMostOne  One         Many        AtLeastOne\r\n  // Empty        Empty       AtMostOne  One         Many        AtLeastOne\r\n  // AtMostOne    AtMostOne   Many       AtLeastOne  Many        AtLeastOne\r\n  // One          One         AtLeastOne AtLeastOne  AtLeastOne  AtLeastOne\r\n  // Many         Many        Many       AtLeastOne  Many        AtLeastOne\r\n  // AtLeastOne   AtLeastOne  AtLeastOne AtLeastOne  AtLeastOne  AtLeastOne\r\n\r\n  export type mergeCardinalities<\r\n    A extends Cardinality,\r\n    B extends Cardinality\r\n  > = A extends Cardinality.Empty\r\n    ? B\r\n    : B extends Cardinality.Empty\r\n    ? A\r\n    : A extends Cardinality.AtLeastOne\r\n    ? Cardinality.AtLeastOne\r\n    : B extends Cardinality.AtLeastOne\r\n    ? Cardinality.AtLeastOne\r\n    : A extends Cardinality.One\r\n    ? Cardinality.AtLeastOne\r\n    : B extends Cardinality.One\r\n    ? Cardinality.AtLeastOne\r\n    : Cardinality.Many;\r\n\r\n  export function mergeCardinalities<\r\n    A extends Cardinality,\r\n    B extends Cardinality\r\n  >(a: A, b: B): mergeCardinalities<A, B> {\r\n    if (a === Cardinality.Empty) return b as any;\r\n    if (b === Cardinality.Empty) return a as any;\r\n    if (a === Cardinality.AtLeastOne) return Cardinality.AtLeastOne as any;\r\n    if (b === Cardinality.AtLeastOne) return Cardinality.AtLeastOne as any;\r\n    if (a === Cardinality.One) return Cardinality.AtLeastOne as any;\r\n    if (b === Cardinality.One) return Cardinality.AtLeastOne as any;\r\n    return Cardinality.Many as any;\r\n  }\r\n\r\n  type _mergeCardinalitiesVariadic<\r\n    Cards extends [Cardinality, ...Cardinality[]]\r\n  > = Cards extends [infer Card]\r\n    ? Card\r\n    : Cards extends [infer A, infer B, ...infer Rest]\r\n    ? A extends Cardinality\r\n      ? B extends Cardinality\r\n        ? Rest extends Cardinality[]\r\n          ? mergeCardinalities<A, B> extends Cardinality\r\n            ? _mergeCardinalitiesVariadic<[mergeCardinalities<A, B>, ...Rest]>\r\n            : never\r\n          : never\r\n        : never\r\n      : never\r\n    : never;\r\n\r\n  export type mergeCardinalitiesVariadic<\r\n    Cards extends [Cardinality, ...Cardinality[]]\r\n  > = _mergeCardinalitiesVariadic<Cards> extends Cardinality\r\n    ? _mergeCardinalitiesVariadic<Cards>\r\n    : never;\r\n  export function mergeCardinalitiesVariadic<\r\n    Cards extends [Cardinality, ...Cardinality[]]\r\n  >(cards: Cards): mergeCardinalitiesVariadic<Cards> {\r\n    if (cards.length === 0) throw new Error(\"Empty tuple not allowed\");\r\n    if (cards.length === 1) return cards[0] as any;\r\n    const [first, second, ...rest] = cards as unknown as [\r\n      Cardinality,\r\n      Cardinality,\r\n      ...Cardinality[]\r\n    ];\r\n    if (cards.length === 2) return mergeCardinalities(first, second) as any;\r\n    return mergeCardinalitiesVariadic([\r\n      mergeCardinalities(first, second),\r\n      ...rest,\r\n    ]);\r\n  }\r\n\r\n  // 'or' cardinalities together\r\n  // used in the IF ELSE operator, for expr (a IF bool ELSE b)\r\n  // result cardinality is 'a' cardinality *or* 'b' cardinality\r\n  // Cardinality  Empty       AtMostOne   One         Many        AtLeastOne\r\n  // Empty        0           AtMostOne   AtMostOne   Many        Many\r\n  // AtMostOne    AtMostOne   AtMostOne   AtMostOne   Many        Many\r\n  // One          AtMostOne   AtMostOne   One         Many        AtLeastOne\r\n  // Many         Many        Many        Many        Many        Many\r\n  // AtLeastOne   Many        Many        AtLeastOne  Many        AtLeastOne\r\n\r\n  export type orCardinalities<\r\n    C1 extends Cardinality,\r\n    C2 extends Cardinality\r\n  > = C1 extends C2\r\n    ? C1\r\n    : C1 extends Cardinality.Many\r\n    ? C1\r\n    : C1 extends Cardinality.AtMostOne\r\n    ? C2 extends Cardinality.Many\r\n      ? C2\r\n      : C2 extends Cardinality.AtLeastOne\r\n      ? Cardinality.Many\r\n      : C1\r\n    : C1 extends Cardinality.AtLeastOne\r\n    ? C2 extends Cardinality.One\r\n      ? Cardinality.AtLeastOne\r\n      : Cardinality.Many\r\n    : C1 extends Cardinality.Empty\r\n    ? C2 extends Cardinality.AtMostOne\r\n      ? Cardinality.AtMostOne\r\n      : C2 extends Cardinality.One\r\n      ? Cardinality.AtMostOne\r\n      : Cardinality.Many\r\n    : C2 extends Cardinality.Empty\r\n    ? Cardinality.AtMostOne\r\n    : C2;\r\n\r\n  export function orCardinalities(\r\n    c1: Cardinality,\r\n    c2: Cardinality\r\n  ): Cardinality {\r\n    if (c1 === c2 || c1 === Cardinality.Many) return c1;\r\n    if (c1 === Cardinality.AtLeastOne) {\r\n      if (c2 === Cardinality.One) return Cardinality.AtLeastOne;\r\n      return Cardinality.Many;\r\n    }\r\n    if (c1 === Cardinality.AtMostOne) {\r\n      if (c2 === Cardinality.Many || c2 === Cardinality.AtLeastOne) {\r\n        return Cardinality.Many;\r\n      }\r\n      return c1;\r\n    }\r\n    if (c1 === Cardinality.Empty) {\r\n      if (c2 === Cardinality.AtMostOne || c2 === Cardinality.One) {\r\n        return Cardinality.AtMostOne;\r\n      }\r\n      return Cardinality.Many;\r\n    }\r\n    if (c2 === Cardinality.Empty) return Cardinality.AtMostOne;\r\n    return c2;\r\n  }\r\n\r\n  //          Empty  AtMostOne  One         Many        AtLeastOne\r\n  // One      One    One        One         AtLeastOne  AtLeastOne\r\n  // Zero     0      AtMostOne  AtMostOne   Many        Many\r\n\r\n  export type overrideLowerBound<\r\n    C extends Cardinality,\r\n    O extends \"One\" | \"Zero\"\r\n  > = O extends \"One\"\r\n    ? C extends Cardinality.Many\r\n      ? Cardinality.AtLeastOne\r\n      : C extends Cardinality.AtLeastOne\r\n      ? Cardinality.AtLeastOne\r\n      : Cardinality.One\r\n    : C extends Cardinality.Empty\r\n    ? Cardinality.Empty\r\n    : C extends Cardinality.Many\r\n    ? Cardinality.Many\r\n    : C extends Cardinality.AtLeastOne\r\n    ? Cardinality.Many\r\n    : Cardinality.AtMostOne;\r\n\r\n  export function overrideLowerBound<\r\n    C extends Cardinality,\r\n    O extends \"One\" | \"Zero\"\r\n  >(card: C, override: O): overrideLowerBound<C, O> {\r\n    if (override === \"One\") {\r\n      if (card === Cardinality.Many || card === Cardinality.AtLeastOne) {\r\n        return Cardinality.AtLeastOne as any;\r\n      } else {\r\n        return Cardinality.One as any;\r\n      }\r\n    } else {\r\n      if (card === Cardinality.Many || card === Cardinality.AtLeastOne) {\r\n        return Cardinality.Many as any;\r\n      } else if (card === Cardinality.Empty) {\r\n        return Cardinality.Empty as any;\r\n      } else {\r\n        return Cardinality.AtMostOne as any;\r\n      }\r\n    }\r\n  }\r\n\r\n  //          Empty      AtMostOne  One         Many        AtLeastOne\r\n  // One      AtMostOne  AtMostOne  One         AtMostOne   One\r\n  // Many     Many       Many       AtLeastOne  Many        AtLeastOne\r\n\r\n  export type overrideUpperBound<\r\n    C extends Cardinality,\r\n    O extends \"One\" | \"Many\"\r\n  > = O extends \"One\"\r\n    ? C extends Cardinality.Many\r\n      ? Cardinality.AtMostOne\r\n      : C extends Cardinality.AtLeastOne\r\n      ? Cardinality.One\r\n      : C extends Cardinality.Empty\r\n      ? Cardinality.AtMostOne\r\n      : C\r\n    : C extends Cardinality.One\r\n    ? Cardinality.AtLeastOne\r\n    : C extends Cardinality.AtMostOne\r\n    ? Cardinality.Many\r\n    : C extends Cardinality.Empty\r\n    ? Cardinality.Many\r\n    : C;\r\n\r\n  export function overrideUpperBound<\r\n    C extends Cardinality,\r\n    O extends \"One\" | \"Many\"\r\n  >(card: C, override: O): overrideUpperBound<C, O> {\r\n    if (override === \"One\") {\r\n      if (card === Cardinality.One || card === Cardinality.AtLeastOne) {\r\n        return Cardinality.One as any;\r\n      } else {\r\n        return Cardinality.AtMostOne as any;\r\n      }\r\n    } else {\r\n      if (card === Cardinality.One || card === Cardinality.AtLeastOne) {\r\n        return Cardinality.AtLeastOne as any;\r\n      } else {\r\n        return Cardinality.Many as any;\r\n      }\r\n    }\r\n  }\r\n\r\n  export type paramCardinality<P> = [P] extends [TypeSet]\r\n    ? // default to one\r\n      // fixes multiplyCardinalities bug for func with optional args\r\n      [Cardinality] extends [P[\"__cardinality__\"]]\r\n      ? Cardinality.One\r\n      : P[\"__cardinality__\"]\r\n    : Cardinality.One;\r\n\r\n  export type optionalParamCardinality<P> = overrideLowerBound<\r\n    paramCardinality<P>,\r\n    \"One\"\r\n  >;\r\n\r\n  type _paramArrayCardinality<T> = {\r\n    [K in keyof T]: T[K] extends TypeSet\r\n      ? T[K][\"__cardinality__\"]\r\n      : Cardinality.One;\r\n  };\r\n\r\n  export type paramArrayCardinality<T extends [any, ...any[]]> =\r\n    multiplyCardinalitiesVariadic<_paramArrayCardinality<T>>;\r\n\r\n  export type assignable<C extends Cardinality> = C extends Cardinality.Empty\r\n    ? Cardinality.Empty\r\n    : C extends Cardinality.One\r\n    ? Cardinality.One\r\n    : C extends Cardinality.AtMostOne\r\n    ? Cardinality.One | Cardinality.AtMostOne | Cardinality.Empty\r\n    : C extends Cardinality.AtLeastOne\r\n    ? Cardinality.One | Cardinality.AtLeastOne | Cardinality.Many\r\n    : C extends Cardinality.Many\r\n    ? Cardinality\r\n    : never;\r\n}\r\n"},{"path":"cast.ts","content":"import { ExpressionKind, Cardinality } from \"edgedb/_src/reflection/index.ts\";\r\nimport type {\r\n  Expression,\r\n  BaseType,\r\n  TypeSet,\r\n  ObjectTypeExpression,\r\n} from \"./typesystem.ts\";\r\nimport { $expressionify } from \"./path.ts\";\r\nimport type { orScalarLiteral } from \"./castMaps.ts\";\r\nimport { literalToTypeSet } from \"./castMaps.ts\";\r\n\r\nexport function cast<Target extends BaseType | ObjectTypeExpression>(\r\n  target: Target,\r\n  arg: null\r\n): $expr_Cast<\r\n  Target extends BaseType\r\n    ? Target\r\n    : Target extends ObjectTypeExpression\r\n    ? Target[\"__element__\"]\r\n    : never,\r\n  Cardinality.Empty\r\n>;\r\nexport function cast<Target extends BaseType, Expr extends TypeSet>(\r\n  target: Target,\r\n  expr: orScalarLiteral<Expr>\r\n): $expr_Cast<\r\n  Target,\r\n  Cardinality extends Expr[\"__cardinality__\"]\r\n    ? Cardinality.One\r\n    : Expr[\"__cardinality__\"]\r\n>;\r\nexport function cast(target: BaseType, expr: any) {\r\n  const cleanedExpr = expr === null ? null : literalToTypeSet(expr);\r\n  return $expressionify({\r\n    __element__: (target as any).__cardinality__\r\n      ? (target as any).__element__\r\n      : target,\r\n    __cardinality__:\r\n      cleanedExpr === null ? Cardinality.Empty : cleanedExpr.__cardinality__,\r\n    __expr__: cleanedExpr,\r\n    __kind__: ExpressionKind.Cast,\r\n  }) as any;\r\n}\r\n\r\nexport type $expr_Cast<\r\n  Target extends BaseType = BaseType,\r\n  Card extends Cardinality = Cardinality\r\n> = Expression<{\r\n  __element__: Target;\r\n  __cardinality__: Card;\r\n  __kind__: ExpressionKind.Cast;\r\n  __expr__: TypeSet | null;\r\n}>;\r\n"},{"path":"casting.ts","content":"import type { Cardinality } from \"edgedb/_src/reflection/index.ts\";\r\nimport type {\r\n  ArrayType,\r\n  BaseType,\r\n  BaseTypeTuple,\r\n  BaseTypeToTsType,\r\n  EnumType,\r\n  LinkDesc,\r\n  NamedTupleType,\r\n  ObjectType,\r\n  ObjectTypeSet,\r\n  PrimitiveTypeSet,\r\n  PropertyDesc,\r\n  ScalarType,\r\n  TupleType,\r\n  TypeSet,\r\n  RangeType,\r\n  MultiRangeType,\r\n} from \"./typesystem.ts\";\r\nimport type { cardutil } from \"./cardinality.ts\";\r\n\r\nimport type { scalarCastableFrom, scalarAssignableBy } from \"./castMaps.ts\";\r\n\r\nexport type anonymizeObject<T extends ObjectType> = ObjectType<\r\n  string,\r\n  T[\"__pointers__\"],\r\n  any\r\n>;\r\n\r\n////////////////\r\n// ASSIGNABLE\r\n////////////////\r\n\r\ntype assignableTuple<Items extends BaseTypeTuple> = {\r\n  [k in keyof Items]: Items[k] extends BaseType\r\n    ? assignableBy<Items[k]>\r\n    : never;\r\n} extends infer NewItems\r\n  ? NewItems extends BaseTypeTuple\r\n    ? NewItems\r\n    : never\r\n  : never;\r\n\r\nexport type assignableBy<T extends BaseType> = T extends ScalarType\r\n  ? scalarAssignableBy<T>\r\n  : T extends ObjectType\r\n  ? anonymizeObject<T>\r\n  : T extends EnumType\r\n  ? T\r\n  : T extends ArrayType\r\n  ? ArrayType<assignableBy<T[\"__element__\"]>>\r\n  : T extends TupleType\r\n  ? TupleType<assignableTuple<T[\"__items__\"]>>\r\n  : T extends NamedTupleType\r\n  ? NamedTupleType<{\r\n      [k in keyof T[\"__shape__\"]]: assignableBy<T[\"__shape__\"][k]>;\r\n    }>\r\n  : T extends RangeType\r\n  ? RangeType<\r\n      scalarAssignableBy<T[\"__element__\"]> extends ScalarType\r\n        ? scalarAssignableBy<T[\"__element__\"]>\r\n        : never\r\n    >\r\n  : T extends MultiRangeType\r\n  ? MultiRangeType<\r\n      scalarAssignableBy<T[\"__element__\"]> extends ScalarType\r\n        ? scalarAssignableBy<T[\"__element__\"]>\r\n        : never\r\n    >\r\n  : never;\r\n\r\nexport type pointerToAssignmentExpression<\r\n  Pointer extends PropertyDesc | LinkDesc,\r\n  IsSetModifier extends boolean = false\r\n> = setToAssignmentExpression<\r\n  TypeSet<Pointer[\"target\"], Pointer[\"cardinality\"]>,\r\n  IsSetModifier\r\n>;\r\n\r\nexport type setToAssignmentExpression<\r\n  Set extends TypeSet,\r\n  IsSetModifier extends boolean\r\n> = [Set] extends [PrimitiveTypeSet]\r\n  ?\r\n      | TypeSet<\r\n          assignableBy<Set[\"__element__\"]>,\r\n          cardutil.assignable<\r\n            // Set[\"__cardinality__\"]\r\n            cardutil.overrideLowerBound<Set[\"__cardinality__\"], \"Zero\">\r\n          >\r\n        >\r\n      | getAssignmentLiteral<Set, IsSetModifier>\r\n  : [Set] extends [ObjectTypeSet]\r\n  ? TypeSet<\r\n      ObjectType<\r\n        // anonymize the object type\r\n        string,\r\n        Set[\"__element__\"][\"__pointers__\"]\r\n      >,\r\n      cardutil.assignable<\r\n        // Allow expressions with AtMostOne or Many cardinality in\r\n        // insert/update shape even when link is required since EdgeDB will\r\n        // assert cardinality at runtime\r\n        cardutil.overrideLowerBound<Set[\"__cardinality__\"], \"Zero\">\r\n      >\r\n    >\r\n  : never;\r\n\r\ntype getAssignmentLiteral<\r\n  Set extends PrimitiveTypeSet,\r\n  IsSetModifier extends boolean\r\n> = BaseTypeToTsType<Set[\"__element__\"]> extends infer TsType\r\n  ?\r\n      | TsType\r\n      | (Set[\"__cardinality__\"] extends Cardinality.Many\r\n          ? TsType[]\r\n          : Set[\"__cardinality__\"] extends Cardinality.AtLeastOne\r\n          ? IsSetModifier extends true\r\n            ? TsType[]\r\n            : [TsType, ...TsType[]]\r\n          : never)\r\n  : never;\r\n\r\n////////////////\r\n// CASTABLES\r\n////////////////\r\n\r\ntype castableTuple<Items extends BaseTypeTuple> = {\r\n  [k in keyof Items]: Items[k] extends BaseType\r\n    ? castableFrom<Items[k]>\r\n    : never;\r\n} extends infer NewItems\r\n  ? NewItems extends BaseTypeTuple\r\n    ? NewItems\r\n    : never\r\n  : never;\r\n\r\nexport type castableFrom<T extends BaseType> = T extends ScalarType\r\n  ? scalarCastableFrom<T>\r\n  : T extends ObjectType\r\n  ? anonymizeObject<T>\r\n  : T extends ArrayType\r\n  ? ArrayType<castableFrom<T[\"__element__\"]>>\r\n  : T extends TupleType\r\n  ? TupleType<castableTuple<T[\"__items__\"]>>\r\n  : T extends NamedTupleType\r\n  ? NamedTupleType<{\r\n      [k in keyof T[\"__shape__\"]]: castableFrom<T[\"__shape__\"][k]>;\r\n    }>\r\n  : never;\r\n\r\nexport type pointerToCastableExpression<\r\n  Pointer extends PropertyDesc | LinkDesc\r\n> = [Pointer] extends [PropertyDesc]\r\n  ? {\r\n      __element__: castableFrom<Pointer[\"target\"]>;\r\n      __cardinality__: cardutil.assignable<Pointer[\"cardinality\"]>;\r\n    }\r\n  : [Pointer] extends [LinkDesc]\r\n  ? TypeSet<\r\n      ObjectType<\r\n        // anonymize the object type\r\n        string,\r\n        Pointer[\"target\"][\"__pointers__\"]\r\n      >,\r\n      cardutil.assignable<Pointer[\"cardinality\"]>\r\n    >\r\n  : never;\r\n"},{"path":"castMaps.ts","content":"export type scalarCastableFrom<T extends any> = any;\r\nexport type scalarAssignableBy<T extends any> = any;\r\nexport type orScalarLiteral<T extends any> = any;\r\nexport type scalarLiterals = any;\r\nexport type literalToScalarType<T extends any> = any;\r\ntype literalToTypeSet<T extends any> = any;\r\nexport type mapLiteralToTypeSet<T> = {\r\n  [k in keyof T]: literalToTypeSet<T[k]>;\r\n};\r\ndeclare function literalToTypeSet(t: any): any;\r\nexport { literalToTypeSet };\r\nexport declare function isImplicitlyCastableTo(\r\n  from: string,\r\n  to: string\r\n): boolean;\r\nexport function getSharedParentScalar(a: any, b: any): any {}\r\nexport type getSharedParentScalar<A, B> = any;\r\n"},{"path":"collections.ts","content":"import {\r\n  Cardinality,\r\n  ExpressionKind,\r\n  TypeKind,\r\n  type typeutil,\r\n} from \"edgedb/_src/reflection/index.ts\";\r\nimport { cardutil } from \"./cardinality.ts\";\r\nimport type {\r\n  $expr_Array,\r\n  $expr_NamedTuple,\r\n  $expr_Tuple,\r\n  $expr_TuplePath,\r\n  ArrayType,\r\n  BaseType,\r\n  getPrimitiveBaseType,\r\n  NamedTupleLiteralShape,\r\n  NamedTupleShape,\r\n  NamedTupleType,\r\n  NonArrayType,\r\n  ObjectTypeExpression,\r\n  ObjectTypePointers,\r\n  PropertyDesc,\r\n  TupleType,\r\n  TypeSet,\r\n} from \"./typesystem.ts\";\r\n\r\nimport { $expressionify, type ExpressionRoot } from \"./path.ts\";\r\nimport type { getCardsFromExprs } from \"./set.ts\";\r\nimport {\r\n  type literalToScalarType,\r\n  literalToTypeSet,\r\n  type mapLiteralToTypeSet,\r\n  type orScalarLiteral,\r\n  type scalarLiterals,\r\n} from \"./castMaps.ts\";\r\n\r\nconst indexSliceRegx = /^(-?\\d+)(?:(:)(-?\\d+)?)?|:(-?\\d+)$/;\r\n\r\nconst arrayLikeProxyHandlers: ProxyHandler<ExpressionRoot> = {\r\n  get(target: ExpressionRoot, prop: string | symbol, proxy: any) {\r\n    const match = typeof prop === \"string\" ? prop.match(indexSliceRegx) : null;\r\n    if (match) {\r\n      const start = match[1];\r\n      const end = match[3] ?? match[4];\r\n      const isIndex = start && !match[2];\r\n      return $expressionify({\r\n        __kind__: ExpressionKind.Operator,\r\n        __element__:\r\n          target.__element__.__kind__ === TypeKind.array && isIndex\r\n            ? (target.__element__ as ArrayType).__element__\r\n            : target.__element__,\r\n        __cardinality__: target.__cardinality__,\r\n        __name__: \"[]\",\r\n        __opkind__: \"Infix\",\r\n        __args__: [\r\n          proxy,\r\n          isIndex\r\n            ? literalToTypeSet(Number(start))\r\n            : [\r\n                start && literalToTypeSet(Number(start)),\r\n                end && literalToTypeSet(Number(end)),\r\n              ],\r\n        ],\r\n      }) as any;\r\n    }\r\n    return (target as any)[prop];\r\n  },\r\n};\r\n\r\nfunction arrayLikeIndex(this: ExpressionRoot, index: any) {\r\n  const indexTypeSet = literalToTypeSet(index);\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.Operator,\r\n    __element__:\r\n      this.__element__.__kind__ === TypeKind.array\r\n        ? (this.__element__ as ArrayType).__element__\r\n        : this.__element__,\r\n    __cardinality__: cardutil.multiplyCardinalities(\r\n      this.__cardinality__,\r\n      indexTypeSet.__cardinality__\r\n    ),\r\n    __name__: \"[]\",\r\n    __opkind__: \"Infix\",\r\n    __args__: [this, indexTypeSet],\r\n  }) as any;\r\n}\r\n\r\nfunction arrayLikeSlice(this: ExpressionRoot, start: any, end: any) {\r\n  const startTypeSet = start && literalToTypeSet(start);\r\n  const endTypeSet = end && literalToTypeSet(end);\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.Operator,\r\n    __element__: this.__element__,\r\n    __cardinality__: cardutil.multiplyCardinalities(\r\n      cardutil.multiplyCardinalities(\r\n        this.__cardinality__,\r\n        startTypeSet?.__cardinality__ ?? Cardinality.One\r\n      ),\r\n      endTypeSet?.__cardinality__ ?? Cardinality.One\r\n    ),\r\n    __name__: \"[]\",\r\n    __opkind__: \"Infix\",\r\n    __args__: [this, [startTypeSet, endTypeSet]],\r\n  }) as any;\r\n}\r\n\r\nexport function $arrayLikeIndexify(_expr: ExpressionRoot) {\r\n  if (\r\n    _expr.__element__.__kind__ === TypeKind.array ||\r\n    (_expr.__element__.__kind__ === TypeKind.scalar &&\r\n      (_expr.__element__.__name__ === \"std::str\" ||\r\n        _expr.__element__.__name__ === \"std::bytes\"))\r\n  ) {\r\n    const expr = new Proxy(_expr, arrayLikeProxyHandlers) as any;\r\n\r\n    expr.index = arrayLikeIndex.bind(expr);\r\n    expr.slice = arrayLikeSlice.bind(expr);\r\n\r\n    return expr;\r\n  }\r\n\r\n  return _expr;\r\n}\r\n\r\n// ARRAY\r\nexport function array<Element extends NonArrayType>(\r\n  element: Element\r\n): ArrayType<Element>;\r\nexport function array<\r\n  Expr extends TypeSet<NonArrayType> | scalarLiterals,\r\n  Exprs extends orScalarLiteral<\r\n    TypeSet<\r\n      Expr extends TypeSet\r\n        ? getPrimitiveBaseType<Expr[\"__element__\"]>\r\n        : getPrimitiveBaseType<literalToScalarType<Expr>>\r\n    >\r\n  >[]\r\n>(\r\n  arg: [Expr, ...Exprs]\r\n): $expr_Array<\r\n  ArrayType<\r\n    Expr extends TypeSet\r\n      ? getPrimitiveBaseType<Expr[\"__element__\"]>\r\n      : getPrimitiveBaseType<literalToScalarType<Expr>>\r\n  >,\r\n  cardutil.multiplyCardinalitiesVariadic<\r\n    getCardsFromExprs<mapLiteralToTypeSet<[Expr, ...Exprs]>>\r\n  >\r\n>;\r\nexport function array(arg: any) {\r\n  if (Array.isArray(arg)) {\r\n    const items = arg.map((a) => literalToTypeSet(a));\r\n    return $expressionify({\r\n      __kind__: ExpressionKind.Array,\r\n      __cardinality__: cardutil.multiplyCardinalitiesVariadic(\r\n        items.map((item) => item.__cardinality__) as any\r\n      ),\r\n      __element__: {\r\n        __kind__: TypeKind.array,\r\n        __name__: `array<${items[0]!.__element__.__name__}>`,\r\n        __element__: items[0]!.__element__,\r\n      } as any,\r\n      __items__: items,\r\n    });\r\n  }\r\n  if (arg.__kind__) {\r\n    return {\r\n      __kind__: TypeKind.array,\r\n      __name__: `array<${arg.__name__}>`,\r\n      __element__: arg,\r\n    } as any;\r\n  }\r\n\r\n  throw new Error(\"Invalid array input.\");\r\n}\r\n\r\n// TUPLE\r\n\r\nconst tupleProxyHandlers: ProxyHandler<ExpressionRoot> = {\r\n  get(target: ExpressionRoot, prop: string | symbol, proxy: any) {\r\n    const type = target.__element__;\r\n    const items =\r\n      type.__kind__ === TypeKind.tuple\r\n        ? (type as TupleType).__items__\r\n        : type.__kind__ === TypeKind.namedtuple\r\n        ? (type as NamedTupleType).__shape__\r\n        : null;\r\n    return items?.hasOwnProperty(prop)\r\n      ? tuplePath(proxy, (items as any)[prop], prop as any)\r\n      : (target as any)[prop];\r\n  },\r\n};\r\n\r\nexport function $tuplePathify(expr: ExpressionRoot) {\r\n  if (\r\n    expr.__element__.__kind__ !== TypeKind.tuple &&\r\n    expr.__element__.__kind__ !== TypeKind.namedtuple\r\n  ) {\r\n    return expr;\r\n  }\r\n\r\n  return new Proxy(expr, tupleProxyHandlers);\r\n}\r\n\r\nfunction tuplePath(\r\n  parent: $expr_Tuple | $expr_TuplePath,\r\n  itemType: BaseType,\r\n  index: string\r\n): $expr_TuplePath {\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.TuplePath,\r\n    __element__: itemType,\r\n    __cardinality__: parent.__cardinality__,\r\n    __parent__: parent,\r\n    __index__: index,\r\n  }) as any;\r\n}\r\n\r\nfunction makeTupleType(name: string, items: BaseType[]) {\r\n  return {\r\n    __kind__: TypeKind.tuple,\r\n    __name__: name,\r\n    __items__: items,\r\n  } as any;\r\n}\r\n\r\nconst typeKinds = new Set(Object.values(TypeKind));\r\n\r\nexport function tuple<Items extends typeutil.tupleOf<BaseType>>(\r\n  items: Items\r\n): TupleType<Items>;\r\nexport function tuple<\r\n  Item extends TypeSet | scalarLiterals,\r\n  Items extends typeutil.tupleOf<TypeSet | scalarLiterals>\r\n>(\r\n  items: Items\r\n): $expr_Tuple<\r\n  Items extends typeutil.tupleOf<any> ? mapLiteralToTypeSet<Items> : never\r\n>;\r\nexport function tuple<Shape extends NamedTupleShape>(\r\n  shape: Shape\r\n): NamedTupleType<Shape>;\r\nexport function tuple<Shape extends { [k: string]: TypeSet | scalarLiterals }>(\r\n  shape: Shape\r\n): $expr_NamedTuple<mapLiteralToTypeSet<Shape>>;\r\nexport function tuple(input: any) {\r\n  if (Array.isArray(input)) {\r\n    // is tuple\r\n    if (input.every((item) => typeKinds.has(item.__kind__))) {\r\n      const typeItems = input as BaseType[];\r\n      const typeName = `tuple<${typeItems\r\n        .map((item) => item.__name__)\r\n        .join(\", \")}>`;\r\n      return makeTupleType(typeName, typeItems);\r\n    }\r\n\r\n    const items = input.map((item) => literalToTypeSet(item));\r\n    const name = `tuple<${items\r\n      .map((item) => item.__element__.__name__)\r\n      .join(\", \")}>`;\r\n    return $expressionify({\r\n      __kind__: ExpressionKind.Tuple,\r\n      __element__: makeTupleType(\r\n        name,\r\n        items.map((item) => item.__element__)\r\n      ),\r\n      __cardinality__: cardutil.multiplyCardinalitiesVariadic(\r\n        items.map((i) => i.__cardinality__) as any\r\n      ),\r\n      __items__: items,\r\n    }) as any;\r\n  } else {\r\n    // is named tuple\r\n    if (Object.values(input).every((el: any) => typeKinds.has(el.__kind__))) {\r\n      const typeName = `tuple<${Object.entries(input)\r\n        .map(([key, val]: [string, any]) => `${key}: ${val.__name__}`)\r\n        .join(\", \")}>`;\r\n      return {\r\n        __kind__: TypeKind.namedtuple,\r\n        __name__: typeName,\r\n        __shape__: input,\r\n      } as any;\r\n    }\r\n\r\n    const exprShape: NamedTupleLiteralShape = {};\r\n    const typeShape: NamedTupleShape = {};\r\n    for (const [key, val] of Object.entries(input)) {\r\n      const typeSet = literalToTypeSet(val);\r\n      exprShape[key] = typeSet;\r\n      typeShape[key] = typeSet.__element__;\r\n    }\r\n    const name = `tuple<${Object.entries(exprShape)\r\n      .map(([key, val]) => `${key}: ${val.__element__.__name__}`)\r\n      .join(\", \")}>`;\r\n    return $expressionify({\r\n      __kind__: ExpressionKind.NamedTuple,\r\n      __element__: {\r\n        __kind__: TypeKind.namedtuple,\r\n        __name__: name,\r\n        __shape__: typeShape,\r\n      } as any,\r\n      __cardinality__: cardutil.multiplyCardinalitiesVariadic(\r\n        Object.values(exprShape).map((val) => val.__cardinality__) as any\r\n      ),\r\n      __shape__: exprShape,\r\n    }) as any;\r\n  }\r\n}\r\n\r\ntype PropertyNamesFromPointers<Pointers extends ObjectTypePointers> = {\r\n  [k in keyof Pointers as Pointers[k] extends PropertyDesc\r\n    ? Pointers[k][\"computed\"] extends true\r\n      ? never\r\n      : k\r\n    : never]: Pointers[k];\r\n};\r\n\r\nexport function $objectTypeToTupleType<Expr extends ObjectTypeExpression>(\r\n  objectType: Expr\r\n): PropertyNamesFromPointers<\r\n  Expr[\"__element__\"][\"__pointers__\"]\r\n> extends infer Pointers\r\n  ? Pointers extends ObjectTypePointers\r\n    ? NamedTupleType<{\r\n        [k in keyof Pointers as k extends \"id\"\r\n          ? never\r\n          : k]: Pointers[k][\"target\"];\r\n      }>\r\n    : never\r\n  : never;\r\nexport function $objectTypeToTupleType<\r\n  Expr extends ObjectTypeExpression,\r\n  Fields extends keyof PropertyNamesFromPointers<\r\n    Expr[\"__element__\"][\"__pointers__\"]\r\n  >\r\n>(\r\n  objectType: Expr,\r\n  includeFields: Fields[]\r\n): NamedTupleType<{\r\n  [k in Fields]: Expr[\"__element__\"][\"__pointers__\"][k] extends PropertyDesc\r\n    ? Expr[\"__element__\"][\"__pointers__\"][k][\"target\"]\r\n    : never;\r\n}>;\r\nexport function $objectTypeToTupleType(...args: any[]): any {\r\n  const [objExpr, fields] = args as [\r\n    ObjectTypeExpression,\r\n    string[] | undefined\r\n  ];\r\n  const shape = Object.entries(objExpr.__element__.__pointers__).reduce(\r\n    (_shape, [key, val]) => {\r\n      if (\r\n        fields?.length\r\n          ? fields.includes(key)\r\n          : key !== \"id\" && val.__kind__ === \"property\" && !val.computed\r\n      ) {\r\n        _shape[key] = val.target;\r\n      }\r\n      return _shape;\r\n    },\r\n    {} as NamedTupleShape\r\n  );\r\n  return tuple(shape);\r\n}\r\n"},{"path":"detached.ts","content":"import { ExpressionKind } from \"edgedb/_src/reflection/index.ts\";\r\nimport type { Expression, TypeSet } from \"./typesystem.ts\";\r\nimport { $expressionify } from \"./path.ts\";\r\n\r\nexport function detached<Expr extends TypeSet>(\r\n  expr: Expr\r\n): $expr_Detached<Expr> {\r\n  return $expressionify({\r\n    __element__: expr.__element__,\r\n    __cardinality__: expr.__cardinality__,\r\n    __expr__: expr,\r\n    __kind__: ExpressionKind.Detached,\r\n  }) as any;\r\n}\r\n\r\nexport type $expr_Detached<Expr extends TypeSet = TypeSet> = Expression<{\r\n  __element__: Expr[\"__element__\"];\r\n  __cardinality__: Expr[\"__cardinality__\"];\r\n  __kind__: ExpressionKind.Detached;\r\n  __expr__: TypeSet;\r\n}>;\r\n"},{"path":"external.ts","content":"import type { TypeSet, setToTsType } from \"./typesystem.ts\";\r\n\r\nexport { literal } from \"./literal.ts\";\r\nexport {} from \"./path.ts\";\r\nexport { set } from \"./set.ts\";\r\nexport { cast } from \"./cast.ts\";\r\nexport {\r\n  ASC,\r\n  DESC,\r\n  EMPTY_FIRST,\r\n  EMPTY_LAST,\r\n  is,\r\n  delete,\r\n  select,\r\n} from \"./select.ts\";\r\nexport { update } from \"./update.ts\";\r\nexport { insert } from \"./insert.ts\";\r\nexport {\r\n  array,\r\n  tuple,\r\n  $objectTypeToTupleType as objectTypeToTupleType,\r\n} from \"./collections.ts\";\r\nexport {} from \"./funcops.ts\";\r\nexport { for } from \"./for.ts\";\r\nexport { alias, with } from \"./with.ts\";\r\nexport { optional, params } from \"./params.ts\";\r\nexport { detached } from \"./detached.ts\";\r\nexport {} from \"./toEdgeQL.ts\";\r\n\r\nexport type $infer<A extends TypeSet> = setToTsType<A>;\r\n"},{"path":"for.ts","content":"import { Cardinality, ExpressionKind } from \"edgedb/_src/reflection/index.ts\";\r\nimport { cardutil } from \"./cardinality.ts\";\r\nimport type { Expression, BaseType, BaseTypeSet } from \"./typesystem.ts\";\r\nimport { $expressionify } from \"./path.ts\";\r\n\r\nexport type $expr_For<\r\n  El extends BaseType = BaseType,\r\n  Card extends Cardinality = Cardinality\r\n  // IterSet extends BaseTypeSet = BaseTypeSet,\r\n  // Expr extends BaseTypeSet = BaseTypeSet\r\n> = Expression<{\r\n  __element__: El;\r\n  __cardinality__: Card;\r\n  __kind__: ExpressionKind.For;\r\n  __iterSet__: BaseTypeSet;\r\n  __forVar__: $expr_ForVar;\r\n  __expr__: BaseTypeSet;\r\n}>;\r\n\r\nexport type $expr_ForVar<Type extends BaseType = BaseType> = Expression<{\r\n  __element__: Type;\r\n  __cardinality__: Cardinality.One;\r\n  __kind__: ExpressionKind.ForVar;\r\n}>;\r\n\r\nfunction _for<IteratorSet extends BaseTypeSet, Expr extends BaseTypeSet>(\r\n  set: IteratorSet,\r\n  expr: (variable: $expr_ForVar<IteratorSet[\"__element__\"]>) => Expr\r\n): $expr_For<\r\n  Expr[\"__element__\"],\r\n  cardutil.multiplyCardinalities<\r\n    IteratorSet[\"__cardinality__\"],\r\n    Expr[\"__cardinality__\"]\r\n  >\r\n> {\r\n  const forVar = $expressionify({\r\n    __kind__: ExpressionKind.ForVar,\r\n    __element__: set.__element__,\r\n    __cardinality__: Cardinality.One,\r\n  }) as $expr_ForVar<IteratorSet[\"__element__\"]>;\r\n\r\n  const returnExpr = expr(forVar);\r\n\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.For,\r\n    __element__: returnExpr.__element__,\r\n    __cardinality__: cardutil.multiplyCardinalities(\r\n      set.__cardinality__,\r\n      returnExpr.__cardinality__\r\n    ),\r\n    __iterSet__: set,\r\n    __expr__: returnExpr,\r\n    __forVar__: forVar,\r\n  }) as any;\r\n}\r\n\r\nexport { _for as for };\r\n"},{"path":"funcops.ts","content":"import {\r\n  Cardinality,\r\n  type introspect,\r\n  TypeKind,\r\n} from \"edgedb/_src/reflection/index.ts\";\r\nimport { cardutil } from \"./cardinality.ts\";\r\nimport { makeType } from \"./hydrate.ts\";\r\nimport type {\r\n  BaseType,\r\n  BaseTypeSet,\r\n  ArrayType,\r\n  ObjectType,\r\n  TypeSet,\r\n  RangeType,\r\n  Expression,\r\n  MultiRangeType,\r\n} from \"./typesystem.ts\";\r\nimport { cast } from \"./cast.ts\";\r\nimport { isImplicitlyCastableTo, literalToTypeSet } from \"./castMaps.ts\";\r\nimport { literal } from \"./literal.ts\";\r\n\r\nimport type {\r\n  ExpressionKind,\r\n  OperatorKind,\r\n} from \"edgedb/_src/reflection/index.ts\";\r\n\r\nexport type $expr_Function<\r\n  // Name extends string = string,\r\n  // Args extends (BaseTypeSet | undefined)[] = (BaseTypeSet | undefined)[],\r\n  // NamedArgs extends {[key: string]: BaseTypeSet} = {\r\n  //   [key: string]: BaseTypeSet;\r\n  // },\r\n  // ReturnType extends BaseTypeSet = BaseTypeSet,\r\n  El extends BaseType = BaseType,\r\n  Card extends Cardinality = Cardinality\r\n> = Expression<{\r\n  __element__: El;\r\n  __cardinality__: Card;\r\n  __kind__: ExpressionKind.Function;\r\n  __name__: string;\r\n  __args__: (BaseTypeSet | undefined)[];\r\n  __namedargs__: { [key: string]: BaseTypeSet };\r\n}>;\r\n\r\nexport type $expr_Operator<\r\n  // Name extends string = string,\r\n  // OpKind extends OperatorKind = OperatorKind,\r\n  // Args extends TypeSet[] = TypeSet[],\r\n  // ReturnType extends TypeSet = TypeSet,\r\n  El extends BaseType = BaseType,\r\n  Card extends Cardinality = Cardinality\r\n> = Expression<{\r\n  __element__: El;\r\n  __cardinality__: Card;\r\n  __kind__: ExpressionKind.Operator;\r\n  __name__: string;\r\n  __opkind__: OperatorKind;\r\n  __args__: TypeSet[];\r\n}>;\r\n\r\ninterface OverloadFuncArgDef {\r\n  typeId: string;\r\n  optional?: boolean;\r\n  setoftype?: boolean;\r\n  variadic?: boolean;\r\n}\r\n\r\ninterface OverloadFuncDef {\r\n  kind?: string;\r\n  args: OverloadFuncArgDef[];\r\n  namedArgs?: { [key: string]: OverloadFuncArgDef };\r\n  returnTypeId: string;\r\n  returnTypemod?: \"SetOfType\" | \"OptionalType\";\r\n  preservesOptionality?: boolean;\r\n}\r\n\r\nfunction mapLiteralToTypeSet(literals: any[]): TypeSet[];\r\nfunction mapLiteralToTypeSet(literals: { [key: string]: any }): {\r\n  [key: string]: TypeSet;\r\n};\r\nfunction mapLiteralToTypeSet(literals: any[] | { [key: string]: any }) {\r\n  if (Array.isArray(literals)) {\r\n    return literals.map((lit) => (lit != null ? literalToTypeSet(lit) : lit));\r\n  }\r\n  const obj: { [key: string]: TypeSet } = {};\r\n  for (const key of Object.keys(literals)) {\r\n    obj[key] =\r\n      literals[key] != null ? literalToTypeSet(literals[key]) : literals[key];\r\n  }\r\n  return obj;\r\n}\r\n\r\nexport function $resolveOverload(\r\n  funcName: string,\r\n  args: any[],\r\n  typeSpec: introspect.Types,\r\n  funcDefs: OverloadFuncDef[]\r\n) {\r\n  const positionalArgs: (TypeSet | undefined)[] = [];\r\n  let namedArgs: { [key: string]: TypeSet } | undefined;\r\n  if (args.length) {\r\n    if (args[0] !== undefined) {\r\n      try {\r\n        positionalArgs.push(literalToTypeSet(args[0]));\r\n      } catch {\r\n        // first arg is not a expr or literal type, so assume named args object\r\n        namedArgs = mapLiteralToTypeSet(args[0] as object);\r\n      }\r\n    } else {\r\n      positionalArgs.push(undefined);\r\n    }\r\n    positionalArgs.push(...mapLiteralToTypeSet(args.slice(1)));\r\n  }\r\n\r\n  for (const def of funcDefs) {\r\n    const resolvedOverload = _tryOverload(\r\n      funcName,\r\n      positionalArgs,\r\n      namedArgs,\r\n      typeSpec,\r\n      def\r\n    );\r\n    if (resolvedOverload !== null) {\r\n      return resolvedOverload;\r\n    }\r\n  }\r\n\r\n  throw new Error(\r\n    `No function overload found for ${\r\n      funcName.includes(\"::\")\r\n        ? `'e.${funcName.split(\"::\").join(\".\")}()'`\r\n        : `operator '${funcName}'`\r\n    } with args: ${[...positionalArgs, ...Object.values(namedArgs ?? {})]\r\n      .filter(Boolean)\r\n      .map(\r\n        (arg) =>\r\n          `Element: ${arg!.__element__.__name__} (${arg!.__cardinality__})`\r\n      )\r\n      .join(\", \")}`\r\n  );\r\n}\r\n\r\nconst ANYTYPE_ARG = Symbol();\r\n\r\nfunction _tryOverload(\r\n  funcName: string,\r\n  args: (BaseTypeSet | undefined)[],\r\n  namedArgs: { [key: string]: BaseTypeSet } | undefined,\r\n  typeSpec: introspect.Types,\r\n  funcDef: OverloadFuncDef\r\n): {\r\n  kind?: string;\r\n  returnType: BaseType;\r\n  cardinality: Cardinality;\r\n  args: BaseTypeSet[];\r\n  namedArgs: { [key: string]: BaseTypeSet };\r\n} | null {\r\n  if (\r\n    (funcDef.namedArgs === undefined && namedArgs !== undefined) ||\r\n    (namedArgs === undefined &&\r\n      funcDef.namedArgs &&\r\n      Object.values(funcDef.namedArgs).some((arg) => !arg.optional))\r\n  ) {\r\n    return null;\r\n  }\r\n\r\n  const lastParamVariadic = funcDef.args[funcDef.args.length - 1]?.variadic;\r\n  if (!lastParamVariadic && args.length > funcDef.args.length) {\r\n    return null;\r\n  }\r\n\r\n  const paramCardinalities: [Cardinality, ...Cardinality[]] = [Cardinality.One];\r\n\r\n  if (namedArgs) {\r\n    for (const [key, value] of Object.entries(namedArgs)) {\r\n      const argDef = funcDef.namedArgs?.[key];\r\n      if (\r\n        !argDef ||\r\n        !compareType(typeSpec, argDef.typeId, value.__element__).match\r\n      ) {\r\n        return null;\r\n      }\r\n\r\n      paramCardinalities.push(\r\n        argDef.setoftype\r\n          ? funcDef.preservesOptionality\r\n            ? cardutil.overrideUpperBound(value.__cardinality__, \"One\")\r\n            : Cardinality.One\r\n          : argDef.optional\r\n          ? cardutil.overrideLowerBound(value.__cardinality__, \"One\")\r\n          : value.__cardinality__\r\n      );\r\n    }\r\n  }\r\n\r\n  let positionalArgs: BaseTypeSet[] = [];\r\n\r\n  let returnAnytype: BaseType | undefined;\r\n  let needsAnytypeReplacement = false;\r\n\r\n  for (let i = 0; i < funcDef.args.length; i++) {\r\n    const argDef = funcDef.args[i]!;\r\n    const arg = args[i];\r\n\r\n    if (arg === undefined) {\r\n      if (!argDef.optional) {\r\n        return null;\r\n      }\r\n\r\n      if (i < args.length) {\r\n        // arg is explicitly undefined, inject empty set\r\n        const argTypeName = typeSpec.get(argDef.typeId).name;\r\n        if (\r\n          argTypeName.includes(\"anytype\") ||\r\n          argTypeName.includes(\"std::anypoint\")\r\n        ) {\r\n          if (!returnAnytype) {\r\n            positionalArgs.push(ANYTYPE_ARG as any);\r\n            needsAnytypeReplacement = true;\r\n          } else {\r\n            positionalArgs.push(cast(returnAnytype, null));\r\n          }\r\n        } else {\r\n          const argType = makeType<any>(typeSpec, argDef.typeId, literal);\r\n          positionalArgs.push(cast(argType, null));\r\n        }\r\n      }\r\n    } else {\r\n      const { match, anytype } = compareType(\r\n        typeSpec,\r\n        argDef.typeId,\r\n        arg.__element__\r\n      );\r\n\r\n      if (!match) {\r\n        return null;\r\n      }\r\n      if (!returnAnytype && anytype) {\r\n        returnAnytype = anytype;\r\n      }\r\n\r\n      positionalArgs.push(\r\n        ...(argDef.variadic ? (args.slice(i) as BaseTypeSet[]) : [arg])\r\n      );\r\n      if (argDef.setoftype) {\r\n        paramCardinalities.push(\r\n          funcDef.preservesOptionality\r\n            ? cardutil.overrideUpperBound(arg.__cardinality__, \"One\")\r\n            : Cardinality.One\r\n        );\r\n      } else {\r\n        const card = argDef.variadic\r\n          ? cardutil.multiplyCardinalitiesVariadic(\r\n              (args.slice(i) as BaseTypeSet[]).map(\r\n                (el) => el.__cardinality__\r\n              ) as [Cardinality, ...Cardinality[]]\r\n            )\r\n          : arg.__cardinality__;\r\n\r\n        paramCardinalities.push(\r\n          argDef.optional ? cardutil.overrideLowerBound(card, \"One\") : card\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  let cardinality: Cardinality;\r\n  if (funcName === \"if_else\") {\r\n    cardinality = cardutil.multiplyCardinalities(\r\n      cardutil.orCardinalities(\r\n        positionalArgs[0]!.__cardinality__,\r\n        positionalArgs[2]!.__cardinality__\r\n      ),\r\n      positionalArgs[1]!.__cardinality__\r\n    );\r\n  } else if (funcName === \"std::assert_exists\") {\r\n    cardinality = cardutil.overrideLowerBound(\r\n      positionalArgs[0]!.__cardinality__,\r\n      \"One\"\r\n    );\r\n  } else if (funcName === \"union\") {\r\n    cardinality = cardutil.mergeCardinalities(\r\n      positionalArgs[0]!.__cardinality__,\r\n      positionalArgs[1]!.__cardinality__\r\n    );\r\n  } else if (funcName === \"??\") {\r\n    cardinality = cardutil.orCardinalities(\r\n      positionalArgs[0]!.__cardinality__,\r\n      positionalArgs[1]!.__cardinality__\r\n    );\r\n  } else if (funcName === \"distinct\") {\r\n    cardinality = positionalArgs[0]!.__cardinality__;\r\n  } else {\r\n    cardinality =\r\n      funcDef.returnTypemod === \"SetOfType\"\r\n        ? Cardinality.Many\r\n        : cardutil.multiplyCardinalitiesVariadic(paramCardinalities);\r\n\r\n    if (\r\n      funcDef.returnTypemod === \"OptionalType\" &&\r\n      !funcDef.preservesOptionality\r\n    ) {\r\n      cardinality = cardutil.overrideLowerBound(cardinality, \"Zero\");\r\n    }\r\n  }\r\n\r\n  if (needsAnytypeReplacement) {\r\n    if (!returnAnytype) {\r\n      throw new Error(`could not resolve anytype for ${funcName}`);\r\n    }\r\n    positionalArgs = positionalArgs.map((arg) =>\r\n      (arg as any) === ANYTYPE_ARG ? cast(returnAnytype!, null) : arg\r\n    );\r\n  }\r\n\r\n  return {\r\n    kind: funcDef.kind,\r\n    returnType: makeType(\r\n      typeSpec,\r\n      funcDef.returnTypeId,\r\n      literal,\r\n      returnAnytype\r\n    ),\r\n    cardinality,\r\n    args: positionalArgs,\r\n    namedArgs: namedArgs ?? {},\r\n  };\r\n}\r\n\r\nconst nameRemapping: { [key: string]: string } = {\r\n  \"std::int16\": \"std::number\",\r\n  \"std::int32\": \"std::number\",\r\n  \"std::int64\": \"std::number\",\r\n  \"std::float32\": \"std::number\",\r\n  \"std::float64\": \"std::number\",\r\n};\r\nconst descendantCache = new Map<string, string[]>();\r\nfunction getDescendantNames(typeSpec: introspect.Types, typeId: string) {\r\n  if (descendantCache.has(typeId)) {\r\n    return descendantCache.get(typeId)!;\r\n  }\r\n  const descendants: string[] = [\r\n    ...new Set(\r\n      [...typeSpec.values()]\r\n        .filter(\r\n          (type) =>\r\n            type.kind === \"scalar\" && type.bases.some(({ id }) => id === typeId)\r\n        )\r\n        .flatMap((type) =>\r\n          type.is_abstract\r\n            ? getDescendantNames(typeSpec, type.id)\r\n            : [nameRemapping[type.name]!, type.name]\r\n        )\r\n    ),\r\n  ];\r\n  descendantCache.set(typeId, descendants);\r\n  return descendants;\r\n}\r\n\r\nfunction compareType(\r\n  typeSpec: introspect.Types,\r\n  typeId: string,\r\n  arg: BaseType\r\n): { match: boolean; anytype?: BaseType } {\r\n  const type = typeSpec.get(typeId);\r\n\r\n  if (type.name === \"anytype\") {\r\n    return { match: true, anytype: arg };\r\n  }\r\n\r\n  if (type.name === \"anyobject\") {\r\n    return { match: arg.__kind__ === TypeKind.object, anytype: arg };\r\n  }\r\n\r\n  if (type.name === \"std::anypoint\") {\r\n    const descendants = getDescendantNames(typeSpec, typeId);\r\n    if (descendants.includes(arg.__name__)) {\r\n      return { match: true, anytype: arg };\r\n    }\r\n  }\r\n\r\n  if (type.name === \"std::anyenum\") {\r\n    return { match: arg.__kind__ === TypeKind.enum };\r\n  }\r\n\r\n  if (type.kind === \"scalar\") {\r\n    arg = (arg as any).__casttype__ ?? arg;\r\n    return {\r\n      match:\r\n        (arg.__kind__ === TypeKind.scalar || arg.__kind__ === TypeKind.enum) &&\r\n        (arg.__name__ === type.name ||\r\n          isImplicitlyCastableTo(arg.__name__, type.name)),\r\n    };\r\n  }\r\n  if (type.kind === \"array\") {\r\n    if (arg.__kind__ === TypeKind.array) {\r\n      return compareType(\r\n        typeSpec,\r\n        type.array_element_id,\r\n        (arg as any as ArrayType).__element__ as BaseType\r\n      );\r\n    }\r\n  }\r\n  if (type.kind === \"range\") {\r\n    if (arg.__kind__ === TypeKind.range) {\r\n      return compareType(\r\n        typeSpec,\r\n        type.range_element_id,\r\n        (arg as any as RangeType).__element__ as BaseType\r\n      );\r\n    }\r\n  }\r\n  if (type.kind === \"multirange\") {\r\n    if (arg.__kind__ === TypeKind.multirange) {\r\n      return compareType(\r\n        typeSpec,\r\n        type.multirange_element_id,\r\n        (arg as any as MultiRangeType).__element__ as BaseType\r\n      );\r\n    }\r\n  }\r\n  if (type.kind === \"object\") {\r\n    if (arg.__kind__ !== TypeKind.object) return { match: false };\r\n\r\n    const objectArg = arg as ObjectType;\r\n    let match = true;\r\n\r\n    // shape comparison\r\n    for (const ptr of type.pointers) {\r\n      if (objectArg.__pointers__[ptr.name]) {\r\n        const argPtr = objectArg.__pointers__[ptr.name]!;\r\n        const ptrTarget = typeSpec.get(ptr.target_id);\r\n        if (\r\n          ptrTarget.name !== argPtr.target.__name__ ||\r\n          ptr.card !== argPtr.cardinality\r\n        ) {\r\n          match = false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      match,\r\n    };\r\n  }\r\n  if (type.kind === \"tuple\") {\r\n    const items =\r\n      arg.__kind__ === TypeKind.tuple\r\n        ? (arg as any).__items__\r\n        : arg.__kind__ === TypeKind.namedtuple\r\n        ? (arg as any).__shape__\r\n        : null;\r\n    if (items) {\r\n      const keys = Object.keys(items);\r\n\r\n      if (keys.length === type.tuple_elements.length) {\r\n        let anytype: BaseType | undefined;\r\n        for (let i = 0; i < keys.length; i++) {\r\n          if (keys[i] !== type.tuple_elements[i]!.name) {\r\n            return { match: false };\r\n          }\r\n          const { match: m, anytype: a } = compareType(\r\n            typeSpec,\r\n            type.tuple_elements[i]!.target_id,\r\n            (items as any)[keys[i]!]\r\n          );\r\n          if (!m) {\r\n            return { match: false };\r\n          }\r\n          if (a) anytype = a;\r\n        }\r\n        return { match: true, anytype };\r\n      }\r\n    }\r\n  }\r\n\r\n  return { match: false };\r\n}\r\n"},{"path":"globals.ts","content":"import { ExpressionKind, Cardinality } from \"edgedb/_src/reflection/index.ts\";\r\nimport type { Expression, BaseType } from \"./typesystem.ts\";\r\nimport { $expressionify } from \"./path.ts\";\r\n\r\nexport function makeGlobal<\r\n  // Name extends string,\r\n  Type extends BaseType,\r\n  Card extends Cardinality\r\n>(name: string, type: Type, card: Card): $expr_Global<Type, Card> {\r\n  return $expressionify({\r\n    __name__: name,\r\n    __element__: type,\r\n    __cardinality__: card,\r\n    __kind__: ExpressionKind.Global,\r\n  });\r\n}\r\n\r\nexport type $expr_Global<\r\n  // Name extends string = string,\r\n  Type extends BaseType = BaseType,\r\n  Card extends Cardinality = Cardinality\r\n> = Expression<{\r\n  __name__: string;\r\n  __element__: Type;\r\n  __cardinality__: Card;\r\n  __kind__: ExpressionKind.Global;\r\n}>;\r\n"},{"path":"group.ts","content":"import type {\r\n  Expression,\r\n  ObjectType,\r\n  ObjectTypeSet,\r\n  TypeSet,\r\n  BaseType,\r\n  $scopify,\r\n  PropertyDesc,\r\n  LinkDesc,\r\n} from \"./typesystem.ts\";\r\nimport {\r\n  Cardinality,\r\n  ExpressionKind,\r\n  TypeKind,\r\n} from \"edgedb/_src/reflection/index.ts\";\r\nimport { makeType } from \"./hydrate.ts\";\r\n\r\nimport { $expressionify, $getScopedExpr } from \"./path.ts\";\r\n// @ts-ignore\r\nimport type { $FreeObjectλShape, $str } from \"./modules/std.ts\";\r\nimport { spec } from \"./__spec__.ts\";\r\nimport { literal } from \"./literal.ts\";\r\nimport { resolveShapeElement } from \"./select.ts\";\r\nimport type {\r\n  normaliseShape,\r\n  // normaliseElement,\r\n  objectTypeToSelectShape,\r\n} from \"./select.ts\";\r\n\r\ntype SingletonSet = Expression<\r\n  TypeSet<BaseType, Cardinality.One | Cardinality.AtMostOne>\r\n>;\r\ntype SimpleGroupElements = { [k: string]: SingletonSet };\r\ntype GroupModifiers = { by: SimpleGroupElements };\r\ntype NestedGroupElements = {\r\n  [k: string]: SingletonSet | GroupingSet;\r\n};\r\n\r\nexport type GroupingSet = {\r\n  __kind__: \"groupingset\";\r\n  __settype__: \"set\" | \"tuple\" | \"rollup\" | \"cube\";\r\n  __elements__: NestedGroupElements;\r\n  __exprs__: [string, SingletonSet][];\r\n};\r\nexport function isGroupingSet(arg: any): arg is GroupingSet {\r\n  return arg.__kind__ === \"groupingset\";\r\n}\r\n\r\n// result is partial to prevent \"X is specified more than once\" errors\r\n// the return type is a lie, this function returns a grouping set\r\n// but it pretends to return a SimpleGroupElements\r\n// to make the static computatation of `key` easier\r\nconst makeGroupingSet =\r\n  (prefix: string) =>\r\n  <T extends SimpleGroupElements>(grps: T): { [k in keyof T]?: T[k] } => {\r\n    const seenKeys = new Map<string, SingletonSet>();\r\n    const unfiltered = Object.entries(grps as NestedGroupElements).flatMap(\r\n      ([k, grp]) =>\r\n        isGroupingSet(grp)\r\n          ? grp.__exprs__\r\n          : ([[k, grp]] as [string, SingletonSet][])\r\n    );\r\n    const filtered = unfiltered.filter(([k, expr]) => {\r\n      if (!seenKeys.has(k)) {\r\n        seenKeys.set(k, expr);\r\n        return true;\r\n      }\r\n\r\n      if (expr !== seenKeys.get(k)) {\r\n        throw new Error(\r\n          `Cannot override pre-existing expression with key \"${k}\"`\r\n        );\r\n      }\r\n\r\n      return false;\r\n    });\r\n\r\n    return {\r\n      [`${Math.round(1000000 * Math.random())}___`]: {\r\n        __kind__: \"groupingset\",\r\n        __settype__: prefix,\r\n        __elements__: grps,\r\n        __exprs__: filtered,\r\n      } as GroupingSet,\r\n    } as any;\r\n  };\r\nconst set = makeGroupingSet(\"set\");\r\nconst tuple = makeGroupingSet(\"tuple\");\r\nconst rollup = makeGroupingSet(\"rollup\");\r\nconst cube = makeGroupingSet(\"cube\");\r\n\r\nconst setFuncs = { set, tuple, rollup, cube };\r\n\r\nexport type $expr_Group<\r\n  Expr extends ObjectTypeSet = ObjectTypeSet,\r\n  Mods extends GroupModifiers = GroupModifiers,\r\n  Shape extends object = { id: true }\r\n> = Expression<{\r\n  __element__: ObjectType<\r\n    \"std::FreeObject\",\r\n    $FreeObjectλShape & {\r\n      // adding free shape elements into __pointers__\r\n      // because objectTypeToSelectShape doesn't allow shapes on computeds\r\n      // and setToTsType can't handle that currently\r\n      grouping: PropertyDesc<$str, Cardinality.Many, false, true, true, false>;\r\n      key: LinkDesc<\r\n        ObjectType<\r\n          \"std::FreeObject\",\r\n          {\r\n            // tslint:disable-next-line\r\n            [k in keyof Mods[\"by\"]]: Mods[\"by\"][k][\"__element__\"] extends ObjectType\r\n              ? never\r\n              : PropertyDesc<\r\n                  Mods[\"by\"][k][\"__element__\"],\r\n                  Cardinality.AtMostOne\r\n                >;\r\n          }\r\n        >,\r\n        Cardinality.One,\r\n        {},\r\n        false,\r\n        true,\r\n        true,\r\n        false\r\n      >;\r\n      elements: LinkDesc<\r\n        Expr[\"__element__\"],\r\n        Cardinality.Many,\r\n        {},\r\n        false,\r\n        true,\r\n        true,\r\n        false\r\n      >;\r\n    },\r\n    {\r\n      // grouping: true;\r\n      // key: {[k in keyof Mods[\"by\"]]: true};\r\n      // elements: normaliseShape<Shape, \"by\">;\r\n      grouping: TypeSet<$str, Cardinality.Many>;\r\n      key: Expression<{\r\n        __element__: ObjectType<\r\n          \"std::FreeObject\",\r\n          $FreeObjectλShape,\r\n          {\r\n            [k in keyof Mods[\"by\"]]: Expression<{\r\n              __element__: Mods[\"by\"][k][\"__element__\"];\r\n              __cardinality__: Cardinality.AtMostOne;\r\n            }>;\r\n          }\r\n        >;\r\n        __cardinality__: Cardinality.One;\r\n      }>;\r\n      elements: Expression<{\r\n        __element__: ObjectType<\r\n          Expr[\"__element__\"][\"__name__\"],\r\n          Expr[\"__element__\"][\"__pointers__\"],\r\n          // Omit<normaliseShape<Shape>, \"by\">\r\n          normaliseShape<Shape, \"by\">\r\n        >;\r\n        __cardinality__: Cardinality.Many;\r\n      }>;\r\n    }\r\n  >;\r\n  __cardinality__: Cardinality.Many;\r\n  // bit of a lie, this is a GroupingSet at runtime\r\n  __modifiers__: Mods;\r\n  __kind__: ExpressionKind.Group;\r\n  __expr__: ObjectTypeSet;\r\n  __scope__: ObjectTypeSet;\r\n}>;\r\n\r\n// type modifierKeys = \"by\";\r\ntype noUndefined<T> = T extends undefined ? never : T;\r\ntype groupFunc = <\r\n  Expr extends ObjectTypeSet,\r\n  // Shape extends GroupModifiers\r\n  // Grps extends SimpleGroupElements,\r\n  Shape extends { by?: SimpleGroupElements } & objectTypeToSelectShape<\r\n    Expr[\"__element__\"]\r\n  >\r\n  // Mods extends GroupModifiers = {by: Shape[\"by\"]}\r\n>(\r\n  expr: Expr,\r\n  getter: (arg: $scopify<Expr[\"__element__\"]>) => Readonly<Shape>\r\n) => $expr_Group<\r\n  Expr,\r\n  { by: noUndefined<Shape[\"by\"]> },\r\n  normaliseShape<Shape, \"by\">\r\n>;\r\n\r\nconst groupFunc: groupFunc = (expr, getter) => {\r\n  const { shape, scope, modifiers } = resolveShape(getter, expr);\r\n  // const scope = $getScopedExpr(expr as any);\r\n  // const rawGroupings = getter(scope);\r\n  const groupSet = tuple(modifiers.by);\r\n\r\n  // only one key in object returned from makeGroupingSet\r\n  const key = Object.keys(groupSet)[0]!;\r\n  const grouping = groupSet[key] as any as GroupingSet;\r\n  const keyShape: any = {};\r\n  const keyPointers: any = {};\r\n  const keyShapeElement: any = {};\r\n\r\n  for (const [k, e] of grouping.__exprs__) {\r\n    keyShape[k] = $expressionify({\r\n      __element__: e.__element__,\r\n      __cardinality__: Cardinality.AtMostOne,\r\n    } as any);\r\n    keyPointers[k] = {\r\n      __kind__: \"property\",\r\n      target: e.__element__,\r\n      cardinality: Cardinality.AtMostOne,\r\n      exclusive: false,\r\n      computed: false,\r\n      readonly: false,\r\n      hasDefault: false,\r\n    } as PropertyDesc;\r\n    keyShapeElement[k] = true;\r\n  }\r\n\r\n  const $FreeObject = makeType(\r\n    spec,\r\n    [...spec.values()].find((s) => s.name === \"std::FreeObject\")!.id,\r\n    literal\r\n  );\r\n\r\n  const str = makeType(\r\n    spec,\r\n    [...spec.values()].find((s) => s.name === \"std::str\")!.id,\r\n    literal\r\n  );\r\n\r\n  return $expressionify({\r\n    __element__: {\r\n      ...$FreeObject,\r\n      __name__: \"std::FreeObject\",\r\n      __pointers__: {\r\n        ...($FreeObject as any).__pointers__,\r\n        __name__: \"std::FreeObject\",\r\n        grouping: {\r\n          __kind__: \"property\",\r\n          target: str,\r\n          cardinality: Cardinality.Many,\r\n          exclusive: false,\r\n          computed: false,\r\n          readonly: false,\r\n          hasDefault: false,\r\n        } as PropertyDesc,\r\n        key: {\r\n          __kind__: \"link\",\r\n          target: {\r\n            ...$FreeObject,\r\n            __name__: \"std::FreeObject\",\r\n            __pointers__: {\r\n              ...($FreeObject as any).__pointers__,\r\n              ...keyPointers,\r\n            },\r\n            __shape__: keyShape,\r\n          },\r\n          properties: {},\r\n          cardinality: Cardinality.One,\r\n          exclusive: false,\r\n          computed: false,\r\n          readonly: false,\r\n          hasDefault: false,\r\n        } as LinkDesc,\r\n\r\n        elements: {\r\n          __kind__: \"link\",\r\n          target: expr.__element__,\r\n          cardinality: Cardinality.Many,\r\n          properties: {},\r\n          exclusive: false,\r\n          computed: false,\r\n          readonly: false,\r\n          hasDefault: false,\r\n        } as LinkDesc,\r\n      },\r\n      __shape__: {\r\n        grouping: $expressionify({\r\n          __element__: str,\r\n          __cardinality__: Cardinality.Many,\r\n        } as any),\r\n        key: $expressionify({\r\n          __element__: {\r\n            ...$FreeObject,\r\n            __shape__: keyShape,\r\n          },\r\n          __cardinality__: Cardinality.One,\r\n        } as any),\r\n        elements: $expressionify({\r\n          __element__: { ...expr.__element__, __shape__: shape } as any,\r\n          __cardinality__: Cardinality.Many,\r\n        } as any),\r\n      },\r\n    },\r\n\r\n    __cardinality__: Cardinality.Many,\r\n    __expr__: expr,\r\n    __modifiers__: { by: grouping },\r\n    __kind__: ExpressionKind.Group,\r\n    __scope__: scope,\r\n  }) as any;\r\n};\r\nObject.assign(groupFunc, setFuncs);\r\n\r\nfunction resolveShape(\r\n  shapeGetter: ((scope: any) => any) | any,\r\n  expr: TypeSet\r\n): { modifiers: { by: SimpleGroupElements }; shape: any; scope: TypeSet } {\r\n  const modifiers: { by: SimpleGroupElements } = {} as any;\r\n  const shape: any = {};\r\n\r\n  // get scoped object if expression is objecttypeset\r\n  const scope = $getScopedExpr(expr as any) as ObjectTypeSet;\r\n\r\n  // execute getter with scope\r\n  const selectShape =\r\n    typeof shapeGetter === \"function\" ? shapeGetter(scope) : shapeGetter;\r\n\r\n  for (const [key, value] of Object.entries(selectShape)) {\r\n    // handle modifier keys\r\n    if (key === \"by\") {\r\n      modifiers[key] = value as any;\r\n    } else {\r\n      // for scalar expressions, scope === expr\r\n      // shape keys are not allowed\r\n      if (expr.__element__.__kind__ !== TypeKind.object) {\r\n        throw new Error(\r\n          `Invalid select shape key '${key}' on scalar expression, ` +\r\n            `only modifiers are allowed (filter, order_by, offset and limit)`\r\n        );\r\n      }\r\n      shape[key] = resolveShapeElement(key, value, scope);\r\n    }\r\n  }\r\n  if (Object.keys(shape).length === 0) {\r\n    shape.id = true;\r\n  }\r\n  if (!modifiers.by) {\r\n    throw new Error(\"Must provide a `by` key in `e.group`\");\r\n  }\r\n  return { shape, modifiers, scope };\r\n}\r\nexport const group: typeof setFuncs & groupFunc = groupFunc as any;\r\n"},{"path":"hydrate.ts","content":"import type { $ } from \"edgedb\";\r\n\r\nimport type {\r\n  BaseType,\r\n  ObjectType,\r\n  ObjectTypePointers,\r\n  LinkDesc,\r\n  PropertyDesc,\r\n  TupleType,\r\n} from \"./typesystem.ts\";\r\n\r\nimport { util, TypeKind } from \"edgedb/_src/reflection/index.ts\";\r\nimport type { typeutil } from \"edgedb/_src/reflection/index.ts\";\r\n\r\nconst typeCache = new Map<string, BaseType>();\r\n\r\nconst _linkProps = Symbol();\r\n\r\nfunction applySpec(\r\n  spec: $.introspect.Types,\r\n  type: $.introspect.ObjectType,\r\n  shape: any,\r\n  seen: Set<string>,\r\n  literal: any\r\n): void {\r\n  const allPointers = [\r\n    ...type.pointers,\r\n    ...type.backlinks,\r\n    ...type.backlink_stubs,\r\n  ];\r\n  for (const ptr of allPointers) {\r\n    if (seen.has(ptr.name)) {\r\n      continue;\r\n    }\r\n    seen.add(ptr.name);\r\n\r\n    if (ptr.kind === \"link\") {\r\n      shape[ptr.name] = {\r\n        __kind__: \"link\",\r\n        cardinality: ptr.card,\r\n        exclusive: ptr.is_exclusive,\r\n        computed: ptr.is_computed,\r\n        readonly: ptr.is_readonly,\r\n      } as LinkDesc;\r\n      util.defineGetter(shape[ptr.name], \"target\", () =>\r\n        makeType(spec, ptr.target_id, literal)\r\n      );\r\n      util.defineGetter(shape[ptr.name], \"properties\", () => {\r\n        if (!shape[ptr.name][_linkProps]) {\r\n          const linkProperties: { [k: string]: any } = (shape[ptr.name][\r\n            _linkProps\r\n          ] = {});\r\n          for (const linkProp of ptr.pointers ?? []) {\r\n            // We only support \"link properties\" in EdgeDB, currently.\r\n            if (linkProp.kind !== \"property\") {\r\n              return;\r\n            }\r\n            // No use for them reflected, at the moment.\r\n            if (linkProp.name === \"source\" || linkProp.name === \"target\") {\r\n              return;\r\n            }\r\n\r\n            const linkPropObject: any = {\r\n              __kind__: \"property\",\r\n            };\r\n            linkPropObject.cardinality = linkProp.card;\r\n            util.defineGetter(linkPropObject, \"target\", () => {\r\n              return makeType(spec, linkProp.target_id, literal);\r\n            });\r\n            linkProperties[linkProp.name] = linkPropObject;\r\n          }\r\n        }\r\n        return shape[ptr.name][_linkProps];\r\n      });\r\n    } else if (ptr.kind === \"property\") {\r\n      shape[ptr.name] = {\r\n        __kind__: \"property\",\r\n        cardinality: ptr.card,\r\n        exclusive: ptr.is_exclusive,\r\n        computed: ptr.is_computed,\r\n        readonly: ptr.is_readonly,\r\n      } as PropertyDesc;\r\n      util.defineGetter(shape[ptr.name], \"target\", () =>\r\n        makeType(spec, ptr.target_id, literal)\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nexport function makeType<T extends BaseType>(\r\n  spec: $.introspect.Types,\r\n  id: string,\r\n  // should be (type: any, val: any) => any, but causes\r\n  // 'Type instantiation is excessively deep and possibly infinite' error\r\n  // in typescript 4.5\r\n  literal: any,\r\n  anytype?: BaseType\r\n): T {\r\n  const type = spec.get(id);\r\n\r\n  if (type.name === \"anytype\" || type.name === \"std::anypoint\") {\r\n    if (anytype) return anytype as unknown as T;\r\n    throw new Error(\"anytype not provided\");\r\n  }\r\n\r\n  if (typeCache.has(id)) {\r\n    return typeCache.get(id) as T;\r\n  }\r\n\r\n  const obj: any = {};\r\n  obj.__name__ = type.name;\r\n\r\n  if (type.kind === \"object\") {\r\n    obj.__kind__ = TypeKind.object;\r\n\r\n    const pointers: any = {};\r\n    const seen = new Set<string>();\r\n    applySpec(spec, type, pointers, seen, literal);\r\n    const ancestors = [...type.bases];\r\n    for (const anc of ancestors) {\r\n      const ancType = spec.get(anc.id);\r\n      if (ancType.kind === \"object\" || ancType.kind === \"scalar\") {\r\n        ancestors.push(...ancType.bases);\r\n      }\r\n      if (ancType.kind !== \"object\") {\r\n        throw new Error(`Not an object: ${id}`);\r\n      }\r\n      applySpec(spec, ancType, pointers, seen, literal);\r\n    }\r\n\r\n    obj.__pointers__ = pointers;\r\n    obj.__shape__ = {};\r\n    typeCache.set(id, obj);\r\n    return obj;\r\n  } else if (type.kind === \"scalar\") {\r\n    const scalarObj = type.is_abstract\r\n      ? {}\r\n      : type.enum_values\r\n      ? {}\r\n      : // : type.name === \"std::json\"\r\n        // ? (((val: any) => {\r\n        //     return literal(scalarObj, JSON.stringify(val));\r\n        //   }) as any)\r\n        (((val: any) => {\r\n          return literal(scalarObj, val);\r\n        }) as any);\r\n\r\n    if (type.enum_values) {\r\n      scalarObj.__kind__ = TypeKind.enum;\r\n      scalarObj.__values__ = type.enum_values;\r\n      for (const val of type.enum_values) {\r\n        Object.defineProperty(scalarObj, val, {\r\n          get() {\r\n            return literal(scalarObj, val);\r\n          },\r\n        });\r\n      }\r\n    } else {\r\n      scalarObj.__kind__ = TypeKind.scalar;\r\n    }\r\n    scalarObj.__name__ = type.name;\r\n\r\n    if (type.cast_type) {\r\n      scalarObj.__casttype__ = makeType(spec, type.cast_type, literal);\r\n    }\r\n    typeCache.set(id, scalarObj);\r\n    return scalarObj;\r\n  } else if (type.kind === \"array\") {\r\n    obj.__kind__ = TypeKind.array;\r\n    util.defineGetter(obj, \"__element__\", () => {\r\n      return makeType(spec, type.array_element_id, literal, anytype);\r\n    });\r\n    util.defineGetter(obj, \"__name__\", () => {\r\n      return `array<${obj.__element__.__name__}>`;\r\n    });\r\n    return obj;\r\n  } else if (type.kind === \"tuple\") {\r\n    if (type.tuple_elements[0]!.name === \"0\") {\r\n      // unnamed tuple\r\n      obj.__kind__ = TypeKind.tuple;\r\n\r\n      util.defineGetter(obj, \"__items__\", () => {\r\n        return type.tuple_elements.map((el) =>\r\n          makeType(spec, el.target_id, literal, anytype)\r\n        ) as any;\r\n      });\r\n      util.defineGetter(obj, \"__name__\", () => {\r\n        return `tuple<${obj.__items__\r\n          .map((item: any) => item.__name__)\r\n          .join(\", \")}>`;\r\n      });\r\n      return obj;\r\n    } else {\r\n      // named tuple\r\n      obj.__kind__ = TypeKind.namedtuple;\r\n\r\n      util.defineGetter(obj, \"__shape__\", () => {\r\n        const shape: any = {};\r\n        for (const el of type.tuple_elements) {\r\n          shape[el.name] = makeType(spec, el.target_id, literal, anytype);\r\n        }\r\n        return shape;\r\n      });\r\n      util.defineGetter(obj, \"__name__\", () => {\r\n        return `tuple<${Object.entries(obj.__shape__)\r\n          .map(([key, val]: [string, any]) => `${key}: ${val.__name__}`)\r\n          .join(\", \")}>`;\r\n      });\r\n      return obj;\r\n    }\r\n  } else if (type.kind === \"range\") {\r\n    obj.__kind__ = TypeKind.range;\r\n    util.defineGetter(obj, \"__element__\", () => {\r\n      return makeType(spec, type.range_element_id, literal, anytype);\r\n    });\r\n    util.defineGetter(obj, \"__name__\", () => {\r\n      return `range<${obj.__element__.__name__}>`;\r\n    });\r\n    return obj;\r\n  } else if (type.kind === \"multirange\") {\r\n    obj.__kind__ = TypeKind.multirange;\r\n    util.defineGetter(obj, \"__element__\", () => {\r\n      return makeType(spec, type.multirange_element_id, literal, anytype);\r\n    });\r\n    util.defineGetter(obj, \"__name__\", () => {\r\n      return `multirange<${obj.__element__.__name__}>`;\r\n    });\r\n    return obj;\r\n  } else {\r\n    throw new Error(`Invalid type: ${JSON.stringify(type, null, 2)}`);\r\n  }\r\n}\r\nexport type mergeObjectShapes<\r\n  A extends ObjectTypePointers,\r\n  B extends ObjectTypePointers\r\n> = typeutil.flatten<{\r\n  [k in keyof A & keyof B]: A[k] extends B[k] // possible performance issue?\r\n    ? B[k] extends A[k]\r\n      ? A[k]\r\n      : never\r\n    : never;\r\n}>;\r\n\r\nexport type mergeObjectTypes<\r\n  A extends ObjectType | undefined,\r\n  B extends ObjectType | undefined\r\n> = A extends ObjectType\r\n  ? B extends ObjectType\r\n    ? ObjectType<\r\n        `${A[\"__name__\"]} UNION ${B[\"__name__\"]}`,\r\n        mergeObjectShapes<A[\"__pointers__\"], B[\"__pointers__\"]>,\r\n        null\r\n      >\r\n    : A\r\n  : B extends ObjectType\r\n  ? B\r\n  : undefined;\r\n\r\nexport function $mergeObjectTypes<A extends ObjectType, B extends ObjectType>(\r\n  a: A,\r\n  b: B\r\n): mergeObjectTypes<A, B> {\r\n  const obj = {\r\n    __kind__: TypeKind.object,\r\n    __name__: `${a.__name__} UNION ${b.__name__}`,\r\n    get __pointers__() {\r\n      const merged: any = {};\r\n      for (const [akey, aitem] of Object.entries(a.__pointers__)) {\r\n        if (!b.__pointers__[akey]) continue;\r\n\r\n        const bitem = b.__pointers__[akey]!;\r\n        if (aitem.cardinality !== bitem.cardinality) continue;\r\n        // names must reflect full type\r\n        if (aitem.target.__name__ !== bitem.target.__name__) continue;\r\n        merged[akey] = aitem;\r\n      }\r\n      return merged;\r\n    },\r\n    __shape__: {},\r\n  };\r\n  return obj as any;\r\n}\r\n\r\nexport function $mergeTupleTypes<A extends TupleType, B extends TupleType>(\r\n  a: A,\r\n  b: B\r\n): TupleType {\r\n  if (a.__items__.length !== b.__items__.length) {\r\n    throw new Error(\"Incompatible tuple types; lengths differ.\");\r\n  }\r\n  return {} as TupleType;\r\n}\r\n"},{"path":"insert.ts","content":"import {\r\n  Cardinality,\r\n  ExpressionKind,\r\n  type typeutil,\r\n  TypeKind,\r\n} from \"edgedb/_src/reflection/index.ts\";\r\nimport type {\r\n  Expression,\r\n  LinkDesc,\r\n  ObjectTypeSet,\r\n  ObjectTypePointers,\r\n  PropertyDesc,\r\n  stripBacklinks,\r\n  stripNonInsertables,\r\n  $scopify,\r\n  stripSet,\r\n  TypeSet,\r\n  ObjectType,\r\n  NamedTupleType,\r\n} from \"./typesystem.ts\";\r\nimport type { pointerToAssignmentExpression } from \"./casting.ts\";\r\nimport { $expressionify, $getScopedExpr } from \"./path.ts\";\r\nimport { cast } from \"./cast.ts\";\r\nimport { set } from \"./set.ts\";\r\nimport { literal } from \"./literal.ts\";\r\nimport { $getTypeByName } from \"./literal.ts\";\r\nimport type { $expr_PathNode } from \"./path.ts\";\r\nimport type { $Object } from \"./modules/std.ts\";\r\nimport type { scalarLiterals } from \"./castMaps.ts\";\r\n\r\nexport type pointerIsOptional<T extends PropertyDesc | LinkDesc> =\r\n  T[\"cardinality\"] extends\r\n    | Cardinality.Many\r\n    | Cardinality.Empty\r\n    | Cardinality.AtMostOne\r\n    ? true\r\n    : false;\r\n\r\nexport type InsertShape<El extends ObjectType> = typeutil.flatten<\r\n  RawInsertShape<El>\r\n>;\r\n\r\nexport type RawInsertShape<El extends ObjectType> =\r\n  // short-circuit infinitely deep\r\n  ObjectType extends El\r\n    ? never\r\n    : typeutil.stripNever<\r\n        stripNonInsertables<stripBacklinks<El[\"__pointers__\"]>>\r\n      > extends infer Shape\r\n    ? Shape extends ObjectTypePointers\r\n      ? typeutil.addQuestionMarks<{\r\n          [k in keyof Shape]:\r\n            | pointerToAssignmentExpression<Shape[k]>\r\n            | (pointerIsOptional<Shape[k]> extends true\r\n                ? undefined | null\r\n                : never)\r\n            | (Shape[k][\"hasDefault\"] extends true ? undefined : never);\r\n        }> & { [k in `@${string}`]: TypeSet | scalarLiterals }\r\n      : never\r\n    : never;\r\n\r\ninterface UnlessConflict {\r\n  on: TypeSet | null;\r\n  else?: TypeSet;\r\n}\r\n\r\ntype InsertBaseExpression<Root extends TypeSet = TypeSet> = {\r\n  __kind__: ExpressionKind.Insert;\r\n  __element__: Root[\"__element__\"];\r\n  __cardinality__: Cardinality.One;\r\n  __expr__: stripSet<Root>;\r\n  __shape__: any;\r\n};\r\nexport type $expr_Insert<\r\n  // Root extends $expr_PathNode = $expr_PathNode\r\n  El extends ObjectType = ObjectType\r\n  // Conflict = UnlessConflict | null\r\n  // Shape extends InsertShape<Root> = any\r\n> = Expression<{\r\n  __kind__: ExpressionKind.Insert;\r\n  __element__: El;\r\n  __cardinality__: Cardinality.One;\r\n  __expr__: $expr_PathNode;\r\n  __shape__: InsertShape<El>;\r\n\r\n  unlessConflict(): $expr_InsertUnlessConflict<\r\n    El,\r\n    // Expression<{\r\n    //   __kind__: ExpressionKind.Insert;\r\n    //   __element__: El;\r\n    //   __cardinality__: Cardinality.One;\r\n    //   __expr__: $expr_PathNode;\r\n    //   __shape__: InsertShape<El>;\r\n    // }>,\r\n    { on: null }\r\n  >;\r\n  unlessConflict<Conflict extends UnlessConflict>(\r\n    conflictGetter: (scope: $scopify<El>) => Conflict\r\n  ): $expr_InsertUnlessConflict<\r\n    El,\r\n    // Expression<{\r\n    //   __kind__: ExpressionKind.Insert;\r\n    //   __element__: El;\r\n    //   __cardinality__: Cardinality.One;\r\n    //   __expr__: $expr_PathNode;\r\n    //   __shape__: InsertShape<El>;\r\n    // }>,\r\n    Conflict\r\n  >;\r\n}>;\r\n\r\nexport type $expr_InsertUnlessConflict<\r\n  El extends ObjectType = ObjectType,\r\n  // Root extends InsertBaseExpression = InsertBaseExpression,\r\n  Conflict extends UnlessConflict = UnlessConflict\r\n> = Expression<{\r\n  __kind__: ExpressionKind.InsertUnlessConflict;\r\n  __element__: Conflict[\"else\"] extends TypeSet\r\n    ? Conflict[\"else\"][\"__element__\"][\"__name__\"] extends El[\"__name__\"]\r\n      ? El\r\n      : $Object\r\n    : El;\r\n  __cardinality__: Conflict[\"else\"] extends TypeSet\r\n    ? Conflict[\"else\"][\"__cardinality__\"]\r\n    : Cardinality.AtMostOne;\r\n  __expr__: InsertBaseExpression;\r\n  __conflict__: Conflict;\r\n}>;\r\n\r\nfunction unlessConflict(\r\n  this: $expr_Insert,\r\n  conflictGetter?: (scope: TypeSet) => UnlessConflict\r\n) {\r\n  const expr: any = {\r\n    __kind__: ExpressionKind.InsertUnlessConflict,\r\n    __element__: this.__element__,\r\n    __cardinality__: Cardinality.AtMostOne,\r\n    __expr__: this,\r\n    // __conflict__: Conflict;\r\n  };\r\n\r\n  if (!conflictGetter) {\r\n    expr.__conflict__ = { on: null };\r\n    return $expressionify(expr);\r\n  } else {\r\n    const scopedExpr = $getScopedExpr(this.__expr__);\r\n    const conflict = conflictGetter(scopedExpr);\r\n    expr.__conflict__ = conflict;\r\n    if (conflict.else) {\r\n      expr.__cardinality__ = conflict.else.__cardinality__;\r\n      if (this.__element__.__name__ !== conflict.else.__element__.__name__) {\r\n        expr.__element__ = $getTypeByName(\"std::Object\");\r\n      }\r\n    }\r\n    return $expressionify(expr);\r\n  }\r\n}\r\n\r\nexport function $insertify(\r\n  expr: Omit<$expr_Insert, \"unlessConflict\">\r\n): $expr_Insert {\r\n  (expr as any).unlessConflict = unlessConflict.bind(expr as any);\r\n  return expr as any;\r\n}\r\n\r\nexport function $normaliseInsertShape(\r\n  root: ObjectTypeSet,\r\n  shape: { [key: string]: any },\r\n  isUpdate: boolean = false\r\n): { [key: string]: TypeSet | { \"+=\": TypeSet } | { \"-=\": TypeSet } } {\r\n  const newShape: {\r\n    [key: string]: TypeSet | { \"+=\": TypeSet } | { \"-=\": TypeSet };\r\n  } = {};\r\n\r\n  const _shape: [string, any][] =\r\n    shape.__element__?.__kind__ === TypeKind.namedtuple\r\n      ? Object.keys((shape.__element__ as NamedTupleType).__shape__).map(\r\n          (key) => [key, shape[key]]\r\n        )\r\n      : Object.entries(shape);\r\n  for (const [key, _val] of _shape) {\r\n    let val = _val;\r\n    let setModify: string | null = null;\r\n    if (isUpdate && _val != null && typeof _val === \"object\") {\r\n      const valKeys = Object.keys(_val);\r\n      if (\r\n        valKeys.length === 1 &&\r\n        (valKeys[0] === \"+=\" || valKeys[0] === \"-=\")\r\n      ) {\r\n        val = _val[valKeys[0]];\r\n        setModify = valKeys[0];\r\n      }\r\n    }\r\n\r\n    const pointer = root.__element__.__pointers__[key];\r\n\r\n    // no pointer, not a link property\r\n    const isLinkProp = key[0] === \"@\";\r\n    if (!pointer && !isLinkProp) {\r\n      throw new Error(\r\n        `Could not find property pointer for ${\r\n          isUpdate ? \"update\" : \"insert\"\r\n        } shape key: '${key}'`\r\n      );\r\n    }\r\n\r\n    // skip undefined vals\r\n    if (val === undefined) continue;\r\n\r\n    // is val is expression, assign to newShape\r\n    if (val?.__kind__) {\r\n      // ranges can contain null values, so if the type is 'std::number'\r\n      // we need to set the type to the exact number type of the pointer\r\n      // so null casts are correct\r\n      if (\r\n        val.__kind__ === ExpressionKind.Literal &&\r\n        val.__element__.__kind__ === TypeKind.range &&\r\n        val.__element__.__element__.__name__ === \"std::number\"\r\n      ) {\r\n        newShape[key] = (literal as any)(pointer?.target, val.__value__);\r\n      } else {\r\n        newShape[key] = _val;\r\n      }\r\n      continue;\r\n    }\r\n\r\n    // handle link props\r\n    // after this guard, pointer definitely is defined\r\n    if (isLinkProp) {\r\n      throw new Error(\r\n        `Cannot assign plain data to link property '${key}'. Provide an expression instead.`\r\n      );\r\n    }\r\n    // Workaround to tell TypeScript pointer definitely is defined\r\n    if (!pointer) {\r\n      throw new Error(\r\n        \"Code will never reach here, but TypeScript cannot determine\"\r\n      );\r\n    }\r\n\r\n    // trying to assign plain data to a link\r\n    if (pointer.__kind__ !== \"property\" && val !== null) {\r\n      throw new Error(\r\n        `Must provide subquery when assigning to link '${key}' in ${\r\n          isUpdate ? \"update\" : \"insert\"\r\n        } query.`\r\n      );\r\n    }\r\n\r\n    // val is plain data\r\n    // key corresponds to pointer or starts with \"@\"\r\n    const isMulti =\r\n      pointer.cardinality === Cardinality.AtLeastOne ||\r\n      pointer.cardinality === Cardinality.Many;\r\n    if (pointer.__kind__ === \"property\") {\r\n      if (pointer.target.__name__ === \"std::json\") {\r\n      }\r\n    }\r\n\r\n    const wrappedVal =\r\n      val === null\r\n        ? cast(pointer.target, null)\r\n        : isMulti && Array.isArray(val)\r\n        ? val.length === 0\r\n          ? cast(pointer.target, null)\r\n          : set(...val.map((v) => (literal as any)(pointer.target, v)))\r\n        : (literal as any)(pointer.target, val);\r\n    newShape[key] = setModify\r\n      ? ({ [setModify]: wrappedVal } as any)\r\n      : wrappedVal;\r\n  }\r\n  return newShape;\r\n}\r\n\r\nexport function insert<Root extends $expr_PathNode>(\r\n  root: Root,\r\n  shape: InsertShape<Root[\"__element__\"]>\r\n): $expr_Insert<Root[\"__element__\"]> {\r\n  if (typeof shape !== \"object\") {\r\n    throw new Error(\r\n      `invalid insert shape.${\r\n        typeof shape === \"function\"\r\n          ? \" Hint: Insert shape is expected to be an object, \" +\r\n            \"not a function returning a shape object.\"\r\n          : \"\"\r\n      }`\r\n    );\r\n  }\r\n  const expr: any = {\r\n    __kind__: ExpressionKind.Insert,\r\n    __element__: root.__element__,\r\n    __cardinality__: Cardinality.One,\r\n    __expr__: root,\r\n    __shape__: $normaliseInsertShape(root, shape),\r\n  };\r\n  (expr as any).unlessConflict = unlessConflict.bind(expr);\r\n  return $expressionify($insertify(expr)) as any;\r\n}\r\n"},{"path":"json.ts","content":"import { ExpressionKind, TypeKind } from \"edgedb/_src/reflection/index.ts\";\r\nimport type { ParamType } from \"./typesystem.ts\";\r\nimport { encodeB64 } from \"edgedb/_src/primitives/buffer.ts\";\r\nimport type { $expr_WithParams } from \"./params.ts\";\r\n\r\nfunction jsonStringify(type: ParamType, val: any): string {\r\n  if (type.__kind__ === TypeKind.array) {\r\n    if (Array.isArray(val)) {\r\n      return `[${val\r\n        .map((item) => jsonStringify(type.__element__, item))\r\n        .join()}]`;\r\n    }\r\n    throw new Error(`Param with array type is not an array`);\r\n  }\r\n  if (type.__kind__ === TypeKind.tuple) {\r\n    if (!Array.isArray(val)) {\r\n      throw new Error(`Param with tuple type is not an array`);\r\n    }\r\n    if (val.length !== type.__items__.length) {\r\n      throw new Error(\r\n        `Param with tuple type has incorrect number of items. Got ${val.length} expected ${type.__items__.length}`\r\n      );\r\n    }\r\n    return `[${val\r\n      .map((item, i) => jsonStringify(type.__items__[i]!, item))\r\n      .join()}]`;\r\n  }\r\n  if (type.__kind__ === TypeKind.namedtuple) {\r\n    if (typeof val !== \"object\") {\r\n      throw new Error(`Param with named tuple type is not an object`);\r\n    }\r\n    if (Object.keys(val).length !== Object.keys(type.__shape__).length) {\r\n      throw new Error(\r\n        `Param with named tuple type has incorrect number of items. Got ${\r\n          Object.keys(val).length\r\n        } expected ${Object.keys(type.__shape__).length}`\r\n      );\r\n    }\r\n    return `{${Object.entries(val)\r\n      .map(([key, item]) => {\r\n        if (!type.__shape__[key]) {\r\n          throw new Error(\r\n            `Unexpected key in named tuple param: ${key}, expected keys: ${Object.keys(\r\n              type.__shape__\r\n            ).join()}`\r\n          );\r\n        }\r\n        return `\"${key}\": ${jsonStringify(type.__shape__[key]!, item)}`;\r\n      })\r\n      .join()}}`;\r\n  }\r\n  if (\r\n    type.__kind__ === TypeKind.scalar\r\n    // || type.__kind__ === TypeKind.castonlyscalar\r\n  ) {\r\n    switch (type.__name__) {\r\n      case \"std::bigint\":\r\n        return val.toString();\r\n      case \"std::json\":\r\n        return JSON.stringify(val);\r\n      case \"std::bytes\":\r\n        return `\"${encodeB64(val)}\"`;\r\n      case \"cfg::memory\":\r\n        return `\"${val.toString()}\"`;\r\n      default:\r\n        return JSON.stringify(val);\r\n    }\r\n  }\r\n  if (type.__kind__ === TypeKind.enum) {\r\n    return JSON.stringify(val);\r\n  }\r\n  throw new Error(`Invalid param type: ${(type as any).__kind__}`);\r\n}\r\n\r\nexport function jsonifyComplexParams(expr: any, _args: any) {\r\n  if (_args && expr.__kind__ === ExpressionKind.WithParams) {\r\n    const args = { ..._args };\r\n    for (const param of (expr as $expr_WithParams).__params__) {\r\n      if (param.__isComplex__) {\r\n        args[param.__name__] = jsonStringify(\r\n          param.__element__ as any,\r\n          args[param.__name__]\r\n        );\r\n      }\r\n    }\r\n\r\n    return args;\r\n  }\r\n  return _args;\r\n}\r\n"},{"path":"literal.ts","content":"import type {\r\n  Expression,\r\n  BaseType,\r\n  BaseTypeToTsType,\r\n  ScalarType,\r\n} from \"./typesystem.ts\";\r\n\r\n// import {\r\n//   Cardinality,\r\n//   ExpressionKind,\r\n//   BaseType,\r\n//   BaseTypeToTsType,\r\n//   makeType,\r\n//   ScalarType\r\n// } from \"edgedb/_src/reflection/index.ts\";\r\n\r\n// import type {$expr_Literal} from \"./literal.ts\";\r\nimport { $expressionify } from \"./path.ts\";\r\nimport { spec } from \"./__spec__.ts\";\r\nimport { Cardinality, ExpressionKind } from \"edgedb/_src/reflection/index.ts\";\r\nimport { makeType } from \"./hydrate.ts\";\r\n\r\nexport type $expr_Literal<Type extends BaseType = BaseType> = Expression<{\r\n  __element__: Type;\r\n  __cardinality__: Cardinality.One;\r\n  __kind__: ExpressionKind.Literal;\r\n  __value__: any;\r\n}>;\r\n\r\nexport function literal<T extends BaseType>(\r\n  type: T,\r\n  value: BaseTypeToTsType<T>\r\n): $expr_Literal<T> {\r\n  return $expressionify({\r\n    __element__: type,\r\n    __cardinality__: Cardinality.One,\r\n    __kind__: ExpressionKind.Literal,\r\n    __value__: value,\r\n  }) as any;\r\n}\r\n\r\nexport const $nameMapping = new Map<string, string>([\r\n  ...([...spec.values()].map((type) => [type.name, type.id]) as any),\r\n  [\"std::number\", \"00000000-0000-0000-0000-0000000001ff\"],\r\n]);\r\n\r\nexport function $getType(id: string): (val: any) => $expr_Literal<ScalarType> {\r\n  return makeType(spec, id, literal) as any;\r\n}\r\n\r\nexport function $getTypeByName(\r\n  name: string\r\n): (val: any) => $expr_Literal<ScalarType> {\r\n  return makeType(spec, $nameMapping.get(name)!, literal) as any;\r\n}\r\n"},{"path":"operators.ts","content":"export declare function op(...args: any[]): any;\r\n"},{"path":"params.ts","content":"import type { Executor } from \"edgedb\";\r\nimport {\r\n  ExpressionKind,\r\n  Cardinality,\r\n  TypeKind,\r\n} from \"edgedb/_src/reflection/index.ts\";\r\nimport type {\r\n  Expression,\r\n  ParamType,\r\n  setToTsType,\r\n  TypeSet,\r\n  BaseTypeToTsType,\r\n} from \"./typesystem.ts\";\r\nimport { $expressionify } from \"./path.ts\";\r\nimport { runnableExpressionKinds } from \"./query.ts\";\r\nimport { select } from \"./select.ts\";\r\nimport { complexParamKinds } from \"./__spec__.ts\";\r\n\r\ntype Param = ParamType | $expr_OptionalParam;\r\n\r\ntype ParamsRecord = Record<string, Param>;\r\n\r\nexport type $expr_OptionalParam<Type extends ParamType = ParamType> = {\r\n  __kind__: ExpressionKind.OptionalParam;\r\n  __type__: Type;\r\n};\r\n\r\nexport function optional<Type extends ParamType>(\r\n  type: Type\r\n): $expr_OptionalParam<Type> {\r\n  return {\r\n    __kind__: ExpressionKind.OptionalParam,\r\n    __type__: type,\r\n  };\r\n}\r\n\r\nexport type QueryableWithParamsExpression<\r\n  Set extends TypeSet = TypeSet,\r\n  Params extends ParamsRecord = Record<string, never>\r\n> = Expression<Set, false> & {\r\n  run(\r\n    cxn: Executor,\r\n    args: paramsToParamArgs<Params>\r\n  ): Promise<setToTsType<Set>>;\r\n  runJSON(cxn: Executor, args: paramsToParamArgs<Params>): Promise<string>;\r\n};\r\n\r\nexport type $expr_WithParams<\r\n  Params extends ParamsRecord = Record<string, never>,\r\n  Expr extends TypeSet = TypeSet\r\n> = QueryableWithParamsExpression<\r\n  {\r\n    __kind__: ExpressionKind.WithParams;\r\n    __element__: Expr[\"__element__\"];\r\n    __cardinality__: Expr[\"__cardinality__\"];\r\n    __expr__: Expr;\r\n    __params__: $expr_Param[];\r\n  },\r\n  Params\r\n>;\r\n\r\ntype paramsToParamArgs<Params extends ParamsRecord> = {\r\n  [key in keyof Params as Params[key] extends ParamType\r\n    ? key\r\n    : never]: Params[key] extends ParamType\r\n    ? Readonly<BaseTypeToTsType<Params[key], true>>\r\n    : never;\r\n} & {\r\n  [key in keyof Params as Params[key] extends $expr_OptionalParam\r\n    ? key\r\n    : never]?: Params[key] extends $expr_OptionalParam\r\n    ? Readonly<BaseTypeToTsType<Params[key][\"__type__\"], true> | null>\r\n    : never;\r\n};\r\n\r\nexport type $expr_Param<\r\n  Name extends string | number | symbol = string,\r\n  Type extends ParamType = ParamType,\r\n  Optional extends boolean = boolean\r\n> = Expression<{\r\n  __kind__: ExpressionKind.Param;\r\n  __element__: Type;\r\n  __cardinality__: Optional extends true\r\n    ? Cardinality.AtMostOne\r\n    : Cardinality.One;\r\n  __name__: Name;\r\n  __isComplex__: boolean;\r\n}>;\r\n\r\ntype paramsToParamExprs<Params extends ParamsRecord> = {\r\n  [key in keyof Params]: Params[key] extends $expr_OptionalParam\r\n    ? $expr_Param<key, Params[key][\"__type__\"], true>\r\n    : Params[key] extends ParamType\r\n    ? $expr_Param<key, Params[key], false>\r\n    : never;\r\n};\r\n\r\nexport function params<\r\n  Params extends ParamsRecord = Record<string, never>,\r\n  Expr extends Expression = Expression\r\n>(\r\n  paramsDef: Params,\r\n  expr: (params: paramsToParamExprs<Params>) => Expr\r\n): $expr_WithParams<Params, Expr> {\r\n  const paramExprs: { [key: string]: $expr_Param } = {};\r\n  for (const [key, param] of Object.entries(paramsDef)) {\r\n    const paramType =\r\n      param.__kind__ === ExpressionKind.OptionalParam ? param.__type__ : param;\r\n    const isComplex =\r\n      complexParamKinds.has(paramType.__kind__) ||\r\n      (paramType.__kind__ === TypeKind.array &&\r\n        complexParamKinds.has(paramType.__element__.__kind__));\r\n    paramExprs[key] = $expressionify({\r\n      __kind__: ExpressionKind.Param,\r\n      __element__: paramType,\r\n      __cardinality__:\r\n        param.__kind__ === ExpressionKind.OptionalParam\r\n          ? Cardinality.AtMostOne\r\n          : Cardinality.One,\r\n      __name__: key,\r\n      __isComplex__: isComplex,\r\n    }) as any;\r\n  }\r\n\r\n  let returnExpr = expr(paramExprs as any);\r\n\r\n  if (!runnableExpressionKinds.has((returnExpr as any).__kind__)) {\r\n    returnExpr = select(returnExpr) as any;\r\n  }\r\n\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.WithParams,\r\n    __element__: returnExpr.__element__,\r\n    __cardinality__: returnExpr.__cardinality__,\r\n    __expr__: returnExpr,\r\n    __params__: Object.values(paramExprs),\r\n  }) as any;\r\n}\r\n"},{"path":"path.ts","content":"import {\r\n  // cardutil,\r\n  // ObjectTypeSet,\r\n  // TypeSet,\r\n  // Expression,\r\n  ExpressionKind,\r\n  TypeKind,\r\n  // LinkDesc,\r\n  // PropertyDesc,\r\n  Cardinality,\r\n  // BaseType,\r\n  type typeutil,\r\n} from \"edgedb/_src/reflection/index.ts\";\r\n\r\nimport { cardutil } from \"./cardinality.ts\";\r\n\r\nimport { literalToTypeSet } from \"./castMaps.ts\";\r\nimport { $arrayLikeIndexify, $tuplePathify } from \"./collections.ts\";\r\nimport { $toEdgeQL } from \"./toEdgeQL.ts\";\r\nimport { $queryFunc, $queryFuncJSON } from \"./query.ts\";\r\n\r\nimport type {\r\n  BaseType,\r\n  Expression,\r\n  LinkDesc,\r\n  ObjectType,\r\n  ObjectTypePointers,\r\n  ObjectTypeSet,\r\n  PropertyDesc,\r\n  PropertyShape,\r\n  TypeSet,\r\n} from \"./typesystem.ts\";\r\n// import {typeutil} from \"./typeutil.ts\";\r\n// import {cardutil} from \"./cardinality.ts\";\r\n\r\n// get the set representing the result of a path traversal\r\n// including cardinality merging\r\ntype getChildOfObjectTypeSet<\r\n  Root extends ObjectTypeSet,\r\n  ChildKey extends keyof Root[\"__element__\"][\"__pointers__\"]\r\n> = TypeSet<\r\n  Root[\"__element__\"][\"__pointers__\"][ChildKey][\"target\"],\r\n  cardutil.multiplyCardinalities<\r\n    Root[\"__cardinality__\"],\r\n    Root[\"__element__\"][\"__pointers__\"][ChildKey][\"cardinality\"]\r\n  >\r\n>;\r\n\r\n// path parent must be object expression\r\nexport interface PathParent<\r\n  Parent extends ObjectTypeSet = ObjectTypeSet,\r\n  L extends string = string\r\n> {\r\n  type: Parent;\r\n  linkName: L;\r\n}\r\n\r\nexport type $linkPropify<Root extends ObjectTypeSet> = Root extends {\r\n  __parent__: PathParent<infer Parent, infer L>;\r\n}\r\n  ? // tslint:disable-next-line\r\n    Parent[\"__element__\"][\"__pointers__\"][L] extends LinkDesc<\r\n      any,\r\n      any,\r\n      infer LinkProps,\r\n      any,\r\n      any,\r\n      any,\r\n      any\r\n    >\r\n    ? pathifyLinkProps<LinkProps, Root, PathParent<Parent, L>>\r\n    : {}\r\n  : unknown;\r\n\r\nexport type $pathify<\r\n  Root extends TypeSet\r\n  // Parent extends PathParent | null = null\r\n> = Root extends ObjectTypeSet\r\n  ? ObjectTypeSet extends Root\r\n    ? {} // Root is literally ObjectTypeSet\r\n    : pathifyPointers<Root> & pathifyShape<Root> & $linkPropify<Root>\r\n  : {}; // pathify does nothing on non-object types\r\n\r\nexport type pathifyPointers<\r\n  Root extends ObjectTypeSet\r\n  // Parent extends PathParent | null = null\r\n> = ObjectTypePointers extends Root[\"__element__\"][\"__pointers__\"]\r\n  ? unknown\r\n  : {\r\n      // & string required to avoid typeError on linkName\r\n      [k in keyof Root[\"__element__\"][\"__pointers__\"] &\r\n        string]: Root[\"__element__\"][\"__pointers__\"][k] extends PropertyDesc\r\n        ? $expr_PathLeaf<\r\n            getChildOfObjectTypeSet<Root, k>,\r\n            { type: anonymizeObjectTypeSet<Root>; linkName: k }\r\n            // Root[\"__element__\"][\"__pointers__\"][k][\"exclusive\"]\r\n          >\r\n        : Root[\"__element__\"][\"__pointers__\"][k] extends LinkDesc\r\n        ? getChildOfObjectTypeSet<Root, k> extends ObjectTypeSet\r\n          ? $expr_PathNode<\r\n              getChildOfObjectTypeSet<Root, k>,\r\n              { type: anonymizeObjectTypeSet<Root>; linkName: k }\r\n              // Root[\"__element__\"][\"__pointers__\"][k][\"exclusive\"]\r\n            >\r\n          : unknown\r\n        : unknown;\r\n    };\r\n\r\ntype anonymizeObjectTypeSet<T extends ObjectTypeSet> = typeutil.flatten<{\r\n  __element__: ObjectType<\r\n    T[\"__element__\"][\"__name__\"],\r\n    T[\"__element__\"][\"__pointers__\"],\r\n    { id: true }\r\n  >;\r\n  __cardinality__: T[\"__cardinality__\"];\r\n}>;\r\n\r\nexport type pathifyShape<\r\n  Root extends ObjectTypeSet,\r\n  Shape extends { [k: string]: any } = Root[\"__element__\"][\"__shape__\"]\r\n> = string extends keyof Shape\r\n  ? {}\r\n  : {\r\n      [k in keyof Shape & string]: Shape[k] extends ObjectTypeSet\r\n        ? $expr_PathNode<\r\n            TypeSet<\r\n              Shape[k][\"__element__\"],\r\n              cardutil.multiplyCardinalities<\r\n                Root[\"__cardinality__\"],\r\n                Shape[k][\"__cardinality__\"]\r\n              >\r\n            >,\r\n            { type: Root; linkName: k }\r\n            // false\r\n          >\r\n        : Shape[k] extends TypeSet\r\n        ? $expr_PathLeaf<\r\n            TypeSet<\r\n              Shape[k][\"__element__\"],\r\n              cardutil.multiplyCardinalities<\r\n                Root[\"__cardinality__\"],\r\n                Shape[k][\"__cardinality__\"]\r\n              >\r\n            >,\r\n            { type: Root; linkName: k }\r\n            // false\r\n          >\r\n        : // must be unknown (not never) to avoid overriding\r\n          // a pointer with the same key\r\n          unknown;\r\n    };\r\n\r\ntype pathifyLinkProps<\r\n  Props extends PropertyShape,\r\n  Root extends ObjectTypeSet,\r\n  Parent extends PathParent | null = null\r\n> = {\r\n  [k in keyof Props & string]: Props[k] extends PropertyDesc\r\n    ? $expr_PathLeaf<\r\n        TypeSet<\r\n          Props[k][\"target\"],\r\n          cardutil.multiplyCardinalities<\r\n            Root[\"__cardinality__\"],\r\n            Props[k][\"cardinality\"]\r\n          >\r\n        >,\r\n        { type: $expr_PathNode<Root, Parent>; linkName: k }\r\n        // {type: $expr_PathNode<Root>; linkName: k},\r\n        // Props[k][\"exclusive\"]\r\n      >\r\n    : unknown;\r\n};\r\n\r\nexport type getPropsShape<T extends ObjectType> = typeutil.flatten<\r\n  typeutil.stripNever<{\r\n    [k in keyof T[\"__pointers__\"]]: T[\"__pointers__\"][k][\"__kind__\"] extends \"property\"\r\n      ? true\r\n      : never;\r\n  }>\r\n>;\r\n\r\nexport type $expr_PathNode<\r\n  Root extends ObjectTypeSet = ObjectTypeSet,\r\n  Parent extends PathParent | null = PathParent | null\r\n  // Exclusive extends boolean = boolean\r\n> = Expression<{\r\n  __element__: Root[\"__element__\"];\r\n  __cardinality__: Root[\"__cardinality__\"];\r\n  __parent__: Parent;\r\n  __kind__: ExpressionKind.PathNode;\r\n  // __exclusive__: boolean;\r\n  \"*\": getPropsShape<Root[\"__element__\"]>;\r\n}>;\r\n\r\nexport type $expr_TypeIntersection<\r\n  Card extends Cardinality = Cardinality,\r\n  Intersection extends ObjectType = ObjectType\r\n> = Expression<{\r\n  __element__: Intersection;\r\n  __cardinality__: Card;\r\n  __kind__: ExpressionKind.TypeIntersection;\r\n  __expr__: TypeSet;\r\n}>;\r\n\r\nexport type $expr_PathLeaf<\r\n  Root extends TypeSet = TypeSet,\r\n  Parent extends PathParent = PathParent\r\n  // Exclusive extends boolean = boolean\r\n> = Expression<{\r\n  __element__: Root[\"__element__\"];\r\n  __cardinality__: Root[\"__cardinality__\"];\r\n  __kind__: ExpressionKind.PathLeaf;\r\n  __parent__: Parent;\r\n  // __exclusive__: boolean;\r\n}>;\r\n\r\nexport type ExpressionRoot = {\r\n  __element__: BaseType;\r\n  __cardinality__: Cardinality;\r\n  __kind__: ExpressionKind;\r\n};\r\n\r\nfunction PathLeaf<\r\n  Root extends TypeSet,\r\n  Parent extends PathParent,\r\n  Exclusive extends boolean = boolean\r\n>(\r\n  root: Root,\r\n  parent: Parent,\r\n  exclusive: Exclusive,\r\n  scopeRoot: TypeSet | null = null\r\n): $expr_PathLeaf<Root, Parent> {\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.PathLeaf,\r\n    __element__: root.__element__,\r\n    __cardinality__: root.__cardinality__,\r\n    __parent__: parent,\r\n    // __exclusive__: exclusive,\r\n    __scopeRoot__: scopeRoot,\r\n  }) as any;\r\n}\r\n\r\nfunction getStarShapeFromPointers(pointers: ObjectTypePointers) {\r\n  const shape: any = {};\r\n  for (const [key, ptr] of Object.entries(pointers)) {\r\n    if (ptr.__kind__ === \"property\") {\r\n      shape[key] = true;\r\n    }\r\n  }\r\n  return shape;\r\n}\r\n\r\nfunction PathNode<\r\n  Root extends ObjectTypeSet,\r\n  Parent extends PathParent | null\r\n  // Exclusive extends boolean = boolean\r\n>(\r\n  root: Root,\r\n  parent: Parent,\r\n  // exclusive: boolean,\r\n  scopeRoot: TypeSet | null = null\r\n): $expr_PathNode<Root, Parent> {\r\n  const obj = {\r\n    __kind__: ExpressionKind.PathNode,\r\n    __element__: root.__element__,\r\n    __cardinality__: root.__cardinality__,\r\n    __parent__: parent,\r\n    // __exclusive__: exclusive,\r\n    __scopeRoot__: scopeRoot,\r\n  };\r\n\r\n  Object.defineProperty(obj, \"*\", {\r\n    writable: false,\r\n    value: getStarShapeFromPointers(obj.__element__.__pointers__),\r\n  });\r\n  return $expressionify(obj) as any;\r\n}\r\n\r\nconst _pathCache = Symbol();\r\nconst _pointers = Symbol();\r\n\r\nconst pathifyProxyHandlers: ProxyHandler<any> = {\r\n  get(target: any, prop: string | symbol, proxy: any) {\r\n    const ptr = target[_pointers][prop as any] as LinkDesc | PropertyDesc;\r\n    if (ptr) {\r\n      return (\r\n        target[_pathCache][prop] ??\r\n        (target[_pathCache][prop] = (\r\n          (ptr.__kind__ === \"property\" ? PathLeaf : PathNode) as any\r\n        )(\r\n          {\r\n            __element__: ptr.target,\r\n            __cardinality__: cardutil.multiplyCardinalities(\r\n              target.__cardinality__,\r\n              ptr.cardinality\r\n            ),\r\n          },\r\n          {\r\n            linkName: prop,\r\n            type: proxy,\r\n          },\r\n          ptr.exclusive ?? false,\r\n          target.__scopeRoot__ ?? (scopeRoots.has(proxy) ? proxy : null)\r\n        ))\r\n      );\r\n    }\r\n    return target[prop];\r\n  },\r\n};\r\n\r\nexport function $pathify<Root extends TypeSet, Parent extends PathParent>(\r\n  _root: Root\r\n): $pathify<Root> {\r\n  if (_root.__element__.__kind__ !== TypeKind.object) {\r\n    return _root as any;\r\n  }\r\n\r\n  const root: $expr_PathNode<ObjectTypeSet> = _root as any;\r\n\r\n  let pointers = {\r\n    ...root.__element__.__pointers__,\r\n  };\r\n\r\n  if (root.__parent__) {\r\n    const { type, linkName } = root.__parent__;\r\n    const parentPointer = type.__element__.__pointers__[linkName];\r\n    if (parentPointer?.__kind__ === \"link\") {\r\n      pointers = { ...pointers, ...parentPointer.properties };\r\n    }\r\n  }\r\n\r\n  for (const [key, val] of Object.entries(\r\n    root.__element__.__shape__ || { id: true }\r\n  )) {\r\n    if (pointers[key]) continue;\r\n    const valType: BaseType = (val as any)?.__element__;\r\n    if (!valType) continue;\r\n\r\n    pointers[key] = {\r\n      __kind__: valType.__kind__ === TypeKind.object ? \"link\" : \"property\",\r\n      properties: {},\r\n      target: (val as any).__element__,\r\n      cardinality: (val as any).__cardinality__,\r\n      exclusive: false,\r\n      computed: true,\r\n      readonly: true,\r\n      hasDefault: false,\r\n    };\r\n  }\r\n\r\n  (root as any)[_pointers] = pointers;\r\n  (root as any)[_pathCache] = {};\r\n\r\n  return new Proxy(root, pathifyProxyHandlers);\r\n}\r\n\r\nfunction isFunc(this: any, expr: ObjectTypeSet) {\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.TypeIntersection,\r\n    __cardinality__: this.__cardinality__,\r\n    __element__: {\r\n      ...expr.__element__,\r\n      __shape__: { id: true },\r\n    } as any,\r\n    __expr__: this,\r\n  });\r\n}\r\n\r\nexport function $assert_single(expr: Expression) {\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.Function,\r\n    __element__: expr.__element__,\r\n    __cardinality__: cardutil.overrideUpperBound(expr.__cardinality__, \"One\"),\r\n    __name__: \"std::assert_single\",\r\n    __args__: [expr],\r\n    __namedargs__: {},\r\n  }) as any;\r\n}\r\n\r\nconst jsonDestructureProxyHandlers: ProxyHandler<ExpressionRoot> = {\r\n  get(target: ExpressionRoot, prop: string | symbol, proxy: any) {\r\n    if (typeof prop === \"string\" && !(prop in target)) {\r\n      const parsedProp = Number.isInteger(Number(prop)) ? Number(prop) : prop;\r\n      return jsonDestructure.call(proxy, parsedProp);\r\n    }\r\n    return (target as any)[prop];\r\n  },\r\n};\r\n\r\nfunction jsonDestructure(this: ExpressionRoot, path: any) {\r\n  const pathTypeSet = literalToTypeSet(path);\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.Operator,\r\n    __element__: this.__element__,\r\n    __cardinality__: cardutil.multiplyCardinalities(\r\n      this.__cardinality__,\r\n      pathTypeSet.__cardinality__\r\n    ),\r\n    __name__: \"[]\",\r\n    __opkind__: \"Infix\",\r\n    __args__: [this, pathTypeSet],\r\n  }) as any;\r\n}\r\n\r\nexport function $jsonDestructure(_expr: ExpressionRoot) {\r\n  if (\r\n    _expr.__element__.__kind__ === TypeKind.scalar &&\r\n    _expr.__element__.__name__ === \"std::json\"\r\n  ) {\r\n    const expr = new Proxy(_expr, jsonDestructureProxyHandlers) as any;\r\n\r\n    expr.destructure = jsonDestructure.bind(expr);\r\n\r\n    return expr;\r\n  }\r\n\r\n  return _expr;\r\n}\r\n\r\nexport function $expressionify<T extends ExpressionRoot>(\r\n  _expr: T\r\n): Expression<T> {\r\n  const expr: Expression = $pathify(\r\n    $jsonDestructure($arrayLikeIndexify($tuplePathify(_expr)))\r\n  ) as any;\r\n\r\n  expr.run = $queryFunc.bind(expr) as any;\r\n  expr.runJSON = $queryFuncJSON.bind(expr) as any;\r\n  expr.is = isFunc.bind(expr) as any;\r\n  expr.toEdgeQL = $toEdgeQL.bind(expr);\r\n  expr.assert_single = () => $assert_single(expr) as any;\r\n\r\n  return Object.freeze(expr) as any;\r\n}\r\n\r\nconst scopedExprCache = new WeakMap<ExpressionRoot, Expression>();\r\nconst scopeRoots = new WeakSet<Expression>();\r\n\r\nexport function $getScopedExpr<T extends ExpressionRoot>(\r\n  expr: T,\r\n  existingScopes?: Set<Expression>\r\n): Expression<T> {\r\n  let scopedExpr = scopedExprCache.get(expr);\r\n  if (!scopedExpr || existingScopes?.has(scopedExpr)) {\r\n    // free objects should not be scopified\r\n    const isFreeObject =\r\n      expr.__cardinality__ === Cardinality.One &&\r\n      expr.__element__.__name__ === \"std::FreeObject\";\r\n\r\n    scopedExpr = isFreeObject\r\n      ? (expr as any as Expression<TypeSet<BaseType, Cardinality>>)\r\n      : $expressionify({\r\n          ...expr,\r\n          __cardinality__: Cardinality.One,\r\n          __scopedFrom__: expr,\r\n          ...(expr.__element__.__kind__ === TypeKind.object\r\n            ? {\r\n                \"*\": getStarShapeFromPointers(\r\n                  (expr.__element__ as ObjectType).__pointers__\r\n                ),\r\n              }\r\n            : {}),\r\n        });\r\n    scopeRoots.add(scopedExpr);\r\n    const uncached = !scopedExpr;\r\n    if (uncached) {\r\n      scopedExprCache.set(expr, scopedExpr);\r\n    }\r\n  }\r\n  existingScopes?.add(scopedExpr);\r\n  return scopedExpr as any;\r\n}\r\n\r\nexport { PathLeaf as $PathLeaf, PathNode as $PathNode };\r\n"},{"path":"query.ts","content":"import type * as edgedb from \"edgedb\";\r\nimport { Cardinality, ExpressionKind } from \"edgedb/_src/reflection/index.ts\";\r\nimport { jsonifyComplexParams } from \"./json.ts\";\r\nimport { select } from \"./select.ts\";\r\n\r\nexport const runnableExpressionKinds = new Set([\r\n  ExpressionKind.Select,\r\n  ExpressionKind.Update,\r\n  ExpressionKind.Insert,\r\n  ExpressionKind.InsertUnlessConflict,\r\n  ExpressionKind.Delete,\r\n  ExpressionKind.Group,\r\n  ExpressionKind.For,\r\n  ExpressionKind.With,\r\n  ExpressionKind.WithParams,\r\n]);\r\n\r\nconst wrappedExprCache = new WeakMap();\r\n\r\nexport async function $queryFunc(this: any, cxn: edgedb.Executor, args: any) {\r\n  const expr = runnableExpressionKinds.has(this.__kind__)\r\n    ? this\r\n    : wrappedExprCache.get(this) ??\r\n      wrappedExprCache.set(this, select(this)).get(this);\r\n\r\n  const _args = jsonifyComplexParams(expr, args);\r\n\r\n  const query = expr.toEdgeQL();\r\n\r\n  if (\r\n    expr.__cardinality__ === Cardinality.One ||\r\n    expr.__cardinality__ === Cardinality.AtMostOne ||\r\n    expr.__cardinality__ === Cardinality.Empty\r\n  ) {\r\n    return cxn.querySingle(query, _args);\r\n  } else {\r\n    return cxn.query(query, _args);\r\n  }\r\n}\r\n\r\nexport async function $queryFuncJSON(\r\n  this: any,\r\n  cxn: edgedb.Executor,\r\n  args: any\r\n) {\r\n  const expr = runnableExpressionKinds.has(this.__kind__)\r\n    ? this\r\n    : wrappedExprCache.get(this) ??\r\n      wrappedExprCache.set(this, select(this)).get(this);\r\n  const _args = jsonifyComplexParams(expr, args);\r\n\r\n  if (\r\n    expr.__cardinality__ === Cardinality.One ||\r\n    expr.__cardinality__ === Cardinality.AtMostOne\r\n  ) {\r\n    return cxn.querySingleJSON(expr.toEdgeQL(), _args);\r\n  } else {\r\n    return cxn.queryJSON(expr.toEdgeQL(), _args);\r\n  }\r\n}\r\n"},{"path":"range.ts","content":"import type { LocalDate, LocalDateTime, Duration } from \"edgedb\";\r\nimport { Range } from \"edgedb\";\r\nimport { TypeKind, ExpressionKind } from \"edgedb/_src/reflection/index.ts\";\r\n\r\nimport type { cardutil } from \"./cardinality.ts\";\r\nimport type {\r\n  RangeType,\r\n  getPrimitiveBaseType,\r\n  TypeSet,\r\n  BaseType,\r\n} from \"./typesystem.ts\";\r\nimport type { $expr_Literal } from \"./literal.ts\";\r\n\r\nimport type {\r\n  $number,\r\n  $decimal,\r\n  $datetime,\r\n  $duration,\r\n  $bool,\r\n} from \"./modules/std.ts\";\r\nimport type { $local_date, $local_datetime } from \"./modules/cal.ts\";\r\nimport type { literalToScalarType, orScalarLiteral } from \"./castMaps.ts\";\r\nimport { literalToTypeSet } from \"./castMaps.ts\";\r\nimport { spec } from \"./__spec__.ts\";\r\nimport { literal, $nameMapping } from \"./literal.ts\";\r\nimport { type $expr_Function, $resolveOverload } from \"./funcops.ts\";\r\nimport { $expressionify } from \"./path.ts\";\r\n\r\ntype $anypoint =\r\n  | $number\r\n  | $local_date\r\n  | $decimal\r\n  | $datetime\r\n  | $local_datetime\r\n  | $duration;\r\n\r\nfunction range<Element extends $anypoint>(element: Element): RangeType<Element>;\r\nfunction range<T extends number | Date | LocalDate | LocalDateTime | Duration>(\r\n  val: Range<T>\r\n): $expr_Literal<RangeType<getPrimitiveBaseType<literalToScalarType<T>>>>;\r\nfunction range<\r\n  NamedArgs extends {\r\n    inc_lower?: orScalarLiteral<TypeSet<$bool>>;\r\n    inc_upper?: orScalarLiteral<TypeSet<$bool>>;\r\n    empty?: orScalarLiteral<TypeSet<$bool>>;\r\n  },\r\n  P1 extends orScalarLiteral<TypeSet<$anypoint>> | undefined,\r\n  P2 extends\r\n    | orScalarLiteral<\r\n        TypeSet<\r\n          BaseType extends literalToScalarType<P1>\r\n            ? $anypoint\r\n            : getPrimitiveBaseType<literalToScalarType<P1>>\r\n        >\r\n      >\r\n    | undefined\r\n>(\r\n  namedArgs: NamedArgs,\r\n  lower?: P1,\r\n  upper?: P2\r\n): $expr_Function<\r\n  // \"std::range\",\r\n  // mapLiteralToTypeSet<[P1, P2]>,\r\n  // mapLiteralToTypeSet<NamedArgs>,\r\n  // TypeSet<\r\n  RangeType<\r\n    literalToScalarType<P1> extends $anypoint\r\n      ? literalToScalarType<P1>\r\n      : literalToScalarType<P2> extends $anypoint\r\n      ? literalToScalarType<P2>\r\n      : $anypoint\r\n  >,\r\n  cardutil.multiplyCardinalities<\r\n    cardutil.multiplyCardinalities<\r\n      cardutil.multiplyCardinalities<\r\n        cardutil.multiplyCardinalities<\r\n          cardutil.optionalParamCardinality<P1>,\r\n          cardutil.optionalParamCardinality<P2>\r\n        >,\r\n        cardutil.optionalParamCardinality<NamedArgs[\"inc_lower\"]>\r\n      >,\r\n      cardutil.optionalParamCardinality<NamedArgs[\"inc_upper\"]>\r\n    >,\r\n    cardutil.optionalParamCardinality<NamedArgs[\"empty\"]>\r\n  >\r\n  // >\r\n>;\r\nfunction range<\r\n  P1 extends orScalarLiteral<TypeSet<$anypoint>> | undefined,\r\n  P2 extends\r\n    | orScalarLiteral<\r\n        TypeSet<\r\n          BaseType extends literalToScalarType<P1>\r\n            ? $anypoint\r\n            : getPrimitiveBaseType<literalToScalarType<P1>>\r\n        >\r\n      >\r\n    | undefined\r\n>(\r\n  lower?: P1,\r\n  upper?: P2\r\n): $expr_Function<\r\n  // \"std::range\",\r\n  // mapLiteralToTypeSet<[P1, P2]>,\r\n  // {},\r\n  // TypeSet<\r\n  RangeType<\r\n    literalToScalarType<P1> extends $anypoint\r\n      ? literalToScalarType<P1>\r\n      : literalToScalarType<P2> extends $anypoint\r\n      ? literalToScalarType<P2>\r\n      : $anypoint\r\n  >,\r\n  cardutil.multiplyCardinalities<\r\n    cardutil.optionalParamCardinality<P1>,\r\n    cardutil.optionalParamCardinality<P2>\r\n  >\r\n  // >\r\n>;\r\nfunction range(...args: any[]): any {\r\n  if (args.length === 1) {\r\n    const arg = args[0];\r\n    if (arg instanceof Range) {\r\n      if (arg.lower === null && arg.upper === null) {\r\n        throw new Error(\r\n          `Can't create literal expression from unbounded range. Try this instead:\\n\\n  e.range(e.cast(e.int64, e.set()), e.cast(e.int64, e.set()))`\r\n        );\r\n      }\r\n      if (arg.isEmpty) {\r\n        throw new Error(`Can't create literal expression from empty range.`);\r\n      }\r\n      return literal(\r\n        range(literalToTypeSet(arg.lower ?? arg.upper).__element__ as any),\r\n        arg\r\n      );\r\n    }\r\n    if (arg.__kind__ && !arg.__element__) {\r\n      return {\r\n        __kind__: TypeKind.range,\r\n        __name__: `range<${arg.__name__}>`,\r\n        __element__: arg,\r\n      } as any;\r\n    }\r\n  }\r\n  const {\r\n    returnType,\r\n    cardinality,\r\n    args: positionalArgs,\r\n    namedArgs,\r\n  } = $resolveOverload(\"std::range\", args, spec, [\r\n    {\r\n      args: [\r\n        {\r\n          typeId: $nameMapping.get(\"std::anypoint\")!,\r\n          optional: true,\r\n          setoftype: false,\r\n          variadic: false,\r\n        },\r\n        {\r\n          typeId: $nameMapping.get(\"std::anypoint\")!,\r\n          optional: true,\r\n          setoftype: false,\r\n          variadic: false,\r\n        },\r\n      ],\r\n      namedArgs: {\r\n        inc_lower: {\r\n          typeId: $nameMapping.get(\"std::bool\")!,\r\n          optional: true,\r\n          setoftype: false,\r\n          variadic: false,\r\n        },\r\n        inc_upper: {\r\n          typeId: $nameMapping.get(\"std::bool\")!,\r\n          optional: true,\r\n          setoftype: false,\r\n          variadic: false,\r\n        },\r\n        empty: {\r\n          typeId: $nameMapping.get(\"std::bool\")!,\r\n          optional: true,\r\n          setoftype: false,\r\n          variadic: false,\r\n        },\r\n      },\r\n      returnTypeId: $nameMapping.get(\"range<std::anypoint>\")!,\r\n    },\r\n  ]);\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.Function,\r\n    __element__: returnType,\r\n    __cardinality__: cardinality,\r\n    __name__: \"std::range\",\r\n    __args__: positionalArgs,\r\n    __namedargs__: namedArgs,\r\n  }) as any;\r\n}\r\n\r\nexport { range as $range };\r\n"},{"path":"reflection.ts","content":"export * from \"edgedb/_src/reflection/index.ts\";\r\nexport * from \"./typesystem.ts\";\r\nexport { cardutil } from \"./cardinality.ts\";\r\nexport type { $expr_Literal } from \"./literal.ts\";\r\nexport type { $expr_PathNode, $expr_PathLeaf } from \"./path.ts\";\r\nexport type { $expr_Function, $expr_Operator } from \"./funcops.ts\";\r\nexport { makeType, $mergeObjectTypes } from \"./hydrate.ts\";\r\nexport type { mergeObjectTypes } from \"./hydrate.ts\";\r\n"},{"path":"select.ts","content":"import {\r\n  LocalDateTime,\r\n  LocalDate,\r\n  LocalTime,\r\n  Duration,\r\n  RelativeDuration,\r\n  ConfigMemory,\r\n  DateDuration,\r\n} from \"edgedb\";\r\nimport type { $bool, $number } from \"./modules/std.ts\";\r\n\r\nimport {\r\n  Cardinality,\r\n  ExpressionKind,\r\n  TypeKind,\r\n  OperatorKind,\r\n} from \"edgedb/_src/reflection/index.ts\";\r\nimport { makeType } from \"./hydrate.ts\";\r\n\r\nimport { cardutil } from \"./cardinality.ts\";\r\nimport type {\r\n  $expr_PolyShapeElement,\r\n  $scopify,\r\n  Expression,\r\n  LinkDesc,\r\n  ObjectType,\r\n  ObjectTypeExpression,\r\n  ObjectTypePointers,\r\n  ObjectTypeSet,\r\n  PrimitiveTypeSet,\r\n  PropertyDesc,\r\n  ScalarType,\r\n  stripSet,\r\n  TypeSet,\r\n  BaseType,\r\n  ExclusiveTuple,\r\n  orLiteralValue,\r\n} from \"./typesystem.ts\";\r\n\r\nimport {\r\n  $assert_single,\r\n  type $expr_PathLeaf,\r\n  type $expr_PathNode,\r\n  type $linkPropify,\r\n  type ExpressionRoot,\r\n} from \"./path.ts\";\r\nimport type { anonymizeObject } from \"./casting.ts\";\r\nimport { $expressionify, $getScopedExpr } from \"./path.ts\";\r\nimport { $getTypeByName, literal } from \"./literal.ts\";\r\nimport { spec } from \"./__spec__.ts\";\r\nimport {\r\n  type scalarLiterals,\r\n  type literalToScalarType,\r\n  literalToTypeSet,\r\n} from \"./castMaps.ts\";\r\nimport type { $expr_Operator } from \"./funcops.ts\";\r\n\r\nexport const ASC: \"ASC\" = \"ASC\";\r\nexport const DESC: \"DESC\" = \"DESC\";\r\nexport const EMPTY_FIRST: \"EMPTY FIRST\" = \"EMPTY FIRST\";\r\nexport const EMPTY_LAST: \"EMPTY LAST\" = \"EMPTY LAST\";\r\nexport type OrderByDirection = \"ASC\" | \"DESC\";\r\nexport type OrderByEmpty = \"EMPTY FIRST\" | \"EMPTY LAST\";\r\n\r\nexport type OrderByExpr = TypeSet<ScalarType | ObjectType, Cardinality>;\r\nexport type OrderByObjExpr = {\r\n  expression: OrderByExpr;\r\n  direction?: OrderByDirection;\r\n  empty?: OrderByEmpty;\r\n};\r\n\r\nexport type OrderByExpression =\r\n  | OrderByExpr\r\n  | OrderByObjExpr\r\n  | [OrderByExpr | OrderByObjExpr, ...(OrderByExpr | OrderByObjExpr)[]];\r\n\r\nexport type OffsetExpression = TypeSet<\r\n  $number,\r\n  Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne\r\n>;\r\n\r\nexport type SelectFilterExpression = TypeSet<$bool, Cardinality>;\r\nexport type LimitOffsetExpression = TypeSet<\r\n  $number,\r\n  Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne\r\n>;\r\nexport type LimitExpression = TypeSet<\r\n  $number,\r\n  Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne\r\n>;\r\n\r\nexport type SelectModifierNames =\r\n  | \"filter\"\r\n  | \"filter_single\"\r\n  | \"order_by\"\r\n  | \"offset\"\r\n  | \"limit\";\r\n\r\ntype filterSingle<T extends TypeSet> = T extends ObjectTypeSet\r\n  ? TypeSet<anonymizeObject<T[\"__element__\"]>, T[\"__cardinality__\"]>\r\n  : orLiteralValue<T>;\r\n\r\nexport type exclusivesToFilterSingle<E extends ExclusiveTuple> =\r\n  ExclusiveTuple extends E\r\n    ? never\r\n    : E extends []\r\n    ? never\r\n    : {\r\n        [j in keyof E]: {\r\n          [k in keyof E[j]]: filterSingle<E[j][k]>;\r\n        };\r\n      }[number];\r\nexport type SelectModifiers<T extends ObjectType = ObjectType> = {\r\n  // export type SelectModifiers = {\r\n  filter?: SelectFilterExpression;\r\n  filter_single?: // | Partial<\r\n  //     typeutil.stripNever<{\r\n  //       [k in keyof T[\"__pointers__\"]]: T[\"__pointers__\"][k]\r\n  // extends PropertyDesc\r\n  //         ? orScalarLiteral<{\r\n  //             __element__: T[\"__pointers__\"][k][\"target\"];\r\n  //             __cardinality__: T[\"__pointers__\"][k][\"cardinality\"];\r\n  //           }>\r\n  //         : never;\r\n  //     }>\r\n  //   >\r\n\r\n  // | (ObjectType extends T\r\n  //       ? unknown\r\n  //       : typeutil.stripNever<{\r\n  //           [k in keyof T[\"__pointers__\"]]: T[\"__pointers__\"][k]\r\n  // extends PropertyDesc<\r\n  //             infer T,\r\n  //             infer C,\r\n  //             infer E\r\n  //           >\r\n  //             ? E extends true\r\n  //               ? orScalarLiteral<{\r\n  //                   __element__: T;\r\n  //                   __cardinality__: C;\r\n  //                 }>\r\n  //               : never\r\n  //             : never;\r\n  //         }>)\r\n  exclusivesToFilterSingle<T[\"__exclusives__\"]> | SelectFilterExpression;\r\n\r\n  // | (ObjectType extends T\r\n  //     ? unknown\r\n  //     : typeutil.stripNever<{\r\n  //         [k in keyof T[\"__pointers__\"]]: T[\"__pointers__\"][k]\r\n  // extends PropertyDesc<\r\n  //           infer T,\r\n  //           infer C,\r\n  //           infer E\r\n  //         >\r\n  //           ? E extends true\r\n  //             ? orScalarLiteral<{\r\n  //                 __element__: T;\r\n  //                 __cardinality__: C;\r\n  //               }>\r\n  //             : never\r\n  //           : never;\r\n  //       }>);\r\n  order_by?: OrderByExpression;\r\n  offset?: OffsetExpression | number;\r\n  limit?: LimitExpression | number;\r\n};\r\n\r\nexport type UnknownSelectModifiers = { [k in keyof SelectModifiers]: unknown };\r\n\r\nexport type NormalisedSelectModifiers = {\r\n  filter?: SelectFilterExpression;\r\n  order_by?: OrderByObjExpr[];\r\n  offset?: OffsetExpression;\r\n  limit?: LimitExpression;\r\n  singleton: boolean;\r\n};\r\n\r\n// type NormaliseOrderByModifier<Mods extends OrderByExpression> =\r\n//   Mods extends OrderByExpr\r\n//     ? [{expression: Mods}]\r\n//     : Mods extends OrderByObjExpr\r\n//     ? [Mods]\r\n//     : Mods extends (OrderByExpr | OrderByObjExpr)[]\r\n//     ? {\r\n//         [K in keyof Mods]: Mods[K] extends OrderByExpr\r\n//           ? {expression: Mods[K]}\r\n//           : Mods[K];\r\n//       }\r\n//     : [];\r\n\r\n// type NormaliseSelectModifiers<Mods extends SelectModifiers> = {\r\n//   filter: Mods[\"filter\"];\r\n//   order_by: Mods[\"order_by\"] extends OrderByExpression\r\n//     ? NormaliseOrderByModifier<Mods[\"order_by\"]>\r\n//     : [];\r\n//   offset: Mods[\"offset\"] extends number\r\n//     ? $expr_Literal<ScalarType<\"std::int64\", number, Mods[\"offset\"]>>\r\n//     : Mods[\"offset\"];\r\n//   limit: Mods[\"offset\"] extends number\r\n//     ? $expr_Literal<ScalarType<\"std::int64\", number, Mods[\"offset\"]>>\r\n//     : Mods[\"offset\"];\r\n// };\r\n\r\nexport type $expr_Select<Set extends TypeSet = TypeSet> = Expression<{\r\n  __element__: Set[\"__element__\"];\r\n  __cardinality__: Set[\"__cardinality__\"];\r\n  __expr__: TypeSet;\r\n  __kind__: ExpressionKind.Select;\r\n  __modifiers__: NormalisedSelectModifiers;\r\n  __scope__?: ObjectTypeExpression;\r\n}>;\r\n// Modifier methods removed for now, until we can fix typescript inference\r\n// problems / excessively deep errors\r\n// & SelectModifierMethods<stripSet<Set>>;\r\n\r\nexport interface SelectModifierMethods<Root extends TypeSet> {\r\n  filter<Filter extends SelectFilterExpression>(\r\n    filter:\r\n      | Filter\r\n      | ((\r\n          scope: Root extends ObjectTypeSet\r\n            ? $scopify<Root[\"__element__\"]>\r\n            : stripSet<Root>\r\n        ) => Filter)\r\n  ): this;\r\n  order_by(\r\n    order_by:\r\n      | OrderByExpression\r\n      | ((\r\n          scope: Root extends ObjectTypeSet\r\n            ? $scopify<Root[\"__element__\"]>\r\n            : stripSet<Root>\r\n        ) => OrderByExpression)\r\n  ): this;\r\n  offset(\r\n    offset:\r\n      | OffsetExpression\r\n      | number\r\n      | ((\r\n          scope: Root extends ObjectTypeSet\r\n            ? $scopify<Root[\"__element__\"]>\r\n            : stripSet<Root>\r\n        ) => OffsetExpression | number)\r\n  ): this;\r\n  // $expr_Select<{\r\n  //   __element__: Root[\"__element__\"];\r\n  //   __cardinality__: cardutil.overrideLowerBound<\r\n  //     Root[\"__cardinality__\"],\r\n  //     \"Zero\"\r\n  //   >;\r\n  // }>;\r\n  limit(\r\n    limit:\r\n      | LimitExpression\r\n      | number\r\n      | ((\r\n          scope: Root extends ObjectTypeSet\r\n            ? $scopify<Root[\"__element__\"]>\r\n            : stripSet<Root>\r\n        ) => LimitExpression | number)\r\n  ): this;\r\n  // $expr_Select<{\r\n  //   __element__: Root[\"__element__\"];\r\n  //   __cardinality__: cardutil.overrideLowerBound<\r\n  //     Root[\"__cardinality__\"],\r\n  //     \"Zero\"\r\n  //   >;\r\n  // }>;\r\n}\r\n// Base is ObjectTypeSet &\r\n// Filter is equality &\r\n// Filter.args[0] is PathLeaf\r\n//   Filter.args[0] is __exclusive__ &\r\n//   Filter.args[0].parent.__element__ === Base.__element__\r\n//   Filter.args[1].__cardinality__ is AtMostOne or One\r\n// if Filter.args[0] is PathNode:\r\n//   Filter.args[0] is __exclusive__ &\r\n//   if Filter.args[0].parent === null\r\n//     Filter.args[0].parent.__element__ === Base.__element__\r\n//     Filter.args[1].__cardinality__ is AtMostOne or One\r\n//   else\r\n//     Filter.args[0].type.__element__ === Base.__element__ &\r\n//     Filter.args[1].__cardinality__ is AtMostOne or One\r\n\r\n// type argCardToResultCard<\r\n//   OpCard extends Cardinality,\r\n//   BaseCase extends Cardinality\r\n// > = [OpCard] extends [Cardinality.AtMostOne | Cardinality.One]\r\n//   ? Cardinality.AtMostOne\r\n//   : [OpCard] extends [Cardinality.Empty]\r\n//   ? Cardinality.Empty\r\n//   : BaseCase;\r\n\r\n// export type InferFilterCardinality<\r\n//   Base extends TypeSet,\r\n//   Filter\r\n// > = Filter extends TypeSet\r\n//   ? // Base is ObjectTypeExpression &\r\n//     Base extends ObjectTypeSet // $expr_PathNode\r\n//     ? // Filter is equality\r\n//       Filter extends $expr_Operator<\"=\", any, infer Args, any>\r\n//       ? // Filter.args[0] is PathLeaf\r\n//         Args[0] extends $expr_PathLeaf\r\n//         ? // Filter.args[0] is unique\r\n//           Args[0][\"__exclusive__\"] extends true\r\n//           ? //   Filter.args[0].parent.__element__ === Base.__element__\r\n//             typeutil.assertEqual<InferFilterCardinality\r\n//               Args[0][\"__parent__\"][\"type\"][\"__element__\"][\"__name__\"],\r\n//               Base[\"__element__\"][\"__name__\"]\r\n//             > extends true\r\n//             ? // Filter.args[1].__cardinality__ is AtMostOne or One\r\n//               argCardToResultCard<\r\n//                 Args[1][\"__cardinality__\"],\r\n//                 Base[\"__cardinality__\"]\r\n//               >\r\n//             : Base[\"__cardinality__\"]\r\n//           : Base[\"__cardinality__\"]\r\n//         : Args[0] extends $expr_PathNode<any, any, any>\r\n//         ? Args[0][\"__exclusive__\"] extends true\r\n//           ? //   Filter.args[0].parent.__element__ === Base.__element__\r\n//             Args[0][\"__parent__\"] extends null\r\n//             ? typeutil.assertEqual<\r\n//                 Args[0][\"__element__\"][\"__name__\"],\r\n//                 Base[\"__element__\"][\"__name__\"]\r\n//               > extends true\r\n//               ? // Filter.args[1].__cardinality__ is AtMostOne or One\r\n//                 argCardToResultCard<\r\n//                   Args[1][\"__cardinality__\"],\r\n//                   Base[\"__cardinality__\"]\r\n//                 >\r\n//               : Base[\"__cardinality__\"]\r\n//             : Args[0][\"__parent__\"] extends infer Parent\r\n//             ? Parent extends PathParent\r\n//               ? typeutil.assertEqual<\r\n//                   Parent[\"type\"][\"__element__\"][\"__name__\"],\r\n//                   Base[\"__element__\"][\"__name__\"]\r\n//                 > extends true\r\n//                 ? // Filter.args[1].__cardinality__ is AtMostOne or One\r\n//                   argCardToResultCard<\r\n//                     Args[1][\"__cardinality__\"],\r\n//                     Base[\"__cardinality__\"]\r\n//                   >\r\n//                 : Base[\"__cardinality__\"]\r\n//               : Base[\"__cardinality__\"]\r\n//             : Base[\"__cardinality__\"]\r\n//           : Base[\"__cardinality__\"]\r\n//         : Base[\"__cardinality__\"]\r\n//       : Base[\"__cardinality__\"]\r\n//     : Base[\"__cardinality__\"]\r\n//   : Base[\"__cardinality__\"];\r\n\r\nexport type InferOffsetLimitCardinality<\r\n  Card extends Cardinality,\r\n  Modifiers extends UnknownSelectModifiers\r\n> = Modifiers[\"limit\"] extends number | LimitExpression\r\n  ? cardutil.overrideLowerBound<Card, \"Zero\">\r\n  : Modifiers[\"offset\"] extends number | OffsetExpression\r\n  ? cardutil.overrideLowerBound<Card, \"Zero\">\r\n  : Card;\r\n\r\n// export type ComputeSelectCardinality<\r\n//   Expr extends ObjectTypeExpression,\r\n//   Modifiers extends UnknownSelectModifiers\r\n// > = InferOffsetLimitCardinality<\r\n//   InferFilterCardinality<Expr, Modifiers[\"filter\"]>,\r\n//   Modifiers\r\n// >;\r\nexport type ComputeSelectCardinality<\r\n  Expr extends ObjectTypeExpression,\r\n  Modifiers extends UnknownSelectModifiers\r\n> = InferOffsetLimitCardinality<\r\n  undefined extends Modifiers[\"filter_single\"]\r\n    ? Expr[\"__cardinality__\"]\r\n    : cardutil.overrideUpperBound<Expr[\"__cardinality__\"], \"One\">,\r\n  Modifiers\r\n>;\r\n\r\nexport function is<\r\n  Expr extends ObjectTypeExpression,\r\n  Shape extends objectTypeToSelectShape<Expr[\"__element__\"]>\r\n>(\r\n  expr: Expr,\r\n  shape: Shape\r\n): {\r\n  [k in Exclude<\r\n    keyof Shape,\r\n    SelectModifierNames | \"id\"\r\n  >]: $expr_PolyShapeElement<Expr, normaliseElement<Shape[k]>>;\r\n} {\r\n  const mappedShape: any = {};\r\n  for (const [key, value] of Object.entries(shape)) {\r\n    if (key === \"id\") continue;\r\n    mappedShape[key] = {\r\n      __kind__: ExpressionKind.PolyShapeElement,\r\n      __polyType__: expr,\r\n      __shapeElement__: value,\r\n    };\r\n  }\r\n  return mappedShape;\r\n}\r\n\r\n// function computeFilterCardinality(\r\n//   expr: SelectFilterExpression,\r\n//   cardinality: Cardinality,\r\n//   base: TypeSet\r\n// ) {\r\n//   let card = cardinality;\r\n\r\n//   const filter: any = expr;\r\n//   // Base is ObjectExpression\r\n//   const baseIsObjectExpr = base?.__element__?.__kind__ === TypeKind.object;\r\n//   const filterExprIsEq =\r\n//     filter.__kind__ === ExpressionKind.Operator && filter.__name__ === \"=\";\r\n//   const arg0: $expr_PathLeaf | $expr_PathNode = filter?.__args__?.[0];\r\n//   const arg1: TypeSet = filter?.__args__?.[1];\r\n//   const argsExist = !!arg0 && !!arg1 && !!arg1.__cardinality__;\r\n//   const arg0IsUnique = arg0?.__exclusive__ === true;\r\n\r\n//   if (baseIsObjectExpr && filterExprIsEq && argsExist && arg0IsUnique) {\r\n//     const newCard =\r\n//       arg1.__cardinality__ === Cardinality.One ||\r\n//       arg1.__cardinality__ === Cardinality.AtMostOne\r\n//         ? Cardinality.AtMostOne\r\n//         : arg1.__cardinality__ === Cardinality.Empty\r\n//         ? Cardinality.Empty\r\n//         : cardinality;\r\n\r\n//     if (arg0.__kind__ === ExpressionKind.PathLeaf) {\r\n//       const arg0ParentMatchesBase =\r\n//         arg0.__parent__.type.__element__.__name__ ===\r\n//         base.__element__.__name__;\r\n//       if (arg0ParentMatchesBase) {\r\n//         card = newCard;\r\n//       }\r\n//     } else if (arg0.__kind__ === ExpressionKind.PathNode) {\r\n//       // if Filter.args[0] is PathNode:\r\n//       //   Filter.args[0] is __exclusive__ &\r\n//       //   if Filter.args[0].parent === null\r\n//       //     Filter.args[0].__element__ === Base.__element__\r\n//       //     Filter.args[1].__cardinality__ is AtMostOne or One\r\n//       //   else\r\n//       //     Filter.args[0].type.__element__ === Base.__element__ &\r\n//       //     Filter.args[1].__cardinality__ is AtMostOne or One\r\n//       const parent = arg0.__parent__;\r\n//       if (parent === null) {\r\n//         const arg0MatchesBase =\r\n//           arg0.__element__.__name__ === base.__element__.__name__;\r\n//         if (arg0MatchesBase) {\r\n//           card = newCard;\r\n//         }\r\n//       } else {\r\n//         const arg0ParentMatchesBase =\r\n//           parent?.type.__element__.__name__ === base.__element__.__name__;\r\n//         if (arg0ParentMatchesBase) {\r\n//           card = newCard;\r\n//         }\r\n//       }\r\n//     }\r\n//   }\r\n\r\n//   return card;\r\n// }\r\n\r\nexport function $handleModifiers(\r\n  modifiers: SelectModifiers,\r\n  params: { root: TypeSet; scope: TypeSet }\r\n): {\r\n  modifiers: NormalisedSelectModifiers;\r\n  cardinality: Cardinality;\r\n  needsAssertSingle: boolean;\r\n} {\r\n  const { root, scope } = params;\r\n  const mods: NormalisedSelectModifiers = {\r\n    singleton: !!modifiers[\"filter_single\"],\r\n  };\r\n\r\n  let card = root.__cardinality__;\r\n  let needsAssertSingle = false;\r\n\r\n  if (modifiers.filter) {\r\n    mods.filter = modifiers.filter;\r\n    // card = computeFilterCardinality(mods.filter, card, rootExpr);\r\n  }\r\n\r\n  if (modifiers.filter_single) {\r\n    if (root.__element__.__kind__ !== TypeKind.object) {\r\n      throw new Error(\"filter_single can only be used with object types\");\r\n    }\r\n    card = Cardinality.AtMostOne;\r\n    // mods.filter = modifiers.filter_single;\r\n    const fs: any = modifiers.filter_single;\r\n    if (fs.__element__) {\r\n      mods.filter = modifiers.filter_single as any;\r\n      needsAssertSingle = true;\r\n    } else {\r\n      const exprs = Object.keys(fs).map((key) => {\r\n        const val = fs[key].__element__\r\n          ? fs[key]\r\n          : (literal as any)(\r\n              (root.__element__ as any as ObjectType)[\"__pointers__\"][key]![\r\n                \"target\"\r\n              ],\r\n              fs[key]\r\n            );\r\n        return $expressionify({\r\n          __element__: {\r\n            __name__: \"std::bool\",\r\n            __kind__: TypeKind.scalar,\r\n          } as any,\r\n          __cardinality__: Cardinality.One,\r\n          __kind__: ExpressionKind.Operator,\r\n          __opkind__: OperatorKind.Infix,\r\n          __name__: \"=\",\r\n          __args__: [(scope as any)[key], val],\r\n        }) as $expr_Operator;\r\n      });\r\n      if (exprs.length === 1) {\r\n        mods.filter = exprs[0] as any;\r\n      } else {\r\n        mods.filter = exprs.reduce((a, b) => {\r\n          return $expressionify({\r\n            __element__: {\r\n              __name__: \"std::bool\",\r\n              __kind__: TypeKind.scalar,\r\n            } as any,\r\n            __cardinality__: Cardinality.One,\r\n            __kind__: ExpressionKind.Operator,\r\n            __opkind__: OperatorKind.Infix,\r\n            __name__: \"and\",\r\n            __args__: [a, b],\r\n          }) as $expr_Operator;\r\n        }) as any;\r\n      }\r\n    }\r\n  }\r\n  if (modifiers.order_by) {\r\n    const orderExprs = Array.isArray(modifiers.order_by)\r\n      ? modifiers.order_by\r\n      : [modifiers.order_by];\r\n    mods.order_by = orderExprs.map((expr) =>\r\n      typeof (expr as any).__element__ === \"undefined\"\r\n        ? expr\r\n        : { expression: expr }\r\n    ) as any;\r\n  }\r\n  if (modifiers.offset) {\r\n    mods.offset =\r\n      typeof modifiers.offset === \"number\"\r\n        ? ($getTypeByName(\"std::number\")(modifiers.offset) as any)\r\n        : modifiers.offset;\r\n    card = cardutil.overrideLowerBound(card, \"Zero\");\r\n  }\r\n  if (modifiers.limit) {\r\n    let expr: LimitExpression;\r\n    if (typeof modifiers.limit === \"number\") {\r\n      expr = $getTypeByName(\"std::number\")(modifiers.limit) as any;\r\n    } else {\r\n      const type =\r\n        (modifiers.limit.__element__ as any).__casttype__ ??\r\n        modifiers.limit.__element__;\r\n      if (\r\n        type.__kind__ === TypeKind.scalar &&\r\n        type.__name__ === \"std::number\"\r\n      ) {\r\n        expr = modifiers.limit;\r\n      } else {\r\n        throw new Error(\"Invalid value for `limit` modifier\");\r\n      }\r\n    }\r\n    mods.limit = expr;\r\n    card = cardutil.overrideLowerBound(card, \"Zero\");\r\n  }\r\n\r\n  return {\r\n    modifiers: mods as NormalisedSelectModifiers,\r\n    cardinality: card,\r\n    needsAssertSingle,\r\n  };\r\n}\r\n\r\nexport type $expr_Delete<Root extends ObjectTypeSet = ObjectTypeSet> =\r\n  Expression<{\r\n    __kind__: ExpressionKind.Delete;\r\n    __element__: Root[\"__element__\"];\r\n    __cardinality__: Root[\"__cardinality__\"];\r\n    __expr__: ObjectTypeSet;\r\n  }>;\r\n\r\nfunction deleteExpr<\r\n  Expr extends ObjectTypeExpression,\r\n  Modifiers extends SelectModifiers<Expr[\"__element__\"]>\r\n>(\r\n  expr: Expr,\r\n  modifiers?: (scope: $scopify<Expr[\"__element__\"]>) => Readonly<Modifiers>\r\n): $expr_Delete<{\r\n  __element__: ObjectType<\r\n    Expr[\"__element__\"][\"__name__\"],\r\n    Expr[\"__element__\"][\"__pointers__\"],\r\n    { id: true }\r\n  >;\r\n  __cardinality__: ComputeSelectCardinality<Expr, Modifiers>;\r\n}>;\r\nfunction deleteExpr(expr: any, modifiersGetter: any) {\r\n  const selectExpr = select(expr, modifiersGetter);\r\n\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.Delete,\r\n    __element__: selectExpr.__element__,\r\n    __cardinality__: selectExpr.__cardinality__,\r\n    __expr__: selectExpr,\r\n  }) as any;\r\n}\r\n\r\nexport { deleteExpr as delete };\r\n\r\n// Modifier methods removed for now, until we can fix typescript inference\r\n// problems / excessively deep errors\r\n\r\n// function resolveModifierGetter(parent: any, modGetter: any) {\r\n//   if (typeof modGetter === \"function\" && !modGetter.__kind__) {\r\n//     if (parent.__expr__.__element__.__kind__ === TypeKind.object) {\r\n//       const shape = parent.__element__.__shape__;\r\n//       const _scope =\r\n//         parent.__scope__ ?? $getScopedExpr(parent.__expr__,\r\n//           $existingScopes);\r\n//       const scope = new Proxy(_scope, {\r\n//         get(target: any, prop: string) {\r\n//           if (shape[prop] && shape[prop] !== true) {\r\n//             return shape[prop];\r\n//           }\r\n//           return target[prop];\r\n//         },\r\n//       });\r\n//       return {\r\n//         scope: _scope,\r\n//         modExpr: modGetter(scope),\r\n//       };\r\n//     } else {\r\n//       return {\r\n//         scope: undefined,\r\n//         modExpr: modGetter(parent.__expr__),\r\n//       };\r\n//     }\r\n//   } else {\r\n//     return {scope: parent.__scope__, modExpr: modGetter};\r\n//   }\r\n// }\r\n\r\n// function updateModifier(\r\n//   parent: any,\r\n//   modName: \"filter\" | \"order_by\" | \"offset\" | \"limit\",\r\n//   modGetter: any\r\n// ) {\r\n//   const modifiers = {\r\n//     ...parent.__modifiers__,\r\n//   };\r\n//   const cardinality = parent.__cardinality__;\r\n\r\n//   const {modExpr, scope} = resolveModifierGetter(parent, modGetter);\r\n\r\n//   switch (modName) {\r\n//     case \"filter\":\r\n//       modifiers.filter = modifiers.filter\r\n//         ? op(modifiers.filter, \"and\", modExpr)\r\n//         : modExpr;\r\n\r\n//       // methods no longer change cardinality\r\n//       // cardinality = computeFilterCardinality(\r\n//       //   modExpr,\r\n//       //   cardinality,\r\n//       //   parent.__expr__\r\n//       // );\r\n//       break;\r\n//     case \"order_by\":\r\n//       const ordering =\r\n//         typeof (modExpr as any).__element__ === \"undefined\"\r\n//           ? modExpr\r\n//           : {expression: modExpr};\r\n//       modifiers.order_by = modifiers.order_by\r\n//         ? [...modifiers.order_by, ordering]\r\n//         : [ordering];\r\n//       break;\r\n//     case \"offset\":\r\n//       modifiers.offset =\r\n//         typeof modExpr === \"number\" ? _std.number(modExpr) : modExpr;\r\n//       // methods no longer change cardinality\r\n//       // cardinality = cardutil\r\n//            .overrideLowerBound(cardinality, \"Zero\");\r\n//       break;\r\n//     case \"limit\":\r\n//       modifiers.limit =\r\n//         typeof modExpr === \"number\"\r\n//           ? _std.number(modExpr)\r\n//           : (modExpr as any).__kind__ === ExpressionKind.Set\r\n//           ? (modExpr as any).__exprs__[0]\r\n//           : modExpr;\r\n//       // methods no longer change cardinality\r\n//       // cardinality = cardutil\r\n//            .overrideLowerBound(cardinality, \"Zero\");\r\n//       break;\r\n//   }\r\n\r\n//   return $expressionify(\r\n//     $selectify({\r\n//       __kind__: ExpressionKind.Select,\r\n//       __element__: parent.__element__,\r\n//       __cardinality__: cardinality,\r\n//       __expr__: parent.__expr__,\r\n//       __modifiers__: modifiers,\r\n//       __scope__: scope,\r\n//     })\r\n//   );\r\n// }\r\n\r\nexport function $selectify<Expr extends ExpressionRoot>(expr: Expr) {\r\n  // Object.assign(expr, {\r\n  //   filter: (filter: any) => updateModifier(expr, \"filter\", filter),\r\n  //   order_by: (order_by: any) => updateModifier(expr, \"order_by\", order_by),\r\n  //   offset: (offset: any) => updateModifier(expr, \"offset\", offset),\r\n  //   limit: (limit: any) => updateModifier(expr, \"limit\", limit),\r\n  // });\r\n  return expr;\r\n}\r\n\r\nexport type linkDescToLinkProps<Desc extends LinkDesc> = {\r\n  [k in keyof Desc[\"properties\"] & string]: $expr_PathLeaf<\r\n    TypeSet<\r\n      Desc[\"properties\"][k][\"target\"],\r\n      Desc[\"properties\"][k][\"cardinality\"]\r\n    >\r\n    // {\r\n    //   type: $scopify<Desc[\"target\"]>;\r\n    //   linkName: k;\r\n    // },\r\n    // Desc[\"properties\"][k][\"exclusive\"]\r\n  >;\r\n};\r\n\r\nexport type pointersToObjectType<P extends ObjectTypePointers> = ObjectType<\r\n  string,\r\n  P,\r\n  object\r\n>;\r\n\r\ntype linkDescToShape<L extends LinkDesc> = objectTypeToSelectShape<\r\n  L[\"target\"]\r\n> &\r\n  objectTypeToSelectShape<pointersToObjectType<L[\"properties\"]>> &\r\n  SelectModifiers;\r\n\r\ntype linkDescToSelectElement<L extends LinkDesc> =\r\n  | boolean\r\n  | TypeSet<anonymizeObject<L[\"target\"]>, cardutil.assignable<L[\"cardinality\"]>>\r\n  | linkDescToShape<L>\r\n  | ((\r\n      scope: $scopify<L[\"target\"]> & linkDescToLinkProps<L>\r\n    ) => linkDescToShape<L>);\r\n\r\ntype propDescToSelectElement<P extends PropertyDesc> =\r\n  | boolean\r\n  | TypeSet<P[\"target\"], cardutil.assignable<P[\"cardinality\"]>>\r\n  | $expr_PolyShapeElement;\r\n\r\n// object types -> pointers\r\n// pointers -> links\r\n// links -> target object type\r\n// links -> link properties\r\nexport type objectTypeToSelectShape<\r\n  T extends ObjectType = ObjectType,\r\n  Pointers extends ObjectTypePointers = T[\"__pointers__\"]\r\n> = Partial<{\r\n  [k in keyof Pointers]: Pointers[k] extends PropertyDesc\r\n    ? propDescToSelectElement<Pointers[k]>\r\n    : Pointers[k] extends LinkDesc\r\n    ? linkDescToSelectElement<Pointers[k]>\r\n    : any;\r\n}> & { [k: string]: unknown };\r\n\r\n// incorporate __shape__ (computeds) on selection shapes\r\n// this works but a major rewrite of setToTsType is required\r\n// to incorporate __shape__-based selection shapes into\r\n// result type inference\r\n// & [k in keyof T[\"__shape__\"]]:\r\n//    string | number | symbol extends k //   Partial<{ // &\r\n//       ? unknown\r\n//       : T[\"__shape__\"][k] extends infer U\r\n//       ? U extends ObjectTypeSet\r\n//         ?\r\n//             | boolean\r\n//             | TypeSet<\r\n//                 anonymizeObject<U[\"__element__\"]>,\r\n//                 cardutil.assignable<U[\"__cardinality__\"]>\r\n//               >\r\n//             | objectTypeToSelectShape<U[\"__element__\"]>\r\n//             | ((\r\n//                 scope: $scopify<U[\"__element__\"]>\r\n//               ) => objectTypeToSelectShape<U[\"__element__\"]> &\r\n//                 SelectModifiers)\r\n//         : U extends TypeSet\r\n//         ?\r\n//             | boolean\r\n//             | TypeSet<\r\n//                 U[\"__element__\"],\r\n//                 cardutil.assignable<U[\"__cardinality__\"]>\r\n//               >\r\n//         : unknown\r\n//       : unknown;\r\n//   }>\r\n\r\nexport type normaliseElement<El> = El extends boolean\r\n  ? El\r\n  : El extends TypeSet\r\n  ? stripSet<El>\r\n  : El extends (...scope: any[]) => any\r\n  ? normaliseShape<ReturnType<El>>\r\n  : El extends object\r\n  ? normaliseShape<stripSet<El>>\r\n  : stripSet<El>;\r\n\r\nexport type normaliseShape<\r\n  Shape extends object,\r\n  Strip = SelectModifierNames\r\n> = {\r\n  [k in Exclude<keyof Shape, Strip>]: normaliseElement<Shape[k]>;\r\n};\r\n\r\nconst $FreeObject = makeType(\r\n  spec,\r\n  [...spec.values()].find((s) => s.name === \"std::FreeObject\")!.id,\r\n  literal\r\n);\r\nconst FreeObject: $expr_PathNode = {\r\n  __kind__: ExpressionKind.PathNode,\r\n  __element__: $FreeObject as any,\r\n  __cardinality__: Cardinality.One,\r\n  __parent__: null,\r\n  __exclusive__: true,\r\n  __scopeRoot__: null,\r\n} as any;\r\n\r\nexport const $existingScopes = new Set<\r\n  Expression<TypeSet<BaseType, Cardinality>>\r\n>();\r\n\r\nfunction $shape<\r\n  Expr extends ObjectTypeExpression,\r\n  Element extends Expr[\"__element__\"],\r\n  Shape extends objectTypeToSelectShape<Element> & SelectModifiers<Element>,\r\n  Scope extends $scopify<Element> &\r\n    $linkPropify<{\r\n      [k in keyof Expr]: k extends \"__cardinality__\"\r\n        ? Cardinality.One\r\n        : Expr[k];\r\n    }>\r\n>(\r\n  expr: Expr,\r\n  _shape: (scope: Scope) => Readonly<Shape>\r\n): (scope: unknown) => Readonly<Shape>;\r\nfunction $shape(_a: unknown, b: (...args: any) => any) {\r\n  return b;\r\n}\r\nexport { $shape as shape };\r\n\r\nexport function select<\r\n  Expr extends ObjectTypeExpression,\r\n  Element extends Expr[\"__element__\"],\r\n  ElementName extends `${Element[\"__name__\"]}`,\r\n  ElementPointers extends Element[\"__pointers__\"],\r\n  ElementShape extends Element[\"__shape__\"],\r\n  Card extends Expr[\"__cardinality__\"]\r\n>(\r\n  expr: Expr\r\n): $expr_Select<{\r\n  __element__: ObjectType<ElementName, ElementPointers, ElementShape>;\r\n  __cardinality__: Card;\r\n}>;\r\nexport function select<Expr extends TypeSet>(\r\n  expr: Expr\r\n): $expr_Select<stripSet<Expr>>;\r\nexport function select<\r\n  Expr extends ObjectTypeExpression,\r\n  Element extends Expr[\"__element__\"],\r\n  Shape extends objectTypeToSelectShape<Element> & SelectModifiers<Element>,\r\n  SelectCard extends ComputeSelectCardinality<Expr, Modifiers>,\r\n  SelectShape extends normaliseShape<Shape, SelectModifierNames>,\r\n  Scope extends $scopify<Element> &\r\n    $linkPropify<{\r\n      [k in keyof Expr]: k extends \"__cardinality__\"\r\n        ? Cardinality.One\r\n        : Expr[k];\r\n    }>,\r\n  ElementName extends `${Element[\"__name__\"]}`,\r\n  Modifiers extends UnknownSelectModifiers = Pick<Shape, SelectModifierNames>\r\n>(\r\n  expr: Expr,\r\n  shape: (scope: Scope) => Readonly<Shape>\r\n): $expr_Select<{\r\n  __element__: ObjectType<ElementName, Element[\"__pointers__\"], SelectShape>;\r\n  __cardinality__: SelectCard;\r\n}>;\r\n/*\r\n\r\nFor the moment is isn't possible to implement both closure-based and plain\r\nobject overloads without breaking autocomplete on one or the other.\r\nThis is due to a limitation in TS:\r\n\r\nhttps://github.com/microsoft/TypeScript/issues/26892\r\nhttps://github.com/microsoft/TypeScript/issues/47081\r\n\r\n*/\r\n\r\nexport function select<\r\n  Expr extends PrimitiveTypeSet,\r\n  Modifiers extends SelectModifiers\r\n>(\r\n  expr: Expr,\r\n  modifiers: (expr: Expr) => Readonly<Modifiers>\r\n): $expr_Select<{\r\n  __element__: Expr[\"__element__\"];\r\n  __cardinality__: InferOffsetLimitCardinality<\r\n    Expr[\"__cardinality__\"],\r\n    Modifiers\r\n  >;\r\n}>;\r\nexport function select<Shape extends { [key: string]: TypeSet }>(\r\n  shape: Shape\r\n): $expr_Select<{\r\n  __element__: ObjectType<\r\n    `std::FreeObject`,\r\n    {\r\n      [k in keyof Shape]: Shape[k][\"__element__\"] extends ObjectType\r\n        ? LinkDesc<\r\n            Shape[k][\"__element__\"],\r\n            Shape[k][\"__cardinality__\"],\r\n            {},\r\n            false,\r\n            true,\r\n            true,\r\n            false\r\n          >\r\n        : PropertyDesc<\r\n            Shape[k][\"__element__\"],\r\n            Shape[k][\"__cardinality__\"],\r\n            false,\r\n            true,\r\n            true,\r\n            false\r\n          >;\r\n    },\r\n    Shape\r\n  >; // _shape\r\n  __cardinality__: Cardinality.One;\r\n}>;\r\nexport function select<Expr extends scalarLiterals>(\r\n  expr: Expr\r\n): $expr_Select<{\r\n  __element__: literalToScalarType<Expr>;\r\n  __cardinality__: Cardinality.One;\r\n}>;\r\nexport function select(...args: any[]) {\r\n  const firstArg = args[0];\r\n\r\n  if (\r\n    typeof firstArg !== \"object\" ||\r\n    firstArg instanceof Uint8Array ||\r\n    firstArg instanceof Date ||\r\n    firstArg instanceof Duration ||\r\n    firstArg instanceof LocalDateTime ||\r\n    firstArg instanceof LocalDate ||\r\n    firstArg instanceof LocalTime ||\r\n    firstArg instanceof RelativeDuration ||\r\n    firstArg instanceof DateDuration ||\r\n    firstArg instanceof ConfigMemory ||\r\n    firstArg instanceof Float32Array\r\n  ) {\r\n    const literalExpr = literalToTypeSet(firstArg);\r\n    return $expressionify(\r\n      $selectify({\r\n        __kind__: ExpressionKind.Select,\r\n        __element__: literalExpr.__element__,\r\n        __cardinality__: literalExpr.__cardinality__,\r\n        __expr__: literalExpr,\r\n        __modifiers__: {},\r\n      })\r\n    ) as any;\r\n  }\r\n\r\n  const exprPair: [TypeSet, (scope: any) => any] =\r\n    typeof args[0].__element__ !== \"undefined\"\r\n      ? (args as any)\r\n      : [FreeObject, () => args[0]];\r\n\r\n  let expr = exprPair[0];\r\n  const shapeGetter = exprPair[1];\r\n  if (expr === FreeObject) {\r\n    const freeObjectPtrs: ObjectTypePointers = {};\r\n    for (const [k, v] of Object.entries(args[0]) as [string, TypeSet][]) {\r\n      freeObjectPtrs[k] = {\r\n        __kind__:\r\n          v.__element__.__kind__ === TypeKind.object ? \"link\" : \"property\",\r\n        target: v.__element__,\r\n\r\n        cardinality: v.__cardinality__,\r\n        exclusive: false,\r\n        computed: true,\r\n        readonly: true,\r\n        hasDefault: false,\r\n        properties: {},\r\n      };\r\n    }\r\n    expr = {\r\n      ...FreeObject,\r\n      __element__: {\r\n        ...FreeObject.__element__,\r\n        __pointers__: {\r\n          ...FreeObject.__element__.__pointers__,\r\n          ...freeObjectPtrs,\r\n        },\r\n      } as any,\r\n    };\r\n  }\r\n  if (!shapeGetter) {\r\n    if (expr.__element__.__kind__ === TypeKind.object) {\r\n      const objectExpr: ObjectTypeSet = expr as any;\r\n      return $expressionify(\r\n        $selectify({\r\n          __kind__: ExpressionKind.Select,\r\n          __element__: {\r\n            __kind__: TypeKind.object,\r\n            __name__: `${objectExpr.__element__.__name__}`, // _shape\r\n            __pointers__: objectExpr.__element__.__pointers__,\r\n            __shape__: objectExpr.__element__.__shape__,\r\n          } as any,\r\n          __cardinality__: objectExpr.__cardinality__,\r\n          __expr__: objectExpr,\r\n          __modifiers__: {},\r\n        })\r\n      ) as any;\r\n    } else {\r\n      return $expressionify(\r\n        $selectify({\r\n          __kind__: ExpressionKind.Select,\r\n          __element__: expr.__element__,\r\n          __cardinality__: expr.__cardinality__,\r\n          __expr__: expr,\r\n          __modifiers__: {},\r\n        })\r\n      ) as any;\r\n    }\r\n  }\r\n\r\n  const cleanScopedExprs = $existingScopes.size === 0;\r\n\r\n  const { modifiers: mods, shape, scope } = resolveShape(shapeGetter, expr);\r\n\r\n  if (cleanScopedExprs) {\r\n    $existingScopes.clear();\r\n  }\r\n\r\n  const { modifiers, cardinality, needsAssertSingle } = $handleModifiers(mods, {\r\n    root: expr,\r\n    scope,\r\n  });\r\n  const selectExpr = $selectify({\r\n    __kind__: ExpressionKind.Select,\r\n    __element__:\r\n      expr.__element__.__kind__ === TypeKind.object\r\n        ? {\r\n            __kind__: TypeKind.object,\r\n            __name__: `${expr.__element__.__name__}`, // _shape\r\n            __pointers__: (expr.__element__ as ObjectType).__pointers__,\r\n            __shape__: shape,\r\n          }\r\n        : expr.__element__,\r\n    __cardinality__: cardinality,\r\n    __expr__: expr,\r\n    __modifiers__: modifiers,\r\n    __scope__: expr !== scope ? scope : undefined,\r\n  }) as any;\r\n\r\n  return needsAssertSingle\r\n    ? $assert_single(selectExpr)\r\n    : $expressionify(selectExpr);\r\n}\r\n\r\nfunction resolveShape(\r\n  shapeGetter: ((scope: any) => any) | any,\r\n  expr: TypeSet\r\n): { modifiers: any; shape: any; scope: TypeSet } {\r\n  const modifiers: any = {};\r\n  const shape: any = {};\r\n\r\n  // get scoped object if expression is objecttypeset\r\n  const scope =\r\n    expr.__element__.__kind__ === TypeKind.object\r\n      ? $getScopedExpr(expr as any, $existingScopes)\r\n      : expr;\r\n\r\n  // execute getter with scope\r\n  const selectShape =\r\n    typeof shapeGetter === \"function\" ? shapeGetter(scope) : shapeGetter;\r\n\r\n  for (const [key, value] of Object.entries(selectShape)) {\r\n    // handle modifier keys\r\n    if (\r\n      key === \"filter\" ||\r\n      key === \"filter_single\" ||\r\n      key === \"order_by\" ||\r\n      key === \"offset\" ||\r\n      key === \"limit\"\r\n    ) {\r\n      modifiers[key] = value;\r\n    } else {\r\n      // for scalar expressions, scope === expr\r\n      // shape keys are not allowed\r\n      if (expr.__element__.__kind__ !== TypeKind.object) {\r\n        throw new Error(\r\n          `Invalid select shape key '${key}' on scalar expression, ` +\r\n            `only modifiers are allowed (filter, order_by, offset and limit)`\r\n        );\r\n      }\r\n      shape[key] = resolveShapeElement(key, value, scope);\r\n    }\r\n  }\r\n  return { shape, modifiers, scope };\r\n}\r\n\r\nexport function resolveShapeElement(\r\n  key: any,\r\n  value: any,\r\n  scope: ObjectTypeExpression\r\n): any {\r\n  // if value is a nested closure\r\n  // or a nested shape object\r\n  const isSubshape =\r\n    typeof value === \"object\" && typeof (value as any).__kind__ === \"undefined\";\r\n  const isClosure =\r\n    typeof value === \"function\" &&\r\n    scope.__element__.__pointers__[key]?.__kind__ === \"link\";\r\n  // if (isSubshape) {\r\n  //   // return value;\r\n  //   const childExpr = (scope as any)[key];\r\n  //   const {\r\n  //     shape: childShape,\r\n  //     // scope: childScope,\r\n  //     // modifiers: mods,\r\n  //   } = resolveShape(value as any, childExpr);\r\n  //   return childShape;\r\n  // }\r\n  if (isSubshape || isClosure) {\r\n    // get child node expression\r\n    // this relies on Proxy-based getters\r\n    const childExpr = (scope as any)[key];\r\n    if (!childExpr) {\r\n      throw new Error(\r\n        `Invalid shape element \"${key}\" for type ${scope.__element__.__name__}`\r\n      );\r\n    }\r\n    const {\r\n      shape: childShape,\r\n      scope: childScope,\r\n      modifiers: mods,\r\n    } = resolveShape(value as any, childExpr);\r\n\r\n    // extracts normalized modifiers\r\n    const { modifiers, needsAssertSingle } = $handleModifiers(mods, {\r\n      root: childExpr,\r\n      scope: childScope,\r\n    });\r\n\r\n    const selectExpr = {\r\n      __kind__: ExpressionKind.Select,\r\n      __element__: {\r\n        __kind__: TypeKind.object,\r\n        __name__: `${childExpr.__element__.__name__}`,\r\n        __pointers__: childExpr.__element__.__pointers__,\r\n        __shape__: childShape,\r\n      },\r\n      __cardinality__:\r\n        scope.__element__.__pointers__?.[key]?.cardinality ||\r\n        scope.__element__.__shape__?.[key]?.__cardinality__,\r\n      __expr__: childExpr,\r\n      __modifiers__: modifiers,\r\n      __scope__: childExpr !== childScope ? childScope : undefined,\r\n    };\r\n    return needsAssertSingle ? $assert_single(selectExpr as any) : selectExpr;\r\n  } else if ((value as any)?.__kind__ === ExpressionKind.PolyShapeElement) {\r\n    const polyElement = value as $expr_PolyShapeElement;\r\n\r\n    const polyScope = (scope as any).is(polyElement.__polyType__);\r\n    return {\r\n      __kind__: ExpressionKind.PolyShapeElement,\r\n      __polyType__: polyScope,\r\n      __shapeElement__: resolveShapeElement(\r\n        key,\r\n        polyElement.__shapeElement__,\r\n        polyScope\r\n      ),\r\n    };\r\n  } else if (typeof value === \"boolean\" && key.startsWith(\"@\")) {\r\n    const linkProp = (scope as any)[key];\r\n    if (!linkProp) {\r\n      throw new Error(\r\n        (scope as any).__parent__\r\n          ? `link property '${key}' does not exist on link ${\r\n              (scope as any).__parent__.linkName\r\n            }`\r\n          : `cannot select link property '${key}' on an object (${scope.__element__.__name__})`\r\n      );\r\n    }\r\n    return value ? linkProp : false;\r\n  } else {\r\n    return value;\r\n  }\r\n}\r\n"},{"path":"set.ts","content":"import type { ExpressionKind, Cardinality } from \"edgedb/_src/reflection/index.ts\";\r\nimport { TypeKind } from \"edgedb/_src/reflection/index.ts\";\r\nimport type {\r\n  ArrayType,\r\n  BaseTypeTuple,\r\n  BaseType,\r\n  NamedTupleType,\r\n  ObjectTypeSet,\r\n  TypeSet,\r\n  TupleType,\r\n  Expression,\r\n  ObjectType,\r\n  getPrimitiveBaseType,\r\n  SomeType,\r\n} from \"./typesystem.ts\";\r\n\r\nimport { $mergeObjectTypes, type mergeObjectTypes } from \"./hydrate.ts\";\r\n\r\nimport * as castMaps from \"./castMaps.ts\";\r\n\r\nexport function getSharedParent(a: SomeType, b: SomeType): SomeType {\r\n  if (a.__kind__ !== b.__kind__) {\r\n    throw new Error(\r\n      `Incompatible array types: ${a.__name__} and ${b.__name__}`\r\n    );\r\n  }\r\n  if (a.__kind__ === TypeKind.scalar && b.__kind__ === TypeKind.scalar) {\r\n    return castMaps.getSharedParentScalar(a, b);\r\n  } else if (a.__kind__ === TypeKind.object && b.__kind__ === TypeKind.object) {\r\n    return $mergeObjectTypes(a, b);\r\n  } else if (a.__kind__ === TypeKind.tuple && b.__kind__ === TypeKind.tuple) {\r\n    if (a.__items__.length !== b.__items__.length) {\r\n      throw new Error(\r\n        `Incompatible tuple types: ${a.__name__} and ${b.__name__}`\r\n      );\r\n    }\r\n    try {\r\n      const items = a.__items__.map((_, i) => {\r\n        if (!a.__items__[i] || !b.__items__[i]) {\r\n          throw new Error();\r\n        }\r\n        return getSharedParent(\r\n          a.__items__[i] as SomeType,\r\n          b.__items__[i] as SomeType\r\n        );\r\n      });\r\n\r\n      return {\r\n        __kind__: TypeKind.tuple,\r\n        __name__: `tuple<${items.map((item) => item.__name__).join(\", \")}>`,\r\n        __items__: items as BaseTypeTuple,\r\n      };\r\n    } catch (err) {\r\n      throw new Error(\r\n        `Incompatible tuple types: ${a.__name__} and ${b.__name__}`\r\n      );\r\n    }\r\n  } else if (\r\n    a.__kind__ === TypeKind.namedtuple &&\r\n    b.__kind__ === TypeKind.namedtuple\r\n  ) {\r\n    const aKeys = Object.keys(a);\r\n    const bKeys = new Set(Object.keys(b));\r\n    const sameKeys =\r\n      aKeys.length === bKeys.size && aKeys.every((k) => bKeys.has(k));\r\n    if (!sameKeys) {\r\n      throw new Error(\r\n        `Incompatible tuple types: ${a.__name__} and ${b.__name__}`\r\n      );\r\n    }\r\n    try {\r\n      const items: { [k: string]: BaseType } = {};\r\n      for (const [i] of Object.entries(a.__shape__)) {\r\n        if (!a.__shape__[i] || !b.__shape__[i]) {\r\n          throw new Error();\r\n        }\r\n        items[i] = getSharedParent(\r\n          a.__shape__[i] as SomeType,\r\n          b.__shape__[i] as SomeType\r\n        );\r\n      }\r\n\r\n      return {\r\n        __kind__: TypeKind.namedtuple,\r\n        __name__: `tuple<${Object.entries(items)\r\n          .map(([key, val]: [string, any]) => `${key}: ${val.__name__}`)\r\n          .join(\", \")}>`,\r\n        __shape__: items,\r\n      };\r\n    } catch (err) {\r\n      throw new Error(\r\n        `Incompatible tuple types: ${a.__name__} and ${b.__name__}`\r\n      );\r\n    }\r\n  } else if (a.__kind__ === TypeKind.array && b.__kind__ === TypeKind.array) {\r\n    try {\r\n      const mergedEl: any = getSharedParent(\r\n        a.__element__ as any,\r\n        b.__element__ as any\r\n      );\r\n      return {\r\n        __kind__: TypeKind.array,\r\n        __name__: a.__name__,\r\n        __element__: mergedEl,\r\n      } as ArrayType;\r\n    } catch (err) {\r\n      throw new Error(\r\n        `Incompatible array types: ${a.__name__} and ${b.__name__}`\r\n      );\r\n    }\r\n  } else if (a.__kind__ === TypeKind.enum && b.__kind__ === TypeKind.enum) {\r\n    if (a.__name__ === b.__name__) return a;\r\n    throw new Error(\r\n      `Incompatible array types: ${a.__name__} and ${b.__name__}`\r\n    );\r\n  } else {\r\n    throw new Error(\r\n      `Incompatible array types: ${a.__name__} and ${b.__name__}`\r\n    );\r\n  }\r\n}\r\n\r\nexport { set } from \"./setImpl.ts\";\r\n\r\n// export type $expr_Set<Set extends LooseTypeSet = LooseTypeSet> = Expression<\r\nexport type $expr_Set<Set extends LooseTypeSet = LooseTypeSet> = Expression<{\r\n  __element__: Set[\"__element__\"];\r\n  __cardinality__: Set[\"__cardinality__\"];\r\n  __exprs__: TypeSet[];\r\n  __kind__: ExpressionKind.Set;\r\n}>;\r\n\r\ntype mergeTypeTuples<AItems, BItems> = {\r\n  [k in keyof AItems]: k extends keyof BItems\r\n    ? getSharedParentPrimitive<AItems[k], BItems[k]>\r\n    : never;\r\n};\r\n\r\n// find shared parent of two primitives\r\nexport type getSharedParentPrimitive<A, B> = A extends undefined\r\n  ? B extends undefined\r\n    ? undefined\r\n    : B\r\n  : B extends undefined\r\n  ? A\r\n  : A extends ArrayType<infer AEl>\r\n  ? B extends ArrayType<infer BEl>\r\n    ? ArrayType<castMaps.getSharedParentScalar<AEl, BEl>>\r\n    : never\r\n  : A extends NamedTupleType<infer AShape>\r\n  ? B extends NamedTupleType<infer BShape>\r\n    ? NamedTupleType<{\r\n        [k in keyof AShape & keyof BShape]: castMaps.getSharedParentScalar<\r\n          AShape[k],\r\n          BShape[k]\r\n        >;\r\n      }>\r\n    : never\r\n  : A extends TupleType<infer AItems>\r\n  ? B extends TupleType<infer BItems>\r\n    ? mergeTypeTuples<AItems, BItems> extends BaseTypeTuple\r\n      ? TupleType<mergeTypeTuples<AItems, BItems>>\r\n      : never\r\n    : never\r\n  : castMaps.getSharedParentScalar<A, B>;\r\n\r\ntype _getSharedParentPrimitiveVariadic<Types extends [any, ...any[]]> =\r\n  Types extends [infer U]\r\n    ? U\r\n    : Types extends [infer A, infer B, ...infer Rest]\r\n    ? _getSharedParentPrimitiveVariadic<\r\n        [getSharedParentPrimitive<A, B>, ...Rest]\r\n      >\r\n    : never;\r\n\r\nexport type getSharedParentPrimitiveVariadic<Types extends [any, ...any[]]> =\r\n  _getSharedParentPrimitiveVariadic<Types>;\r\n\r\nexport type LooseTypeSet<\r\n  T extends any = any,\r\n  C extends Cardinality = Cardinality\r\n> = {\r\n  __element__: T;\r\n  __cardinality__: C;\r\n};\r\n\r\nexport type { mergeObjectTypes };\r\n\r\ntype _mergeObjectTypesVariadic<Types extends [ObjectType, ...ObjectType[]]> =\r\n  Types extends [infer U]\r\n    ? U\r\n    : Types extends [infer A, infer B, ...infer Rest]\r\n    ? A extends ObjectType\r\n      ? B extends ObjectType\r\n        ? mergeObjectTypes<A, B> extends BaseType\r\n          ? mergeObjectTypesVariadic<[mergeObjectTypes<A, B>, ...Rest]>\r\n          : never\r\n        : never\r\n      : never\r\n    : never;\r\n\r\nexport type mergeObjectTypesVariadic<Types extends [any, ...any[]]> =\r\n  _mergeObjectTypesVariadic<Types>;\r\n\r\nexport type getTypesFromExprs<Exprs extends [TypeSet, ...TypeSet[]]> = {\r\n  [k in keyof Exprs]: Exprs[k] extends TypeSet<infer El, any>\r\n    ? getPrimitiveBaseType<El>\r\n    : never;\r\n};\r\n\r\nexport type getTypesFromObjectExprs<\r\n  Exprs extends [ObjectTypeSet, ...ObjectTypeSet[]]\r\n> = {\r\n  [k in keyof Exprs]: Exprs[k] extends TypeSet<infer El, any> ? El : never;\r\n};\r\n\r\nexport type getCardsFromExprs<Exprs extends [TypeSet, ...TypeSet[]]> = {\r\n  [k in keyof Exprs]: Exprs[k] extends TypeSet<any, infer Card> ? Card : never;\r\n};\r\n"},{"path":"setImpl.ts","content":"export function set(...args: any[]): any {}\r\n"},{"path":"syntax.ts","content":"import type { TypeSet, setToTsType } from \"./typesystem.ts\";\r\n\r\nexport * from \"./literal.ts\";\r\nexport * from \"./path.ts\";\r\nexport * from \"./set.ts\";\r\nexport * from \"./cast.ts\";\r\nexport * from \"./select.ts\";\r\nexport * from \"./update.ts\";\r\nexport * from \"./insert.ts\";\r\nexport * from \"./group.ts\";\r\nexport * from \"./collections.ts\";\r\nexport * from \"./funcops.ts\";\r\nexport * from \"./for.ts\";\r\nexport * from \"./with.ts\";\r\nexport * from \"./params.ts\";\r\nexport * from \"./globals.ts\";\r\nexport * from \"./detached.ts\";\r\nexport * from \"./toEdgeQL.ts\";\r\nexport * from \"./range.ts\";\r\n\r\nexport type $infer<A extends TypeSet> = setToTsType<A>;\r\n"},{"path":"toEdgeQL.ts","content":"import {\r\n  Duration,\r\n  LocalDate,\r\n  LocalDateTime,\r\n  LocalTime,\r\n  RelativeDuration,\r\n  DateDuration,\r\n  Range,\r\n} from \"edgedb\";\r\nimport {\r\n  Cardinality,\r\n  ExpressionKind,\r\n  OperatorKind,\r\n  TypeKind,\r\n  util,\r\n} from \"edgedb/_src/reflection/index.ts\";\r\nimport {\r\n  type $expr_Array,\r\n  type $expr_NamedTuple,\r\n  type $expr_Tuple,\r\n  type $expr_TuplePath,\r\n  type BaseType,\r\n  type EnumType,\r\n  isArrayType,\r\n  isNamedTupleType,\r\n  isObjectType,\r\n  isTupleType,\r\n  type ObjectType,\r\n  type ObjectTypeSet,\r\n  type RangeType,\r\n  type TypeSet,\r\n} from \"./typesystem.ts\";\r\nimport type { $expr_Literal } from \"./literal.ts\";\r\nimport type {\r\n  $expr_PathLeaf,\r\n  $expr_PathNode,\r\n  $expr_TypeIntersection,\r\n} from \"./path.ts\";\r\nimport { reservedKeywords } from \"edgedb/_src/reflection/index.ts\";\r\nimport type { $expr_Cast } from \"./cast.ts\";\r\nimport type { $expr_Detached } from \"./detached.ts\";\r\nimport type { $expr_For, $expr_ForVar } from \"./for.ts\";\r\nimport type { $expr_Function, $expr_Operator } from \"./funcops.ts\";\r\nimport type { $expr_Insert, $expr_InsertUnlessConflict } from \"./insert.ts\";\r\nimport type { $expr_Param, $expr_WithParams } from \"./params.ts\";\r\nimport type {\r\n  $expr_Delete,\r\n  $expr_Select,\r\n  LimitExpression,\r\n  OffsetExpression,\r\n} from \"./select.ts\";\r\nimport type { $expr_Set } from \"./set.ts\";\r\nimport type { $expr_Update } from \"./update.ts\";\r\nimport type { $expr_Alias, $expr_With } from \"./with.ts\";\r\nimport type { $expr_Group, GroupingSet } from \"./group.ts\";\r\nimport type { $expr_Global } from \"./globals.ts\";\r\n\r\nexport type SomeExpression =\r\n  | $expr_PathNode\r\n  | $expr_PathLeaf\r\n  | $expr_Literal\r\n  | $expr_Set\r\n  | $expr_Array\r\n  | $expr_Tuple\r\n  | $expr_NamedTuple\r\n  | $expr_TuplePath\r\n  | $expr_Cast\r\n  | $expr_Select\r\n  | $expr_Delete\r\n  | $expr_Update\r\n  | $expr_Insert\r\n  | $expr_InsertUnlessConflict\r\n  | $expr_Function\r\n  | $expr_Operator\r\n  | $expr_For\r\n  | $expr_ForVar\r\n  | $expr_TypeIntersection\r\n  | $expr_Alias\r\n  | $expr_With\r\n  | $expr_WithParams\r\n  | $expr_Param\r\n  | $expr_Detached\r\n  | $expr_Group\r\n  | $expr_Global;\r\n\r\ntype WithScopeExpr =\r\n  | $expr_Select\r\n  | $expr_Update\r\n  | $expr_Insert\r\n  | $expr_InsertUnlessConflict\r\n  | $expr_For\r\n  | $expr_Group;\r\n\r\ninterface RenderCtx {\r\n  // mapping withable expr to list of with vars\r\n  withBlocks: Map<WithScopeExpr, Set<SomeExpression>>;\r\n  // metadata about each with var\r\n  withVars: Map<\r\n    SomeExpression,\r\n    {\r\n      name: string;\r\n      scope: WithScopeExpr;\r\n      childExprs: Set<SomeExpression>;\r\n      scopedExpr?: SomeExpression; // scope vars only\r\n    }\r\n  >;\r\n  renderWithVar?: SomeExpression;\r\n  forVars: Map<$expr_ForVar, string>;\r\n  linkProps: Map<SomeExpression, string[]>;\r\n}\r\n\r\nexport function $toEdgeQL(this: any) {\r\n  const walkExprCtx: WalkExprTreeCtx = {\r\n    seen: new Map(),\r\n    rootScope: null,\r\n  };\r\n\r\n  walkExprTree(this, null, walkExprCtx);\r\n\r\n  // get variables by block\r\n  const withBlocks: RenderCtx[\"withBlocks\"] = new Map();\r\n  // get per-variable metadata\r\n  const withVars: RenderCtx[\"withVars\"] = new Map();\r\n  const seen = new Map(walkExprCtx.seen);\r\n  const linkProps: RenderCtx[\"linkProps\"] = new Map();\r\n\r\n  // iterate over all expressions\r\n  for (const [expr, refData] of seen) {\r\n    // delete from seen after visitinng\r\n    seen.delete(expr);\r\n\r\n    // convert referenced link props to simple string array\r\n    if (refData.linkProps.length) {\r\n      linkProps.set(\r\n        expr,\r\n        refData.linkProps.map((linkProp) =>\r\n          linkProp.__parent__.linkName.slice(1)\r\n        )\r\n      );\r\n    }\r\n\r\n    // already extracted\r\n    if (withVars.has(expr)) {\r\n      continue;\r\n    }\r\n\r\n    // ignore unbound leaves, nodes, and intersections\r\n    // these should be rendered as is\r\n    if (\r\n      !refData.boundScope &&\r\n      (expr.__kind__ === ExpressionKind.PathLeaf ||\r\n        expr.__kind__ === ExpressionKind.PathNode ||\r\n        expr.__kind__ === ExpressionKind.TypeIntersection)\r\n    ) {\r\n      continue;\r\n    }\r\n\r\n    // forvars and params should not be hoisted\r\n    if (\r\n      expr.__kind__ === ExpressionKind.ForVar ||\r\n      expr.__kind__ === ExpressionKind.Param\r\n    ) {\r\n      continue;\r\n    }\r\n\r\n    // pull out scope variables\r\n    // from select, update, and group expressions.\r\n    // these are always rendered in with blocks\r\n    if (\r\n      (expr.__kind__ === ExpressionKind.Select ||\r\n        expr.__kind__ === ExpressionKind.Update ||\r\n        expr.__kind__ === ExpressionKind.Group) &&\r\n      expr.__scope__ &&\r\n      // with var not previously registered\r\n      !withVars.has(expr.__scope__ as any)\r\n    ) {\r\n      const withBlock = expr;\r\n      const scopeVar = expr.__scope__ as SomeExpression;\r\n      const scopeVarName = `__scope_${\r\n        withVars.size\r\n      }_${scopeVar.__element__.__name__.replace(/[^A-Za-z]/g, \"\")}`;\r\n\r\n      withVars.set(scopeVar, {\r\n        name: scopeVarName,\r\n        scope: withBlock,\r\n        childExprs: new Set(),\r\n        scopedExpr:\r\n          expr.__element__.__kind__ === TypeKind.object\r\n            ? (expr.__expr__ as any)\r\n            : undefined,\r\n      });\r\n    }\r\n\r\n    // expression should be extracted to with block if\r\n    // - bound with e.with\r\n    // - refcount > 1\r\n    // - aliased with e.alias\r\n    if (\r\n      refData.refCount > 1 ||\r\n      refData.boundScope ||\r\n      refData.aliases.length > 0\r\n    ) {\r\n      // first, check if expr is bound to scope\r\n      let withBlock = refData.boundScope;\r\n\r\n      const parentScopes = [...refData.parentScopes];\r\n\r\n      // if expression is unbound\r\n      if (!withBlock) {\r\n        // if parent scopes haven't all been resolved,\r\n        // re-add current expr to `seen` to be resolved later\r\n        if (\r\n          parentScopes.some(\r\n            (parentScope) => parentScope && seen.has(parentScope)\r\n          )\r\n        ) {\r\n          seen.set(expr, refData);\r\n          continue;\r\n        }\r\n\r\n        if (parentScopes.some((scope) => scope == null)) {\r\n          throw new Error(\r\n            `Cannot extract repeated expression into 'WITH' block, ` +\r\n              `expression used outside of 'WITH'able expression`\r\n          );\r\n        }\r\n\r\n        const [firstParentScopeChain, ...parentScopeChains] = parentScopes.map(\r\n          (scope) => {\r\n            const scopes: WithScopeExpr[] = [scope!];\r\n            const pendingScopes = [scope];\r\n            while (pendingScopes.length) {\r\n              const currentScope = pendingScopes.shift()!;\r\n              pendingScopes.push(\r\n                ...[...walkExprCtx.seen.get(currentScope)!.parentScopes].filter(\r\n                  (s) => s !== null\r\n                )\r\n              );\r\n              if (!scopes.includes(currentScope)) {\r\n                scopes.push(currentScope);\r\n              }\r\n            }\r\n            return scopes;\r\n          }\r\n        );\r\n        const commonParentScope = firstParentScopeChain\r\n          ? firstParentScopeChain.find((scope) =>\r\n              // find the first parent scope in the chain that is shared by\r\n              // the other parent scope chains\r\n              parentScopeChains.every((otherScope) =>\r\n                otherScope.includes(scope)\r\n              )\r\n            )\r\n          : null;\r\n\r\n        withBlock = commonParentScope ?? walkExprCtx.rootScope;\r\n      }\r\n\r\n      if (!withBlock) {\r\n        throw new Error(\r\n          `Cannot extract repeated expression into 'WITH' block, ` +\r\n            `expression does not appear within common 'WITH'able expression`\r\n        );\r\n      }\r\n\r\n      if (!withBlocks.has(withBlock)) {\r\n        withBlocks.set(withBlock, new Set());\r\n      }\r\n\r\n      // check all references and aliases are within this block\r\n      const validScopes = new Set([\r\n        withBlock,\r\n        ...walkExprCtx.seen.get(withBlock)!.childExprs,\r\n      ]);\r\n      for (const scope of [\r\n        ...refData.parentScopes,\r\n        ...util.flatMap(refData.aliases, (alias) => [\r\n          ...walkExprCtx.seen.get(alias)!.parentScopes,\r\n        ]),\r\n      ]) {\r\n        if (scope === null || !validScopes.has(scope)) {\r\n          throw new Error(\r\n            refData.boundScope\r\n              ? `Expr or its aliases used outside of declared 'WITH' block scope`\r\n              : `Cannot extract repeated or aliased expression into 'WITH' block, ` +\r\n                `expression or its aliases appear outside root scope`\r\n          );\r\n        }\r\n      }\r\n\r\n      for (const withVar of [expr, ...refData.aliases]) {\r\n        // withVar is an alias already explicitly bound\r\n        // to an inner WITH block\r\n        const withVarBoundScope = walkExprCtx.seen.get(withVar)!.boundScope;\r\n        if (withVarBoundScope && withVarBoundScope !== refData.boundScope) {\r\n          continue;\r\n        }\r\n\r\n        const withVarName = `__withVar_${withVars.size}`;\r\n\r\n        withBlocks.get(withBlock)!.add(withVar);\r\n        withVars.set(withVar, {\r\n          name: withVarName,\r\n          scope: withBlock,\r\n          childExprs: new Set(walkExprCtx.seen.get(withVar)!.childExprs),\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  let edgeQL = renderEdgeQL(this, {\r\n    withBlocks,\r\n    withVars,\r\n    forVars: new Map(),\r\n    linkProps,\r\n  });\r\n  if (\r\n    edgeQL.startsWith(\"(\") &&\r\n    edgeQL.endsWith(\")\") &&\r\n    !(\r\n      this.__kind__ === ExpressionKind.Tuple ||\r\n      this.__kind__ === ExpressionKind.NamedTuple ||\r\n      this.__kind__ === ExpressionKind.Literal\r\n    )\r\n  ) {\r\n    edgeQL = edgeQL.slice(1, -1);\r\n  }\r\n\r\n  return edgeQL;\r\n}\r\n\r\ninterface WalkExprTreeCtx {\r\n  seen: Map<\r\n    SomeExpression,\r\n    {\r\n      refCount: number;\r\n      // tracks all withable ancestors\r\n      parentScopes: Set<WithScopeExpr | null>;\r\n      // tracks all child exprs\r\n      childExprs: SomeExpression[];\r\n      // tracks bound scope from e.with\r\n      boundScope: WithScopeExpr | null;\r\n      // tracks aliases from e.alias\r\n      aliases: SomeExpression[];\r\n      linkProps: $expr_PathLeaf[];\r\n    }\r\n  >;\r\n  rootScope: WithScopeExpr | null;\r\n}\r\n\r\n// walks entire expression tree\r\n// populates\r\nfunction walkExprTree(\r\n  _expr: TypeSet,\r\n  parentScope: WithScopeExpr | null,\r\n  ctx: WalkExprTreeCtx\r\n): SomeExpression[] {\r\n  if (!(_expr as any).__kind__) {\r\n    throw new Error(\r\n      `Expected a valid querybuilder expression, ` +\r\n        `instead received ${typeof _expr}${\r\n          typeof _expr !== \"undefined\" ? `: '${_expr}'` : \"\"\r\n        }.` +\r\n        getErrorHint(_expr)\r\n    );\r\n  }\r\n\r\n  const expr = _expr as SomeExpression;\r\n\r\n  function walkShape(shape: object) {\r\n    for (let param of Object.values(shape)) {\r\n      if (param.__kind__ === ExpressionKind.PolyShapeElement) {\r\n        param = param.__shapeElement__;\r\n      }\r\n      if (typeof param === \"object\") {\r\n        if (!!(param as any).__kind__) {\r\n          // param is expression\r\n          childExprs.push(...walkExprTree(param as any, expr as any, ctx));\r\n        } else {\r\n          walkShape(param);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // set root scope\r\n  if (!ctx.rootScope && parentScope) {\r\n    ctx.rootScope = parentScope;\r\n  }\r\n\r\n  // return without walking if expression has been seen\r\n  const seenExpr = ctx.seen.get(expr);\r\n  if (seenExpr) {\r\n    seenExpr.refCount += 1;\r\n    // if (seenExpr.refCount > 1) {\r\n    // console.log(`###########\\nSEEN ${seenExpr.refCount} times`);\r\n    // console.log(expr.__kind__);\r\n    // console.log(expr.__element__.__name__);\r\n    // const arg = (expr as any)?.__parent__ || (expr as any)?.__name__;\r\n    // if (arg) console.log(arg);\r\n    // }\r\n    seenExpr.parentScopes.add(parentScope);\r\n    return [expr, ...seenExpr.childExprs];\r\n  }\r\n\r\n  const childExprs: SomeExpression[] = [];\r\n  ctx.seen.set(expr, {\r\n    refCount: 1,\r\n    parentScopes: new Set([parentScope]),\r\n    childExprs,\r\n    boundScope: null,\r\n    aliases: [],\r\n    linkProps: [],\r\n  });\r\n\r\n  switch (expr.__kind__) {\r\n    case ExpressionKind.Alias:\r\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\r\n      ctx.seen.get(expr.__expr__ as any)!.aliases.push(expr);\r\n      break;\r\n    case ExpressionKind.With:\r\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\r\n      for (const refExpr of expr.__refs__) {\r\n        walkExprTree(refExpr, expr.__expr__, ctx);\r\n        const seenRef = ctx.seen.get(refExpr as any)!;\r\n        if (seenRef.boundScope) {\r\n          throw new Error(`Expression bound to multiple 'WITH' blocks`);\r\n        }\r\n        seenRef.boundScope = expr.__expr__;\r\n      }\r\n      break;\r\n    case ExpressionKind.Literal:\r\n    case ExpressionKind.ForVar:\r\n    case ExpressionKind.Param:\r\n      break;\r\n    case ExpressionKind.PathLeaf:\r\n    case ExpressionKind.PathNode:\r\n      if (expr.__parent__) {\r\n        if ((expr.__parent__.type as any).__scopedFrom__) {\r\n          // if parent is scoped expr then don't walk expr\r\n          // since it will already be walked by enclosing select/update\r\n\r\n          childExprs.push(expr.__parent__.type as any);\r\n        } else {\r\n          childExprs.push(\r\n            ...walkExprTree(expr.__parent__.type, parentScope, ctx)\r\n          );\r\n        }\r\n\r\n        if (\r\n          // is link prop\r\n          expr.__kind__ === ExpressionKind.PathLeaf &&\r\n          expr.__parent__.linkName.startsWith(\"@\")\r\n        ) {\r\n          // don't hoist a linkprop that isn't scoped from parentScope\r\n          const parentScopeVar = (parentScope as any).__scope__;\r\n          if (parentScopeVar === expr.__parent__.type) {\r\n            ctx.seen.get(parentScope!)?.linkProps.push(expr);\r\n          }\r\n        }\r\n      }\r\n      break;\r\n    case ExpressionKind.Cast:\r\n      if (expr.__expr__ === null) break;\r\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\r\n      break;\r\n    case ExpressionKind.Set:\r\n      for (const subExpr of expr.__exprs__) {\r\n        childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\r\n      }\r\n      break;\r\n    case ExpressionKind.Array:\r\n      for (const subExpr of expr.__items__) {\r\n        childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\r\n      }\r\n      break;\r\n    case ExpressionKind.Tuple:\r\n      for (const subExpr of expr.__items__) {\r\n        childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\r\n      }\r\n      break;\r\n    case ExpressionKind.NamedTuple:\r\n      for (const subExpr of Object.values(expr.__shape__)) {\r\n        childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\r\n      }\r\n      break;\r\n    case ExpressionKind.TuplePath:\r\n      childExprs.push(...walkExprTree(expr.__parent__, parentScope, ctx));\r\n      break;\r\n    case ExpressionKind.Select:\r\n    case ExpressionKind.Update: {\r\n      const modifiers = expr.__modifiers__;\r\n      if (modifiers.filter) {\r\n        childExprs.push(...walkExprTree(modifiers.filter, expr, ctx));\r\n      }\r\n      if (modifiers.order_by) {\r\n        for (const orderExpr of modifiers.order_by) {\r\n          childExprs.push(...walkExprTree(orderExpr.expression, expr, ctx));\r\n        }\r\n      }\r\n      if (modifiers.offset) {\r\n        childExprs.push(...walkExprTree(modifiers.offset!, expr, ctx));\r\n      }\r\n      if (modifiers.limit) {\r\n        childExprs.push(...walkExprTree(modifiers.limit!, expr, ctx));\r\n      }\r\n\r\n      if (expr.__kind__ === ExpressionKind.Select) {\r\n        if (\r\n          isObjectType(expr.__element__) &&\r\n          // don't walk shape twice if select expr justs wrap another object\r\n          // type expr with the same shape\r\n          expr.__element__.__shape__ !==\r\n            (expr.__expr__ as ObjectTypeSet).__element__.__shape__\r\n        ) {\r\n          walkShape(expr.__element__.__shape__ ?? {});\r\n        }\r\n      } else {\r\n        // Update\r\n        const shape: any = expr.__shape__ ?? {};\r\n\r\n        for (const _element of Object.values(shape)) {\r\n          let element: any = _element;\r\n          if (!element.__element__) {\r\n            if (element[\"+=\"]) element = element[\"+=\"];\r\n            else if (element[\"-=\"]) element = element[\"-=\"];\r\n          }\r\n          childExprs.push(...walkExprTree(element as any, expr, ctx));\r\n        }\r\n      }\r\n\r\n      childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\r\n      break;\r\n    }\r\n    case ExpressionKind.Delete: {\r\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\r\n      break;\r\n    }\r\n    case ExpressionKind.Insert: {\r\n      const shape: any = expr.__shape__ ?? {};\r\n\r\n      for (const element of Object.values(shape)) {\r\n        childExprs.push(...walkExprTree(element as any, expr, ctx));\r\n      }\r\n\r\n      childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\r\n      break;\r\n    }\r\n    case ExpressionKind.InsertUnlessConflict: {\r\n      // InsertUnlessConflict doesn't create a new scope, the parent scope of\r\n      // child expressions is the wrapped Insert expr\r\n      const insertChildExprs: SomeExpression[] = [];\r\n      if (expr.__conflict__.on) {\r\n        insertChildExprs.push(\r\n          ...walkExprTree(\r\n            expr.__conflict__.on,\r\n            expr.__expr__ as $expr_Insert,\r\n            ctx\r\n          )\r\n        );\r\n      }\r\n      if (expr.__conflict__.else) {\r\n        insertChildExprs.push(\r\n          ...walkExprTree(\r\n            expr.__conflict__.else,\r\n            expr.__expr__ as $expr_Insert,\r\n            ctx\r\n          )\r\n        );\r\n      }\r\n\r\n      walkExprTree(expr.__expr__, parentScope, ctx);\r\n      ctx.seen\r\n        .get(expr.__expr__ as $expr_Insert)!\r\n        .childExprs.push(...insertChildExprs);\r\n      break;\r\n    }\r\n    case ExpressionKind.Group: {\r\n      const groupingSet = expr.__modifiers__.by as any as GroupingSet;\r\n      // const groupingSet = expr.__grouping__ as any as GroupingSet;\r\n      for (const [_k, groupExpr] of groupingSet.__exprs__) {\r\n        // this prevents recurring grouping elements from being walked twice\r\n        // this way, these won't get pulled into with blocks,\r\n        // which is good because they need to be rendered in `using`\r\n        const seen: Set<any> = new Set();\r\n        if (!seen.has(expr)) {\r\n          childExprs.push(...walkExprTree(groupExpr, expr, ctx));\r\n          seen.add(expr);\r\n        }\r\n      }\r\n\r\n      if (!expr.__element__.__shape__.elements.__element__.__shape__) {\r\n        throw new Error(\"Missing shape in GROUP statement\");\r\n      }\r\n      walkShape(expr.__element__.__shape__.elements.__element__.__shape__);\r\n      childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\r\n      break;\r\n    }\r\n    case ExpressionKind.TypeIntersection:\r\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\r\n      break;\r\n    case ExpressionKind.Operator:\r\n    case ExpressionKind.Function:\r\n      for (const subExpr of expr.__args__) {\r\n        if (Array.isArray(subExpr)) {\r\n          for (const arg of subExpr) {\r\n            if (arg) childExprs.push(...walkExprTree(arg, parentScope, ctx));\r\n          }\r\n        } else {\r\n          childExprs.push(...walkExprTree(subExpr!, parentScope, ctx));\r\n        }\r\n      }\r\n      if (expr.__kind__ === ExpressionKind.Function) {\r\n        for (const subExpr of Object.values(expr.__namedargs__)) {\r\n          childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\r\n        }\r\n      }\r\n      break;\r\n    case ExpressionKind.For: {\r\n      childExprs.push(...walkExprTree(expr.__iterSet__ as any, expr, ctx));\r\n      childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\r\n      break;\r\n    }\r\n    case ExpressionKind.WithParams: {\r\n      if (parentScope !== null) {\r\n        throw new Error(\r\n          `'withParams' does not support being used as a nested expression`\r\n        );\r\n      }\r\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\r\n      break;\r\n    }\r\n    case ExpressionKind.Detached: {\r\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\r\n      break;\r\n    }\r\n    case ExpressionKind.Global:\r\n      break;\r\n    default:\r\n      util.assertNever(\r\n        expr,\r\n        new Error(`Unrecognized expression kind: \"${(expr as any).__kind__}\"`)\r\n      );\r\n  }\r\n\r\n  return [expr, ...childExprs];\r\n}\r\n\r\nfunction renderEdgeQL(\r\n  _expr: TypeSet,\r\n  ctx: RenderCtx,\r\n  renderShape: boolean = true,\r\n  noImplicitDetached: boolean = false\r\n): string {\r\n  if (!(_expr as any).__kind__) {\r\n    throw new Error(\"Invalid expression.\");\r\n  }\r\n  const expr = _expr as SomeExpression;\r\n\r\n  // if expression is in a with block\r\n  // render its name\r\n  const withVar = ctx.withVars.get(expr);\r\n\r\n  if (withVar && ctx.renderWithVar !== expr) {\r\n    return renderShape &&\r\n      expr.__kind__ === ExpressionKind.Select &&\r\n      isObjectType(expr.__element__)\r\n      ? `(${withVar.name} ${shapeToEdgeQL(\r\n          (expr.__element__.__shape__ || {}) as object,\r\n          ctx,\r\n          null,\r\n          true // render shape only\r\n        )})`\r\n      : withVar.name;\r\n  }\r\n\r\n  // render with block expression\r\n  function renderWithBlockExpr(\r\n    varExpr: SomeExpression,\r\n    _noImplicitDetached?: boolean\r\n  ) {\r\n    const withBlockElement = ctx.withVars.get(varExpr)!;\r\n    let renderedExpr = renderEdgeQL(\r\n      withBlockElement.scopedExpr ?? varExpr,\r\n      {\r\n        ...ctx,\r\n        renderWithVar: varExpr,\r\n      },\r\n      !withBlockElement.scopedExpr, // render shape if no scopedExpr exists\r\n      _noImplicitDetached\r\n    );\r\n    const renderedExprNoDetached = renderEdgeQL(\r\n      withBlockElement.scopedExpr ?? varExpr,\r\n      {\r\n        ...ctx,\r\n        renderWithVar: varExpr,\r\n      },\r\n      !withBlockElement.scopedExpr, // render shape if no scopedExpr exists\r\n      true\r\n    );\r\n\r\n    if (ctx.linkProps.has(expr)) {\r\n      renderedExpr = `(SELECT ${renderedExpr} {\\n${ctx.linkProps\r\n        .get(expr)!\r\n        .map(\r\n          (linkPropName) =>\r\n            `  __linkprop_${linkPropName} := ${renderedExprNoDetached}@${linkPropName}`\r\n        )\r\n        .join(\",\\n\")}\\n})`;\r\n    }\r\n    return `  ${withBlockElement.name} := ${\r\n      renderedExpr.includes(\"\\n\")\r\n        ? `(\\n${indent(\r\n            renderedExpr[0] === \"(\" &&\r\n              renderedExpr[renderedExpr.length - 1] === \")\"\r\n              ? renderedExpr.slice(1, -1)\r\n              : renderedExpr,\r\n            4\r\n          )}\\n  )`\r\n        : renderedExpr\r\n    }`;\r\n  }\r\n\r\n  // extract scope expression from select/update if exists\r\n  const scopeExpr =\r\n    (expr.__kind__ === ExpressionKind.Select ||\r\n      expr.__kind__ === ExpressionKind.Update ||\r\n      expr.__kind__ === ExpressionKind.Group) &&\r\n    ctx.withVars.has(expr.__scope__ as any)\r\n      ? (expr.__scope__ as SomeExpression)\r\n      : undefined;\r\n\r\n  const scopeExprVar: string[] = [];\r\n  const unscopedWithBlock: string[] = [];\r\n  const scopedWithBlock: string[] = [];\r\n\r\n  // generate with block if needed\r\n  if (ctx.withBlocks.has(expr as any) || scopeExpr) {\r\n    // sort associated vars\r\n    const sortedBlockVars = topoSortWithVars(\r\n      ctx.withBlocks.get(expr as any) ?? new Set(),\r\n      ctx\r\n    );\r\n\r\n    if (!scopeExpr) {\r\n      // if no scope expression exists, all variables are unscoped\r\n      unscopedWithBlock.push(\r\n        ...sortedBlockVars.map((blockVar) => renderWithBlockExpr(blockVar))\r\n      );\r\n    }\r\n    // else if (expr.__kind__ === ExpressionKind.Group) {\r\n    //   // add all vars into scoped with block\r\n    //   // this is rendered inside the `using` clause later\r\n    //   // no need for the with/for trick\r\n    //   scopeExprVar.push(renderWithBlockExpr(scopeExpr, noImplicitDetached));\r\n    //   scopedWithBlock.push(\r\n    //     ...sortedBlockVars.map(blockVar => renderWithBlockExpr(blockVar))\r\n    //   );\r\n    // }\r\n    else {\r\n      // get scope variable\r\n      const scopeVar = ctx.withVars.get(scopeExpr)!;\r\n\r\n      // get list of with vars that reference scope\r\n      const scopedVars = sortedBlockVars.filter((blockVarExpr) =>\r\n        ctx.withVars.get(blockVarExpr)?.childExprs.has(scopeExpr)\r\n      );\r\n      // filter blockvars to only include vars that don't reference scope\r\n      unscopedWithBlock.push(\r\n        ...sortedBlockVars\r\n          .filter((blockVar) => !scopedVars.includes(blockVar))\r\n          .map((blockVar) => renderWithBlockExpr(blockVar))\r\n      );\r\n\r\n      // when rendering `with` variables that reference current scope\r\n      // they are extracted into computed properties defining in a for loop\r\n      if (!scopedVars.length) {\r\n        scopeExprVar.push(renderWithBlockExpr(scopeExpr, noImplicitDetached));\r\n      } else {\r\n        const scopeName = scopeVar.name;\r\n\r\n        // render a reference to scoped path (e.g. \".nemesis\")\r\n        scopeVar.name = scopeName + \"_expr\";\r\n        scopeExprVar.push(renderWithBlockExpr(scopeExpr, noImplicitDetached));\r\n        // scopedWithBlock.push(\r\n        //   renderWithBlockExpr(scopeExpr, noImplicitDetached)\r\n        // );\r\n\r\n        // render a for loop containing all scoped block vars\r\n        // as computed properties\r\n        scopeVar.name = scopeName + \"_inner\";\r\n        scopeExprVar.push(\r\n          `  ${scopeName} := (FOR ${scopeVar.name} IN {${\r\n            scopeName + \"_expr\"\r\n          }} UNION (\\n    WITH\\n${indent(\r\n            scopedVars\r\n              .map((blockVar) => renderWithBlockExpr(blockVar))\r\n              .join(\",\\n\"),\r\n            4\r\n          )}\\n    SELECT ${scopeVar.name} {\\n${scopedVars\r\n            .map((blockVar) => {\r\n              const name = ctx.withVars.get(blockVar)!.name;\r\n              return `      ${name} := ${name}`;\r\n            })\r\n            .join(\",\\n\")}\\n    }\\n  ))`\r\n        );\r\n\r\n        // change var name back to original value\r\n        scopeVar.name = scopeName;\r\n\r\n        // reassign name for all scoped block vars\r\n        for (const blockVarExpr of scopedVars) {\r\n          const blockVar = ctx.withVars.get(blockVarExpr)!;\r\n          blockVar.name = `${scopeName}.${blockVar.name}`;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  const withBlockElements = [\r\n    ...unscopedWithBlock,\r\n    ...scopeExprVar,\r\n    ...scopedWithBlock,\r\n  ];\r\n  const withBlock = withBlockElements.length\r\n    ? `WITH\\n${withBlockElements.join(\",\\n\")}\\n`\r\n    : \"\";\r\n\r\n  if (expr.__kind__ === ExpressionKind.With) {\r\n    return renderEdgeQL(expr.__expr__, ctx);\r\n  } else if (expr.__kind__ === ExpressionKind.WithParams) {\r\n    return `(WITH\\n${expr.__params__\r\n      .map((param) => {\r\n        const optional =\r\n          param.__cardinality__ === Cardinality.AtMostOne ? \"OPTIONAL \" : \"\";\r\n        let paramExpr: string;\r\n        if (param.__isComplex__) {\r\n          let cast = param.__element__.__name__;\r\n          cast = cast.includes(\"std::decimal\")\r\n            ? `<${cast}><${cast.replace(/std::decimal/g, \"std::str\")}>`\r\n            : `<${cast}>`;\r\n          paramExpr = `${cast}to_json(<${optional}str>$${param.__name__})`;\r\n        } else {\r\n          paramExpr = `<${optional}${param.__element__.__name__}>$${param.__name__}`;\r\n        }\r\n        return `  __param__${param.__name__} := ${paramExpr}`;\r\n      })\r\n      .join(\",\\n\")}\\nSELECT ${renderEdgeQL(expr.__expr__, ctx)})`;\r\n  } else if (expr.__kind__ === ExpressionKind.Alias) {\r\n    const aliasedExprVar = ctx.withVars.get(expr.__expr__ as any);\r\n    if (!aliasedExprVar) {\r\n      throw new Error(\r\n        `Expression referenced by alias does not exist in 'WITH' block`\r\n      );\r\n    }\r\n    return aliasedExprVar.name;\r\n  } else if (\r\n    expr.__kind__ === ExpressionKind.PathNode ||\r\n    expr.__kind__ === ExpressionKind.PathLeaf\r\n  ) {\r\n    if (!expr.__parent__) {\r\n      return `${noImplicitDetached ? \"\" : \"DETACHED \"}${\r\n        expr.__element__.__name__\r\n      }`;\r\n    } else {\r\n      const isScopedLinkProp =\r\n        expr.__parent__.linkName.startsWith(\"@\") &&\r\n        ctx.withVars.has(expr.__parent__.type as any);\r\n      const linkName = isScopedLinkProp\r\n        ? `__linkprop_${expr.__parent__.linkName.slice(1)}`\r\n        : expr.__parent__.linkName;\r\n      const parent = renderEdgeQL(\r\n        expr.__parent__.type,\r\n        ctx,\r\n        false,\r\n        noImplicitDetached\r\n      );\r\n      return `${parent}${linkName.startsWith(\"@\") ? \"\" : \".\"}${q(linkName)}`;\r\n    }\r\n  } else if (expr.__kind__ === ExpressionKind.Literal) {\r\n    return literalToEdgeQL(expr.__element__, expr.__value__);\r\n  } else if (expr.__kind__ === ExpressionKind.Set) {\r\n    const exprs = expr.__exprs__;\r\n\r\n    if (\r\n      exprs.every((ex) => ex.__element__.__kind__ === TypeKind.object) ||\r\n      exprs.every((ex) => ex.__element__.__kind__ !== TypeKind.object)\r\n    ) {\r\n      if (exprs.length === 0) return `<${expr.__element__.__name__}>{}`;\r\n      return `{ ${exprs.map((ex) => renderEdgeQL(ex, ctx)).join(\", \")} }`;\r\n    } else {\r\n      throw new Error(\r\n        `Invalid arguments to set constructor: ${exprs\r\n          .map((ex) => ex.__element__.__name__)\r\n          .join(\", \")}`\r\n      );\r\n    }\r\n  } else if (expr.__kind__ === ExpressionKind.Array) {\r\n    return `[${expr.__items__\r\n      .map((item) => renderEdgeQL(item, ctx))\r\n      .join(\", \")}]`;\r\n  } else if (expr.__kind__ === ExpressionKind.Tuple) {\r\n    return `(\\n${expr.__items__\r\n      .map(\r\n        (item) =>\r\n          `  ` + renderEdgeQL(item, ctx, renderShape, noImplicitDetached)\r\n      )\r\n      .join(\",\\n\")}${expr.__items__.length === 1 ? \",\" : \"\"}\\n)`;\r\n  } else if (expr.__kind__ === ExpressionKind.NamedTuple) {\r\n    return `(\\n${Object.keys(expr.__shape__)\r\n      .map(\r\n        (key) =>\r\n          `  ${key} := ${renderEdgeQL(\r\n            expr.__shape__[key]!,\r\n            ctx,\r\n            renderShape,\r\n            noImplicitDetached\r\n          )}`\r\n      )\r\n      .join(\",\\n\")}\\n)`;\r\n  } else if (expr.__kind__ === ExpressionKind.TuplePath) {\r\n    return `${renderEdgeQL(expr.__parent__, ctx)}.${expr.__index__}`;\r\n  } else if (expr.__kind__ === ExpressionKind.Cast) {\r\n    const typeName =\r\n      expr.__element__.__name__ === \"std::number\"\r\n        ? \"std::float64\"\r\n        : expr.__element__.__name__;\r\n    if (expr.__expr__ === null) {\r\n      return `<${typeName}>{}`;\r\n    }\r\n    return `<${typeName}>(${renderEdgeQL(expr.__expr__, ctx)})`;\r\n  } else if (expr.__kind__ === ExpressionKind.Select) {\r\n    const lines: string[] = [];\r\n    if (isObjectType(expr.__element__)) {\r\n      const selectionTarget = renderEdgeQL(\r\n        expr.__scope__ ?? expr.__expr__,\r\n        ctx,\r\n        false\r\n      );\r\n\r\n      lines.push(\r\n        `SELECT${\r\n          selectionTarget === \"DETACHED std::FreeObject\"\r\n            ? \"\"\r\n            : ` ${selectionTarget}`\r\n        }`\r\n      );\r\n\r\n      if (\r\n        expr.__element__.__shape__ !==\r\n        (expr.__expr__ as ObjectTypeSet).__element__.__shape__\r\n      ) {\r\n        lines.push(\r\n          shapeToEdgeQL(\r\n            (expr.__element__.__shape__ || {}) as object,\r\n            ctx,\r\n            expr.__element__\r\n          )\r\n        );\r\n      }\r\n    } else {\r\n      // non-object/non-shape select expression\r\n      const needsScalarVar =\r\n        (expr.__modifiers__.filter ||\r\n          expr.__modifiers__.order_by ||\r\n          expr.__modifiers__.offset ||\r\n          expr.__modifiers__.limit) &&\r\n        !ctx.withVars.has(expr.__expr__ as any);\r\n\r\n      lines.push(\r\n        `SELECT ${needsScalarVar ? \"_ := \" : \"\"}${renderEdgeQL(\r\n          expr.__expr__,\r\n          ctx\r\n        )}`\r\n      );\r\n\r\n      if (needsScalarVar) {\r\n        ctx = { ...ctx, withVars: new Map(ctx.withVars) };\r\n        ctx.withVars.set(expr.__expr__ as any, {\r\n          name: \"_\",\r\n          childExprs: new Set(),\r\n          scope: expr,\r\n        });\r\n      }\r\n    }\r\n\r\n    const modifiers: string[] = [];\r\n\r\n    if (expr.__modifiers__.filter) {\r\n      modifiers.push(`FILTER ${renderEdgeQL(expr.__modifiers__.filter, ctx)}`);\r\n    }\r\n    if (expr.__modifiers__.order_by) {\r\n      modifiers.push(\r\n        ...expr.__modifiers__.order_by.map(\r\n          ({ expression, direction, empty }, i) => {\r\n            return `${i === 0 ? \"ORDER BY\" : \"  THEN\"} ${renderEdgeQL(\r\n              expression,\r\n              ctx\r\n            )}${direction ? \" \" + direction : \"\"}${empty ? \" \" + empty : \"\"}`;\r\n          }\r\n        )\r\n      );\r\n    }\r\n    if (expr.__modifiers__.offset) {\r\n      modifiers.push(\r\n        `OFFSET ${renderEdgeQL(\r\n          expr.__modifiers__.offset as OffsetExpression,\r\n          ctx\r\n        )}`\r\n      );\r\n    }\r\n    if (expr.__modifiers__.limit) {\r\n      modifiers.push(\r\n        `LIMIT ${renderEdgeQL(\r\n          expr.__modifiers__.limit as LimitExpression,\r\n          ctx\r\n        )}`\r\n      );\r\n    }\r\n\r\n    // without assert_single, the query will return a more informative\r\n    // CardinalityMismatchError when the query returns more than one result\r\n    return (\r\n      // (expr.__modifiers__.singleton ? `select assert_single((` : ``) +\r\n      \"(\" +\r\n      withBlock +\r\n      lines.join(\" \") +\r\n      (modifiers.length ? \"\\n\" + modifiers.join(\"\\n\") : \"\") +\r\n      \")\"\r\n      // + (expr.__modifiers__.singleton ? `))` : ``)\r\n    );\r\n  } else if (expr.__kind__ === ExpressionKind.Update) {\r\n    return `(${withBlock}UPDATE ${renderEdgeQL(expr.__scope__, ctx, false)}${\r\n      expr.__modifiers__.filter\r\n        ? `\\nFILTER ${renderEdgeQL(expr.__modifiers__.filter, ctx)}\\n`\r\n        : \" \"\r\n    }SET ${shapeToEdgeQL(expr.__shape__, ctx, null, false, false)})`;\r\n  } else if (expr.__kind__ === ExpressionKind.Delete) {\r\n    return `(${withBlock}DELETE ${renderEdgeQL(\r\n      expr.__expr__,\r\n      ctx,\r\n      undefined,\r\n      noImplicitDetached\r\n    )})`;\r\n  } else if (expr.__kind__ === ExpressionKind.Insert) {\r\n    return `(${withBlock}INSERT ${renderEdgeQL(\r\n      expr.__expr__,\r\n      ctx,\r\n      false,\r\n      true\r\n    )} ${shapeToEdgeQL(expr.__shape__, ctx, null, false, false)})`;\r\n  } else if (expr.__kind__ === ExpressionKind.InsertUnlessConflict) {\r\n    const $on = expr.__conflict__.on;\r\n    const $else = expr.__conflict__.else;\r\n    const clause: string[] = [];\r\n    if (!$on) {\r\n      clause.push(\"\\nUNLESS CONFLICT\");\r\n    }\r\n    if ($on) {\r\n      clause.push(\r\n        `\\nUNLESS CONFLICT ON ${renderEdgeQL($on, ctx, false, true)}`\r\n      );\r\n    }\r\n    if ($else) {\r\n      clause.push(`\\nELSE (${renderEdgeQL($else, ctx, true, true)})`);\r\n    }\r\n    return `(${renderEdgeQL(expr.__expr__, ctx, false, true).slice(\r\n      1,\r\n      -1\r\n    )}${clause.join(\"\")})`;\r\n  } else if (expr.__kind__ === ExpressionKind.Group) {\r\n    const groupingSet = expr.__modifiers__.by as any as GroupingSet;\r\n    const elementsShape =\r\n      expr.__element__.__shape__.elements.__element__.__shape__;\r\n\r\n    const selectStatement: string[] = [];\r\n    const groupStatement: string[] = [];\r\n\r\n    const groupTarget = renderEdgeQL(expr.__scope__, ctx, false);\r\n    groupStatement.push(`GROUP ${groupTarget}`);\r\n\r\n    // render scoped withvars in using\r\n    const combinedBlock = [\r\n      // ...scopedWithBlock,\r\n      // this is deduplicated in e.group\r\n      ...groupingSet.__exprs__.map(\r\n        ([k, v]) => `  ${k} := ${renderEdgeQL(v, ctx)}`\r\n      ),\r\n    ];\r\n    groupStatement.push(`USING\\n${combinedBlock.join(\",\\n\")}`);\r\n\r\n    let by = renderGroupingSet(groupingSet).trim();\r\n    if (by[0] === \"(\" && by[by.length - 1] === \")\") {\r\n      by = by.slice(1, by.length - 1);\r\n    }\r\n    groupStatement.push(`BY ` + by);\r\n\r\n    // clause.push(withBlock.trim());\r\n\r\n    // render scope var and any unscoped withVars in with block\r\n    const selectTarget = `${groupTarget}_groups`;\r\n    selectStatement.push(\r\n      `WITH\\n${[\r\n        ...unscopedWithBlock,\r\n        ...scopeExprVar,\r\n        // ...scopedWithBlock,\r\n      ].join(\",\\n\")},\r\n  ${selectTarget} := (\r\n${indent(groupStatement.join(\"\\n\"), 4)}\r\n)`\r\n    );\r\n\r\n    // rename scope var to fix all scope references that\r\n    // occur in the `elements` subshape\r\n    const scopeVar = ctx.withVars.get(expr.__scope__ as any);\r\n\r\n    // replace references to __scope__ with\r\n    // .elements reference\r\n    const elementsShapeQuery = indent(\r\n      shapeToEdgeQL(elementsShape as object, { ...ctx }, expr.__element__),\r\n      2\r\n    )\r\n      .trim()\r\n      .split(scopeVar!.name + \".\")\r\n      .join(`${selectTarget}.elements.`);\r\n\r\n    selectStatement.push(`SELECT ${selectTarget} {\r\n  key: {${groupingSet.__exprs__.map((e) => e[0]).join(\", \")}},\r\n  grouping,\r\n  elements: ${elementsShapeQuery}\r\n}`);\r\n    return `(${selectStatement.join(\"\\n\")})`;\r\n  } else if (expr.__kind__ === ExpressionKind.Function) {\r\n    const args = expr.__args__.map(\r\n      (arg) => `${renderEdgeQL(arg!, ctx, false)}`\r\n    );\r\n    for (const [key, arg] of Object.entries(expr.__namedargs__)) {\r\n      args.push(`${q(key)} := ${renderEdgeQL(arg, ctx, false)}`);\r\n    }\r\n    return `${expr.__name__}(${args.join(\", \")})`;\r\n  } else if (expr.__kind__ === ExpressionKind.Operator) {\r\n    const operator = expr.__name__;\r\n    const args = expr.__args__;\r\n    switch (expr.__opkind__) {\r\n      case OperatorKind.Infix:\r\n        if (operator === \"[]\") {\r\n          let index = \"\";\r\n          if (Array.isArray(args[1])) {\r\n            const [start, end] = args[1];\r\n            if (start) {\r\n              index += renderEdgeQL(start, ctx);\r\n            }\r\n            index += \":\";\r\n            if (end) {\r\n              index += renderEdgeQL(end, ctx);\r\n            }\r\n          } else {\r\n            index = renderEdgeQL(args[1]!, ctx);\r\n          }\r\n\r\n          return `${renderEdgeQL(args[0]!, ctx)}[${index}]`;\r\n        }\r\n        return `(${renderEdgeQL(args[0]!, ctx)} ${operator} ${renderEdgeQL(\r\n          args[1]!,\r\n          ctx\r\n        )})`;\r\n      case OperatorKind.Postfix:\r\n        return `(${renderEdgeQL(args[0]!, ctx)} ${operator})`;\r\n      case OperatorKind.Prefix:\r\n        return `(${operator} ${renderEdgeQL(args[0]!, ctx)})`;\r\n      case OperatorKind.Ternary:\r\n        if (operator === \"if_else\") {\r\n          return `(${renderEdgeQL(args[0]!, ctx)} IF ${renderEdgeQL(\r\n            args[1]!,\r\n            ctx\r\n          )} ELSE ${renderEdgeQL(args[2]!, ctx)})`;\r\n        } else {\r\n          throw new Error(`Unknown operator: ${operator}`);\r\n        }\r\n      default:\r\n        util.assertNever(\r\n          expr.__opkind__,\r\n          new Error(`Unknown operator kind: ${expr.__opkind__}`)\r\n        );\r\n    }\r\n  } else if (expr.__kind__ === ExpressionKind.TypeIntersection) {\r\n    return `${renderEdgeQL(expr.__expr__, ctx)}[IS ${\r\n      expr.__element__.__name__\r\n    }]`;\r\n  } else if (expr.__kind__ === ExpressionKind.For) {\r\n    ctx.forVars.set(expr.__forVar__, `__forVar__${ctx.forVars.size}`);\r\n    return `(${withBlock}FOR ${ctx.forVars.get(\r\n      expr.__forVar__\r\n    )} IN {${renderEdgeQL(expr.__iterSet__, ctx)}}\r\nUNION (\\n${indent(renderEdgeQL(expr.__expr__, ctx), 2)}\\n))`;\r\n  } else if (expr.__kind__ === ExpressionKind.ForVar) {\r\n    const forVar = ctx.forVars.get(expr);\r\n    if (!forVar) {\r\n      throw new Error(`'FOR' loop variable used outside of 'FOR' loop`);\r\n    }\r\n    return forVar;\r\n  } else if (expr.__kind__ === ExpressionKind.Param) {\r\n    return `__param__${expr.__name__}`;\r\n  } else if (expr.__kind__ === ExpressionKind.Detached) {\r\n    return `(DETACHED ${renderEdgeQL(\r\n      expr.__expr__,\r\n      {\r\n        ...ctx,\r\n        renderWithVar: expr.__expr__ as any,\r\n      },\r\n      undefined,\r\n      true\r\n    )})`;\r\n  } else if (expr.__kind__ === ExpressionKind.Global) {\r\n    return `(GLOBAL ${expr.__name__})`;\r\n  } else {\r\n    util.assertNever(\r\n      expr,\r\n      new Error(`Unrecognized expression kind: \"${(expr as any).__kind__}\"`)\r\n    );\r\n  }\r\n}\r\n\r\nfunction isGroupingSet(arg: any): arg is GroupingSet {\r\n  return arg.__kind__ === \"groupingset\";\r\n}\r\n\r\n// recursive renderer\r\nfunction renderGroupingSet(set: GroupingSet): string {\r\n  const contents = Object.entries(set.__elements__)\r\n    .map(([k, v]) => {\r\n      return isGroupingSet(v) ? renderGroupingSet(v) : k;\r\n    })\r\n    .join(\", \");\r\n  if (set.__settype__ === \"tuple\") {\r\n    return `(${contents})`;\r\n  } else if (set.__settype__ === \"set\") {\r\n    return `{${contents}}`;\r\n  } else if (set.__settype__ === \"cube\") {\r\n    return `cube(${contents})`;\r\n  } else if (set.__settype__ === \"rollup\") {\r\n    return `rollup(${contents})`;\r\n  } else {\r\n    throw new Error(`Unrecognized set type: \"${set.__settype__}\"`);\r\n  }\r\n}\r\n\r\nfunction shapeToEdgeQL(\r\n  shape: object | null,\r\n  ctx: RenderCtx,\r\n  type: ObjectType | null = null,\r\n  keysOnly: boolean = false,\r\n  injectImplicitId: boolean = true\r\n) {\r\n  const pointers = type?.__pointers__ || null;\r\n  const isFreeObject = type?.__name__ === \"std::FreeObject\";\r\n  if (shape === null) {\r\n    return ``;\r\n  }\r\n\r\n  const lines: string[] = [];\r\n  const addLine = (line: string) =>\r\n    lines.push(`${keysOnly ? \"\" : \"  \"}${line}`);\r\n\r\n  const seen = new Set();\r\n\r\n  for (const key in shape) {\r\n    if (!shape.hasOwnProperty(key)) continue;\r\n    if (seen.has(key)) {\r\n      // tslint:disable-next-line\r\n      console.warn(`Invalid: duplicate key \"${key}\"`);\r\n      continue;\r\n    }\r\n    seen.add(key);\r\n    let val = (shape as any)[key];\r\n    let operator = \":=\";\r\n    let polyType: SomeExpression | null = null;\r\n\r\n    if (typeof val === \"object\" && !val.__element__) {\r\n      if (!!val[\"+=\"]) {\r\n        operator = \"+=\";\r\n        val = val[\"+=\"];\r\n      } else if (!!val[\"-=\"]) {\r\n        operator = \"-=\";\r\n        val = val[\"-=\"];\r\n      }\r\n    }\r\n    if (val.__kind__ === ExpressionKind.PolyShapeElement) {\r\n      polyType = val.__polyType__;\r\n      val = val.__shapeElement__;\r\n    }\r\n    const polyIntersection = polyType\r\n      ? `[IS ${polyType.__element__.__name__}].`\r\n      : \"\";\r\n\r\n    // For computed properties in select shapes, inject the expected\r\n    // cardinality inferred by the query builder. This ensures the actual\r\n    // type returned by the server matches the inferred return type, or an\r\n    // explicit error is thrown, instead of a silent mismatch between\r\n    // actual and inferred type.\r\n    // Add annotations on FreeObjects, despite the existence of a pointer.\r\n    const ptr = pointers?.[key];\r\n    const addCardinalityAnnotations = pointers && (!ptr || isFreeObject);\r\n\r\n    const expectedCardinality =\r\n      addCardinalityAnnotations && val.hasOwnProperty(\"__cardinality__\")\r\n        ? val.__cardinality__ === Cardinality.Many ||\r\n          val.__cardinality__ === Cardinality.AtLeastOne\r\n          ? \"multi \"\r\n          : \"single \"\r\n        : \"\";\r\n\r\n    // if selecting a required multi link, wrap expr in 'assert_exists'\r\n    const wrapAssertExists = ptr?.cardinality === Cardinality.AtLeastOne;\r\n\r\n    if (typeof val === \"boolean\") {\r\n      if (\r\n        !pointers?.[key] &&\r\n        key[0] !== \"@\" &&\r\n        type &&\r\n        type?.__name__ !== \"std::FreeObject\" &&\r\n        !polyIntersection\r\n      ) {\r\n        throw new Error(`Field \"${key}\" does not exist in ${type?.__name__}`);\r\n      }\r\n      if (val) {\r\n        addLine(`${polyIntersection}${q(key)}`);\r\n      }\r\n      continue;\r\n    }\r\n\r\n    if (typeof val !== \"object\") {\r\n      throw new Error(`Invalid shape element at \"${key}\".`);\r\n    }\r\n\r\n    const valIsExpression = val.hasOwnProperty(\"__kind__\");\r\n\r\n    // is subshape\r\n    if (!valIsExpression) {\r\n      addLine(\r\n        `${polyIntersection}${q(key, false)}: ${indent(\r\n          shapeToEdgeQL(val, ctx, ptr?.target),\r\n          2\r\n        ).trim()}`\r\n      );\r\n      continue;\r\n    }\r\n\r\n    // val is expression\r\n\r\n    // is computed\r\n    if (keysOnly) {\r\n      addLine(\r\n        q(key, false) +\r\n          (isObjectType(val.__element__)\r\n            ? `: ${shapeToEdgeQL(val.__element__.__shape__, ctx, null, true)}`\r\n            : \"\")\r\n      );\r\n      continue;\r\n    }\r\n    const renderedExpr = renderEdgeQL(val, ctx);\r\n\r\n    addLine(\r\n      `${expectedCardinality}${q(key, false)} ${operator} ${\r\n        wrapAssertExists ? \"assert_exists(\" : \"\"\r\n      }${\r\n        renderedExpr.includes(\"\\n\")\r\n          ? `(\\n${indent(\r\n              renderedExpr[0] === \"(\" &&\r\n                renderedExpr[renderedExpr.length - 1] === \")\"\r\n                ? renderedExpr.slice(1, -1)\r\n                : renderedExpr,\r\n              4\r\n            )}\\n  )`\r\n          : renderedExpr\r\n      }${wrapAssertExists ? \")\" : \"\"}`\r\n    );\r\n  }\r\n\r\n  if (lines.length === 0 && injectImplicitId) {\r\n    addLine(\"id\");\r\n  }\r\n  return keysOnly ? `{${lines.join(\", \")}}` : `{\\n${lines.join(\",\\n\")}\\n}`;\r\n}\r\n\r\nfunction topoSortWithVars(\r\n  vars: Set<SomeExpression>,\r\n  ctx: RenderCtx\r\n): SomeExpression[] {\r\n  if (!vars.size) {\r\n    return [];\r\n  }\r\n\r\n  const sorted: SomeExpression[] = [];\r\n\r\n  const unvisited = new Set(vars);\r\n  const visiting = new Set<SomeExpression>();\r\n\r\n  for (const withVar of unvisited) {\r\n    visit(withVar);\r\n  }\r\n\r\n  function visit(withVar: SomeExpression): void {\r\n    if (!unvisited.has(withVar)) {\r\n      return;\r\n    }\r\n    if (visiting.has(withVar)) {\r\n      throw new Error(`'WITH' variables contain a cyclic dependency`);\r\n    }\r\n\r\n    visiting.add(withVar);\r\n\r\n    for (const child of ctx.withVars.get(withVar)!.childExprs) {\r\n      if (vars.has(child)) {\r\n        visit(child);\r\n      }\r\n    }\r\n\r\n    visiting.delete(withVar);\r\n    unvisited.delete(withVar);\r\n\r\n    sorted.push(withVar);\r\n  }\r\n  return sorted;\r\n}\r\n\r\nconst numericalTypes: Record<string, boolean> = {\r\n  \"std::number\": true,\r\n  \"std::int16\": true,\r\n  \"std::int32\": true,\r\n  \"std::int64\": true,\r\n  \"std::float32\": true,\r\n  \"std::float64\": true,\r\n};\r\n\r\nfunction literalToEdgeQL(type: BaseType, val: any): string {\r\n  const typename = (type as any).__casttype__?.__name__ ?? type.__name__;\r\n  let skipCast = false;\r\n  let stringRep;\r\n  if (typename === \"std::json\") {\r\n    skipCast = true;\r\n    stringRep = `to_json($$${JSON.stringify(val)}$$)`;\r\n  } else if (typeof val === \"string\") {\r\n    if (numericalTypes[typename]) {\r\n      skipCast = typename === type.__name__;\r\n      stringRep = val;\r\n    } else if (type.__kind__ === TypeKind.enum) {\r\n      skipCast = true;\r\n      const vals = (type as EnumType).__values__;\r\n      if (vals.includes(val)) {\r\n        skipCast = true;\r\n        if (val.includes(\" \")) {\r\n          stringRep = `<${type.__name__}>\"${val}\"`;\r\n        } else {\r\n          stringRep = `${type.__name__}.${q(val)}`;\r\n        }\r\n      } else {\r\n        throw new Error(\r\n          `Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`\r\n        );\r\n      }\r\n    } else {\r\n      if (typename === \"std::str\") {\r\n        skipCast = true;\r\n      }\r\n      stringRep = JSON.stringify(val);\r\n    }\r\n  } else if (typeof val === \"number\") {\r\n    if (numericalTypes[typename]) {\r\n      skipCast = typename === type.__name__;\r\n    } else {\r\n      throw new Error(`Unknown numerical type: ${type.__name__}!`);\r\n    }\r\n    stringRep = `${val.toString()}`;\r\n  } else if (typeof val === \"boolean\") {\r\n    stringRep = `${val.toString()}`;\r\n    skipCast = true;\r\n  } else if (typeof val === \"bigint\") {\r\n    stringRep = `${val.toString()}n`;\r\n  } else if (Array.isArray(val)) {\r\n    skipCast = val.length !== 0;\r\n    if (isArrayType(type)) {\r\n      stringRep = `[${val\r\n        .map((el) => literalToEdgeQL(type.__element__ as any, el))\r\n        .join(\", \")}]`;\r\n    } else if (isTupleType(type)) {\r\n      stringRep = `( ${val\r\n        .map((el, j) => literalToEdgeQL(type.__items__[j] as any, el))\r\n        .join(\", \")}${type.__items__.length === 1 ? \",\" : \"\"} )`;\r\n    } else {\r\n      throw new Error(\r\n        `Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`\r\n      );\r\n    }\r\n  } else if (val instanceof Date) {\r\n    stringRep = `'${val.toISOString()}'`;\r\n  } else if (\r\n    val instanceof LocalDate ||\r\n    val instanceof LocalDateTime ||\r\n    val instanceof LocalTime ||\r\n    val instanceof Duration ||\r\n    val instanceof RelativeDuration ||\r\n    val instanceof DateDuration\r\n  ) {\r\n    stringRep = `'${val.toString()}'`;\r\n  } else if (val instanceof Uint8Array) {\r\n    stringRep = bufferToStringRep(val);\r\n    skipCast = true;\r\n  } else if (val instanceof Float32Array) {\r\n    stringRep = `[${val.join(\",\")}]`;\r\n  } else if (val instanceof Range) {\r\n    const elType = (type as RangeType).__element__;\r\n\r\n    // actual type will be inferred from\r\n    // defined value\r\n    const elTypeName =\r\n      elType.__name__ === \"std::number\" ? \"std::int64\" : elType.__name__;\r\n\r\n    return `std::range(${\r\n      val.lower === null\r\n        ? `<${elTypeName}>{}`\r\n        : literalToEdgeQL(elType, val.lower)\r\n    }, ${\r\n      val.upper === null\r\n        ? `<${elTypeName}>{}`\r\n        : literalToEdgeQL(elType, val.upper)\r\n    }, inc_lower := ${val.incLower}, inc_upper := ${val.incUpper})`;\r\n  } else if (typeof val === \"object\") {\r\n    if (isNamedTupleType(type)) {\r\n      stringRep = `( ${Object.entries(val).map(\r\n        ([key, value]) =>\r\n          `${key} := ${literalToEdgeQL(type.__shape__[key]!, value)}`\r\n      )} )`;\r\n      skipCast = true;\r\n    } else {\r\n      throw new Error(\r\n        `Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`\r\n      );\r\n    }\r\n  } else {\r\n    throw new Error(\r\n      `Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`\r\n    );\r\n  }\r\n  if (skipCast) {\r\n    return stringRep;\r\n  }\r\n  return `<${type.__name__}>${stringRep}`;\r\n}\r\n\r\nfunction indent(str: string, depth: number) {\r\n  return str\r\n    .split(\"\\n\")\r\n    .map((line) => \" \".repeat(depth) + line)\r\n    .join(\"\\n\");\r\n}\r\n\r\n// backtick quote identifiers if needed\r\n// https://github.com/edgedb/edgedb/blob/master/edb/edgeql/quote.py\r\nfunction q(ident: string, allowBacklinks: boolean = true): string {\r\n  if (\r\n    !ident ||\r\n    ident.startsWith(\"@\") ||\r\n    (allowBacklinks && (ident.startsWith(\"<\") || ident.includes(\"::\")))\r\n  ) {\r\n    return ident;\r\n  }\r\n\r\n  const isAlphaNum = /^([^\\W\\d]\\w*|([1-9]\\d*|0))$/.test(ident);\r\n  if (isAlphaNum) {\r\n    const lident = ident.toLowerCase();\r\n    const isReserved =\r\n      lident !== \"__type__\" &&\r\n      lident !== \"__std__\" &&\r\n      reservedKeywords.has(lident);\r\n\r\n    if (!isReserved) {\r\n      return ident;\r\n    }\r\n  }\r\n\r\n  return \"`\" + ident.replace(/`/g, \"``\") + \"`\";\r\n}\r\n\r\nfunction bufferToStringRep(buf: Uint8Array): string {\r\n  let stringRep = \"\";\r\n  for (const byte of buf) {\r\n    if (byte < 32 || byte > 126) {\r\n      // non printable ascii\r\n      switch (byte) {\r\n        case 8:\r\n          stringRep += \"\\\\b\";\r\n          break;\r\n        case 9:\r\n          stringRep += \"\\\\t\";\r\n          break;\r\n        case 10:\r\n          stringRep += \"\\\\n\";\r\n          break;\r\n        case 12:\r\n          stringRep += \"\\\\f\";\r\n          break;\r\n        case 13:\r\n          stringRep += \"\\\\r\";\r\n          break;\r\n        default:\r\n          stringRep += `\\\\x${byte.toString(16).padStart(2, \"0\")}`;\r\n      }\r\n    } else {\r\n      stringRep +=\r\n        (byte === 39 || byte === 92 ? \"\\\\\" : \"\") + String.fromCharCode(byte);\r\n    }\r\n  }\r\n  return `b'${stringRep}'`;\r\n}\r\n\r\nfunction getErrorHint(expr: any): string {\r\n  let literalConstructor: string | null = null;\r\n  switch (typeof expr) {\r\n    case \"string\":\r\n      literalConstructor = \"e.str()\";\r\n      break;\r\n    case \"number\":\r\n      literalConstructor = Number.isInteger(expr) ? \"e.int64()\" : \"e.float64()\";\r\n      break;\r\n    case \"bigint\":\r\n      literalConstructor = \"e.bigint()\";\r\n      break;\r\n    case \"boolean\":\r\n      literalConstructor = \"e.bool()\";\r\n      break;\r\n  }\r\n  switch (true) {\r\n    case expr instanceof Date:\r\n      literalConstructor = \"e.datetime()\";\r\n      break;\r\n    case expr instanceof Duration:\r\n      literalConstructor = \"e.duration()\";\r\n      break;\r\n    case expr instanceof LocalDate:\r\n      literalConstructor = \"e.cal.local_date()\";\r\n      break;\r\n    case expr instanceof LocalDateTime:\r\n      literalConstructor = \"e.cal.local_datetime()\";\r\n      break;\r\n    case expr instanceof LocalTime:\r\n      literalConstructor = \"e.cal.local_time()\";\r\n      break;\r\n    case expr instanceof RelativeDuration:\r\n      literalConstructor = \"e.cal.relative_duration()\";\r\n      break;\r\n    case expr instanceof DateDuration:\r\n      literalConstructor = \"e.cal.date_duration()\";\r\n      break;\r\n  }\r\n\r\n  return literalConstructor\r\n    ? `\\nHint: Maybe you meant to wrap the value in ` +\r\n        `a '${literalConstructor}' expression?`\r\n    : \"\";\r\n}\r\n"},{"path":"typesystem.ts","content":"import type { Executor } from \"edgedb/_src/ifaces.ts\";\r\nimport type { $expr_PathNode, $expr_TypeIntersection, $pathify } from \"./path.ts\";\r\nimport type { $expr_Literal } from \"./literal.ts\";\r\nimport type { $expr_Operator } from \"./funcops.ts\";\r\nimport type {\r\n  typeutil,\r\n  Cardinality,\r\n  ExpressionKind,\r\n} from \"edgedb/_src/reflection/index.ts\";\r\nimport { TypeKind } from \"edgedb/_src/reflection/index.ts\";\r\nimport type { cardutil } from \"./cardinality.ts\";\r\nimport type { Range, MultiRange } from \"edgedb\";\r\n\r\n//////////////////\r\n// BASETYPE\r\n//////////////////\r\n\r\nexport interface BaseType {\r\n  __kind__: TypeKind;\r\n  __name__: string;\r\n}\r\nexport type BaseTypeSet = {\r\n  __element__: BaseType;\r\n  __cardinality__: Cardinality;\r\n};\r\nexport type BaseTypeTuple = typeutil.tupleOf<BaseType>;\r\n\r\n//////////////////\r\n// SCALARTYPE\r\n//////////////////\r\n\r\nexport interface ScalarType<\r\n  Name extends string = string,\r\n  TsType = any,\r\n  TsArgType = TsType,\r\n  TsConstType extends TsType = TsType\r\n> extends BaseType {\r\n  __kind__: TypeKind.scalar;\r\n  __tstype__: TsType;\r\n  __tsargtype__: TsArgType;\r\n  __tsconsttype__: TsConstType;\r\n  __name__: Name;\r\n}\r\n\r\nexport type scalarTypeWithConstructor<\r\n  S extends ScalarType,\r\n  ExtraTsTypes = never\r\n> = S & {\r\n  // tslint:disable-next-line\r\n  <T extends S[\"__tstype__\"] | ExtraTsTypes>(val: T): $expr_Literal<\r\n    Omit<S, \"__tsconsttype__\"> & {\r\n      __tsconsttype__: T extends S[\"__tstype__\"] ? T : S[\"__tstype__\"];\r\n    }\r\n  >;\r\n};\r\n\r\ntype $jsonDestructure<Set extends TypeSet> =\r\n  Set[\"__element__\"] extends ScalarType<\"std::json\">\r\n    ? {\r\n        [path: string]: $expr_Operator<\r\n          // \"[]\",\r\n          // OperatorKind.Infix,\r\n          // [Set, TypeSet],\r\n          // TypeSet<\r\n          Set[\"__element__\"],\r\n          Set[\"__cardinality__\"]\r\n          // >\r\n        >;\r\n      } & {\r\n        destructure<T extends TypeSet<ScalarType<\"std::str\">> | string>(\r\n          path: T\r\n        ): $expr_Operator<\r\n          // \"[]\",\r\n          // OperatorKind.Infix,\r\n          // [Set, TypeSet],\r\n          // TypeSet<\r\n          Set[\"__element__\"],\r\n          cardutil.multiplyCardinalities<\r\n            Set[\"__cardinality__\"],\r\n            T extends TypeSet ? T[\"__cardinality__\"] : Cardinality.One\r\n          >\r\n          // >\r\n        >;\r\n      }\r\n    : unknown;\r\n\r\n////////////////////\r\n// SETS AND EXPRESSIONS\r\n////////////////////\r\n\r\nexport interface TypeSet<\r\n  T extends BaseType = BaseType,\r\n  Card extends Cardinality = Cardinality\r\n> {\r\n  __element__: T;\r\n  __cardinality__: Card;\r\n}\r\n\r\n// utility function for creating set\r\nexport function $toSet<Root extends BaseType, Card extends Cardinality>(\r\n  root: Root,\r\n  card: Card\r\n): TypeSet<Root, Card> {\r\n  return {\r\n    __element__: root,\r\n    __cardinality__: card,\r\n  };\r\n}\r\n\r\nexport type Expression<\r\n  Set extends TypeSet = TypeSet,\r\n  Runnable extends boolean = true\r\n> = Set &\r\n  (BaseType extends Set[\"__element__\"] // short-circuit non-specific types\r\n    ? {\r\n        run(cxn: Executor): any;\r\n        runJSON(cxn: Executor): any;\r\n        toEdgeQL(): string;\r\n        is: any;\r\n        assert_single: any;\r\n        // warning: any;\r\n      }\r\n    : $pathify<Set> &\r\n        ExpressionMethods<stripSet<Set>> &\r\n        (Runnable extends true\r\n          ? {\r\n              run(cxn: Executor): Promise<setToTsType<Set>>;\r\n              runJSON(cxn: Executor): Promise<string>;\r\n            }\r\n          : {}) &\r\n        $tuplePathify<Set> &\r\n        $arrayLikeIndexify<Set> &\r\n        $jsonDestructure<Set>);\r\n\r\nexport type stripSet<T> = \"__element__\" extends keyof T\r\n  ? \"__cardinality__\" extends keyof T\r\n    ? {\r\n        __element__: T[\"__element__\"];\r\n        __cardinality__: T[\"__cardinality__\"];\r\n      }\r\n    : T\r\n  : T;\r\n\r\n// export type stripSet<T> = T extends {__element__: any; __cardinality__: any}\r\n//   ? {\r\n//       __element__: T[\"__element__\"];\r\n//       __cardinality__: T[\"__cardinality__\"];\r\n//     }\r\n//   : any;\r\n\r\nexport type stripSetShape<T> = {\r\n  [k in keyof T]: stripSet<T[k]>;\r\n};\r\n\r\n// importing the actual alias from\r\n// generated/modules/std didn't work.\r\n// returned 'any' every time\r\nexport type assert_single<\r\n  El extends BaseType,\r\n  Card extends Cardinality\r\n> = Expression<{\r\n  __element__: El; // [\"__element__\"];\r\n  __cardinality__: Card; // cardutil.overrideUpperBound<\r\n  // Expr[\"__cardinality__\"], \"One\"\r\n  // >;\r\n  __kind__: ExpressionKind.Function;\r\n  __name__: \"std::assert_single\";\r\n  __args__: TypeSet[]; // discard wrapped expression\r\n  __namedargs__: {};\r\n}>;\r\n\r\nexport type ExpressionMethods<Set extends TypeSet> = {\r\n  toEdgeQL(): string;\r\n\r\n  is<T extends ObjectTypeSet>(\r\n    ixn: T\r\n  ): $expr_TypeIntersection<\r\n    Set[\"__cardinality__\"],\r\n    // might cause performance issues\r\n    ObjectType<\r\n      T[\"__element__\"][\"__name__\"],\r\n      T[\"__element__\"][\"__pointers__\"],\r\n      { id: true }\r\n    >\r\n  >;\r\n  assert_single(): assert_single<\r\n    Set[\"__element__\"],\r\n    Cardinality.AtMostOne\r\n    // cardutil.overrideUpperBound<Set[\"__cardinality__\"], \"One\">\r\n  >;\r\n};\r\n\r\n//////////////////\r\n// ENUMTYPE\r\n//////////////////\r\nexport interface EnumType<\r\n  Name extends string = string,\r\n  Values extends [string, ...string[]] = [string, ...string[]]\r\n> extends BaseType {\r\n  __kind__: TypeKind.enum;\r\n  __tstype__: Values[number];\r\n  __name__: Name;\r\n  __values__: Values;\r\n}\r\n\r\n//////////////////\r\n// OBJECTTYPE\r\n//////////////////\r\n\r\nexport type ObjectTypeSet = TypeSet<ObjectType, Cardinality>;\r\nexport type ObjectTypeExpression = TypeSet<ObjectType, Cardinality>;\r\n\r\nexport type ExclusiveTuple = typeutil.tupleOf<{\r\n  [k: string]: TypeSet;\r\n}>;\r\nexport interface ObjectType<\r\n  Name extends string = string,\r\n  Pointers extends ObjectTypePointers = ObjectTypePointers,\r\n  Shape extends object | null = any,\r\n  Exclusives extends ExclusiveTuple = ExclusiveTuple\r\n  // Polys extends Poly[] = any[]\r\n> extends BaseType {\r\n  __kind__: TypeKind.object;\r\n  __name__: Name;\r\n  __pointers__: Pointers;\r\n  __shape__: Shape;\r\n  __exclusives__: Exclusives;\r\n}\r\n\r\nexport type PropertyTypes =\r\n  | ScalarType\r\n  | EnumType\r\n  | ArrayType\r\n  | TupleType\r\n  | NamedTupleType;\r\n\r\nexport type SomeType =\r\n  | ScalarType\r\n  | EnumType\r\n  | ArrayType\r\n  | TupleType\r\n  | ObjectType\r\n  | NamedTupleType\r\n  | RangeType\r\n  | MultiRangeType;\r\n\r\nexport interface PropertyDesc<\r\n  Type extends BaseType = BaseType,\r\n  Card extends Cardinality = Cardinality,\r\n  Exclusive extends boolean = boolean,\r\n  Computed extends boolean = boolean,\r\n  Readonly extends boolean = boolean,\r\n  HasDefault extends boolean = boolean\r\n> {\r\n  __kind__: \"property\";\r\n  target: Type;\r\n  cardinality: Card;\r\n  exclusive: Exclusive;\r\n  computed: Computed;\r\n  readonly: Readonly;\r\n  hasDefault: HasDefault;\r\n}\r\n\r\nexport type $scopify<Type extends ObjectType> = $expr_PathNode<\r\n  TypeSet<Type, Cardinality.One>\r\n  // null,\r\n  // true // exclusivity\r\n>;\r\n\r\nexport type PropertyShape = {\r\n  [k: string]: PropertyDesc;\r\n};\r\n\r\nexport interface LinkDesc<\r\n  Type extends ObjectType = any,\r\n  Card extends Cardinality = Cardinality,\r\n  LinkProps extends PropertyShape = any,\r\n  Exclusive extends boolean = boolean,\r\n  Computed extends boolean = boolean,\r\n  Readonly extends boolean = boolean,\r\n  HasDefault extends boolean = boolean\r\n> {\r\n  __kind__: \"link\";\r\n  target: Type;\r\n  cardinality: Card;\r\n  properties: LinkProps;\r\n  exclusive: Exclusive;\r\n  computed: Computed;\r\n  readonly: Readonly;\r\n  hasDefault: HasDefault;\r\n}\r\n\r\nexport type ObjectTypePointers = {\r\n  [k: string]: PropertyDesc | LinkDesc;\r\n};\r\n\r\nexport type stripBacklinks<T extends ObjectTypePointers> = {\r\n  [k in keyof T]: k extends `<${string}` ? never : T[k];\r\n};\r\n\r\nexport type omitBacklinks<T extends string | number | symbol> =\r\n  T extends `<${string}` ? never : T extends string ? T : never;\r\n\r\nexport type stripNonUpdateables<T extends ObjectTypePointers> = {\r\n  [k in keyof T]: [T[k][\"computed\"]] extends [true]\r\n    ? never\r\n    : [T[k][\"readonly\"]] extends [true]\r\n    ? never\r\n    : k extends \"__type__\"\r\n    ? never\r\n    : k extends \"id\"\r\n    ? never\r\n    : T[k];\r\n};\r\n\r\nexport type stripNonInsertables<T extends ObjectTypePointers> = {\r\n  [k in keyof T]: [T[k][\"computed\"]] extends [true]\r\n    ? never\r\n    : [k] extends [\"__type__\"]\r\n    ? never\r\n    : T[k];\r\n};\r\n\r\ntype shapeElementToTs<Pointer extends PropertyDesc | LinkDesc, Element> = [\r\n  Element\r\n] extends [true]\r\n  ? pointerToTsType<Pointer>\r\n  : [Element] extends [false]\r\n  ? never\r\n  : [Element] extends [boolean]\r\n  ? pointerToTsType<Pointer> | undefined\r\n  : Element extends TypeSet\r\n  ? setToTsType<TypeSet<Element[\"__element__\"], Pointer[\"cardinality\"]>>\r\n  : Pointer extends LinkDesc\r\n  ? Element extends object\r\n    ? computeTsTypeCard<\r\n        computeObjectShape<\r\n          Pointer[\"target\"][\"__pointers__\"] & Pointer[\"properties\"],\r\n          Element\r\n        >,\r\n        Pointer[\"cardinality\"]\r\n      >\r\n    : never\r\n  : never;\r\n\r\n// Element extends (scope: any) => any\r\n// ? Pointer[\"target\"] extends ObjectType\r\n//   ? computeObjectShape<\r\n//       Pointer[\"target\"][\"__pointers__\"],\r\n//       ReturnType<Element>\r\n//     >\r\n//   : never\r\n// : Element extends object\r\n// ? Pointer[\"target\"] extends ObjectType\r\n//   ? computeObjectShape<Pointer[\"target\"][\"__pointers__\"], Element>\r\n//   : never\r\n// : never;\r\n\r\nexport type $expr_PolyShapeElement<\r\n  PolyType extends ObjectTypeSet = ObjectTypeSet,\r\n  ShapeElement extends any = any\r\n> = {\r\n  __kind__: ExpressionKind.PolyShapeElement;\r\n  __polyType__: PolyType;\r\n  __shapeElement__: ShapeElement;\r\n};\r\n\r\nexport type computeObjectShape<\r\n  Pointers extends ObjectTypePointers,\r\n  Shape\r\n> = typeutil.flatten<\r\n  keyof Shape extends never\r\n    ? { id: string }\r\n    : {\r\n        [k in keyof Shape]: Shape[k] extends $expr_PolyShapeElement<\r\n          infer PolyType,\r\n          infer ShapeEl\r\n        >\r\n          ? [k] extends [keyof PolyType[\"__element__\"][\"__pointers__\"]]\r\n            ? shapeElementToTs<\r\n                PolyType[\"__element__\"][\"__pointers__\"][k],\r\n                ShapeEl\r\n              > | null\r\n            : never\r\n          : [k] extends [keyof Pointers]\r\n          ? shapeElementToTs<Pointers[k], Shape[k]>\r\n          : Shape[k] extends TypeSet\r\n          ? setToTsType<Shape[k]>\r\n          : never;\r\n      }\r\n>;\r\n\r\nexport type pointerToTsTypeSimple<El extends PropertyDesc | LinkDesc> =\r\n  El extends PropertyDesc\r\n    ? propToTsType<El>\r\n    : El extends LinkDesc<any, any, any, any>\r\n    ? { id: string }\r\n    : never;\r\n\r\nexport type PrimitiveType =\r\n  | ScalarType\r\n  | EnumType\r\n  | TupleType\r\n  | NamedTupleType\r\n  | ArrayType\r\n  | RangeType\r\n  | MultiRangeType;\r\n\r\nexport type PrimitiveTypeSet = TypeSet<PrimitiveType, Cardinality>;\r\n\r\n/////////////////////////\r\n/// ARRAYTYPE\r\n/////////////////////////\r\n\r\ntype $arrayLikeIndexify<Set extends TypeSet> = Set[\"__element__\"] extends\r\n  | ArrayType\r\n  | ScalarType<\"std::str\">\r\n  | ScalarType<\"std::bytes\">\r\n  ? {\r\n      [index: number]: $expr_Operator<\r\n        // \"[]\",\r\n        // OperatorKind.Infix,\r\n        // [Set, TypeSet],\r\n        // TypeSet<\r\n        getPrimitiveBaseType<\r\n          Set[\"__element__\"] extends ArrayType<infer El>\r\n            ? El\r\n            : Set[\"__element__\"]\r\n        >,\r\n        Set[\"__cardinality__\"]\r\n        // >\r\n      >;\r\n      [slice: `${number}:${number | \"\"}` | `:${number}`]: $expr_Operator<\r\n        // \"[]\",\r\n        // OperatorKind.Infix,\r\n        // [Set, TypeSet],\r\n        // TypeSet<\r\n        getPrimitiveBaseType<Set[\"__element__\"]>,\r\n        Set[\"__cardinality__\"]\r\n        // >\r\n      >;\r\n      index<T extends TypeSet<ScalarType<\"std::number\">> | number>(\r\n        index: T\r\n      ): $expr_Operator<\r\n        // \"[]\",\r\n        // OperatorKind.Infix,\r\n        // [Set, TypeSet],\r\n        // TypeSet<\r\n        getPrimitiveBaseType<\r\n          Set[\"__element__\"] extends ArrayType<infer El>\r\n            ? El\r\n            : Set[\"__element__\"]\r\n        >,\r\n        cardutil.multiplyCardinalities<\r\n          Set[\"__cardinality__\"],\r\n          T extends TypeSet ? T[\"__cardinality__\"] : Cardinality.One\r\n        >\r\n        // >\r\n      >;\r\n      slice<\r\n        S extends TypeSet<ScalarType<\"std::number\">> | number,\r\n        E extends TypeSet<ScalarType<\"std::number\">> | number | undefined | null\r\n      >(\r\n        start: S,\r\n        end: E\r\n      ): $expr_Operator<\r\n        // \"[]\",\r\n        // OperatorKind.Infix,\r\n        // [Set, TypeSet],\r\n        // TypeSet<\r\n        getPrimitiveBaseType<Set[\"__element__\"]>,\r\n        cardutil.multiplyCardinalities<\r\n          cardutil.multiplyCardinalities<\r\n            Set[\"__cardinality__\"],\r\n            S extends TypeSet ? S[\"__cardinality__\"] : Cardinality.One\r\n          >,\r\n          E extends TypeSet<any, infer C> ? C : Cardinality.One\r\n        >\r\n        // >\r\n      >;\r\n      slice<\r\n        E extends TypeSet<ScalarType<\"std::number\">> | number | undefined | null\r\n      >(\r\n        start: undefined | null,\r\n        end: E\r\n      ): $expr_Operator<\r\n        // \"[]\",\r\n        // OperatorKind.Infix,\r\n        // [Set, TypeSet],\r\n        // TypeSet<\r\n        getPrimitiveBaseType<Set[\"__element__\"]>,\r\n        cardutil.multiplyCardinalities<\r\n          Set[\"__cardinality__\"],\r\n          E extends TypeSet<any, infer C> ? C : Cardinality.One\r\n        >\r\n        // >\r\n      >;\r\n    }\r\n  : unknown;\r\n\r\nexport type $expr_Array<\r\n  Type extends ArrayType = ArrayType,\r\n  Card extends Cardinality = Cardinality\r\n  // Items extends typeutil.tupleOf<TypeSet<Type>>\r\n> = Expression<{\r\n  __kind__: ExpressionKind.Array;\r\n  __items__: typeutil.tupleOf<TypeSet<Type[\"__element__\"]>>;\r\n  __element__: Type;\r\n  __cardinality__: Card;\r\n}>;\r\n\r\nexport interface ArrayType<\r\n  Element extends BaseType = BaseType,\r\n  Name extends string = `array<${Element[\"__name__\"]}>`\r\n> extends BaseType {\r\n  __name__: Name;\r\n  __kind__: TypeKind.array;\r\n  __element__: Element;\r\n}\r\n\r\ntype ArrayTypeToTsType<\r\n  Type extends ArrayType,\r\n  isParam extends boolean = false\r\n> = BaseTypeToTsType<Type[\"__element__\"], isParam>[];\r\n\r\n/////////////////////////\r\n/// TUPLE TYPE\r\n/////////////////////////\r\n\r\ntype $tuplePathify<Set extends TypeSet> = Set[\"__element__\"] extends TupleType\r\n  ? addTuplePaths<Set[\"__element__\"][\"__items__\"], Set[\"__cardinality__\"]>\r\n  : Set[\"__element__\"] extends NamedTupleType\r\n  ? addNamedTuplePaths<Set[\"__element__\"][\"__shape__\"], Set[\"__cardinality__\"]>\r\n  : unknown;\r\n\r\nexport type $expr_TuplePath<\r\n  ItemType extends BaseType = BaseType,\r\n  ParentCard extends Cardinality = Cardinality\r\n> = Expression<{\r\n  __kind__: ExpressionKind.TuplePath;\r\n  __element__: ItemType;\r\n  __cardinality__: ParentCard;\r\n  __parent__: $expr_Tuple | $expr_NamedTuple | $expr_TuplePath;\r\n  __index__: string | number;\r\n}>;\r\n\r\nexport type baseTupleElementsToTupleType<T extends typeutil.tupleOf<TypeSet>> =\r\n  {\r\n    [k in keyof T]: T[k] extends TypeSet\r\n      ? getPrimitiveBaseType<T[k][\"__element__\"]>\r\n      : never;\r\n  };\r\nexport type tupleElementsToTupleType<T extends typeutil.tupleOf<TypeSet>> =\r\n  baseTupleElementsToTupleType<T> extends BaseTypeTuple\r\n    ? TupleType<baseTupleElementsToTupleType<T>>\r\n    : never;\r\n\r\nexport type baseTupleElementsToCardTuple<T> = {\r\n  [k in keyof T]: T[k] extends TypeSet<any, infer C> ? C : never;\r\n};\r\n\r\nexport type tupleElementsToCardTuple<T> =\r\n  baseTupleElementsToCardTuple<T> extends [Cardinality, ...Cardinality[]]\r\n    ? baseTupleElementsToCardTuple<T>\r\n    : never;\r\n\r\nexport type $expr_Tuple<\r\n  Items extends typeutil.tupleOf<TypeSet> = typeutil.tupleOf<TypeSet>\r\n> = Expression<{\r\n  __kind__: ExpressionKind.Tuple;\r\n  __items__: typeutil.tupleOf<TypeSet>;\r\n  __element__: tupleElementsToTupleType<Items>;\r\n  __cardinality__: cardutil.multiplyCardinalitiesVariadic<\r\n    tupleElementsToCardTuple<Items>\r\n  >;\r\n}>;\r\n\r\nexport type indexKeys<T> = T extends `${number}` ? T : never;\r\n\r\ntype addTuplePaths<Items extends BaseType[], ParentCard extends Cardinality> = {\r\n  [k in indexKeys<keyof Items>]: Items[k] extends BaseType\r\n    ? $expr_TuplePath<Items[k], ParentCard>\r\n    : never;\r\n};\r\n\r\nexport interface TupleType<Items extends BaseTypeTuple = BaseTypeTuple>\r\n  extends BaseType {\r\n  __name__: string;\r\n  __kind__: TypeKind.tuple;\r\n  __items__: Items;\r\n}\r\n\r\ntype TupleItemsToTsType<\r\n  Items extends BaseTypeTuple,\r\n  isParam extends boolean = false\r\n> = {\r\n  [k in keyof Items]: Items[k] extends BaseType\r\n    ? BaseTypeToTsType<Items[k], isParam>\r\n    : never;\r\n};\r\n\r\n/////////////////////////\r\n/// NAMED TUPLE TYPE\r\n/////////////////////////\r\ntype literalShapeToType<T extends NamedTupleLiteralShape> = NamedTupleType<{\r\n  [k in keyof T]: getPrimitiveBaseType<T[k][\"__element__\"]>;\r\n}>;\r\ntype shapeCardinalities<Shape extends NamedTupleLiteralShape> =\r\n  Shape[keyof Shape][\"__cardinality__\"];\r\ntype inferNamedTupleCardinality<Shape extends NamedTupleLiteralShape> = [\r\n  Cardinality.Many\r\n] extends [shapeCardinalities<Shape>]\r\n  ? Cardinality.Many\r\n  : [Cardinality.Empty] extends [shapeCardinalities<Shape>]\r\n  ? Cardinality.Empty\r\n  : [shapeCardinalities<Shape>] extends [Cardinality.AtMostOne]\r\n  ? Cardinality.AtMostOne\r\n  : [shapeCardinalities<Shape>] extends [\r\n      Cardinality.AtMostOne | Cardinality.One\r\n    ]\r\n  ? Cardinality.One\r\n  : Cardinality.Many;\r\n\r\nexport type $expr_NamedTuple<\r\n  Shape extends NamedTupleLiteralShape = NamedTupleLiteralShape\r\n> = Expression<{\r\n  __kind__: ExpressionKind.NamedTuple;\r\n  __element__: literalShapeToType<Shape>;\r\n  __cardinality__: inferNamedTupleCardinality<Shape>;\r\n  __shape__: Shape;\r\n}>;\r\n\r\ntype addNamedTuplePaths<\r\n  Shape extends NamedTupleShape,\r\n  ParentCard extends Cardinality\r\n> = {\r\n  [k in keyof Shape]: Shape[k] extends BaseType\r\n    ? $expr_TuplePath<Shape[k], ParentCard>\r\n    : never;\r\n};\r\n\r\nexport type NamedTupleLiteralShape = { [k: string]: TypeSet };\r\nexport type NamedTupleShape = { [k: string]: BaseType };\r\nexport interface NamedTupleType<Shape extends NamedTupleShape = NamedTupleShape>\r\n  extends BaseType {\r\n  __name__: string;\r\n  __kind__: TypeKind.namedtuple;\r\n  __shape__: Shape;\r\n}\r\n\r\ntype NamedTupleTypeToTsType<\r\n  Type extends NamedTupleType,\r\n  isParam extends boolean = false\r\n> = {\r\n  [k in keyof Type[\"__shape__\"]]: BaseTypeToTsType<\r\n    Type[\"__shape__\"][k],\r\n    isParam\r\n  >;\r\n};\r\n\r\n/////////////////////////\r\n/// RANGE TYPE\r\n/////////////////////////\r\n\r\nexport interface RangeType<\r\n  Element extends ScalarType = ScalarType,\r\n  Name extends string = `range<${Element[\"__name__\"]}>`\r\n> extends BaseType {\r\n  __name__: Name;\r\n  __kind__: TypeKind.range;\r\n  __element__: Element;\r\n}\r\n\r\n/////////////////////////\r\n/// MULTIRANGE TYPE\r\n/////////////////////////\r\n\r\nexport interface MultiRangeType<\r\n  Element extends ScalarType = ScalarType,\r\n  Name extends string = `multirange<${Element[\"__name__\"]}>`\r\n> extends BaseType {\r\n  __name__: Name;\r\n  __kind__: TypeKind.multirange;\r\n  __element__: Element;\r\n}\r\n\r\n/////////////////////\r\n/// TSTYPE COMPUTATION\r\n/////////////////////\r\nexport type orLiteralValue<Set extends TypeSet> =\r\n  | Set\r\n  | (Set[\"__element__\"] extends ObjectType\r\n      ? never\r\n      : computeTsType<Set[\"__element__\"], Set[\"__cardinality__\"]>);\r\n\r\nexport type BaseTypeToTsType<\r\n  Type extends BaseType,\r\n  isParam extends boolean = false\r\n> = Type extends ScalarType\r\n  ? isParam extends true\r\n    ? Type[\"__tsargtype__\"]\r\n    : Type[\"__tsconsttype__\"]\r\n  : Type extends EnumType\r\n  ? Type[\"__tstype__\"]\r\n  : Type extends ArrayType<any>\r\n  ? ArrayTypeToTsType<Type, isParam>\r\n  : Type extends RangeType\r\n  ? Range<Type[\"__element__\"][\"__tsconsttype__\"]>\r\n  : Type extends MultiRangeType\r\n  ? MultiRange<Type[\"__element__\"][\"__tsconsttype__\"]>\r\n  : Type extends TupleType\r\n  ? TupleItemsToTsType<Type[\"__items__\"], isParam>\r\n  : Type extends NamedTupleType\r\n  ? typeutil.flatten<NamedTupleTypeToTsType<Type, isParam>>\r\n  : Type extends ObjectType\r\n  ? typeutil.flatten<\r\n      computeObjectShape<Type[\"__pointers__\"], Type[\"__shape__\"]>\r\n    >\r\n  : never;\r\n\r\nexport type setToTsType<Set extends TypeSet> = computeTsType<\r\n  Set[\"__element__\"],\r\n  Set[\"__cardinality__\"]\r\n>;\r\n\r\nexport type computeTsTypeCard<\r\n  T extends any,\r\n  C extends Cardinality\r\n> = Cardinality extends C\r\n  ? unknown\r\n  : C extends Cardinality.Empty\r\n  ? null\r\n  : C extends Cardinality.One\r\n  ? T\r\n  : C extends Cardinality.AtLeastOne\r\n  ? [T, ...T[]]\r\n  : C extends Cardinality.AtMostOne\r\n  ? T | null\r\n  : C extends Cardinality.Many\r\n  ? T[]\r\n  : C extends Cardinality\r\n  ? unknown\r\n  : never;\r\n\r\nexport type computeTsType<\r\n  T extends BaseType,\r\n  C extends Cardinality\r\n> = BaseType extends T ? unknown : computeTsTypeCard<BaseTypeToTsType<T>, C>;\r\n\r\nexport type propToTsType<Prop extends PropertyDesc> = Prop extends PropertyDesc<\r\n  infer Type,\r\n  infer Card\r\n>\r\n  ? setToTsType<TypeSet<Type, Card>>\r\n  : never;\r\n\r\nexport type linkToTsType<Link extends LinkDesc> = computeTsType<\r\n  Link[\"target\"],\r\n  Link[\"cardinality\"]\r\n>;\r\n\r\nexport type pointerToTsType<El extends PropertyDesc | LinkDesc> =\r\n  El extends PropertyDesc\r\n    ? propToTsType<El>\r\n    : El extends LinkDesc<any, any, any, any>\r\n    ? linkToTsType<El>\r\n    : never;\r\n\r\n///////////////////\r\n// TYPE HELPERS\r\n///////////////////\r\n\r\nexport type getPrimitiveBaseType<T extends BaseType> = T extends ScalarType\r\n  ? ScalarType<T[\"__name__\"], T[\"__tstype__\"], T[\"__tsargtype__\"]>\r\n  : T;\r\n\r\nexport type getPrimitiveNonArrayBaseType<T extends BaseType> =\r\n  T extends ArrayType ? never : getPrimitiveBaseType<T>;\r\n\r\nexport function isScalarType(type: BaseType): type is ScalarType {\r\n  return type.__kind__ === TypeKind.scalar;\r\n}\r\nexport function isEnumType(type: BaseType): type is EnumType {\r\n  return type.__kind__ === TypeKind.enum;\r\n}\r\nexport function isObjectType(type: BaseType): type is ObjectType {\r\n  return type.__kind__ === TypeKind.object;\r\n}\r\nexport function isTupleType(type: BaseType): type is TupleType {\r\n  return type.__kind__ === TypeKind.tuple;\r\n}\r\nexport function isNamedTupleType(type: BaseType): type is NamedTupleType {\r\n  return type.__kind__ === TypeKind.namedtuple;\r\n}\r\nexport function isArrayType(type: BaseType): type is ArrayType {\r\n  return type.__kind__ === TypeKind.array;\r\n}\r\n\r\nexport type NonArrayType =\r\n  | ScalarType\r\n  | EnumType\r\n  | ObjectType\r\n  | TupleType\r\n  | NamedTupleType\r\n  | RangeType\r\n  | MultiRangeType;\r\n\r\nexport type AnyTupleType = TupleType | NamedTupleType;\r\n\r\nexport type AnyObjectType = ObjectType;\r\n\r\nexport type ParamType =\r\n  | ScalarType\r\n  | EnumType\r\n  | ArrayType<\r\n      | ScalarType\r\n      | TupleType<typeutil.tupleOf<ParamType>>\r\n      | NamedTupleType<{ [k: string]: ParamType }>\r\n      | RangeType\r\n      | MultiRangeType\r\n    >\r\n  | TupleType<typeutil.tupleOf<ParamType>>\r\n  | NamedTupleType<{ [k: string]: ParamType }>\r\n  | RangeType\r\n  | MultiRangeType;\r\n"},{"path":"update.ts","content":"import {\r\n  ExpressionKind,\r\n  type typeutil,\r\n  Cardinality,\r\n} from \"edgedb/_src/reflection/index.ts\";\r\nimport type {\r\n  Expression,\r\n  ObjectTypePointers,\r\n  TypeSet,\r\n  ObjectTypeSet,\r\n  stripBacklinks,\r\n  stripNonUpdateables,\r\n  ObjectTypeExpression,\r\n  ObjectType,\r\n  $scopify,\r\n} from \"./typesystem.ts\";\r\nimport type { pointerToAssignmentExpression } from \"./casting.ts\";\r\nimport { $expressionify, $getScopedExpr, $assert_single } from \"./path.ts\";\r\nimport {\r\n  type SelectModifiers,\r\n  type NormalisedSelectModifiers,\r\n  type ComputeSelectCardinality,\r\n  $existingScopes,\r\n  $handleModifiers,\r\n} from \"./select.ts\";\r\nimport { $normaliseInsertShape, type pointerIsOptional } from \"./insert.ts\";\r\n\r\n/////////////////\r\n/// UPDATE\r\n/////////////////\r\n\r\nexport type $expr_Update<\r\n  El extends ObjectType = ObjectType,\r\n  Card extends Cardinality = Cardinality\r\n  // Set extends TypeSet = TypeSet,\r\n  // Expr extends ObjectTypeSet = ObjectTypeSet,\r\n  // Shape extends UpdateShape<ObjectTypeSet> = any\r\n> = Expression<{\r\n  __kind__: ExpressionKind.Update;\r\n  __element__: El;\r\n  __cardinality__: Card;\r\n  __expr__: TypeSet;\r\n  __shape__: any;\r\n  __modifiers__: NormalisedSelectModifiers;\r\n  __scope__: ObjectTypeExpression;\r\n}>;\r\n\r\nexport type UpdateShape<Root extends ObjectTypeSet> = typeutil.stripNever<\r\n  stripNonUpdateables<stripBacklinks<Root[\"__element__\"][\"__pointers__\"]>>\r\n> extends infer Shape\r\n  ? Shape extends ObjectTypePointers\r\n    ? {\r\n        [k in keyof Shape]?:\r\n          | (\r\n              | pointerToAssignmentExpression<Shape[k]>\r\n              | (Shape[k][\"cardinality\"] extends\r\n                  | Cardinality.Many\r\n                  | Cardinality.AtLeastOne\r\n                  ?\r\n                      | { \"+=\": pointerToAssignmentExpression<Shape[k], true> }\r\n                      | { \"-=\": pointerToAssignmentExpression<Shape[k], true> }\r\n                  : never)\r\n            )\r\n          | (pointerIsOptional<Shape[k]> extends true\r\n              ? undefined | null\r\n              : never);\r\n      }\r\n    : never\r\n  : never;\r\n\r\nexport function update<\r\n  Expr extends ObjectTypeExpression,\r\n  Shape extends {\r\n    filter?: SelectModifiers[\"filter\"];\r\n    filter_single?: SelectModifiers<Expr[\"__element__\"]>[\"filter_single\"];\r\n    set: UpdateShape<Expr>;\r\n  }\r\n  // SetShape extends UpdateShape<Expr>,\r\n  // Modifiers extends Pick<SelectModifiers, \"filter\">\r\n>(\r\n  expr: Expr,\r\n  shape: (scope: $scopify<Expr[\"__element__\"]>) => Readonly<Shape>\r\n): $expr_Update<Expr[\"__element__\"], ComputeSelectCardinality<Expr, Shape>> {\r\n  const cleanScopedExprs = $existingScopes.size === 0;\r\n\r\n  const scope = $getScopedExpr(expr as any, $existingScopes);\r\n\r\n  const resolvedShape = shape(scope);\r\n\r\n  if (cleanScopedExprs) {\r\n    $existingScopes.clear();\r\n  }\r\n\r\n  const mods: any = {};\r\n  let updateShape: any | null;\r\n  for (const [key, val] of Object.entries(resolvedShape)) {\r\n    if (key === \"filter\" || key === \"filter_single\") {\r\n      mods[key] = val;\r\n    } else if (key === \"set\") {\r\n      updateShape = val;\r\n    } else {\r\n      throw new Error(\r\n        `Invalid update shape key '${key}', only 'filter', 'filter_single', ` +\r\n          `and 'set' are allowed`\r\n      );\r\n    }\r\n  }\r\n\r\n  if (!updateShape) {\r\n    throw new Error(`Update shape must contain 'set' shape`);\r\n  }\r\n\r\n  const { modifiers, cardinality, needsAssertSingle } = $handleModifiers(mods, {\r\n    root: expr,\r\n    scope,\r\n  });\r\n\r\n  const updateExpr = {\r\n    __kind__: ExpressionKind.Update,\r\n    __element__: expr.__element__,\r\n    __cardinality__: cardinality,\r\n    __expr__: expr,\r\n    __shape__: $normaliseInsertShape(expr, updateShape, true),\r\n    __modifiers__: modifiers,\r\n    __scope__: scope,\r\n  } as any;\r\n\r\n  return needsAssertSingle\r\n    ? $assert_single(updateExpr)\r\n    : $expressionify(updateExpr);\r\n}\r\n"},{"path":"with.ts","content":"import { ExpressionKind, Cardinality } from \"edgedb/_src/reflection/index.ts\";\r\nimport type { BaseType, Expression, TypeSet } from \"./typesystem.ts\";\r\nimport type { $expr_Select } from \"./select.ts\";\r\nimport type { $expr_For } from \"./for.ts\";\r\nimport type { $expr_Insert } from \"./insert.ts\";\r\nimport type { $expr_Update } from \"./update.ts\";\r\nimport type { $expr_Group } from \"./group.ts\";\r\nimport { $expressionify } from \"./path.ts\";\r\n\r\nexport type $expr_Alias<\r\n  El extends BaseType = BaseType,\r\n  Card extends Cardinality = Cardinality\r\n> = Expression<{\r\n  __element__: El;\r\n  __cardinality__: Card;\r\n  __kind__: ExpressionKind.Alias;\r\n  __expr__: TypeSet;\r\n}>;\r\n\r\nexport function alias<Expr extends Expression>(\r\n  expr: Expr\r\n): $expr_Alias<Expr[\"__element__\"], Expr[\"__cardinality__\"]> {\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.Alias,\r\n    __element__: expr.__element__,\r\n    __cardinality__: expr.__cardinality__,\r\n    __expr__: expr,\r\n  }) as any;\r\n}\r\n\r\nexport type WithableExpression =\r\n  | $expr_Select\r\n  | $expr_For\r\n  | $expr_Insert\r\n  | $expr_Update\r\n  | $expr_Group;\r\n\r\nexport type $expr_With<\r\n  // Refs extends TypeSet[] = TypeSet[],\r\n  Expr extends WithableExpression = WithableExpression\r\n> = Expression<{\r\n  __element__: Expr[\"__element__\"];\r\n  __cardinality__: Expr[\"__cardinality__\"];\r\n  __kind__: ExpressionKind.With;\r\n  __expr__: Expr;\r\n  __refs__: TypeSet[];\r\n}>;\r\n\r\nfunction _with<Expr extends WithableExpression>(\r\n  refs: Expression[],\r\n  expr: Expr\r\n): $expr_With<Expr> {\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.With,\r\n    __element__: expr.__element__,\r\n    __cardinality__: expr.__cardinality__,\r\n    __refs__: refs,\r\n    __expr__: expr as any,\r\n  }) as any;\r\n}\r\n\r\nexport { _with as with };\r\n"},{"path":"__spec__.ts","content":"import type { TypeKind } from \"./reflection.ts\";\r\n\r\nexport declare const spec: Map<string, any>;\r\n\r\nexport declare const complexParamKinds: Set<TypeKind>;\r\n"}],"cjs":[{"path":"cardinality.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.cardutil = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nvar cardutil;\n(function (cardutil) {\n    function multiplyCardinalities(c1, c2) {\n        if (c1 === index_1.Cardinality.Empty)\n            return index_1.Cardinality.Empty;\n        if (c1 === index_1.Cardinality.One)\n            return c2;\n        if (c1 === index_1.Cardinality.AtMostOne) {\n            if (c2 === index_1.Cardinality.One)\n                return index_1.Cardinality.AtMostOne;\n            if (c2 === index_1.Cardinality.AtLeastOne)\n                return index_1.Cardinality.Many;\n            return c2;\n        }\n        if (c1 === index_1.Cardinality.Many) {\n            if (c2 === index_1.Cardinality.Empty)\n                return index_1.Cardinality.Empty;\n            return index_1.Cardinality.Many;\n        }\n        if (c1 === index_1.Cardinality.AtLeastOne) {\n            if (c2 === index_1.Cardinality.AtMostOne)\n                return index_1.Cardinality.Many;\n            if (c2 === index_1.Cardinality.One)\n                return index_1.Cardinality.AtLeastOne;\n            return c2;\n        }\n        throw new Error(`Invalid Cardinality ${c1}`);\n    }\n    cardutil.multiplyCardinalities = multiplyCardinalities;\n    function multiplyCardinalitiesVariadic(cards) {\n        if (cards.length === 0)\n            throw new Error(\"Empty tuple not allowed\");\n        if (cards.length === 1)\n            return cards[0];\n        return cards.reduce((product, card) => multiplyCardinalities(product, card), index_1.Cardinality.One);\n    }\n    cardutil.multiplyCardinalitiesVariadic = multiplyCardinalitiesVariadic;\n    function mergeCardinalities(a, b) {\n        if (a === index_1.Cardinality.Empty)\n            return b;\n        if (b === index_1.Cardinality.Empty)\n            return a;\n        if (a === index_1.Cardinality.AtLeastOne)\n            return index_1.Cardinality.AtLeastOne;\n        if (b === index_1.Cardinality.AtLeastOne)\n            return index_1.Cardinality.AtLeastOne;\n        if (a === index_1.Cardinality.One)\n            return index_1.Cardinality.AtLeastOne;\n        if (b === index_1.Cardinality.One)\n            return index_1.Cardinality.AtLeastOne;\n        return index_1.Cardinality.Many;\n    }\n    cardutil.mergeCardinalities = mergeCardinalities;\n    function mergeCardinalitiesVariadic(cards) {\n        if (cards.length === 0)\n            throw new Error(\"Empty tuple not allowed\");\n        if (cards.length === 1)\n            return cards[0];\n        const [first, second, ...rest] = cards;\n        if (cards.length === 2)\n            return mergeCardinalities(first, second);\n        return mergeCardinalitiesVariadic([\n            mergeCardinalities(first, second),\n            ...rest,\n        ]);\n    }\n    cardutil.mergeCardinalitiesVariadic = mergeCardinalitiesVariadic;\n    function orCardinalities(c1, c2) {\n        if (c1 === c2 || c1 === index_1.Cardinality.Many)\n            return c1;\n        if (c1 === index_1.Cardinality.AtLeastOne) {\n            if (c2 === index_1.Cardinality.One)\n                return index_1.Cardinality.AtLeastOne;\n            return index_1.Cardinality.Many;\n        }\n        if (c1 === index_1.Cardinality.AtMostOne) {\n            if (c2 === index_1.Cardinality.Many || c2 === index_1.Cardinality.AtLeastOne) {\n                return index_1.Cardinality.Many;\n            }\n            return c1;\n        }\n        if (c1 === index_1.Cardinality.Empty) {\n            if (c2 === index_1.Cardinality.AtMostOne || c2 === index_1.Cardinality.One) {\n                return index_1.Cardinality.AtMostOne;\n            }\n            return index_1.Cardinality.Many;\n        }\n        if (c2 === index_1.Cardinality.Empty)\n            return index_1.Cardinality.AtMostOne;\n        return c2;\n    }\n    cardutil.orCardinalities = orCardinalities;\n    function overrideLowerBound(card, override) {\n        if (override === \"One\") {\n            if (card === index_1.Cardinality.Many || card === index_1.Cardinality.AtLeastOne) {\n                return index_1.Cardinality.AtLeastOne;\n            }\n            else {\n                return index_1.Cardinality.One;\n            }\n        }\n        else {\n            if (card === index_1.Cardinality.Many || card === index_1.Cardinality.AtLeastOne) {\n                return index_1.Cardinality.Many;\n            }\n            else if (card === index_1.Cardinality.Empty) {\n                return index_1.Cardinality.Empty;\n            }\n            else {\n                return index_1.Cardinality.AtMostOne;\n            }\n        }\n    }\n    cardutil.overrideLowerBound = overrideLowerBound;\n    function overrideUpperBound(card, override) {\n        if (override === \"One\") {\n            if (card === index_1.Cardinality.One || card === index_1.Cardinality.AtLeastOne) {\n                return index_1.Cardinality.One;\n            }\n            else {\n                return index_1.Cardinality.AtMostOne;\n            }\n        }\n        else {\n            if (card === index_1.Cardinality.One || card === index_1.Cardinality.AtLeastOne) {\n                return index_1.Cardinality.AtLeastOne;\n            }\n            else {\n                return index_1.Cardinality.Many;\n            }\n        }\n    }\n    cardutil.overrideUpperBound = overrideUpperBound;\n})(cardutil || (exports.cardutil = cardutil = {}));\n"},{"path":"cast.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.cast = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst path_1 = require(\"./path\");\nconst castMaps_1 = require(\"./castMaps\");\nfunction cast(target, expr) {\n    const cleanedExpr = expr === null ? null : (0, castMaps_1.literalToTypeSet)(expr);\n    return (0, path_1.$expressionify)({\n        __element__: target.__cardinality__\n            ? target.__element__\n            : target,\n        __cardinality__: cleanedExpr === null ? index_1.Cardinality.Empty : cleanedExpr.__cardinality__,\n        __expr__: cleanedExpr,\n        __kind__: index_1.ExpressionKind.Cast,\n    });\n}\nexports.cast = cast;\n"},{"path":"casting.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n"},{"path":"castMaps.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getSharedParentScalar = exports.literalToTypeSet = void 0;\nfunction getSharedParentScalar(a, b) { }\nexports.getSharedParentScalar = getSharedParentScalar;\n"},{"path":"collections.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.$objectTypeToTupleType = exports.tuple = exports.$tuplePathify = exports.array = exports.$arrayLikeIndexify = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst cardinality_1 = require(\"./cardinality\");\nconst path_1 = require(\"./path\");\nconst castMaps_1 = require(\"./castMaps\");\nconst indexSliceRegx = /^(-?\\d+)(?:(:)(-?\\d+)?)?|:(-?\\d+)$/;\nconst arrayLikeProxyHandlers = {\n    get(target, prop, proxy) {\n        const match = typeof prop === \"string\" ? prop.match(indexSliceRegx) : null;\n        if (match) {\n            const start = match[1];\n            const end = match[3] ?? match[4];\n            const isIndex = start && !match[2];\n            return (0, path_1.$expressionify)({\n                __kind__: index_1.ExpressionKind.Operator,\n                __element__: target.__element__.__kind__ === index_1.TypeKind.array && isIndex\n                    ? target.__element__.__element__\n                    : target.__element__,\n                __cardinality__: target.__cardinality__,\n                __name__: \"[]\",\n                __opkind__: \"Infix\",\n                __args__: [\n                    proxy,\n                    isIndex\n                        ? (0, castMaps_1.literalToTypeSet)(Number(start))\n                        : [\n                            start && (0, castMaps_1.literalToTypeSet)(Number(start)),\n                            end && (0, castMaps_1.literalToTypeSet)(Number(end)),\n                        ],\n                ],\n            });\n        }\n        return target[prop];\n    },\n};\nfunction arrayLikeIndex(index) {\n    const indexTypeSet = (0, castMaps_1.literalToTypeSet)(index);\n    return (0, path_1.$expressionify)({\n        __kind__: index_1.ExpressionKind.Operator,\n        __element__: this.__element__.__kind__ === index_1.TypeKind.array\n            ? this.__element__.__element__\n            : this.__element__,\n        __cardinality__: cardinality_1.cardutil.multiplyCardinalities(this.__cardinality__, indexTypeSet.__cardinality__),\n        __name__: \"[]\",\n        __opkind__: \"Infix\",\n        __args__: [this, indexTypeSet],\n    });\n}\nfunction arrayLikeSlice(start, end) {\n    const startTypeSet = start && (0, castMaps_1.literalToTypeSet)(start);\n    const endTypeSet = end && (0, castMaps_1.literalToTypeSet)(end);\n    return (0, path_1.$expressionify)({\n        __kind__: index_1.ExpressionKind.Operator,\n        __element__: this.__element__,\n        __cardinality__: cardinality_1.cardutil.multiplyCardinalities(cardinality_1.cardutil.multiplyCardinalities(this.__cardinality__, startTypeSet?.__cardinality__ ?? index_1.Cardinality.One), endTypeSet?.__cardinality__ ?? index_1.Cardinality.One),\n        __name__: \"[]\",\n        __opkind__: \"Infix\",\n        __args__: [this, [startTypeSet, endTypeSet]],\n    });\n}\nfunction $arrayLikeIndexify(_expr) {\n    if (_expr.__element__.__kind__ === index_1.TypeKind.array ||\n        (_expr.__element__.__kind__ === index_1.TypeKind.scalar &&\n            (_expr.__element__.__name__ === \"std::str\" ||\n                _expr.__element__.__name__ === \"std::bytes\"))) {\n        const expr = new Proxy(_expr, arrayLikeProxyHandlers);\n        expr.index = arrayLikeIndex.bind(expr);\n        expr.slice = arrayLikeSlice.bind(expr);\n        return expr;\n    }\n    return _expr;\n}\nexports.$arrayLikeIndexify = $arrayLikeIndexify;\nfunction array(arg) {\n    if (Array.isArray(arg)) {\n        const items = arg.map((a) => (0, castMaps_1.literalToTypeSet)(a));\n        return (0, path_1.$expressionify)({\n            __kind__: index_1.ExpressionKind.Array,\n            __cardinality__: cardinality_1.cardutil.multiplyCardinalitiesVariadic(items.map((item) => item.__cardinality__)),\n            __element__: {\n                __kind__: index_1.TypeKind.array,\n                __name__: `array<${items[0].__element__.__name__}>`,\n                __element__: items[0].__element__,\n            },\n            __items__: items,\n        });\n    }\n    if (arg.__kind__) {\n        return {\n            __kind__: index_1.TypeKind.array,\n            __name__: `array<${arg.__name__}>`,\n            __element__: arg,\n        };\n    }\n    throw new Error(\"Invalid array input.\");\n}\nexports.array = array;\nconst tupleProxyHandlers = {\n    get(target, prop, proxy) {\n        const type = target.__element__;\n        const items = type.__kind__ === index_1.TypeKind.tuple\n            ? type.__items__\n            : type.__kind__ === index_1.TypeKind.namedtuple\n                ? type.__shape__\n                : null;\n        return items?.hasOwnProperty(prop)\n            ? tuplePath(proxy, items[prop], prop)\n            : target[prop];\n    },\n};\nfunction $tuplePathify(expr) {\n    if (expr.__element__.__kind__ !== index_1.TypeKind.tuple &&\n        expr.__element__.__kind__ !== index_1.TypeKind.namedtuple) {\n        return expr;\n    }\n    return new Proxy(expr, tupleProxyHandlers);\n}\nexports.$tuplePathify = $tuplePathify;\nfunction tuplePath(parent, itemType, index) {\n    return (0, path_1.$expressionify)({\n        __kind__: index_1.ExpressionKind.TuplePath,\n        __element__: itemType,\n        __cardinality__: parent.__cardinality__,\n        __parent__: parent,\n        __index__: index,\n    });\n}\nfunction makeTupleType(name, items) {\n    return {\n        __kind__: index_1.TypeKind.tuple,\n        __name__: name,\n        __items__: items,\n    };\n}\nconst typeKinds = new Set(Object.values(index_1.TypeKind));\nfunction tuple(input) {\n    if (Array.isArray(input)) {\n        if (input.every((item) => typeKinds.has(item.__kind__))) {\n            const typeItems = input;\n            const typeName = `tuple<${typeItems\n                .map((item) => item.__name__)\n                .join(\", \")}>`;\n            return makeTupleType(typeName, typeItems);\n        }\n        const items = input.map((item) => (0, castMaps_1.literalToTypeSet)(item));\n        const name = `tuple<${items\n            .map((item) => item.__element__.__name__)\n            .join(\", \")}>`;\n        return (0, path_1.$expressionify)({\n            __kind__: index_1.ExpressionKind.Tuple,\n            __element__: makeTupleType(name, items.map((item) => item.__element__)),\n            __cardinality__: cardinality_1.cardutil.multiplyCardinalitiesVariadic(items.map((i) => i.__cardinality__)),\n            __items__: items,\n        });\n    }\n    else {\n        if (Object.values(input).every((el) => typeKinds.has(el.__kind__))) {\n            const typeName = `tuple<${Object.entries(input)\n                .map(([key, val]) => `${key}: ${val.__name__}`)\n                .join(\", \")}>`;\n            return {\n                __kind__: index_1.TypeKind.namedtuple,\n                __name__: typeName,\n                __shape__: input,\n            };\n        }\n        const exprShape = {};\n        const typeShape = {};\n        for (const [key, val] of Object.entries(input)) {\n            const typeSet = (0, castMaps_1.literalToTypeSet)(val);\n            exprShape[key] = typeSet;\n            typeShape[key] = typeSet.__element__;\n        }\n        const name = `tuple<${Object.entries(exprShape)\n            .map(([key, val]) => `${key}: ${val.__element__.__name__}`)\n            .join(\", \")}>`;\n        return (0, path_1.$expressionify)({\n            __kind__: index_1.ExpressionKind.NamedTuple,\n            __element__: {\n                __kind__: index_1.TypeKind.namedtuple,\n                __name__: name,\n                __shape__: typeShape,\n            },\n            __cardinality__: cardinality_1.cardutil.multiplyCardinalitiesVariadic(Object.values(exprShape).map((val) => val.__cardinality__)),\n            __shape__: exprShape,\n        });\n    }\n}\nexports.tuple = tuple;\nfunction $objectTypeToTupleType(...args) {\n    const [objExpr, fields] = args;\n    const shape = Object.entries(objExpr.__element__.__pointers__).reduce((_shape, [key, val]) => {\n        if (fields?.length\n            ? fields.includes(key)\n            : key !== \"id\" && val.__kind__ === \"property\" && !val.computed) {\n            _shape[key] = val.target;\n        }\n        return _shape;\n    }, {});\n    return tuple(shape);\n}\nexports.$objectTypeToTupleType = $objectTypeToTupleType;\n"},{"path":"detached.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.detached = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst path_1 = require(\"./path\");\nfunction detached(expr) {\n    return (0, path_1.$expressionify)({\n        __element__: expr.__element__,\n        __cardinality__: expr.__cardinality__,\n        __expr__: expr,\n        __kind__: index_1.ExpressionKind.Detached,\n    });\n}\nexports.detached = detached;\n"},{"path":"external.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.detached = exports.params = exports.optional = exports.with = exports.alias = exports.for = exports.objectTypeToTupleType = exports.tuple = exports.array = exports.insert = exports.update = exports.select = exports.delete = exports.is = exports.EMPTY_LAST = exports.EMPTY_FIRST = exports.DESC = exports.ASC = exports.cast = exports.set = exports.literal = void 0;\nvar literal_1 = require(\"./literal\");\nObject.defineProperty(exports, \"literal\", { enumerable: true, get: function () { return literal_1.literal; } });\nvar set_1 = require(\"./set\");\nObject.defineProperty(exports, \"set\", { enumerable: true, get: function () { return set_1.set; } });\nvar cast_1 = require(\"./cast\");\nObject.defineProperty(exports, \"cast\", { enumerable: true, get: function () { return cast_1.cast; } });\nvar select_1 = require(\"./select\");\nObject.defineProperty(exports, \"ASC\", { enumerable: true, get: function () { return select_1.ASC; } });\nObject.defineProperty(exports, \"DESC\", { enumerable: true, get: function () { return select_1.DESC; } });\nObject.defineProperty(exports, \"EMPTY_FIRST\", { enumerable: true, get: function () { return select_1.EMPTY_FIRST; } });\nObject.defineProperty(exports, \"EMPTY_LAST\", { enumerable: true, get: function () { return select_1.EMPTY_LAST; } });\nObject.defineProperty(exports, \"is\", { enumerable: true, get: function () { return select_1.is; } });\nObject.defineProperty(exports, \"delete\", { enumerable: true, get: function () { return select_1.delete; } });\nObject.defineProperty(exports, \"select\", { enumerable: true, get: function () { return select_1.select; } });\nvar update_1 = require(\"./update\");\nObject.defineProperty(exports, \"update\", { enumerable: true, get: function () { return update_1.update; } });\nvar insert_1 = require(\"./insert\");\nObject.defineProperty(exports, \"insert\", { enumerable: true, get: function () { return insert_1.insert; } });\nvar collections_1 = require(\"./collections\");\nObject.defineProperty(exports, \"array\", { enumerable: true, get: function () { return collections_1.array; } });\nObject.defineProperty(exports, \"tuple\", { enumerable: true, get: function () { return collections_1.tuple; } });\nObject.defineProperty(exports, \"objectTypeToTupleType\", { enumerable: true, get: function () { return collections_1.$objectTypeToTupleType; } });\nvar for_1 = require(\"./for\");\nObject.defineProperty(exports, \"for\", { enumerable: true, get: function () { return for_1.for; } });\nvar with_1 = require(\"./with\");\nObject.defineProperty(exports, \"alias\", { enumerable: true, get: function () { return with_1.alias; } });\nObject.defineProperty(exports, \"with\", { enumerable: true, get: function () { return with_1.with; } });\nvar params_1 = require(\"./params\");\nObject.defineProperty(exports, \"optional\", { enumerable: true, get: function () { return params_1.optional; } });\nObject.defineProperty(exports, \"params\", { enumerable: true, get: function () { return params_1.params; } });\nvar detached_1 = require(\"./detached\");\nObject.defineProperty(exports, \"detached\", { enumerable: true, get: function () { return detached_1.detached; } });\n"},{"path":"for.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.for = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst cardinality_1 = require(\"./cardinality\");\nconst path_1 = require(\"./path\");\nfunction _for(set, expr) {\n    const forVar = (0, path_1.$expressionify)({\n        __kind__: index_1.ExpressionKind.ForVar,\n        __element__: set.__element__,\n        __cardinality__: index_1.Cardinality.One,\n    });\n    const returnExpr = expr(forVar);\n    return (0, path_1.$expressionify)({\n        __kind__: index_1.ExpressionKind.For,\n        __element__: returnExpr.__element__,\n        __cardinality__: cardinality_1.cardutil.multiplyCardinalities(set.__cardinality__, returnExpr.__cardinality__),\n        __iterSet__: set,\n        __expr__: returnExpr,\n        __forVar__: forVar,\n    });\n}\nexports.for = _for;\n"},{"path":"funcops.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.$resolveOverload = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst cardinality_1 = require(\"./cardinality\");\nconst hydrate_1 = require(\"./hydrate\");\nconst cast_1 = require(\"./cast\");\nconst castMaps_1 = require(\"./castMaps\");\nconst literal_1 = require(\"./literal\");\nfunction mapLiteralToTypeSet(literals) {\n    if (Array.isArray(literals)) {\n        return literals.map((lit) => (lit != null ? (0, castMaps_1.literalToTypeSet)(lit) : lit));\n    }\n    const obj = {};\n    for (const key of Object.keys(literals)) {\n        obj[key] =\n            literals[key] != null ? (0, castMaps_1.literalToTypeSet)(literals[key]) : literals[key];\n    }\n    return obj;\n}\nfunction $resolveOverload(funcName, args, typeSpec, funcDefs) {\n    const positionalArgs = [];\n    let namedArgs;\n    if (args.length) {\n        if (args[0] !== undefined) {\n            try {\n                positionalArgs.push((0, castMaps_1.literalToTypeSet)(args[0]));\n            }\n            catch {\n                namedArgs = mapLiteralToTypeSet(args[0]);\n            }\n        }\n        else {\n            positionalArgs.push(undefined);\n        }\n        positionalArgs.push(...mapLiteralToTypeSet(args.slice(1)));\n    }\n    for (const def of funcDefs) {\n        const resolvedOverload = _tryOverload(funcName, positionalArgs, namedArgs, typeSpec, def);\n        if (resolvedOverload !== null) {\n            return resolvedOverload;\n        }\n    }\n    throw new Error(`No function overload found for ${funcName.includes(\"::\")\n        ? `'e.${funcName.split(\"::\").join(\".\")}()'`\n        : `operator '${funcName}'`} with args: ${[...positionalArgs, ...Object.values(namedArgs ?? {})]\n        .filter(Boolean)\n        .map((arg) => `Element: ${arg.__element__.__name__} (${arg.__cardinality__})`)\n        .join(\", \")}`);\n}\nexports.$resolveOverload = $resolveOverload;\nconst ANYTYPE_ARG = Symbol();\nfunction _tryOverload(funcName, args, namedArgs, typeSpec, funcDef) {\n    if ((funcDef.namedArgs === undefined && namedArgs !== undefined) ||\n        (namedArgs === undefined &&\n            funcDef.namedArgs &&\n            Object.values(funcDef.namedArgs).some((arg) => !arg.optional))) {\n        return null;\n    }\n    const lastParamVariadic = funcDef.args[funcDef.args.length - 1]?.variadic;\n    if (!lastParamVariadic && args.length > funcDef.args.length) {\n        return null;\n    }\n    const paramCardinalities = [index_1.Cardinality.One];\n    if (namedArgs) {\n        for (const [key, value] of Object.entries(namedArgs)) {\n            const argDef = funcDef.namedArgs?.[key];\n            if (!argDef ||\n                !compareType(typeSpec, argDef.typeId, value.__element__).match) {\n                return null;\n            }\n            paramCardinalities.push(argDef.setoftype\n                ? funcDef.preservesOptionality\n                    ? cardinality_1.cardutil.overrideUpperBound(value.__cardinality__, \"One\")\n                    : index_1.Cardinality.One\n                : argDef.optional\n                    ? cardinality_1.cardutil.overrideLowerBound(value.__cardinality__, \"One\")\n                    : value.__cardinality__);\n        }\n    }\n    let positionalArgs = [];\n    let returnAnytype;\n    let needsAnytypeReplacement = false;\n    for (let i = 0; i < funcDef.args.length; i++) {\n        const argDef = funcDef.args[i];\n        const arg = args[i];\n        if (arg === undefined) {\n            if (!argDef.optional) {\n                return null;\n            }\n            if (i < args.length) {\n                const argTypeName = typeSpec.get(argDef.typeId).name;\n                if (argTypeName.includes(\"anytype\") ||\n                    argTypeName.includes(\"std::anypoint\")) {\n                    if (!returnAnytype) {\n                        positionalArgs.push(ANYTYPE_ARG);\n                        needsAnytypeReplacement = true;\n                    }\n                    else {\n                        positionalArgs.push((0, cast_1.cast)(returnAnytype, null));\n                    }\n                }\n                else {\n                    const argType = (0, hydrate_1.makeType)(typeSpec, argDef.typeId, literal_1.literal);\n                    positionalArgs.push((0, cast_1.cast)(argType, null));\n                }\n            }\n        }\n        else {\n            const { match, anytype } = compareType(typeSpec, argDef.typeId, arg.__element__);\n            if (!match) {\n                return null;\n            }\n            if (!returnAnytype && anytype) {\n                returnAnytype = anytype;\n            }\n            positionalArgs.push(...(argDef.variadic ? args.slice(i) : [arg]));\n            if (argDef.setoftype) {\n                paramCardinalities.push(funcDef.preservesOptionality\n                    ? cardinality_1.cardutil.overrideUpperBound(arg.__cardinality__, \"One\")\n                    : index_1.Cardinality.One);\n            }\n            else {\n                const card = argDef.variadic\n                    ? cardinality_1.cardutil.multiplyCardinalitiesVariadic(args.slice(i).map((el) => el.__cardinality__))\n                    : arg.__cardinality__;\n                paramCardinalities.push(argDef.optional ? cardinality_1.cardutil.overrideLowerBound(card, \"One\") : card);\n            }\n        }\n    }\n    let cardinality;\n    if (funcName === \"if_else\") {\n        cardinality = cardinality_1.cardutil.multiplyCardinalities(cardinality_1.cardutil.orCardinalities(positionalArgs[0].__cardinality__, positionalArgs[2].__cardinality__), positionalArgs[1].__cardinality__);\n    }\n    else if (funcName === \"std::assert_exists\") {\n        cardinality = cardinality_1.cardutil.overrideLowerBound(positionalArgs[0].__cardinality__, \"One\");\n    }\n    else if (funcName === \"union\") {\n        cardinality = cardinality_1.cardutil.mergeCardinalities(positionalArgs[0].__cardinality__, positionalArgs[1].__cardinality__);\n    }\n    else if (funcName === \"??\") {\n        cardinality = cardinality_1.cardutil.orCardinalities(positionalArgs[0].__cardinality__, positionalArgs[1].__cardinality__);\n    }\n    else if (funcName === \"distinct\") {\n        cardinality = positionalArgs[0].__cardinality__;\n    }\n    else {\n        cardinality =\n            funcDef.returnTypemod === \"SetOfType\"\n                ? index_1.Cardinality.Many\n                : cardinality_1.cardutil.multiplyCardinalitiesVariadic(paramCardinalities);\n        if (funcDef.returnTypemod === \"OptionalType\" &&\n            !funcDef.preservesOptionality) {\n            cardinality = cardinality_1.cardutil.overrideLowerBound(cardinality, \"Zero\");\n        }\n    }\n    if (needsAnytypeReplacement) {\n        if (!returnAnytype) {\n            throw new Error(`could not resolve anytype for ${funcName}`);\n        }\n        positionalArgs = positionalArgs.map((arg) => arg === ANYTYPE_ARG ? (0, cast_1.cast)(returnAnytype, null) : arg);\n    }\n    return {\n        kind: funcDef.kind,\n        returnType: (0, hydrate_1.makeType)(typeSpec, funcDef.returnTypeId, literal_1.literal, returnAnytype),\n        cardinality,\n        args: positionalArgs,\n        namedArgs: namedArgs ?? {},\n    };\n}\nconst nameRemapping = {\n    \"std::int16\": \"std::number\",\n    \"std::int32\": \"std::number\",\n    \"std::int64\": \"std::number\",\n    \"std::float32\": \"std::number\",\n    \"std::float64\": \"std::number\",\n};\nconst descendantCache = new Map();\nfunction getDescendantNames(typeSpec, typeId) {\n    if (descendantCache.has(typeId)) {\n        return descendantCache.get(typeId);\n    }\n    const descendants = [\n        ...new Set([...typeSpec.values()]\n            .filter((type) => type.kind === \"scalar\" && type.bases.some(({ id }) => id === typeId))\n            .flatMap((type) => type.is_abstract\n            ? getDescendantNames(typeSpec, type.id)\n            : [nameRemapping[type.name], type.name])),\n    ];\n    descendantCache.set(typeId, descendants);\n    return descendants;\n}\nfunction compareType(typeSpec, typeId, arg) {\n    const type = typeSpec.get(typeId);\n    if (type.name === \"anytype\") {\n        return { match: true, anytype: arg };\n    }\n    if (type.name === \"anyobject\") {\n        return { match: arg.__kind__ === index_1.TypeKind.object, anytype: arg };\n    }\n    if (type.name === \"std::anypoint\") {\n        const descendants = getDescendantNames(typeSpec, typeId);\n        if (descendants.includes(arg.__name__)) {\n            return { match: true, anytype: arg };\n        }\n    }\n    if (type.name === \"std::anyenum\") {\n        return { match: arg.__kind__ === index_1.TypeKind.enum };\n    }\n    if (type.kind === \"scalar\") {\n        arg = arg.__casttype__ ?? arg;\n        return {\n            match: (arg.__kind__ === index_1.TypeKind.scalar || arg.__kind__ === index_1.TypeKind.enum) &&\n                (arg.__name__ === type.name ||\n                    (0, castMaps_1.isImplicitlyCastableTo)(arg.__name__, type.name)),\n        };\n    }\n    if (type.kind === \"array\") {\n        if (arg.__kind__ === index_1.TypeKind.array) {\n            return compareType(typeSpec, type.array_element_id, arg.__element__);\n        }\n    }\n    if (type.kind === \"range\") {\n        if (arg.__kind__ === index_1.TypeKind.range) {\n            return compareType(typeSpec, type.range_element_id, arg.__element__);\n        }\n    }\n    if (type.kind === \"multirange\") {\n        if (arg.__kind__ === index_1.TypeKind.multirange) {\n            return compareType(typeSpec, type.multirange_element_id, arg.__element__);\n        }\n    }\n    if (type.kind === \"object\") {\n        if (arg.__kind__ !== index_1.TypeKind.object)\n            return { match: false };\n        const objectArg = arg;\n        let match = true;\n        for (const ptr of type.pointers) {\n            if (objectArg.__pointers__[ptr.name]) {\n                const argPtr = objectArg.__pointers__[ptr.name];\n                const ptrTarget = typeSpec.get(ptr.target_id);\n                if (ptrTarget.name !== argPtr.target.__name__ ||\n                    ptr.card !== argPtr.cardinality) {\n                    match = false;\n                }\n            }\n        }\n        return {\n            match,\n        };\n    }\n    if (type.kind === \"tuple\") {\n        const items = arg.__kind__ === index_1.TypeKind.tuple\n            ? arg.__items__\n            : arg.__kind__ === index_1.TypeKind.namedtuple\n                ? arg.__shape__\n                : null;\n        if (items) {\n            const keys = Object.keys(items);\n            if (keys.length === type.tuple_elements.length) {\n                let anytype;\n                for (let i = 0; i < keys.length; i++) {\n                    if (keys[i] !== type.tuple_elements[i].name) {\n                        return { match: false };\n                    }\n                    const { match: m, anytype: a } = compareType(typeSpec, type.tuple_elements[i].target_id, items[keys[i]]);\n                    if (!m) {\n                        return { match: false };\n                    }\n                    if (a)\n                        anytype = a;\n                }\n                return { match: true, anytype };\n            }\n        }\n    }\n    return { match: false };\n}\n"},{"path":"globals.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.makeGlobal = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst path_1 = require(\"./path\");\nfunction makeGlobal(name, type, card) {\n    return (0, path_1.$expressionify)({\n        __name__: name,\n        __element__: type,\n        __cardinality__: card,\n        __kind__: index_1.ExpressionKind.Global,\n    });\n}\nexports.makeGlobal = makeGlobal;\n"},{"path":"group.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.group = exports.isGroupingSet = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst hydrate_1 = require(\"./hydrate\");\nconst path_1 = require(\"./path\");\nconst __spec__1 = require(\"./__spec__\");\nconst literal_1 = require(\"./literal\");\nconst select_1 = require(\"./select\");\nfunction isGroupingSet(arg) {\n    return arg.__kind__ === \"groupingset\";\n}\nexports.isGroupingSet = isGroupingSet;\nconst makeGroupingSet = (prefix) => (grps) => {\n    const seenKeys = new Map();\n    const unfiltered = Object.entries(grps).flatMap(([k, grp]) => isGroupingSet(grp)\n        ? grp.__exprs__\n        : [[k, grp]]);\n    const filtered = unfiltered.filter(([k, expr]) => {\n        if (!seenKeys.has(k)) {\n            seenKeys.set(k, expr);\n            return true;\n        }\n        if (expr !== seenKeys.get(k)) {\n            throw new Error(`Cannot override pre-existing expression with key \"${k}\"`);\n        }\n        return false;\n    });\n    return {\n        [`${Math.round(1000000 * Math.random())}___`]: {\n            __kind__: \"groupingset\",\n            __settype__: prefix,\n            __elements__: grps,\n            __exprs__: filtered,\n        },\n    };\n};\nconst set = makeGroupingSet(\"set\");\nconst tuple = makeGroupingSet(\"tuple\");\nconst rollup = makeGroupingSet(\"rollup\");\nconst cube = makeGroupingSet(\"cube\");\nconst setFuncs = { set, tuple, rollup, cube };\nconst groupFunc = (expr, getter) => {\n    const { shape, scope, modifiers } = resolveShape(getter, expr);\n    const groupSet = tuple(modifiers.by);\n    const key = Object.keys(groupSet)[0];\n    const grouping = groupSet[key];\n    const keyShape = {};\n    const keyPointers = {};\n    const keyShapeElement = {};\n    for (const [k, e] of grouping.__exprs__) {\n        keyShape[k] = (0, path_1.$expressionify)({\n            __element__: e.__element__,\n            __cardinality__: index_1.Cardinality.AtMostOne,\n        });\n        keyPointers[k] = {\n            __kind__: \"property\",\n            target: e.__element__,\n            cardinality: index_1.Cardinality.AtMostOne,\n            exclusive: false,\n            computed: false,\n            readonly: false,\n            hasDefault: false,\n        };\n        keyShapeElement[k] = true;\n    }\n    const $FreeObject = (0, hydrate_1.makeType)(__spec__1.spec, [...__spec__1.spec.values()].find((s) => s.name === \"std::FreeObject\").id, literal_1.literal);\n    const str = (0, hydrate_1.makeType)(__spec__1.spec, [...__spec__1.spec.values()].find((s) => s.name === \"std::str\").id, literal_1.literal);\n    return (0, path_1.$expressionify)({\n        __element__: {\n            ...$FreeObject,\n            __name__: \"std::FreeObject\",\n            __pointers__: {\n                ...$FreeObject.__pointers__,\n                __name__: \"std::FreeObject\",\n                grouping: {\n                    __kind__: \"property\",\n                    target: str,\n                    cardinality: index_1.Cardinality.Many,\n                    exclusive: false,\n                    computed: false,\n                    readonly: false,\n                    hasDefault: false,\n                },\n                key: {\n                    __kind__: \"link\",\n                    target: {\n                        ...$FreeObject,\n                        __name__: \"std::FreeObject\",\n                        __pointers__: {\n                            ...$FreeObject.__pointers__,\n                            ...keyPointers,\n                        },\n                        __shape__: keyShape,\n                    },\n                    properties: {},\n                    cardinality: index_1.Cardinality.One,\n                    exclusive: false,\n                    computed: false,\n                    readonly: false,\n                    hasDefault: false,\n                },\n                elements: {\n                    __kind__: \"link\",\n                    target: expr.__element__,\n                    cardinality: index_1.Cardinality.Many,\n                    properties: {},\n                    exclusive: false,\n                    computed: false,\n                    readonly: false,\n                    hasDefault: false,\n                },\n            },\n            __shape__: {\n                grouping: (0, path_1.$expressionify)({\n                    __element__: str,\n                    __cardinality__: index_1.Cardinality.Many,\n                }),\n                key: (0, path_1.$expressionify)({\n                    __element__: {\n                        ...$FreeObject,\n                        __shape__: keyShape,\n                    },\n                    __cardinality__: index_1.Cardinality.One,\n                }),\n                elements: (0, path_1.$expressionify)({\n                    __element__: { ...expr.__element__, __shape__: shape },\n                    __cardinality__: index_1.Cardinality.Many,\n                }),\n            },\n        },\n        __cardinality__: index_1.Cardinality.Many,\n        __expr__: expr,\n        __modifiers__: { by: grouping },\n        __kind__: index_1.ExpressionKind.Group,\n        __scope__: scope,\n    });\n};\nObject.assign(groupFunc, setFuncs);\nfunction resolveShape(shapeGetter, expr) {\n    const modifiers = {};\n    const shape = {};\n    const scope = (0, path_1.$getScopedExpr)(expr);\n    const selectShape = typeof shapeGetter === \"function\" ? shapeGetter(scope) : shapeGetter;\n    for (const [key, value] of Object.entries(selectShape)) {\n        if (key === \"by\") {\n            modifiers[key] = value;\n        }\n        else {\n            if (expr.__element__.__kind__ !== index_1.TypeKind.object) {\n                throw new Error(`Invalid select shape key '${key}' on scalar expression, ` +\n                    `only modifiers are allowed (filter, order_by, offset and limit)`);\n            }\n            shape[key] = (0, select_1.resolveShapeElement)(key, value, scope);\n        }\n    }\n    if (Object.keys(shape).length === 0) {\n        shape.id = true;\n    }\n    if (!modifiers.by) {\n        throw new Error(\"Must provide a `by` key in `e.group`\");\n    }\n    return { shape, modifiers, scope };\n}\nexports.group = groupFunc;\n"},{"path":"hydrate.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.$mergeTupleTypes = exports.$mergeObjectTypes = exports.makeType = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst typeCache = new Map();\nconst _linkProps = Symbol();\nfunction applySpec(spec, type, shape, seen, literal) {\n    const allPointers = [\n        ...type.pointers,\n        ...type.backlinks,\n        ...type.backlink_stubs,\n    ];\n    for (const ptr of allPointers) {\n        if (seen.has(ptr.name)) {\n            continue;\n        }\n        seen.add(ptr.name);\n        if (ptr.kind === \"link\") {\n            shape[ptr.name] = {\n                __kind__: \"link\",\n                cardinality: ptr.card,\n                exclusive: ptr.is_exclusive,\n                computed: ptr.is_computed,\n                readonly: ptr.is_readonly,\n            };\n            index_1.util.defineGetter(shape[ptr.name], \"target\", () => makeType(spec, ptr.target_id, literal));\n            index_1.util.defineGetter(shape[ptr.name], \"properties\", () => {\n                if (!shape[ptr.name][_linkProps]) {\n                    const linkProperties = (shape[ptr.name][_linkProps] = {});\n                    for (const linkProp of ptr.pointers ?? []) {\n                        if (linkProp.kind !== \"property\") {\n                            return;\n                        }\n                        if (linkProp.name === \"source\" || linkProp.name === \"target\") {\n                            return;\n                        }\n                        const linkPropObject = {\n                            __kind__: \"property\",\n                        };\n                        linkPropObject.cardinality = linkProp.card;\n                        index_1.util.defineGetter(linkPropObject, \"target\", () => {\n                            return makeType(spec, linkProp.target_id, literal);\n                        });\n                        linkProperties[linkProp.name] = linkPropObject;\n                    }\n                }\n                return shape[ptr.name][_linkProps];\n            });\n        }\n        else if (ptr.kind === \"property\") {\n            shape[ptr.name] = {\n                __kind__: \"property\",\n                cardinality: ptr.card,\n                exclusive: ptr.is_exclusive,\n                computed: ptr.is_computed,\n                readonly: ptr.is_readonly,\n            };\n            index_1.util.defineGetter(shape[ptr.name], \"target\", () => makeType(spec, ptr.target_id, literal));\n        }\n    }\n}\nfunction makeType(spec, id, literal, anytype) {\n    const type = spec.get(id);\n    if (type.name === \"anytype\" || type.name === \"std::anypoint\") {\n        if (anytype)\n            return anytype;\n        throw new Error(\"anytype not provided\");\n    }\n    if (typeCache.has(id)) {\n        return typeCache.get(id);\n    }\n    const obj = {};\n    obj.__name__ = type.name;\n    if (type.kind === \"object\") {\n        obj.__kind__ = index_1.TypeKind.object;\n        const pointers = {};\n        const seen = new Set();\n        applySpec(spec, type, pointers, seen, literal);\n        const ancestors = [...type.bases];\n        for (const anc of ancestors) {\n            const ancType = spec.get(anc.id);\n            if (ancType.kind === \"object\" || ancType.kind === \"scalar\") {\n                ancestors.push(...ancType.bases);\n            }\n            if (ancType.kind !== \"object\") {\n                throw new Error(`Not an object: ${id}`);\n            }\n            applySpec(spec, ancType, pointers, seen, literal);\n        }\n        obj.__pointers__ = pointers;\n        obj.__shape__ = {};\n        typeCache.set(id, obj);\n        return obj;\n    }\n    else if (type.kind === \"scalar\") {\n        const scalarObj = type.is_abstract\n            ? {}\n            : type.enum_values\n                ? {}\n                :\n                    ((val) => {\n                        return literal(scalarObj, val);\n                    });\n        if (type.enum_values) {\n            scalarObj.__kind__ = index_1.TypeKind.enum;\n            scalarObj.__values__ = type.enum_values;\n            for (const val of type.enum_values) {\n                Object.defineProperty(scalarObj, val, {\n                    get() {\n                        return literal(scalarObj, val);\n                    },\n                });\n            }\n        }\n        else {\n            scalarObj.__kind__ = index_1.TypeKind.scalar;\n        }\n        scalarObj.__name__ = type.name;\n        if (type.cast_type) {\n            scalarObj.__casttype__ = makeType(spec, type.cast_type, literal);\n        }\n        typeCache.set(id, scalarObj);\n        return scalarObj;\n    }\n    else if (type.kind === \"array\") {\n        obj.__kind__ = index_1.TypeKind.array;\n        index_1.util.defineGetter(obj, \"__element__\", () => {\n            return makeType(spec, type.array_element_id, literal, anytype);\n        });\n        index_1.util.defineGetter(obj, \"__name__\", () => {\n            return `array<${obj.__element__.__name__}>`;\n        });\n        return obj;\n    }\n    else if (type.kind === \"tuple\") {\n        if (type.tuple_elements[0].name === \"0\") {\n            obj.__kind__ = index_1.TypeKind.tuple;\n            index_1.util.defineGetter(obj, \"__items__\", () => {\n                return type.tuple_elements.map((el) => makeType(spec, el.target_id, literal, anytype));\n            });\n            index_1.util.defineGetter(obj, \"__name__\", () => {\n                return `tuple<${obj.__items__\n                    .map((item) => item.__name__)\n                    .join(\", \")}>`;\n            });\n            return obj;\n        }\n        else {\n            obj.__kind__ = index_1.TypeKind.namedtuple;\n            index_1.util.defineGetter(obj, \"__shape__\", () => {\n                const shape = {};\n                for (const el of type.tuple_elements) {\n                    shape[el.name] = makeType(spec, el.target_id, literal, anytype);\n                }\n                return shape;\n            });\n            index_1.util.defineGetter(obj, \"__name__\", () => {\n                return `tuple<${Object.entries(obj.__shape__)\n                    .map(([key, val]) => `${key}: ${val.__name__}`)\n                    .join(\", \")}>`;\n            });\n            return obj;\n        }\n    }\n    else if (type.kind === \"range\") {\n        obj.__kind__ = index_1.TypeKind.range;\n        index_1.util.defineGetter(obj, \"__element__\", () => {\n            return makeType(spec, type.range_element_id, literal, anytype);\n        });\n        index_1.util.defineGetter(obj, \"__name__\", () => {\n            return `range<${obj.__element__.__name__}>`;\n        });\n        return obj;\n    }\n    else if (type.kind === \"multirange\") {\n        obj.__kind__ = index_1.TypeKind.multirange;\n        index_1.util.defineGetter(obj, \"__element__\", () => {\n            return makeType(spec, type.multirange_element_id, literal, anytype);\n        });\n        index_1.util.defineGetter(obj, \"__name__\", () => {\n            return `multirange<${obj.__element__.__name__}>`;\n        });\n        return obj;\n    }\n    else {\n        throw new Error(`Invalid type: ${JSON.stringify(type, null, 2)}`);\n    }\n}\nexports.makeType = makeType;\nfunction $mergeObjectTypes(a, b) {\n    const obj = {\n        __kind__: index_1.TypeKind.object,\n        __name__: `${a.__name__} UNION ${b.__name__}`,\n        get __pointers__() {\n            const merged = {};\n            for (const [akey, aitem] of Object.entries(a.__pointers__)) {\n                if (!b.__pointers__[akey])\n                    continue;\n                const bitem = b.__pointers__[akey];\n                if (aitem.cardinality !== bitem.cardinality)\n                    continue;\n                if (aitem.target.__name__ !== bitem.target.__name__)\n                    continue;\n                merged[akey] = aitem;\n            }\n            return merged;\n        },\n        __shape__: {},\n    };\n    return obj;\n}\nexports.$mergeObjectTypes = $mergeObjectTypes;\nfunction $mergeTupleTypes(a, b) {\n    if (a.__items__.length !== b.__items__.length) {\n        throw new Error(\"Incompatible tuple types; lengths differ.\");\n    }\n    return {};\n}\nexports.$mergeTupleTypes = $mergeTupleTypes;\n"},{"path":"insert.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.insert = exports.$normaliseInsertShape = exports.$insertify = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst path_1 = require(\"./path\");\nconst cast_1 = require(\"./cast\");\nconst set_1 = require(\"./set\");\nconst literal_1 = require(\"./literal\");\nconst literal_2 = require(\"./literal\");\nfunction unlessConflict(conflictGetter) {\n    const expr = {\n        __kind__: index_1.ExpressionKind.InsertUnlessConflict,\n        __element__: this.__element__,\n        __cardinality__: index_1.Cardinality.AtMostOne,\n        __expr__: this,\n    };\n    if (!conflictGetter) {\n        expr.__conflict__ = { on: null };\n        return (0, path_1.$expressionify)(expr);\n    }\n    else {\n        const scopedExpr = (0, path_1.$getScopedExpr)(this.__expr__);\n        const conflict = conflictGetter(scopedExpr);\n        expr.__conflict__ = conflict;\n        if (conflict.else) {\n            expr.__cardinality__ = conflict.else.__cardinality__;\n            if (this.__element__.__name__ !== conflict.else.__element__.__name__) {\n                expr.__element__ = (0, literal_2.$getTypeByName)(\"std::Object\");\n            }\n        }\n        return (0, path_1.$expressionify)(expr);\n    }\n}\nfunction $insertify(expr) {\n    expr.unlessConflict = unlessConflict.bind(expr);\n    return expr;\n}\nexports.$insertify = $insertify;\nfunction $normaliseInsertShape(root, shape, isUpdate = false) {\n    const newShape = {};\n    const _shape = shape.__element__?.__kind__ === index_1.TypeKind.namedtuple\n        ? Object.keys(shape.__element__.__shape__).map((key) => [key, shape[key]])\n        : Object.entries(shape);\n    for (const [key, _val] of _shape) {\n        let val = _val;\n        let setModify = null;\n        if (isUpdate && _val != null && typeof _val === \"object\") {\n            const valKeys = Object.keys(_val);\n            if (valKeys.length === 1 &&\n                (valKeys[0] === \"+=\" || valKeys[0] === \"-=\")) {\n                val = _val[valKeys[0]];\n                setModify = valKeys[0];\n            }\n        }\n        const pointer = root.__element__.__pointers__[key];\n        const isLinkProp = key[0] === \"@\";\n        if (!pointer && !isLinkProp) {\n            throw new Error(`Could not find property pointer for ${isUpdate ? \"update\" : \"insert\"} shape key: '${key}'`);\n        }\n        if (val === undefined)\n            continue;\n        if (val?.__kind__) {\n            if (val.__kind__ === index_1.ExpressionKind.Literal &&\n                val.__element__.__kind__ === index_1.TypeKind.range &&\n                val.__element__.__element__.__name__ === \"std::number\") {\n                newShape[key] = literal_1.literal(pointer?.target, val.__value__);\n            }\n            else {\n                newShape[key] = _val;\n            }\n            continue;\n        }\n        if (isLinkProp) {\n            throw new Error(`Cannot assign plain data to link property '${key}'. Provide an expression instead.`);\n        }\n        if (!pointer) {\n            throw new Error(\"Code will never reach here, but TypeScript cannot determine\");\n        }\n        if (pointer.__kind__ !== \"property\" && val !== null) {\n            throw new Error(`Must provide subquery when assigning to link '${key}' in ${isUpdate ? \"update\" : \"insert\"} query.`);\n        }\n        const isMulti = pointer.cardinality === index_1.Cardinality.AtLeastOne ||\n            pointer.cardinality === index_1.Cardinality.Many;\n        if (pointer.__kind__ === \"property\") {\n            if (pointer.target.__name__ === \"std::json\") {\n            }\n        }\n        const wrappedVal = val === null\n            ? (0, cast_1.cast)(pointer.target, null)\n            : isMulti && Array.isArray(val)\n                ? val.length === 0\n                    ? (0, cast_1.cast)(pointer.target, null)\n                    : (0, set_1.set)(...val.map((v) => literal_1.literal(pointer.target, v)))\n                : literal_1.literal(pointer.target, val);\n        newShape[key] = setModify\n            ? { [setModify]: wrappedVal }\n            : wrappedVal;\n    }\n    return newShape;\n}\nexports.$normaliseInsertShape = $normaliseInsertShape;\nfunction insert(root, shape) {\n    if (typeof shape !== \"object\") {\n        throw new Error(`invalid insert shape.${typeof shape === \"function\"\n            ? \" Hint: Insert shape is expected to be an object, \" +\n                \"not a function returning a shape object.\"\n            : \"\"}`);\n    }\n    const expr = {\n        __kind__: index_1.ExpressionKind.Insert,\n        __element__: root.__element__,\n        __cardinality__: index_1.Cardinality.One,\n        __expr__: root,\n        __shape__: $normaliseInsertShape(root, shape),\n    };\n    expr.unlessConflict = unlessConflict.bind(expr);\n    return (0, path_1.$expressionify)($insertify(expr));\n}\nexports.insert = insert;\n"},{"path":"json.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.jsonifyComplexParams = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst buffer_1 = require(\"edgedb/dist/primitives/buffer.js\");\nfunction jsonStringify(type, val) {\n    if (type.__kind__ === index_1.TypeKind.array) {\n        if (Array.isArray(val)) {\n            return `[${val\n                .map((item) => jsonStringify(type.__element__, item))\n                .join()}]`;\n        }\n        throw new Error(`Param with array type is not an array`);\n    }\n    if (type.__kind__ === index_1.TypeKind.tuple) {\n        if (!Array.isArray(val)) {\n            throw new Error(`Param with tuple type is not an array`);\n        }\n        if (val.length !== type.__items__.length) {\n            throw new Error(`Param with tuple type has incorrect number of items. Got ${val.length} expected ${type.__items__.length}`);\n        }\n        return `[${val\n            .map((item, i) => jsonStringify(type.__items__[i], item))\n            .join()}]`;\n    }\n    if (type.__kind__ === index_1.TypeKind.namedtuple) {\n        if (typeof val !== \"object\") {\n            throw new Error(`Param with named tuple type is not an object`);\n        }\n        if (Object.keys(val).length !== Object.keys(type.__shape__).length) {\n            throw new Error(`Param with named tuple type has incorrect number of items. Got ${Object.keys(val).length} expected ${Object.keys(type.__shape__).length}`);\n        }\n        return `{${Object.entries(val)\n            .map(([key, item]) => {\n            if (!type.__shape__[key]) {\n                throw new Error(`Unexpected key in named tuple param: ${key}, expected keys: ${Object.keys(type.__shape__).join()}`);\n            }\n            return `\"${key}\": ${jsonStringify(type.__shape__[key], item)}`;\n        })\n            .join()}}`;\n    }\n    if (type.__kind__ === index_1.TypeKind.scalar) {\n        switch (type.__name__) {\n            case \"std::bigint\":\n                return val.toString();\n            case \"std::json\":\n                return JSON.stringify(val);\n            case \"std::bytes\":\n                return `\"${(0, buffer_1.encodeB64)(val)}\"`;\n            case \"cfg::memory\":\n                return `\"${val.toString()}\"`;\n            default:\n                return JSON.stringify(val);\n        }\n    }\n    if (type.__kind__ === index_1.TypeKind.enum) {\n        return JSON.stringify(val);\n    }\n    throw new Error(`Invalid param type: ${type.__kind__}`);\n}\nfunction jsonifyComplexParams(expr, _args) {\n    if (_args && expr.__kind__ === index_1.ExpressionKind.WithParams) {\n        const args = { ..._args };\n        for (const param of expr.__params__) {\n            if (param.__isComplex__) {\n                args[param.__name__] = jsonStringify(param.__element__, args[param.__name__]);\n            }\n        }\n        return args;\n    }\n    return _args;\n}\nexports.jsonifyComplexParams = jsonifyComplexParams;\n"},{"path":"literal.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.$getTypeByName = exports.$getType = exports.$nameMapping = exports.literal = void 0;\nconst path_1 = require(\"./path\");\nconst __spec__1 = require(\"./__spec__\");\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst hydrate_1 = require(\"./hydrate\");\nfunction literal(type, value) {\n    return (0, path_1.$expressionify)({\n        __element__: type,\n        __cardinality__: index_1.Cardinality.One,\n        __kind__: index_1.ExpressionKind.Literal,\n        __value__: value,\n    });\n}\nexports.literal = literal;\nexports.$nameMapping = new Map([\n    ...[...__spec__1.spec.values()].map((type) => [type.name, type.id]),\n    [\"std::number\", \"00000000-0000-0000-0000-0000000001ff\"],\n]);\nfunction $getType(id) {\n    return (0, hydrate_1.makeType)(__spec__1.spec, id, literal);\n}\nexports.$getType = $getType;\nfunction $getTypeByName(name) {\n    return (0, hydrate_1.makeType)(__spec__1.spec, exports.$nameMapping.get(name), literal);\n}\nexports.$getTypeByName = $getTypeByName;\n"},{"path":"operators.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n"},{"path":"params.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.params = exports.optional = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst path_1 = require(\"./path\");\nconst query_1 = require(\"./query\");\nconst select_1 = require(\"./select\");\nconst __spec__1 = require(\"./__spec__\");\nfunction optional(type) {\n    return {\n        __kind__: index_1.ExpressionKind.OptionalParam,\n        __type__: type,\n    };\n}\nexports.optional = optional;\nfunction params(paramsDef, expr) {\n    const paramExprs = {};\n    for (const [key, param] of Object.entries(paramsDef)) {\n        const paramType = param.__kind__ === index_1.ExpressionKind.OptionalParam ? param.__type__ : param;\n        const isComplex = __spec__1.complexParamKinds.has(paramType.__kind__) ||\n            (paramType.__kind__ === index_1.TypeKind.array &&\n                __spec__1.complexParamKinds.has(paramType.__element__.__kind__));\n        paramExprs[key] = (0, path_1.$expressionify)({\n            __kind__: index_1.ExpressionKind.Param,\n            __element__: paramType,\n            __cardinality__: param.__kind__ === index_1.ExpressionKind.OptionalParam\n                ? index_1.Cardinality.AtMostOne\n                : index_1.Cardinality.One,\n            __name__: key,\n            __isComplex__: isComplex,\n        });\n    }\n    let returnExpr = expr(paramExprs);\n    if (!query_1.runnableExpressionKinds.has(returnExpr.__kind__)) {\n        returnExpr = (0, select_1.select)(returnExpr);\n    }\n    return (0, path_1.$expressionify)({\n        __kind__: index_1.ExpressionKind.WithParams,\n        __element__: returnExpr.__element__,\n        __cardinality__: returnExpr.__cardinality__,\n        __expr__: returnExpr,\n        __params__: Object.values(paramExprs),\n    });\n}\nexports.params = params;\n"},{"path":"path.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.$PathNode = exports.$PathLeaf = exports.$getScopedExpr = exports.$expressionify = exports.$jsonDestructure = exports.$assert_single = exports.$pathify = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst cardinality_1 = require(\"./cardinality\");\nconst castMaps_1 = require(\"./castMaps\");\nconst collections_1 = require(\"./collections\");\nconst toEdgeQL_1 = require(\"./toEdgeQL\");\nconst query_1 = require(\"./query\");\nfunction PathLeaf(root, parent, exclusive, scopeRoot = null) {\n    return $expressionify({\n        __kind__: index_1.ExpressionKind.PathLeaf,\n        __element__: root.__element__,\n        __cardinality__: root.__cardinality__,\n        __parent__: parent,\n        __scopeRoot__: scopeRoot,\n    });\n}\nexports.$PathLeaf = PathLeaf;\nfunction getStarShapeFromPointers(pointers) {\n    const shape = {};\n    for (const [key, ptr] of Object.entries(pointers)) {\n        if (ptr.__kind__ === \"property\") {\n            shape[key] = true;\n        }\n    }\n    return shape;\n}\nfunction PathNode(root, parent, scopeRoot = null) {\n    const obj = {\n        __kind__: index_1.ExpressionKind.PathNode,\n        __element__: root.__element__,\n        __cardinality__: root.__cardinality__,\n        __parent__: parent,\n        __scopeRoot__: scopeRoot,\n    };\n    Object.defineProperty(obj, \"*\", {\n        writable: false,\n        value: getStarShapeFromPointers(obj.__element__.__pointers__),\n    });\n    return $expressionify(obj);\n}\nexports.$PathNode = PathNode;\nconst _pathCache = Symbol();\nconst _pointers = Symbol();\nconst pathifyProxyHandlers = {\n    get(target, prop, proxy) {\n        const ptr = target[_pointers][prop];\n        if (ptr) {\n            return (target[_pathCache][prop] ??\n                (target[_pathCache][prop] = (ptr.__kind__ === \"property\" ? PathLeaf : PathNode)({\n                    __element__: ptr.target,\n                    __cardinality__: cardinality_1.cardutil.multiplyCardinalities(target.__cardinality__, ptr.cardinality),\n                }, {\n                    linkName: prop,\n                    type: proxy,\n                }, ptr.exclusive ?? false, target.__scopeRoot__ ?? (scopeRoots.has(proxy) ? proxy : null))));\n        }\n        return target[prop];\n    },\n};\nfunction $pathify(_root) {\n    if (_root.__element__.__kind__ !== index_1.TypeKind.object) {\n        return _root;\n    }\n    const root = _root;\n    let pointers = {\n        ...root.__element__.__pointers__,\n    };\n    if (root.__parent__) {\n        const { type, linkName } = root.__parent__;\n        const parentPointer = type.__element__.__pointers__[linkName];\n        if (parentPointer?.__kind__ === \"link\") {\n            pointers = { ...pointers, ...parentPointer.properties };\n        }\n    }\n    for (const [key, val] of Object.entries(root.__element__.__shape__ || { id: true })) {\n        if (pointers[key])\n            continue;\n        const valType = val?.__element__;\n        if (!valType)\n            continue;\n        pointers[key] = {\n            __kind__: valType.__kind__ === index_1.TypeKind.object ? \"link\" : \"property\",\n            properties: {},\n            target: val.__element__,\n            cardinality: val.__cardinality__,\n            exclusive: false,\n            computed: true,\n            readonly: true,\n            hasDefault: false,\n        };\n    }\n    root[_pointers] = pointers;\n    root[_pathCache] = {};\n    return new Proxy(root, pathifyProxyHandlers);\n}\nexports.$pathify = $pathify;\nfunction isFunc(expr) {\n    return $expressionify({\n        __kind__: index_1.ExpressionKind.TypeIntersection,\n        __cardinality__: this.__cardinality__,\n        __element__: {\n            ...expr.__element__,\n            __shape__: { id: true },\n        },\n        __expr__: this,\n    });\n}\nfunction $assert_single(expr) {\n    return $expressionify({\n        __kind__: index_1.ExpressionKind.Function,\n        __element__: expr.__element__,\n        __cardinality__: cardinality_1.cardutil.overrideUpperBound(expr.__cardinality__, \"One\"),\n        __name__: \"std::assert_single\",\n        __args__: [expr],\n        __namedargs__: {},\n    });\n}\nexports.$assert_single = $assert_single;\nconst jsonDestructureProxyHandlers = {\n    get(target, prop, proxy) {\n        if (typeof prop === \"string\" && !(prop in target)) {\n            const parsedProp = Number.isInteger(Number(prop)) ? Number(prop) : prop;\n            return jsonDestructure.call(proxy, parsedProp);\n        }\n        return target[prop];\n    },\n};\nfunction jsonDestructure(path) {\n    const pathTypeSet = (0, castMaps_1.literalToTypeSet)(path);\n    return $expressionify({\n        __kind__: index_1.ExpressionKind.Operator,\n        __element__: this.__element__,\n        __cardinality__: cardinality_1.cardutil.multiplyCardinalities(this.__cardinality__, pathTypeSet.__cardinality__),\n        __name__: \"[]\",\n        __opkind__: \"Infix\",\n        __args__: [this, pathTypeSet],\n    });\n}\nfunction $jsonDestructure(_expr) {\n    if (_expr.__element__.__kind__ === index_1.TypeKind.scalar &&\n        _expr.__element__.__name__ === \"std::json\") {\n        const expr = new Proxy(_expr, jsonDestructureProxyHandlers);\n        expr.destructure = jsonDestructure.bind(expr);\n        return expr;\n    }\n    return _expr;\n}\nexports.$jsonDestructure = $jsonDestructure;\nfunction $expressionify(_expr) {\n    const expr = $pathify($jsonDestructure((0, collections_1.$arrayLikeIndexify)((0, collections_1.$tuplePathify)(_expr))));\n    expr.run = query_1.$queryFunc.bind(expr);\n    expr.runJSON = query_1.$queryFuncJSON.bind(expr);\n    expr.is = isFunc.bind(expr);\n    expr.toEdgeQL = toEdgeQL_1.$toEdgeQL.bind(expr);\n    expr.assert_single = () => $assert_single(expr);\n    return Object.freeze(expr);\n}\nexports.$expressionify = $expressionify;\nconst scopedExprCache = new WeakMap();\nconst scopeRoots = new WeakSet();\nfunction $getScopedExpr(expr, existingScopes) {\n    let scopedExpr = scopedExprCache.get(expr);\n    if (!scopedExpr || existingScopes?.has(scopedExpr)) {\n        const isFreeObject = expr.__cardinality__ === index_1.Cardinality.One &&\n            expr.__element__.__name__ === \"std::FreeObject\";\n        scopedExpr = isFreeObject\n            ? expr\n            : $expressionify({\n                ...expr,\n                __cardinality__: index_1.Cardinality.One,\n                __scopedFrom__: expr,\n                ...(expr.__element__.__kind__ === index_1.TypeKind.object\n                    ? {\n                        \"*\": getStarShapeFromPointers(expr.__element__.__pointers__),\n                    }\n                    : {}),\n            });\n        scopeRoots.add(scopedExpr);\n        const uncached = !scopedExpr;\n        if (uncached) {\n            scopedExprCache.set(expr, scopedExpr);\n        }\n    }\n    existingScopes?.add(scopedExpr);\n    return scopedExpr;\n}\nexports.$getScopedExpr = $getScopedExpr;\n"},{"path":"query.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.$queryFuncJSON = exports.$queryFunc = exports.runnableExpressionKinds = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst json_1 = require(\"./json\");\nconst select_1 = require(\"./select\");\nexports.runnableExpressionKinds = new Set([\n    index_1.ExpressionKind.Select,\n    index_1.ExpressionKind.Update,\n    index_1.ExpressionKind.Insert,\n    index_1.ExpressionKind.InsertUnlessConflict,\n    index_1.ExpressionKind.Delete,\n    index_1.ExpressionKind.Group,\n    index_1.ExpressionKind.For,\n    index_1.ExpressionKind.With,\n    index_1.ExpressionKind.WithParams,\n]);\nconst wrappedExprCache = new WeakMap();\nasync function $queryFunc(cxn, args) {\n    const expr = exports.runnableExpressionKinds.has(this.__kind__)\n        ? this\n        : wrappedExprCache.get(this) ??\n            wrappedExprCache.set(this, (0, select_1.select)(this)).get(this);\n    const _args = (0, json_1.jsonifyComplexParams)(expr, args);\n    const query = expr.toEdgeQL();\n    if (expr.__cardinality__ === index_1.Cardinality.One ||\n        expr.__cardinality__ === index_1.Cardinality.AtMostOne ||\n        expr.__cardinality__ === index_1.Cardinality.Empty) {\n        return cxn.querySingle(query, _args);\n    }\n    else {\n        return cxn.query(query, _args);\n    }\n}\nexports.$queryFunc = $queryFunc;\nasync function $queryFuncJSON(cxn, args) {\n    const expr = exports.runnableExpressionKinds.has(this.__kind__)\n        ? this\n        : wrappedExprCache.get(this) ??\n            wrappedExprCache.set(this, (0, select_1.select)(this)).get(this);\n    const _args = (0, json_1.jsonifyComplexParams)(expr, args);\n    if (expr.__cardinality__ === index_1.Cardinality.One ||\n        expr.__cardinality__ === index_1.Cardinality.AtMostOne) {\n        return cxn.querySingleJSON(expr.toEdgeQL(), _args);\n    }\n    else {\n        return cxn.queryJSON(expr.toEdgeQL(), _args);\n    }\n}\nexports.$queryFuncJSON = $queryFuncJSON;\n"},{"path":"range.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.$range = void 0;\nconst edgedb_1 = require(\"edgedb\");\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst castMaps_1 = require(\"./castMaps\");\nconst __spec__1 = require(\"./__spec__\");\nconst literal_1 = require(\"./literal\");\nconst funcops_1 = require(\"./funcops\");\nconst path_1 = require(\"./path\");\nfunction range(...args) {\n    if (args.length === 1) {\n        const arg = args[0];\n        if (arg instanceof edgedb_1.Range) {\n            if (arg.lower === null && arg.upper === null) {\n                throw new Error(`Can't create literal expression from unbounded range. Try this instead:\\n\\n  e.range(e.cast(e.int64, e.set()), e.cast(e.int64, e.set()))`);\n            }\n            if (arg.isEmpty) {\n                throw new Error(`Can't create literal expression from empty range.`);\n            }\n            return (0, literal_1.literal)(range((0, castMaps_1.literalToTypeSet)(arg.lower ?? arg.upper).__element__), arg);\n        }\n        if (arg.__kind__ && !arg.__element__) {\n            return {\n                __kind__: index_1.TypeKind.range,\n                __name__: `range<${arg.__name__}>`,\n                __element__: arg,\n            };\n        }\n    }\n    const { returnType, cardinality, args: positionalArgs, namedArgs, } = (0, funcops_1.$resolveOverload)(\"std::range\", args, __spec__1.spec, [\n        {\n            args: [\n                {\n                    typeId: literal_1.$nameMapping.get(\"std::anypoint\"),\n                    optional: true,\n                    setoftype: false,\n                    variadic: false,\n                },\n                {\n                    typeId: literal_1.$nameMapping.get(\"std::anypoint\"),\n                    optional: true,\n                    setoftype: false,\n                    variadic: false,\n                },\n            ],\n            namedArgs: {\n                inc_lower: {\n                    typeId: literal_1.$nameMapping.get(\"std::bool\"),\n                    optional: true,\n                    setoftype: false,\n                    variadic: false,\n                },\n                inc_upper: {\n                    typeId: literal_1.$nameMapping.get(\"std::bool\"),\n                    optional: true,\n                    setoftype: false,\n                    variadic: false,\n                },\n                empty: {\n                    typeId: literal_1.$nameMapping.get(\"std::bool\"),\n                    optional: true,\n                    setoftype: false,\n                    variadic: false,\n                },\n            },\n            returnTypeId: literal_1.$nameMapping.get(\"range<std::anypoint>\"),\n        },\n    ]);\n    return (0, path_1.$expressionify)({\n        __kind__: index_1.ExpressionKind.Function,\n        __element__: returnType,\n        __cardinality__: cardinality,\n        __name__: \"std::range\",\n        __args__: positionalArgs,\n        __namedargs__: namedArgs,\n    });\n}\nexports.$range = range;\n"},{"path":"reflection.js","content":"\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.$mergeObjectTypes = exports.makeType = exports.cardutil = void 0;\n__exportStar(require(\"edgedb/dist/reflection/index.js\"), exports);\n__exportStar(require(\"./typesystem\"), exports);\nvar cardinality_1 = require(\"./cardinality\");\nObject.defineProperty(exports, \"cardutil\", { enumerable: true, get: function () { return cardinality_1.cardutil; } });\nvar hydrate_1 = require(\"./hydrate\");\nObject.defineProperty(exports, \"makeType\", { enumerable: true, get: function () { return hydrate_1.makeType; } });\nObject.defineProperty(exports, \"$mergeObjectTypes\", { enumerable: true, get: function () { return hydrate_1.$mergeObjectTypes; } });\n"},{"path":"select.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveShapeElement = exports.select = exports.shape = exports.$existingScopes = exports.$selectify = exports.delete = exports.$handleModifiers = exports.is = exports.EMPTY_LAST = exports.EMPTY_FIRST = exports.DESC = exports.ASC = void 0;\nconst edgedb_1 = require(\"edgedb\");\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst hydrate_1 = require(\"./hydrate\");\nconst cardinality_1 = require(\"./cardinality\");\nconst path_1 = require(\"./path\");\nconst path_2 = require(\"./path\");\nconst literal_1 = require(\"./literal\");\nconst __spec__1 = require(\"./__spec__\");\nconst castMaps_1 = require(\"./castMaps\");\nexports.ASC = \"ASC\";\nexports.DESC = \"DESC\";\nexports.EMPTY_FIRST = \"EMPTY FIRST\";\nexports.EMPTY_LAST = \"EMPTY LAST\";\nfunction is(expr, shape) {\n    const mappedShape = {};\n    for (const [key, value] of Object.entries(shape)) {\n        if (key === \"id\")\n            continue;\n        mappedShape[key] = {\n            __kind__: index_1.ExpressionKind.PolyShapeElement,\n            __polyType__: expr,\n            __shapeElement__: value,\n        };\n    }\n    return mappedShape;\n}\nexports.is = is;\nfunction $handleModifiers(modifiers, params) {\n    const { root, scope } = params;\n    const mods = {\n        singleton: !!modifiers[\"filter_single\"],\n    };\n    let card = root.__cardinality__;\n    let needsAssertSingle = false;\n    if (modifiers.filter) {\n        mods.filter = modifiers.filter;\n    }\n    if (modifiers.filter_single) {\n        if (root.__element__.__kind__ !== index_1.TypeKind.object) {\n            throw new Error(\"filter_single can only be used with object types\");\n        }\n        card = index_1.Cardinality.AtMostOne;\n        const fs = modifiers.filter_single;\n        if (fs.__element__) {\n            mods.filter = modifiers.filter_single;\n            needsAssertSingle = true;\n        }\n        else {\n            const exprs = Object.keys(fs).map((key) => {\n                const val = fs[key].__element__\n                    ? fs[key]\n                    : literal_1.literal(root.__element__[\"__pointers__\"][key][\"target\"], fs[key]);\n                return (0, path_2.$expressionify)({\n                    __element__: {\n                        __name__: \"std::bool\",\n                        __kind__: index_1.TypeKind.scalar,\n                    },\n                    __cardinality__: index_1.Cardinality.One,\n                    __kind__: index_1.ExpressionKind.Operator,\n                    __opkind__: index_1.OperatorKind.Infix,\n                    __name__: \"=\",\n                    __args__: [scope[key], val],\n                });\n            });\n            if (exprs.length === 1) {\n                mods.filter = exprs[0];\n            }\n            else {\n                mods.filter = exprs.reduce((a, b) => {\n                    return (0, path_2.$expressionify)({\n                        __element__: {\n                            __name__: \"std::bool\",\n                            __kind__: index_1.TypeKind.scalar,\n                        },\n                        __cardinality__: index_1.Cardinality.One,\n                        __kind__: index_1.ExpressionKind.Operator,\n                        __opkind__: index_1.OperatorKind.Infix,\n                        __name__: \"and\",\n                        __args__: [a, b],\n                    });\n                });\n            }\n        }\n    }\n    if (modifiers.order_by) {\n        const orderExprs = Array.isArray(modifiers.order_by)\n            ? modifiers.order_by\n            : [modifiers.order_by];\n        mods.order_by = orderExprs.map((expr) => typeof expr.__element__ === \"undefined\"\n            ? expr\n            : { expression: expr });\n    }\n    if (modifiers.offset) {\n        mods.offset =\n            typeof modifiers.offset === \"number\"\n                ? (0, literal_1.$getTypeByName)(\"std::number\")(modifiers.offset)\n                : modifiers.offset;\n        card = cardinality_1.cardutil.overrideLowerBound(card, \"Zero\");\n    }\n    if (modifiers.limit) {\n        let expr;\n        if (typeof modifiers.limit === \"number\") {\n            expr = (0, literal_1.$getTypeByName)(\"std::number\")(modifiers.limit);\n        }\n        else {\n            const type = modifiers.limit.__element__.__casttype__ ??\n                modifiers.limit.__element__;\n            if (type.__kind__ === index_1.TypeKind.scalar &&\n                type.__name__ === \"std::number\") {\n                expr = modifiers.limit;\n            }\n            else {\n                throw new Error(\"Invalid value for `limit` modifier\");\n            }\n        }\n        mods.limit = expr;\n        card = cardinality_1.cardutil.overrideLowerBound(card, \"Zero\");\n    }\n    return {\n        modifiers: mods,\n        cardinality: card,\n        needsAssertSingle,\n    };\n}\nexports.$handleModifiers = $handleModifiers;\nfunction deleteExpr(expr, modifiersGetter) {\n    const selectExpr = select(expr, modifiersGetter);\n    return (0, path_2.$expressionify)({\n        __kind__: index_1.ExpressionKind.Delete,\n        __element__: selectExpr.__element__,\n        __cardinality__: selectExpr.__cardinality__,\n        __expr__: selectExpr,\n    });\n}\nexports.delete = deleteExpr;\nfunction $selectify(expr) {\n    return expr;\n}\nexports.$selectify = $selectify;\nconst $FreeObject = (0, hydrate_1.makeType)(__spec__1.spec, [...__spec__1.spec.values()].find((s) => s.name === \"std::FreeObject\").id, literal_1.literal);\nconst FreeObject = {\n    __kind__: index_1.ExpressionKind.PathNode,\n    __element__: $FreeObject,\n    __cardinality__: index_1.Cardinality.One,\n    __parent__: null,\n    __exclusive__: true,\n    __scopeRoot__: null,\n};\nexports.$existingScopes = new Set();\nfunction $shape(_a, b) {\n    return b;\n}\nexports.shape = $shape;\nfunction select(...args) {\n    const firstArg = args[0];\n    if (typeof firstArg !== \"object\" ||\n        firstArg instanceof Uint8Array ||\n        firstArg instanceof Date ||\n        firstArg instanceof edgedb_1.Duration ||\n        firstArg instanceof edgedb_1.LocalDateTime ||\n        firstArg instanceof edgedb_1.LocalDate ||\n        firstArg instanceof edgedb_1.LocalTime ||\n        firstArg instanceof edgedb_1.RelativeDuration ||\n        firstArg instanceof edgedb_1.DateDuration ||\n        firstArg instanceof edgedb_1.ConfigMemory ||\n        firstArg instanceof Float32Array) {\n        const literalExpr = (0, castMaps_1.literalToTypeSet)(firstArg);\n        return (0, path_2.$expressionify)($selectify({\n            __kind__: index_1.ExpressionKind.Select,\n            __element__: literalExpr.__element__,\n            __cardinality__: literalExpr.__cardinality__,\n            __expr__: literalExpr,\n            __modifiers__: {},\n        }));\n    }\n    const exprPair = typeof args[0].__element__ !== \"undefined\"\n        ? args\n        : [FreeObject, () => args[0]];\n    let expr = exprPair[0];\n    const shapeGetter = exprPair[1];\n    if (expr === FreeObject) {\n        const freeObjectPtrs = {};\n        for (const [k, v] of Object.entries(args[0])) {\n            freeObjectPtrs[k] = {\n                __kind__: v.__element__.__kind__ === index_1.TypeKind.object ? \"link\" : \"property\",\n                target: v.__element__,\n                cardinality: v.__cardinality__,\n                exclusive: false,\n                computed: true,\n                readonly: true,\n                hasDefault: false,\n                properties: {},\n            };\n        }\n        expr = {\n            ...FreeObject,\n            __element__: {\n                ...FreeObject.__element__,\n                __pointers__: {\n                    ...FreeObject.__element__.__pointers__,\n                    ...freeObjectPtrs,\n                },\n            },\n        };\n    }\n    if (!shapeGetter) {\n        if (expr.__element__.__kind__ === index_1.TypeKind.object) {\n            const objectExpr = expr;\n            return (0, path_2.$expressionify)($selectify({\n                __kind__: index_1.ExpressionKind.Select,\n                __element__: {\n                    __kind__: index_1.TypeKind.object,\n                    __name__: `${objectExpr.__element__.__name__}`,\n                    __pointers__: objectExpr.__element__.__pointers__,\n                    __shape__: objectExpr.__element__.__shape__,\n                },\n                __cardinality__: objectExpr.__cardinality__,\n                __expr__: objectExpr,\n                __modifiers__: {},\n            }));\n        }\n        else {\n            return (0, path_2.$expressionify)($selectify({\n                __kind__: index_1.ExpressionKind.Select,\n                __element__: expr.__element__,\n                __cardinality__: expr.__cardinality__,\n                __expr__: expr,\n                __modifiers__: {},\n            }));\n        }\n    }\n    const cleanScopedExprs = exports.$existingScopes.size === 0;\n    const { modifiers: mods, shape, scope } = resolveShape(shapeGetter, expr);\n    if (cleanScopedExprs) {\n        exports.$existingScopes.clear();\n    }\n    const { modifiers, cardinality, needsAssertSingle } = $handleModifiers(mods, {\n        root: expr,\n        scope,\n    });\n    const selectExpr = $selectify({\n        __kind__: index_1.ExpressionKind.Select,\n        __element__: expr.__element__.__kind__ === index_1.TypeKind.object\n            ? {\n                __kind__: index_1.TypeKind.object,\n                __name__: `${expr.__element__.__name__}`,\n                __pointers__: expr.__element__.__pointers__,\n                __shape__: shape,\n            }\n            : expr.__element__,\n        __cardinality__: cardinality,\n        __expr__: expr,\n        __modifiers__: modifiers,\n        __scope__: expr !== scope ? scope : undefined,\n    });\n    return needsAssertSingle\n        ? (0, path_1.$assert_single)(selectExpr)\n        : (0, path_2.$expressionify)(selectExpr);\n}\nexports.select = select;\nfunction resolveShape(shapeGetter, expr) {\n    const modifiers = {};\n    const shape = {};\n    const scope = expr.__element__.__kind__ === index_1.TypeKind.object\n        ? (0, path_2.$getScopedExpr)(expr, exports.$existingScopes)\n        : expr;\n    const selectShape = typeof shapeGetter === \"function\" ? shapeGetter(scope) : shapeGetter;\n    for (const [key, value] of Object.entries(selectShape)) {\n        if (key === \"filter\" ||\n            key === \"filter_single\" ||\n            key === \"order_by\" ||\n            key === \"offset\" ||\n            key === \"limit\") {\n            modifiers[key] = value;\n        }\n        else {\n            if (expr.__element__.__kind__ !== index_1.TypeKind.object) {\n                throw new Error(`Invalid select shape key '${key}' on scalar expression, ` +\n                    `only modifiers are allowed (filter, order_by, offset and limit)`);\n            }\n            shape[key] = resolveShapeElement(key, value, scope);\n        }\n    }\n    return { shape, modifiers, scope };\n}\nfunction resolveShapeElement(key, value, scope) {\n    const isSubshape = typeof value === \"object\" && typeof value.__kind__ === \"undefined\";\n    const isClosure = typeof value === \"function\" &&\n        scope.__element__.__pointers__[key]?.__kind__ === \"link\";\n    if (isSubshape || isClosure) {\n        const childExpr = scope[key];\n        if (!childExpr) {\n            throw new Error(`Invalid shape element \"${key}\" for type ${scope.__element__.__name__}`);\n        }\n        const { shape: childShape, scope: childScope, modifiers: mods, } = resolveShape(value, childExpr);\n        const { modifiers, needsAssertSingle } = $handleModifiers(mods, {\n            root: childExpr,\n            scope: childScope,\n        });\n        const selectExpr = {\n            __kind__: index_1.ExpressionKind.Select,\n            __element__: {\n                __kind__: index_1.TypeKind.object,\n                __name__: `${childExpr.__element__.__name__}`,\n                __pointers__: childExpr.__element__.__pointers__,\n                __shape__: childShape,\n            },\n            __cardinality__: scope.__element__.__pointers__?.[key]?.cardinality ||\n                scope.__element__.__shape__?.[key]?.__cardinality__,\n            __expr__: childExpr,\n            __modifiers__: modifiers,\n            __scope__: childExpr !== childScope ? childScope : undefined,\n        };\n        return needsAssertSingle ? (0, path_1.$assert_single)(selectExpr) : selectExpr;\n    }\n    else if (value?.__kind__ === index_1.ExpressionKind.PolyShapeElement) {\n        const polyElement = value;\n        const polyScope = scope.is(polyElement.__polyType__);\n        return {\n            __kind__: index_1.ExpressionKind.PolyShapeElement,\n            __polyType__: polyScope,\n            __shapeElement__: resolveShapeElement(key, polyElement.__shapeElement__, polyScope),\n        };\n    }\n    else if (typeof value === \"boolean\" && key.startsWith(\"@\")) {\n        const linkProp = scope[key];\n        if (!linkProp) {\n            throw new Error(scope.__parent__\n                ? `link property '${key}' does not exist on link ${scope.__parent__.linkName}`\n                : `cannot select link property '${key}' on an object (${scope.__element__.__name__})`);\n        }\n        return value ? linkProp : false;\n    }\n    else {\n        return value;\n    }\n}\nexports.resolveShapeElement = resolveShapeElement;\n"},{"path":"set.js","content":"\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.set = exports.getSharedParent = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst hydrate_1 = require(\"./hydrate\");\nconst castMaps = __importStar(require(\"./castMaps\"));\nfunction getSharedParent(a, b) {\n    if (a.__kind__ !== b.__kind__) {\n        throw new Error(`Incompatible array types: ${a.__name__} and ${b.__name__}`);\n    }\n    if (a.__kind__ === index_1.TypeKind.scalar && b.__kind__ === index_1.TypeKind.scalar) {\n        return castMaps.getSharedParentScalar(a, b);\n    }\n    else if (a.__kind__ === index_1.TypeKind.object && b.__kind__ === index_1.TypeKind.object) {\n        return (0, hydrate_1.$mergeObjectTypes)(a, b);\n    }\n    else if (a.__kind__ === index_1.TypeKind.tuple && b.__kind__ === index_1.TypeKind.tuple) {\n        if (a.__items__.length !== b.__items__.length) {\n            throw new Error(`Incompatible tuple types: ${a.__name__} and ${b.__name__}`);\n        }\n        try {\n            const items = a.__items__.map((_, i) => {\n                if (!a.__items__[i] || !b.__items__[i]) {\n                    throw new Error();\n                }\n                return getSharedParent(a.__items__[i], b.__items__[i]);\n            });\n            return {\n                __kind__: index_1.TypeKind.tuple,\n                __name__: `tuple<${items.map((item) => item.__name__).join(\", \")}>`,\n                __items__: items,\n            };\n        }\n        catch (err) {\n            throw new Error(`Incompatible tuple types: ${a.__name__} and ${b.__name__}`);\n        }\n    }\n    else if (a.__kind__ === index_1.TypeKind.namedtuple &&\n        b.__kind__ === index_1.TypeKind.namedtuple) {\n        const aKeys = Object.keys(a);\n        const bKeys = new Set(Object.keys(b));\n        const sameKeys = aKeys.length === bKeys.size && aKeys.every((k) => bKeys.has(k));\n        if (!sameKeys) {\n            throw new Error(`Incompatible tuple types: ${a.__name__} and ${b.__name__}`);\n        }\n        try {\n            const items = {};\n            for (const [i] of Object.entries(a.__shape__)) {\n                if (!a.__shape__[i] || !b.__shape__[i]) {\n                    throw new Error();\n                }\n                items[i] = getSharedParent(a.__shape__[i], b.__shape__[i]);\n            }\n            return {\n                __kind__: index_1.TypeKind.namedtuple,\n                __name__: `tuple<${Object.entries(items)\n                    .map(([key, val]) => `${key}: ${val.__name__}`)\n                    .join(\", \")}>`,\n                __shape__: items,\n            };\n        }\n        catch (err) {\n            throw new Error(`Incompatible tuple types: ${a.__name__} and ${b.__name__}`);\n        }\n    }\n    else if (a.__kind__ === index_1.TypeKind.array && b.__kind__ === index_1.TypeKind.array) {\n        try {\n            const mergedEl = getSharedParent(a.__element__, b.__element__);\n            return {\n                __kind__: index_1.TypeKind.array,\n                __name__: a.__name__,\n                __element__: mergedEl,\n            };\n        }\n        catch (err) {\n            throw new Error(`Incompatible array types: ${a.__name__} and ${b.__name__}`);\n        }\n    }\n    else if (a.__kind__ === index_1.TypeKind.enum && b.__kind__ === index_1.TypeKind.enum) {\n        if (a.__name__ === b.__name__)\n            return a;\n        throw new Error(`Incompatible array types: ${a.__name__} and ${b.__name__}`);\n    }\n    else {\n        throw new Error(`Incompatible array types: ${a.__name__} and ${b.__name__}`);\n    }\n}\nexports.getSharedParent = getSharedParent;\nvar setImpl_1 = require(\"./setImpl\");\nObject.defineProperty(exports, \"set\", { enumerable: true, get: function () { return setImpl_1.set; } });\n"},{"path":"setImpl.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.set = void 0;\nfunction set(...args) { }\nexports.set = set;\n"},{"path":"syntax.js","content":"\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./literal\"), exports);\n__exportStar(require(\"./path\"), exports);\n__exportStar(require(\"./set\"), exports);\n__exportStar(require(\"./cast\"), exports);\n__exportStar(require(\"./select\"), exports);\n__exportStar(require(\"./update\"), exports);\n__exportStar(require(\"./insert\"), exports);\n__exportStar(require(\"./group\"), exports);\n__exportStar(require(\"./collections\"), exports);\n__exportStar(require(\"./funcops\"), exports);\n__exportStar(require(\"./for\"), exports);\n__exportStar(require(\"./with\"), exports);\n__exportStar(require(\"./params\"), exports);\n__exportStar(require(\"./globals\"), exports);\n__exportStar(require(\"./detached\"), exports);\n__exportStar(require(\"./toEdgeQL\"), exports);\n__exportStar(require(\"./range\"), exports);\n"},{"path":"toEdgeQL.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.$toEdgeQL = void 0;\nconst edgedb_1 = require(\"edgedb\");\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst typesystem_1 = require(\"./typesystem\");\nconst index_2 = require(\"edgedb/dist/reflection/index.js\");\nfunction $toEdgeQL() {\n    const walkExprCtx = {\n        seen: new Map(),\n        rootScope: null,\n    };\n    walkExprTree(this, null, walkExprCtx);\n    const withBlocks = new Map();\n    const withVars = new Map();\n    const seen = new Map(walkExprCtx.seen);\n    const linkProps = new Map();\n    for (const [expr, refData] of seen) {\n        seen.delete(expr);\n        if (refData.linkProps.length) {\n            linkProps.set(expr, refData.linkProps.map((linkProp) => linkProp.__parent__.linkName.slice(1)));\n        }\n        if (withVars.has(expr)) {\n            continue;\n        }\n        if (!refData.boundScope &&\n            (expr.__kind__ === index_1.ExpressionKind.PathLeaf ||\n                expr.__kind__ === index_1.ExpressionKind.PathNode ||\n                expr.__kind__ === index_1.ExpressionKind.TypeIntersection)) {\n            continue;\n        }\n        if (expr.__kind__ === index_1.ExpressionKind.ForVar ||\n            expr.__kind__ === index_1.ExpressionKind.Param) {\n            continue;\n        }\n        if ((expr.__kind__ === index_1.ExpressionKind.Select ||\n            expr.__kind__ === index_1.ExpressionKind.Update ||\n            expr.__kind__ === index_1.ExpressionKind.Group) &&\n            expr.__scope__ &&\n            !withVars.has(expr.__scope__)) {\n            const withBlock = expr;\n            const scopeVar = expr.__scope__;\n            const scopeVarName = `__scope_${withVars.size}_${scopeVar.__element__.__name__.replace(/[^A-Za-z]/g, \"\")}`;\n            withVars.set(scopeVar, {\n                name: scopeVarName,\n                scope: withBlock,\n                childExprs: new Set(),\n                scopedExpr: expr.__element__.__kind__ === index_1.TypeKind.object\n                    ? expr.__expr__\n                    : undefined,\n            });\n        }\n        if (refData.refCount > 1 ||\n            refData.boundScope ||\n            refData.aliases.length > 0) {\n            let withBlock = refData.boundScope;\n            const parentScopes = [...refData.parentScopes];\n            if (!withBlock) {\n                if (parentScopes.some((parentScope) => parentScope && seen.has(parentScope))) {\n                    seen.set(expr, refData);\n                    continue;\n                }\n                if (parentScopes.some((scope) => scope == null)) {\n                    throw new Error(`Cannot extract repeated expression into 'WITH' block, ` +\n                        `expression used outside of 'WITH'able expression`);\n                }\n                const [firstParentScopeChain, ...parentScopeChains] = parentScopes.map((scope) => {\n                    const scopes = [scope];\n                    const pendingScopes = [scope];\n                    while (pendingScopes.length) {\n                        const currentScope = pendingScopes.shift();\n                        pendingScopes.push(...[...walkExprCtx.seen.get(currentScope).parentScopes].filter((s) => s !== null));\n                        if (!scopes.includes(currentScope)) {\n                            scopes.push(currentScope);\n                        }\n                    }\n                    return scopes;\n                });\n                const commonParentScope = firstParentScopeChain\n                    ? firstParentScopeChain.find((scope) => parentScopeChains.every((otherScope) => otherScope.includes(scope)))\n                    : null;\n                withBlock = commonParentScope ?? walkExprCtx.rootScope;\n            }\n            if (!withBlock) {\n                throw new Error(`Cannot extract repeated expression into 'WITH' block, ` +\n                    `expression does not appear within common 'WITH'able expression`);\n            }\n            if (!withBlocks.has(withBlock)) {\n                withBlocks.set(withBlock, new Set());\n            }\n            const validScopes = new Set([\n                withBlock,\n                ...walkExprCtx.seen.get(withBlock).childExprs,\n            ]);\n            for (const scope of [\n                ...refData.parentScopes,\n                ...index_1.util.flatMap(refData.aliases, (alias) => [\n                    ...walkExprCtx.seen.get(alias).parentScopes,\n                ]),\n            ]) {\n                if (scope === null || !validScopes.has(scope)) {\n                    throw new Error(refData.boundScope\n                        ? `Expr or its aliases used outside of declared 'WITH' block scope`\n                        : `Cannot extract repeated or aliased expression into 'WITH' block, ` +\n                            `expression or its aliases appear outside root scope`);\n                }\n            }\n            for (const withVar of [expr, ...refData.aliases]) {\n                const withVarBoundScope = walkExprCtx.seen.get(withVar).boundScope;\n                if (withVarBoundScope && withVarBoundScope !== refData.boundScope) {\n                    continue;\n                }\n                const withVarName = `__withVar_${withVars.size}`;\n                withBlocks.get(withBlock).add(withVar);\n                withVars.set(withVar, {\n                    name: withVarName,\n                    scope: withBlock,\n                    childExprs: new Set(walkExprCtx.seen.get(withVar).childExprs),\n                });\n            }\n        }\n    }\n    let edgeQL = renderEdgeQL(this, {\n        withBlocks,\n        withVars,\n        forVars: new Map(),\n        linkProps,\n    });\n    if (edgeQL.startsWith(\"(\") &&\n        edgeQL.endsWith(\")\") &&\n        !(this.__kind__ === index_1.ExpressionKind.Tuple ||\n            this.__kind__ === index_1.ExpressionKind.NamedTuple ||\n            this.__kind__ === index_1.ExpressionKind.Literal)) {\n        edgeQL = edgeQL.slice(1, -1);\n    }\n    return edgeQL;\n}\nexports.$toEdgeQL = $toEdgeQL;\nfunction walkExprTree(_expr, parentScope, ctx) {\n    if (!_expr.__kind__) {\n        throw new Error(`Expected a valid querybuilder expression, ` +\n            `instead received ${typeof _expr}${typeof _expr !== \"undefined\" ? `: '${_expr}'` : \"\"}.` +\n            getErrorHint(_expr));\n    }\n    const expr = _expr;\n    function walkShape(shape) {\n        for (let param of Object.values(shape)) {\n            if (param.__kind__ === index_1.ExpressionKind.PolyShapeElement) {\n                param = param.__shapeElement__;\n            }\n            if (typeof param === \"object\") {\n                if (!!param.__kind__) {\n                    childExprs.push(...walkExprTree(param, expr, ctx));\n                }\n                else {\n                    walkShape(param);\n                }\n            }\n        }\n    }\n    if (!ctx.rootScope && parentScope) {\n        ctx.rootScope = parentScope;\n    }\n    const seenExpr = ctx.seen.get(expr);\n    if (seenExpr) {\n        seenExpr.refCount += 1;\n        seenExpr.parentScopes.add(parentScope);\n        return [expr, ...seenExpr.childExprs];\n    }\n    const childExprs = [];\n    ctx.seen.set(expr, {\n        refCount: 1,\n        parentScopes: new Set([parentScope]),\n        childExprs,\n        boundScope: null,\n        aliases: [],\n        linkProps: [],\n    });\n    switch (expr.__kind__) {\n        case index_1.ExpressionKind.Alias:\n            childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n            ctx.seen.get(expr.__expr__).aliases.push(expr);\n            break;\n        case index_1.ExpressionKind.With:\n            childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n            for (const refExpr of expr.__refs__) {\n                walkExprTree(refExpr, expr.__expr__, ctx);\n                const seenRef = ctx.seen.get(refExpr);\n                if (seenRef.boundScope) {\n                    throw new Error(`Expression bound to multiple 'WITH' blocks`);\n                }\n                seenRef.boundScope = expr.__expr__;\n            }\n            break;\n        case index_1.ExpressionKind.Literal:\n        case index_1.ExpressionKind.ForVar:\n        case index_1.ExpressionKind.Param:\n            break;\n        case index_1.ExpressionKind.PathLeaf:\n        case index_1.ExpressionKind.PathNode:\n            if (expr.__parent__) {\n                if (expr.__parent__.type.__scopedFrom__) {\n                    childExprs.push(expr.__parent__.type);\n                }\n                else {\n                    childExprs.push(...walkExprTree(expr.__parent__.type, parentScope, ctx));\n                }\n                if (expr.__kind__ === index_1.ExpressionKind.PathLeaf &&\n                    expr.__parent__.linkName.startsWith(\"@\")) {\n                    const parentScopeVar = parentScope.__scope__;\n                    if (parentScopeVar === expr.__parent__.type) {\n                        ctx.seen.get(parentScope)?.linkProps.push(expr);\n                    }\n                }\n            }\n            break;\n        case index_1.ExpressionKind.Cast:\n            if (expr.__expr__ === null)\n                break;\n            childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n            break;\n        case index_1.ExpressionKind.Set:\n            for (const subExpr of expr.__exprs__) {\n                childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n            }\n            break;\n        case index_1.ExpressionKind.Array:\n            for (const subExpr of expr.__items__) {\n                childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n            }\n            break;\n        case index_1.ExpressionKind.Tuple:\n            for (const subExpr of expr.__items__) {\n                childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n            }\n            break;\n        case index_1.ExpressionKind.NamedTuple:\n            for (const subExpr of Object.values(expr.__shape__)) {\n                childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n            }\n            break;\n        case index_1.ExpressionKind.TuplePath:\n            childExprs.push(...walkExprTree(expr.__parent__, parentScope, ctx));\n            break;\n        case index_1.ExpressionKind.Select:\n        case index_1.ExpressionKind.Update: {\n            const modifiers = expr.__modifiers__;\n            if (modifiers.filter) {\n                childExprs.push(...walkExprTree(modifiers.filter, expr, ctx));\n            }\n            if (modifiers.order_by) {\n                for (const orderExpr of modifiers.order_by) {\n                    childExprs.push(...walkExprTree(orderExpr.expression, expr, ctx));\n                }\n            }\n            if (modifiers.offset) {\n                childExprs.push(...walkExprTree(modifiers.offset, expr, ctx));\n            }\n            if (modifiers.limit) {\n                childExprs.push(...walkExprTree(modifiers.limit, expr, ctx));\n            }\n            if (expr.__kind__ === index_1.ExpressionKind.Select) {\n                if ((0, typesystem_1.isObjectType)(expr.__element__) &&\n                    expr.__element__.__shape__ !==\n                        expr.__expr__.__element__.__shape__) {\n                    walkShape(expr.__element__.__shape__ ?? {});\n                }\n            }\n            else {\n                const shape = expr.__shape__ ?? {};\n                for (const _element of Object.values(shape)) {\n                    let element = _element;\n                    if (!element.__element__) {\n                        if (element[\"+=\"])\n                            element = element[\"+=\"];\n                        else if (element[\"-=\"])\n                            element = element[\"-=\"];\n                    }\n                    childExprs.push(...walkExprTree(element, expr, ctx));\n                }\n            }\n            childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\n            break;\n        }\n        case index_1.ExpressionKind.Delete: {\n            childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n            break;\n        }\n        case index_1.ExpressionKind.Insert: {\n            const shape = expr.__shape__ ?? {};\n            for (const element of Object.values(shape)) {\n                childExprs.push(...walkExprTree(element, expr, ctx));\n            }\n            childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\n            break;\n        }\n        case index_1.ExpressionKind.InsertUnlessConflict: {\n            const insertChildExprs = [];\n            if (expr.__conflict__.on) {\n                insertChildExprs.push(...walkExprTree(expr.__conflict__.on, expr.__expr__, ctx));\n            }\n            if (expr.__conflict__.else) {\n                insertChildExprs.push(...walkExprTree(expr.__conflict__.else, expr.__expr__, ctx));\n            }\n            walkExprTree(expr.__expr__, parentScope, ctx);\n            ctx.seen\n                .get(expr.__expr__)\n                .childExprs.push(...insertChildExprs);\n            break;\n        }\n        case index_1.ExpressionKind.Group: {\n            const groupingSet = expr.__modifiers__.by;\n            for (const [_k, groupExpr] of groupingSet.__exprs__) {\n                const seen = new Set();\n                if (!seen.has(expr)) {\n                    childExprs.push(...walkExprTree(groupExpr, expr, ctx));\n                    seen.add(expr);\n                }\n            }\n            if (!expr.__element__.__shape__.elements.__element__.__shape__) {\n                throw new Error(\"Missing shape in GROUP statement\");\n            }\n            walkShape(expr.__element__.__shape__.elements.__element__.__shape__);\n            childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\n            break;\n        }\n        case index_1.ExpressionKind.TypeIntersection:\n            childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n            break;\n        case index_1.ExpressionKind.Operator:\n        case index_1.ExpressionKind.Function:\n            for (const subExpr of expr.__args__) {\n                if (Array.isArray(subExpr)) {\n                    for (const arg of subExpr) {\n                        if (arg)\n                            childExprs.push(...walkExprTree(arg, parentScope, ctx));\n                    }\n                }\n                else {\n                    childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n                }\n            }\n            if (expr.__kind__ === index_1.ExpressionKind.Function) {\n                for (const subExpr of Object.values(expr.__namedargs__)) {\n                    childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n                }\n            }\n            break;\n        case index_1.ExpressionKind.For: {\n            childExprs.push(...walkExprTree(expr.__iterSet__, expr, ctx));\n            childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\n            break;\n        }\n        case index_1.ExpressionKind.WithParams: {\n            if (parentScope !== null) {\n                throw new Error(`'withParams' does not support being used as a nested expression`);\n            }\n            childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n            break;\n        }\n        case index_1.ExpressionKind.Detached: {\n            childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n            break;\n        }\n        case index_1.ExpressionKind.Global:\n            break;\n        default:\n            index_1.util.assertNever(expr, new Error(`Unrecognized expression kind: \"${expr.__kind__}\"`));\n    }\n    return [expr, ...childExprs];\n}\nfunction renderEdgeQL(_expr, ctx, renderShape = true, noImplicitDetached = false) {\n    if (!_expr.__kind__) {\n        throw new Error(\"Invalid expression.\");\n    }\n    const expr = _expr;\n    const withVar = ctx.withVars.get(expr);\n    if (withVar && ctx.renderWithVar !== expr) {\n        return renderShape &&\n            expr.__kind__ === index_1.ExpressionKind.Select &&\n            (0, typesystem_1.isObjectType)(expr.__element__)\n            ? `(${withVar.name} ${shapeToEdgeQL((expr.__element__.__shape__ || {}), ctx, null, true)})`\n            : withVar.name;\n    }\n    function renderWithBlockExpr(varExpr, _noImplicitDetached) {\n        const withBlockElement = ctx.withVars.get(varExpr);\n        let renderedExpr = renderEdgeQL(withBlockElement.scopedExpr ?? varExpr, {\n            ...ctx,\n            renderWithVar: varExpr,\n        }, !withBlockElement.scopedExpr, _noImplicitDetached);\n        const renderedExprNoDetached = renderEdgeQL(withBlockElement.scopedExpr ?? varExpr, {\n            ...ctx,\n            renderWithVar: varExpr,\n        }, !withBlockElement.scopedExpr, true);\n        if (ctx.linkProps.has(expr)) {\n            renderedExpr = `(SELECT ${renderedExpr} {\\n${ctx.linkProps\n                .get(expr)\n                .map((linkPropName) => `  __linkprop_${linkPropName} := ${renderedExprNoDetached}@${linkPropName}`)\n                .join(\",\\n\")}\\n})`;\n        }\n        return `  ${withBlockElement.name} := ${renderedExpr.includes(\"\\n\")\n            ? `(\\n${indent(renderedExpr[0] === \"(\" &&\n                renderedExpr[renderedExpr.length - 1] === \")\"\n                ? renderedExpr.slice(1, -1)\n                : renderedExpr, 4)}\\n  )`\n            : renderedExpr}`;\n    }\n    const scopeExpr = (expr.__kind__ === index_1.ExpressionKind.Select ||\n        expr.__kind__ === index_1.ExpressionKind.Update ||\n        expr.__kind__ === index_1.ExpressionKind.Group) &&\n        ctx.withVars.has(expr.__scope__)\n        ? expr.__scope__\n        : undefined;\n    const scopeExprVar = [];\n    const unscopedWithBlock = [];\n    const scopedWithBlock = [];\n    if (ctx.withBlocks.has(expr) || scopeExpr) {\n        const sortedBlockVars = topoSortWithVars(ctx.withBlocks.get(expr) ?? new Set(), ctx);\n        if (!scopeExpr) {\n            unscopedWithBlock.push(...sortedBlockVars.map((blockVar) => renderWithBlockExpr(blockVar)));\n        }\n        else {\n            const scopeVar = ctx.withVars.get(scopeExpr);\n            const scopedVars = sortedBlockVars.filter((blockVarExpr) => ctx.withVars.get(blockVarExpr)?.childExprs.has(scopeExpr));\n            unscopedWithBlock.push(...sortedBlockVars\n                .filter((blockVar) => !scopedVars.includes(blockVar))\n                .map((blockVar) => renderWithBlockExpr(blockVar)));\n            if (!scopedVars.length) {\n                scopeExprVar.push(renderWithBlockExpr(scopeExpr, noImplicitDetached));\n            }\n            else {\n                const scopeName = scopeVar.name;\n                scopeVar.name = scopeName + \"_expr\";\n                scopeExprVar.push(renderWithBlockExpr(scopeExpr, noImplicitDetached));\n                scopeVar.name = scopeName + \"_inner\";\n                scopeExprVar.push(`  ${scopeName} := (FOR ${scopeVar.name} IN {${scopeName + \"_expr\"}} UNION (\\n    WITH\\n${indent(scopedVars\n                    .map((blockVar) => renderWithBlockExpr(blockVar))\n                    .join(\",\\n\"), 4)}\\n    SELECT ${scopeVar.name} {\\n${scopedVars\n                    .map((blockVar) => {\n                    const name = ctx.withVars.get(blockVar).name;\n                    return `      ${name} := ${name}`;\n                })\n                    .join(\",\\n\")}\\n    }\\n  ))`);\n                scopeVar.name = scopeName;\n                for (const blockVarExpr of scopedVars) {\n                    const blockVar = ctx.withVars.get(blockVarExpr);\n                    blockVar.name = `${scopeName}.${blockVar.name}`;\n                }\n            }\n        }\n    }\n    const withBlockElements = [\n        ...unscopedWithBlock,\n        ...scopeExprVar,\n        ...scopedWithBlock,\n    ];\n    const withBlock = withBlockElements.length\n        ? `WITH\\n${withBlockElements.join(\",\\n\")}\\n`\n        : \"\";\n    if (expr.__kind__ === index_1.ExpressionKind.With) {\n        return renderEdgeQL(expr.__expr__, ctx);\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.WithParams) {\n        return `(WITH\\n${expr.__params__\n            .map((param) => {\n            const optional = param.__cardinality__ === index_1.Cardinality.AtMostOne ? \"OPTIONAL \" : \"\";\n            let paramExpr;\n            if (param.__isComplex__) {\n                let cast = param.__element__.__name__;\n                cast = cast.includes(\"std::decimal\")\n                    ? `<${cast}><${cast.replace(/std::decimal/g, \"std::str\")}>`\n                    : `<${cast}>`;\n                paramExpr = `${cast}to_json(<${optional}str>$${param.__name__})`;\n            }\n            else {\n                paramExpr = `<${optional}${param.__element__.__name__}>$${param.__name__}`;\n            }\n            return `  __param__${param.__name__} := ${paramExpr}`;\n        })\n            .join(\",\\n\")}\\nSELECT ${renderEdgeQL(expr.__expr__, ctx)})`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Alias) {\n        const aliasedExprVar = ctx.withVars.get(expr.__expr__);\n        if (!aliasedExprVar) {\n            throw new Error(`Expression referenced by alias does not exist in 'WITH' block`);\n        }\n        return aliasedExprVar.name;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.PathNode ||\n        expr.__kind__ === index_1.ExpressionKind.PathLeaf) {\n        if (!expr.__parent__) {\n            return `${noImplicitDetached ? \"\" : \"DETACHED \"}${expr.__element__.__name__}`;\n        }\n        else {\n            const isScopedLinkProp = expr.__parent__.linkName.startsWith(\"@\") &&\n                ctx.withVars.has(expr.__parent__.type);\n            const linkName = isScopedLinkProp\n                ? `__linkprop_${expr.__parent__.linkName.slice(1)}`\n                : expr.__parent__.linkName;\n            const parent = renderEdgeQL(expr.__parent__.type, ctx, false, noImplicitDetached);\n            return `${parent}${linkName.startsWith(\"@\") ? \"\" : \".\"}${q(linkName)}`;\n        }\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Literal) {\n        return literalToEdgeQL(expr.__element__, expr.__value__);\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Set) {\n        const exprs = expr.__exprs__;\n        if (exprs.every((ex) => ex.__element__.__kind__ === index_1.TypeKind.object) ||\n            exprs.every((ex) => ex.__element__.__kind__ !== index_1.TypeKind.object)) {\n            if (exprs.length === 0)\n                return `<${expr.__element__.__name__}>{}`;\n            return `{ ${exprs.map((ex) => renderEdgeQL(ex, ctx)).join(\", \")} }`;\n        }\n        else {\n            throw new Error(`Invalid arguments to set constructor: ${exprs\n                .map((ex) => ex.__element__.__name__)\n                .join(\", \")}`);\n        }\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Array) {\n        return `[${expr.__items__\n            .map((item) => renderEdgeQL(item, ctx))\n            .join(\", \")}]`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Tuple) {\n        return `(\\n${expr.__items__\n            .map((item) => `  ` + renderEdgeQL(item, ctx, renderShape, noImplicitDetached))\n            .join(\",\\n\")}${expr.__items__.length === 1 ? \",\" : \"\"}\\n)`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.NamedTuple) {\n        return `(\\n${Object.keys(expr.__shape__)\n            .map((key) => `  ${key} := ${renderEdgeQL(expr.__shape__[key], ctx, renderShape, noImplicitDetached)}`)\n            .join(\",\\n\")}\\n)`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.TuplePath) {\n        return `${renderEdgeQL(expr.__parent__, ctx)}.${expr.__index__}`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Cast) {\n        const typeName = expr.__element__.__name__ === \"std::number\"\n            ? \"std::float64\"\n            : expr.__element__.__name__;\n        if (expr.__expr__ === null) {\n            return `<${typeName}>{}`;\n        }\n        return `<${typeName}>(${renderEdgeQL(expr.__expr__, ctx)})`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Select) {\n        const lines = [];\n        if ((0, typesystem_1.isObjectType)(expr.__element__)) {\n            const selectionTarget = renderEdgeQL(expr.__scope__ ?? expr.__expr__, ctx, false);\n            lines.push(`SELECT${selectionTarget === \"DETACHED std::FreeObject\"\n                ? \"\"\n                : ` ${selectionTarget}`}`);\n            if (expr.__element__.__shape__ !==\n                expr.__expr__.__element__.__shape__) {\n                lines.push(shapeToEdgeQL((expr.__element__.__shape__ || {}), ctx, expr.__element__));\n            }\n        }\n        else {\n            const needsScalarVar = (expr.__modifiers__.filter ||\n                expr.__modifiers__.order_by ||\n                expr.__modifiers__.offset ||\n                expr.__modifiers__.limit) &&\n                !ctx.withVars.has(expr.__expr__);\n            lines.push(`SELECT ${needsScalarVar ? \"_ := \" : \"\"}${renderEdgeQL(expr.__expr__, ctx)}`);\n            if (needsScalarVar) {\n                ctx = { ...ctx, withVars: new Map(ctx.withVars) };\n                ctx.withVars.set(expr.__expr__, {\n                    name: \"_\",\n                    childExprs: new Set(),\n                    scope: expr,\n                });\n            }\n        }\n        const modifiers = [];\n        if (expr.__modifiers__.filter) {\n            modifiers.push(`FILTER ${renderEdgeQL(expr.__modifiers__.filter, ctx)}`);\n        }\n        if (expr.__modifiers__.order_by) {\n            modifiers.push(...expr.__modifiers__.order_by.map(({ expression, direction, empty }, i) => {\n                return `${i === 0 ? \"ORDER BY\" : \"  THEN\"} ${renderEdgeQL(expression, ctx)}${direction ? \" \" + direction : \"\"}${empty ? \" \" + empty : \"\"}`;\n            }));\n        }\n        if (expr.__modifiers__.offset) {\n            modifiers.push(`OFFSET ${renderEdgeQL(expr.__modifiers__.offset, ctx)}`);\n        }\n        if (expr.__modifiers__.limit) {\n            modifiers.push(`LIMIT ${renderEdgeQL(expr.__modifiers__.limit, ctx)}`);\n        }\n        return (\"(\" +\n            withBlock +\n            lines.join(\" \") +\n            (modifiers.length ? \"\\n\" + modifiers.join(\"\\n\") : \"\") +\n            \")\");\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Update) {\n        return `(${withBlock}UPDATE ${renderEdgeQL(expr.__scope__, ctx, false)}${expr.__modifiers__.filter\n            ? `\\nFILTER ${renderEdgeQL(expr.__modifiers__.filter, ctx)}\\n`\n            : \" \"}SET ${shapeToEdgeQL(expr.__shape__, ctx, null, false, false)})`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Delete) {\n        return `(${withBlock}DELETE ${renderEdgeQL(expr.__expr__, ctx, undefined, noImplicitDetached)})`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Insert) {\n        return `(${withBlock}INSERT ${renderEdgeQL(expr.__expr__, ctx, false, true)} ${shapeToEdgeQL(expr.__shape__, ctx, null, false, false)})`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.InsertUnlessConflict) {\n        const $on = expr.__conflict__.on;\n        const $else = expr.__conflict__.else;\n        const clause = [];\n        if (!$on) {\n            clause.push(\"\\nUNLESS CONFLICT\");\n        }\n        if ($on) {\n            clause.push(`\\nUNLESS CONFLICT ON ${renderEdgeQL($on, ctx, false, true)}`);\n        }\n        if ($else) {\n            clause.push(`\\nELSE (${renderEdgeQL($else, ctx, true, true)})`);\n        }\n        return `(${renderEdgeQL(expr.__expr__, ctx, false, true).slice(1, -1)}${clause.join(\"\")})`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Group) {\n        const groupingSet = expr.__modifiers__.by;\n        const elementsShape = expr.__element__.__shape__.elements.__element__.__shape__;\n        const selectStatement = [];\n        const groupStatement = [];\n        const groupTarget = renderEdgeQL(expr.__scope__, ctx, false);\n        groupStatement.push(`GROUP ${groupTarget}`);\n        const combinedBlock = [\n            ...groupingSet.__exprs__.map(([k, v]) => `  ${k} := ${renderEdgeQL(v, ctx)}`),\n        ];\n        groupStatement.push(`USING\\n${combinedBlock.join(\",\\n\")}`);\n        let by = renderGroupingSet(groupingSet).trim();\n        if (by[0] === \"(\" && by[by.length - 1] === \")\") {\n            by = by.slice(1, by.length - 1);\n        }\n        groupStatement.push(`BY ` + by);\n        const selectTarget = `${groupTarget}_groups`;\n        selectStatement.push(`WITH\\n${[\n            ...unscopedWithBlock,\n            ...scopeExprVar,\n        ].join(\",\\n\")},\r\n  ${selectTarget} := (\r\n${indent(groupStatement.join(\"\\n\"), 4)}\r\n)`);\n        const scopeVar = ctx.withVars.get(expr.__scope__);\n        const elementsShapeQuery = indent(shapeToEdgeQL(elementsShape, { ...ctx }, expr.__element__), 2)\n            .trim()\n            .split(scopeVar.name + \".\")\n            .join(`${selectTarget}.elements.`);\n        selectStatement.push(`SELECT ${selectTarget} {\r\n  key: {${groupingSet.__exprs__.map((e) => e[0]).join(\", \")}},\r\n  grouping,\r\n  elements: ${elementsShapeQuery}\r\n}`);\n        return `(${selectStatement.join(\"\\n\")})`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Function) {\n        const args = expr.__args__.map((arg) => `${renderEdgeQL(arg, ctx, false)}`);\n        for (const [key, arg] of Object.entries(expr.__namedargs__)) {\n            args.push(`${q(key)} := ${renderEdgeQL(arg, ctx, false)}`);\n        }\n        return `${expr.__name__}(${args.join(\", \")})`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Operator) {\n        const operator = expr.__name__;\n        const args = expr.__args__;\n        switch (expr.__opkind__) {\n            case index_1.OperatorKind.Infix:\n                if (operator === \"[]\") {\n                    let index = \"\";\n                    if (Array.isArray(args[1])) {\n                        const [start, end] = args[1];\n                        if (start) {\n                            index += renderEdgeQL(start, ctx);\n                        }\n                        index += \":\";\n                        if (end) {\n                            index += renderEdgeQL(end, ctx);\n                        }\n                    }\n                    else {\n                        index = renderEdgeQL(args[1], ctx);\n                    }\n                    return `${renderEdgeQL(args[0], ctx)}[${index}]`;\n                }\n                return `(${renderEdgeQL(args[0], ctx)} ${operator} ${renderEdgeQL(args[1], ctx)})`;\n            case index_1.OperatorKind.Postfix:\n                return `(${renderEdgeQL(args[0], ctx)} ${operator})`;\n            case index_1.OperatorKind.Prefix:\n                return `(${operator} ${renderEdgeQL(args[0], ctx)})`;\n            case index_1.OperatorKind.Ternary:\n                if (operator === \"if_else\") {\n                    return `(${renderEdgeQL(args[0], ctx)} IF ${renderEdgeQL(args[1], ctx)} ELSE ${renderEdgeQL(args[2], ctx)})`;\n                }\n                else {\n                    throw new Error(`Unknown operator: ${operator}`);\n                }\n            default:\n                index_1.util.assertNever(expr.__opkind__, new Error(`Unknown operator kind: ${expr.__opkind__}`));\n        }\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.TypeIntersection) {\n        return `${renderEdgeQL(expr.__expr__, ctx)}[IS ${expr.__element__.__name__}]`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.For) {\n        ctx.forVars.set(expr.__forVar__, `__forVar__${ctx.forVars.size}`);\n        return `(${withBlock}FOR ${ctx.forVars.get(expr.__forVar__)} IN {${renderEdgeQL(expr.__iterSet__, ctx)}}\r\nUNION (\\n${indent(renderEdgeQL(expr.__expr__, ctx), 2)}\\n))`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.ForVar) {\n        const forVar = ctx.forVars.get(expr);\n        if (!forVar) {\n            throw new Error(`'FOR' loop variable used outside of 'FOR' loop`);\n        }\n        return forVar;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Param) {\n        return `__param__${expr.__name__}`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Detached) {\n        return `(DETACHED ${renderEdgeQL(expr.__expr__, {\n            ...ctx,\n            renderWithVar: expr.__expr__,\n        }, undefined, true)})`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Global) {\n        return `(GLOBAL ${expr.__name__})`;\n    }\n    else {\n        index_1.util.assertNever(expr, new Error(`Unrecognized expression kind: \"${expr.__kind__}\"`));\n    }\n}\nfunction isGroupingSet(arg) {\n    return arg.__kind__ === \"groupingset\";\n}\nfunction renderGroupingSet(set) {\n    const contents = Object.entries(set.__elements__)\n        .map(([k, v]) => {\n        return isGroupingSet(v) ? renderGroupingSet(v) : k;\n    })\n        .join(\", \");\n    if (set.__settype__ === \"tuple\") {\n        return `(${contents})`;\n    }\n    else if (set.__settype__ === \"set\") {\n        return `{${contents}}`;\n    }\n    else if (set.__settype__ === \"cube\") {\n        return `cube(${contents})`;\n    }\n    else if (set.__settype__ === \"rollup\") {\n        return `rollup(${contents})`;\n    }\n    else {\n        throw new Error(`Unrecognized set type: \"${set.__settype__}\"`);\n    }\n}\nfunction shapeToEdgeQL(shape, ctx, type = null, keysOnly = false, injectImplicitId = true) {\n    const pointers = type?.__pointers__ || null;\n    const isFreeObject = type?.__name__ === \"std::FreeObject\";\n    if (shape === null) {\n        return ``;\n    }\n    const lines = [];\n    const addLine = (line) => lines.push(`${keysOnly ? \"\" : \"  \"}${line}`);\n    const seen = new Set();\n    for (const key in shape) {\n        if (!shape.hasOwnProperty(key))\n            continue;\n        if (seen.has(key)) {\n            console.warn(`Invalid: duplicate key \"${key}\"`);\n            continue;\n        }\n        seen.add(key);\n        let val = shape[key];\n        let operator = \":=\";\n        let polyType = null;\n        if (typeof val === \"object\" && !val.__element__) {\n            if (!!val[\"+=\"]) {\n                operator = \"+=\";\n                val = val[\"+=\"];\n            }\n            else if (!!val[\"-=\"]) {\n                operator = \"-=\";\n                val = val[\"-=\"];\n            }\n        }\n        if (val.__kind__ === index_1.ExpressionKind.PolyShapeElement) {\n            polyType = val.__polyType__;\n            val = val.__shapeElement__;\n        }\n        const polyIntersection = polyType\n            ? `[IS ${polyType.__element__.__name__}].`\n            : \"\";\n        const ptr = pointers?.[key];\n        const addCardinalityAnnotations = pointers && (!ptr || isFreeObject);\n        const expectedCardinality = addCardinalityAnnotations && val.hasOwnProperty(\"__cardinality__\")\n            ? val.__cardinality__ === index_1.Cardinality.Many ||\n                val.__cardinality__ === index_1.Cardinality.AtLeastOne\n                ? \"multi \"\n                : \"single \"\n            : \"\";\n        const wrapAssertExists = ptr?.cardinality === index_1.Cardinality.AtLeastOne;\n        if (typeof val === \"boolean\") {\n            if (!pointers?.[key] &&\n                key[0] !== \"@\" &&\n                type &&\n                type?.__name__ !== \"std::FreeObject\" &&\n                !polyIntersection) {\n                throw new Error(`Field \"${key}\" does not exist in ${type?.__name__}`);\n            }\n            if (val) {\n                addLine(`${polyIntersection}${q(key)}`);\n            }\n            continue;\n        }\n        if (typeof val !== \"object\") {\n            throw new Error(`Invalid shape element at \"${key}\".`);\n        }\n        const valIsExpression = val.hasOwnProperty(\"__kind__\");\n        if (!valIsExpression) {\n            addLine(`${polyIntersection}${q(key, false)}: ${indent(shapeToEdgeQL(val, ctx, ptr?.target), 2).trim()}`);\n            continue;\n        }\n        if (keysOnly) {\n            addLine(q(key, false) +\n                ((0, typesystem_1.isObjectType)(val.__element__)\n                    ? `: ${shapeToEdgeQL(val.__element__.__shape__, ctx, null, true)}`\n                    : \"\"));\n            continue;\n        }\n        const renderedExpr = renderEdgeQL(val, ctx);\n        addLine(`${expectedCardinality}${q(key, false)} ${operator} ${wrapAssertExists ? \"assert_exists(\" : \"\"}${renderedExpr.includes(\"\\n\")\n            ? `(\\n${indent(renderedExpr[0] === \"(\" &&\n                renderedExpr[renderedExpr.length - 1] === \")\"\n                ? renderedExpr.slice(1, -1)\n                : renderedExpr, 4)}\\n  )`\n            : renderedExpr}${wrapAssertExists ? \")\" : \"\"}`);\n    }\n    if (lines.length === 0 && injectImplicitId) {\n        addLine(\"id\");\n    }\n    return keysOnly ? `{${lines.join(\", \")}}` : `{\\n${lines.join(\",\\n\")}\\n}`;\n}\nfunction topoSortWithVars(vars, ctx) {\n    if (!vars.size) {\n        return [];\n    }\n    const sorted = [];\n    const unvisited = new Set(vars);\n    const visiting = new Set();\n    for (const withVar of unvisited) {\n        visit(withVar);\n    }\n    function visit(withVar) {\n        if (!unvisited.has(withVar)) {\n            return;\n        }\n        if (visiting.has(withVar)) {\n            throw new Error(`'WITH' variables contain a cyclic dependency`);\n        }\n        visiting.add(withVar);\n        for (const child of ctx.withVars.get(withVar).childExprs) {\n            if (vars.has(child)) {\n                visit(child);\n            }\n        }\n        visiting.delete(withVar);\n        unvisited.delete(withVar);\n        sorted.push(withVar);\n    }\n    return sorted;\n}\nconst numericalTypes = {\n    \"std::number\": true,\n    \"std::int16\": true,\n    \"std::int32\": true,\n    \"std::int64\": true,\n    \"std::float32\": true,\n    \"std::float64\": true,\n};\nfunction literalToEdgeQL(type, val) {\n    const typename = type.__casttype__?.__name__ ?? type.__name__;\n    let skipCast = false;\n    let stringRep;\n    if (typename === \"std::json\") {\n        skipCast = true;\n        stringRep = `to_json($$${JSON.stringify(val)}$$)`;\n    }\n    else if (typeof val === \"string\") {\n        if (numericalTypes[typename]) {\n            skipCast = typename === type.__name__;\n            stringRep = val;\n        }\n        else if (type.__kind__ === index_1.TypeKind.enum) {\n            skipCast = true;\n            const vals = type.__values__;\n            if (vals.includes(val)) {\n                skipCast = true;\n                if (val.includes(\" \")) {\n                    stringRep = `<${type.__name__}>\"${val}\"`;\n                }\n                else {\n                    stringRep = `${type.__name__}.${q(val)}`;\n                }\n            }\n            else {\n                throw new Error(`Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`);\n            }\n        }\n        else {\n            if (typename === \"std::str\") {\n                skipCast = true;\n            }\n            stringRep = JSON.stringify(val);\n        }\n    }\n    else if (typeof val === \"number\") {\n        if (numericalTypes[typename]) {\n            skipCast = typename === type.__name__;\n        }\n        else {\n            throw new Error(`Unknown numerical type: ${type.__name__}!`);\n        }\n        stringRep = `${val.toString()}`;\n    }\n    else if (typeof val === \"boolean\") {\n        stringRep = `${val.toString()}`;\n        skipCast = true;\n    }\n    else if (typeof val === \"bigint\") {\n        stringRep = `${val.toString()}n`;\n    }\n    else if (Array.isArray(val)) {\n        skipCast = val.length !== 0;\n        if ((0, typesystem_1.isArrayType)(type)) {\n            stringRep = `[${val\n                .map((el) => literalToEdgeQL(type.__element__, el))\n                .join(\", \")}]`;\n        }\n        else if ((0, typesystem_1.isTupleType)(type)) {\n            stringRep = `( ${val\n                .map((el, j) => literalToEdgeQL(type.__items__[j], el))\n                .join(\", \")}${type.__items__.length === 1 ? \",\" : \"\"} )`;\n        }\n        else {\n            throw new Error(`Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`);\n        }\n    }\n    else if (val instanceof Date) {\n        stringRep = `'${val.toISOString()}'`;\n    }\n    else if (val instanceof edgedb_1.LocalDate ||\n        val instanceof edgedb_1.LocalDateTime ||\n        val instanceof edgedb_1.LocalTime ||\n        val instanceof edgedb_1.Duration ||\n        val instanceof edgedb_1.RelativeDuration ||\n        val instanceof edgedb_1.DateDuration) {\n        stringRep = `'${val.toString()}'`;\n    }\n    else if (val instanceof Uint8Array) {\n        stringRep = bufferToStringRep(val);\n        skipCast = true;\n    }\n    else if (val instanceof Float32Array) {\n        stringRep = `[${val.join(\",\")}]`;\n    }\n    else if (val instanceof edgedb_1.Range) {\n        const elType = type.__element__;\n        const elTypeName = elType.__name__ === \"std::number\" ? \"std::int64\" : elType.__name__;\n        return `std::range(${val.lower === null\n            ? `<${elTypeName}>{}`\n            : literalToEdgeQL(elType, val.lower)}, ${val.upper === null\n            ? `<${elTypeName}>{}`\n            : literalToEdgeQL(elType, val.upper)}, inc_lower := ${val.incLower}, inc_upper := ${val.incUpper})`;\n    }\n    else if (typeof val === \"object\") {\n        if ((0, typesystem_1.isNamedTupleType)(type)) {\n            stringRep = `( ${Object.entries(val).map(([key, value]) => `${key} := ${literalToEdgeQL(type.__shape__[key], value)}`)} )`;\n            skipCast = true;\n        }\n        else {\n            throw new Error(`Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`);\n        }\n    }\n    else {\n        throw new Error(`Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`);\n    }\n    if (skipCast) {\n        return stringRep;\n    }\n    return `<${type.__name__}>${stringRep}`;\n}\nfunction indent(str, depth) {\n    return str\n        .split(\"\\n\")\n        .map((line) => \" \".repeat(depth) + line)\n        .join(\"\\n\");\n}\nfunction q(ident, allowBacklinks = true) {\n    if (!ident ||\n        ident.startsWith(\"@\") ||\n        (allowBacklinks && (ident.startsWith(\"<\") || ident.includes(\"::\")))) {\n        return ident;\n    }\n    const isAlphaNum = /^([^\\W\\d]\\w*|([1-9]\\d*|0))$/.test(ident);\n    if (isAlphaNum) {\n        const lident = ident.toLowerCase();\n        const isReserved = lident !== \"__type__\" &&\n            lident !== \"__std__\" &&\n            index_2.reservedKeywords.has(lident);\n        if (!isReserved) {\n            return ident;\n        }\n    }\n    return \"`\" + ident.replace(/`/g, \"``\") + \"`\";\n}\nfunction bufferToStringRep(buf) {\n    let stringRep = \"\";\n    for (const byte of buf) {\n        if (byte < 32 || byte > 126) {\n            switch (byte) {\n                case 8:\n                    stringRep += \"\\\\b\";\n                    break;\n                case 9:\n                    stringRep += \"\\\\t\";\n                    break;\n                case 10:\n                    stringRep += \"\\\\n\";\n                    break;\n                case 12:\n                    stringRep += \"\\\\f\";\n                    break;\n                case 13:\n                    stringRep += \"\\\\r\";\n                    break;\n                default:\n                    stringRep += `\\\\x${byte.toString(16).padStart(2, \"0\")}`;\n            }\n        }\n        else {\n            stringRep +=\n                (byte === 39 || byte === 92 ? \"\\\\\" : \"\") + String.fromCharCode(byte);\n        }\n    }\n    return `b'${stringRep}'`;\n}\nfunction getErrorHint(expr) {\n    let literalConstructor = null;\n    switch (typeof expr) {\n        case \"string\":\n            literalConstructor = \"e.str()\";\n            break;\n        case \"number\":\n            literalConstructor = Number.isInteger(expr) ? \"e.int64()\" : \"e.float64()\";\n            break;\n        case \"bigint\":\n            literalConstructor = \"e.bigint()\";\n            break;\n        case \"boolean\":\n            literalConstructor = \"e.bool()\";\n            break;\n    }\n    switch (true) {\n        case expr instanceof Date:\n            literalConstructor = \"e.datetime()\";\n            break;\n        case expr instanceof edgedb_1.Duration:\n            literalConstructor = \"e.duration()\";\n            break;\n        case expr instanceof edgedb_1.LocalDate:\n            literalConstructor = \"e.cal.local_date()\";\n            break;\n        case expr instanceof edgedb_1.LocalDateTime:\n            literalConstructor = \"e.cal.local_datetime()\";\n            break;\n        case expr instanceof edgedb_1.LocalTime:\n            literalConstructor = \"e.cal.local_time()\";\n            break;\n        case expr instanceof edgedb_1.RelativeDuration:\n            literalConstructor = \"e.cal.relative_duration()\";\n            break;\n        case expr instanceof edgedb_1.DateDuration:\n            literalConstructor = \"e.cal.date_duration()\";\n            break;\n    }\n    return literalConstructor\n        ? `\\nHint: Maybe you meant to wrap the value in ` +\n            `a '${literalConstructor}' expression?`\n        : \"\";\n}\n"},{"path":"typesystem.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isArrayType = exports.isNamedTupleType = exports.isTupleType = exports.isObjectType = exports.isEnumType = exports.isScalarType = exports.$toSet = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nfunction $toSet(root, card) {\n    return {\n        __element__: root,\n        __cardinality__: card,\n    };\n}\nexports.$toSet = $toSet;\nfunction isScalarType(type) {\n    return type.__kind__ === index_1.TypeKind.scalar;\n}\nexports.isScalarType = isScalarType;\nfunction isEnumType(type) {\n    return type.__kind__ === index_1.TypeKind.enum;\n}\nexports.isEnumType = isEnumType;\nfunction isObjectType(type) {\n    return type.__kind__ === index_1.TypeKind.object;\n}\nexports.isObjectType = isObjectType;\nfunction isTupleType(type) {\n    return type.__kind__ === index_1.TypeKind.tuple;\n}\nexports.isTupleType = isTupleType;\nfunction isNamedTupleType(type) {\n    return type.__kind__ === index_1.TypeKind.namedtuple;\n}\nexports.isNamedTupleType = isNamedTupleType;\nfunction isArrayType(type) {\n    return type.__kind__ === index_1.TypeKind.array;\n}\nexports.isArrayType = isArrayType;\n"},{"path":"update.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.update = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst path_1 = require(\"./path\");\nconst select_1 = require(\"./select\");\nconst insert_1 = require(\"./insert\");\nfunction update(expr, shape) {\n    const cleanScopedExprs = select_1.$existingScopes.size === 0;\n    const scope = (0, path_1.$getScopedExpr)(expr, select_1.$existingScopes);\n    const resolvedShape = shape(scope);\n    if (cleanScopedExprs) {\n        select_1.$existingScopes.clear();\n    }\n    const mods = {};\n    let updateShape;\n    for (const [key, val] of Object.entries(resolvedShape)) {\n        if (key === \"filter\" || key === \"filter_single\") {\n            mods[key] = val;\n        }\n        else if (key === \"set\") {\n            updateShape = val;\n        }\n        else {\n            throw new Error(`Invalid update shape key '${key}', only 'filter', 'filter_single', ` +\n                `and 'set' are allowed`);\n        }\n    }\n    if (!updateShape) {\n        throw new Error(`Update shape must contain 'set' shape`);\n    }\n    const { modifiers, cardinality, needsAssertSingle } = (0, select_1.$handleModifiers)(mods, {\n        root: expr,\n        scope,\n    });\n    const updateExpr = {\n        __kind__: index_1.ExpressionKind.Update,\n        __element__: expr.__element__,\n        __cardinality__: cardinality,\n        __expr__: expr,\n        __shape__: (0, insert_1.$normaliseInsertShape)(expr, updateShape, true),\n        __modifiers__: modifiers,\n        __scope__: scope,\n    };\n    return needsAssertSingle\n        ? (0, path_1.$assert_single)(updateExpr)\n        : (0, path_1.$expressionify)(updateExpr);\n}\nexports.update = update;\n"},{"path":"with.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.with = exports.alias = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst path_1 = require(\"./path\");\nfunction alias(expr) {\n    return (0, path_1.$expressionify)({\n        __kind__: index_1.ExpressionKind.Alias,\n        __element__: expr.__element__,\n        __cardinality__: expr.__cardinality__,\n        __expr__: expr,\n    });\n}\nexports.alias = alias;\nfunction _with(refs, expr) {\n    return (0, path_1.$expressionify)({\n        __kind__: index_1.ExpressionKind.With,\n        __element__: expr.__element__,\n        __cardinality__: expr.__cardinality__,\n        __refs__: refs,\n        __expr__: expr,\n    });\n}\nexports.with = _with;\n"},{"path":"__spec__.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n"},{"path":"cardinality.d.ts","content":"import { Cardinality } from \"edgedb/dist/reflection/index\";\nimport type { TypeSet } from \"./typesystem\";\nexport declare namespace cardutil {\n    export type multiplyCardinalities<C1 extends Cardinality, C2 extends Cardinality> = C1 extends Cardinality.Empty ? Cardinality.Empty : C1 extends Cardinality.One ? C2 : C1 extends Cardinality.AtMostOne ? C2 extends Cardinality.One ? Cardinality.AtMostOne : C2 extends Cardinality.AtLeastOne ? Cardinality.Many : C2 : C1 extends Cardinality.Many ? C2 extends Cardinality.Empty ? Cardinality.Empty : Cardinality.Many : C1 extends Cardinality.AtLeastOne ? C2 extends Cardinality.AtMostOne ? Cardinality.Many : C2 extends Cardinality.One ? Cardinality.AtLeastOne : C2 : never;\n    export function multiplyCardinalities(c1: Cardinality, c2: Cardinality): Cardinality;\n    type _multiplyCardinalitiesVariadic<Cards extends [Cardinality, ...Cardinality[]]> = Cards extends [infer Card] ? Card : Cards extends [infer A, infer B, ...infer Rest] ? A extends Cardinality ? B extends Cardinality ? Rest extends Cardinality[] ? multiplyCardinalities<A, B> extends Cardinality ? _multiplyCardinalitiesVariadic<[\n        multiplyCardinalities<A, B>,\n        ...Rest\n    ]> : never : never : never : never : never;\n    export type multiplyCardinalitiesVariadic<Cards extends [Cardinality, ...Cardinality[]]> = _multiplyCardinalitiesVariadic<Cards> extends Cardinality ? _multiplyCardinalitiesVariadic<Cards> : never;\n    export function multiplyCardinalitiesVariadic<Cards extends [Cardinality, ...Cardinality[]]>(cards: Cards): multiplyCardinalitiesVariadic<Cards>;\n    export type mergeCardinalities<A extends Cardinality, B extends Cardinality> = A extends Cardinality.Empty ? B : B extends Cardinality.Empty ? A : A extends Cardinality.AtLeastOne ? Cardinality.AtLeastOne : B extends Cardinality.AtLeastOne ? Cardinality.AtLeastOne : A extends Cardinality.One ? Cardinality.AtLeastOne : B extends Cardinality.One ? Cardinality.AtLeastOne : Cardinality.Many;\n    export function mergeCardinalities<A extends Cardinality, B extends Cardinality>(a: A, b: B): mergeCardinalities<A, B>;\n    type _mergeCardinalitiesVariadic<Cards extends [Cardinality, ...Cardinality[]]> = Cards extends [infer Card] ? Card : Cards extends [infer A, infer B, ...infer Rest] ? A extends Cardinality ? B extends Cardinality ? Rest extends Cardinality[] ? mergeCardinalities<A, B> extends Cardinality ? _mergeCardinalitiesVariadic<[mergeCardinalities<A, B>, ...Rest]> : never : never : never : never : never;\n    export type mergeCardinalitiesVariadic<Cards extends [Cardinality, ...Cardinality[]]> = _mergeCardinalitiesVariadic<Cards> extends Cardinality ? _mergeCardinalitiesVariadic<Cards> : never;\n    export function mergeCardinalitiesVariadic<Cards extends [Cardinality, ...Cardinality[]]>(cards: Cards): mergeCardinalitiesVariadic<Cards>;\n    export type orCardinalities<C1 extends Cardinality, C2 extends Cardinality> = C1 extends C2 ? C1 : C1 extends Cardinality.Many ? C1 : C1 extends Cardinality.AtMostOne ? C2 extends Cardinality.Many ? C2 : C2 extends Cardinality.AtLeastOne ? Cardinality.Many : C1 : C1 extends Cardinality.AtLeastOne ? C2 extends Cardinality.One ? Cardinality.AtLeastOne : Cardinality.Many : C1 extends Cardinality.Empty ? C2 extends Cardinality.AtMostOne ? Cardinality.AtMostOne : C2 extends Cardinality.One ? Cardinality.AtMostOne : Cardinality.Many : C2 extends Cardinality.Empty ? Cardinality.AtMostOne : C2;\n    export function orCardinalities(c1: Cardinality, c2: Cardinality): Cardinality;\n    export type overrideLowerBound<C extends Cardinality, O extends \"One\" | \"Zero\"> = O extends \"One\" ? C extends Cardinality.Many ? Cardinality.AtLeastOne : C extends Cardinality.AtLeastOne ? Cardinality.AtLeastOne : Cardinality.One : C extends Cardinality.Empty ? Cardinality.Empty : C extends Cardinality.Many ? Cardinality.Many : C extends Cardinality.AtLeastOne ? Cardinality.Many : Cardinality.AtMostOne;\n    export function overrideLowerBound<C extends Cardinality, O extends \"One\" | \"Zero\">(card: C, override: O): overrideLowerBound<C, O>;\n    export type overrideUpperBound<C extends Cardinality, O extends \"One\" | \"Many\"> = O extends \"One\" ? C extends Cardinality.Many ? Cardinality.AtMostOne : C extends Cardinality.AtLeastOne ? Cardinality.One : C extends Cardinality.Empty ? Cardinality.AtMostOne : C : C extends Cardinality.One ? Cardinality.AtLeastOne : C extends Cardinality.AtMostOne ? Cardinality.Many : C extends Cardinality.Empty ? Cardinality.Many : C;\n    export function overrideUpperBound<C extends Cardinality, O extends \"One\" | \"Many\">(card: C, override: O): overrideUpperBound<C, O>;\n    export type paramCardinality<P> = [P] extends [TypeSet] ? [\n        Cardinality\n    ] extends [P[\"__cardinality__\"]] ? Cardinality.One : P[\"__cardinality__\"] : Cardinality.One;\n    export type optionalParamCardinality<P> = overrideLowerBound<paramCardinality<P>, \"One\">;\n    type _paramArrayCardinality<T> = {\n        [K in keyof T]: T[K] extends TypeSet ? T[K][\"__cardinality__\"] : Cardinality.One;\n    };\n    export type paramArrayCardinality<T extends [any, ...any[]]> = multiplyCardinalitiesVariadic<_paramArrayCardinality<T>>;\n    export type assignable<C extends Cardinality> = C extends Cardinality.Empty ? Cardinality.Empty : C extends Cardinality.One ? Cardinality.One : C extends Cardinality.AtMostOne ? Cardinality.One | Cardinality.AtMostOne | Cardinality.Empty : C extends Cardinality.AtLeastOne ? Cardinality.One | Cardinality.AtLeastOne | Cardinality.Many : C extends Cardinality.Many ? Cardinality : never;\n    export {};\n}\n"},{"path":"cast.d.ts","content":"import { ExpressionKind, Cardinality } from \"edgedb/dist/reflection/index\";\nimport type { Expression, BaseType, TypeSet, ObjectTypeExpression } from \"./typesystem\";\nimport type { orScalarLiteral } from \"./castMaps\";\nexport declare function cast<Target extends BaseType | ObjectTypeExpression>(target: Target, arg: null): $expr_Cast<Target extends BaseType ? Target : Target extends ObjectTypeExpression ? Target[\"__element__\"] : never, Cardinality.Empty>;\nexport declare function cast<Target extends BaseType, Expr extends TypeSet>(target: Target, expr: orScalarLiteral<Expr>): $expr_Cast<Target, Cardinality extends Expr[\"__cardinality__\"] ? Cardinality.One : Expr[\"__cardinality__\"]>;\nexport type $expr_Cast<Target extends BaseType = BaseType, Card extends Cardinality = Cardinality> = Expression<{\n    __element__: Target;\n    __cardinality__: Card;\n    __kind__: ExpressionKind.Cast;\n    __expr__: TypeSet | null;\n}>;\n"},{"path":"casting.d.ts","content":"import type { Cardinality } from \"edgedb/dist/reflection/index\";\nimport type { ArrayType, BaseType, BaseTypeTuple, BaseTypeToTsType, EnumType, LinkDesc, NamedTupleType, ObjectType, ObjectTypeSet, PrimitiveTypeSet, PropertyDesc, ScalarType, TupleType, TypeSet, RangeType, MultiRangeType } from \"./typesystem\";\nimport type { cardutil } from \"./cardinality\";\nimport type { scalarCastableFrom, scalarAssignableBy } from \"./castMaps\";\nexport type anonymizeObject<T extends ObjectType> = ObjectType<string, T[\"__pointers__\"], any>;\ntype assignableTuple<Items extends BaseTypeTuple> = {\n    [k in keyof Items]: Items[k] extends BaseType ? assignableBy<Items[k]> : never;\n} extends infer NewItems ? NewItems extends BaseTypeTuple ? NewItems : never : never;\nexport type assignableBy<T extends BaseType> = T extends ScalarType ? scalarAssignableBy<T> : T extends ObjectType ? anonymizeObject<T> : T extends EnumType ? T : T extends ArrayType ? ArrayType<assignableBy<T[\"__element__\"]>> : T extends TupleType ? TupleType<assignableTuple<T[\"__items__\"]>> : T extends NamedTupleType ? NamedTupleType<{\n    [k in keyof T[\"__shape__\"]]: assignableBy<T[\"__shape__\"][k]>;\n}> : T extends RangeType ? RangeType<scalarAssignableBy<T[\"__element__\"]> extends ScalarType ? scalarAssignableBy<T[\"__element__\"]> : never> : T extends MultiRangeType ? MultiRangeType<scalarAssignableBy<T[\"__element__\"]> extends ScalarType ? scalarAssignableBy<T[\"__element__\"]> : never> : never;\nexport type pointerToAssignmentExpression<Pointer extends PropertyDesc | LinkDesc, IsSetModifier extends boolean = false> = setToAssignmentExpression<TypeSet<Pointer[\"target\"], Pointer[\"cardinality\"]>, IsSetModifier>;\nexport type setToAssignmentExpression<Set extends TypeSet, IsSetModifier extends boolean> = [Set] extends [PrimitiveTypeSet] ? TypeSet<assignableBy<Set[\"__element__\"]>, cardutil.assignable<cardutil.overrideLowerBound<Set[\"__cardinality__\"], \"Zero\">>> | getAssignmentLiteral<Set, IsSetModifier> : [Set] extends [ObjectTypeSet] ? TypeSet<ObjectType<string, Set[\"__element__\"][\"__pointers__\"]>, cardutil.assignable<cardutil.overrideLowerBound<Set[\"__cardinality__\"], \"Zero\">>> : never;\ntype getAssignmentLiteral<Set extends PrimitiveTypeSet, IsSetModifier extends boolean> = BaseTypeToTsType<Set[\"__element__\"]> extends infer TsType ? TsType | (Set[\"__cardinality__\"] extends Cardinality.Many ? TsType[] : Set[\"__cardinality__\"] extends Cardinality.AtLeastOne ? IsSetModifier extends true ? TsType[] : [TsType, ...TsType[]] : never) : never;\ntype castableTuple<Items extends BaseTypeTuple> = {\n    [k in keyof Items]: Items[k] extends BaseType ? castableFrom<Items[k]> : never;\n} extends infer NewItems ? NewItems extends BaseTypeTuple ? NewItems : never : never;\nexport type castableFrom<T extends BaseType> = T extends ScalarType ? scalarCastableFrom<T> : T extends ObjectType ? anonymizeObject<T> : T extends ArrayType ? ArrayType<castableFrom<T[\"__element__\"]>> : T extends TupleType ? TupleType<castableTuple<T[\"__items__\"]>> : T extends NamedTupleType ? NamedTupleType<{\n    [k in keyof T[\"__shape__\"]]: castableFrom<T[\"__shape__\"][k]>;\n}> : never;\nexport type pointerToCastableExpression<Pointer extends PropertyDesc | LinkDesc> = [Pointer] extends [PropertyDesc] ? {\n    __element__: castableFrom<Pointer[\"target\"]>;\n    __cardinality__: cardutil.assignable<Pointer[\"cardinality\"]>;\n} : [Pointer] extends [LinkDesc] ? TypeSet<ObjectType<string, Pointer[\"target\"][\"__pointers__\"]>, cardutil.assignable<Pointer[\"cardinality\"]>> : never;\nexport {};\n"},{"path":"castMaps.d.ts","content":"export type scalarCastableFrom<T extends any> = any;\nexport type scalarAssignableBy<T extends any> = any;\nexport type orScalarLiteral<T extends any> = any;\nexport type scalarLiterals = any;\nexport type literalToScalarType<T extends any> = any;\ntype literalToTypeSet<T extends any> = any;\nexport type mapLiteralToTypeSet<T> = {\n    [k in keyof T]: literalToTypeSet<T[k]>;\n};\ndeclare function literalToTypeSet(t: any): any;\nexport { literalToTypeSet };\nexport declare function isImplicitlyCastableTo(from: string, to: string): boolean;\nexport declare function getSharedParentScalar(a: any, b: any): any;\nexport type getSharedParentScalar<A, B> = any;\n"},{"path":"collections.d.ts","content":"import { type typeutil } from \"edgedb/dist/reflection/index\";\nimport { cardutil } from \"./cardinality\";\nimport type { $expr_Array, $expr_NamedTuple, $expr_Tuple, ArrayType, BaseType, getPrimitiveBaseType, NamedTupleShape, NamedTupleType, NonArrayType, ObjectTypeExpression, ObjectTypePointers, PropertyDesc, TupleType, TypeSet } from \"./typesystem\";\nimport { type ExpressionRoot } from \"./path\";\nimport type { getCardsFromExprs } from \"./set\";\nimport { type literalToScalarType, type mapLiteralToTypeSet, type orScalarLiteral, type scalarLiterals } from \"./castMaps\";\nexport declare function $arrayLikeIndexify(_expr: ExpressionRoot): any;\nexport declare function array<Element extends NonArrayType>(element: Element): ArrayType<Element>;\nexport declare function array<Expr extends TypeSet<NonArrayType> | scalarLiterals, Exprs extends orScalarLiteral<TypeSet<Expr extends TypeSet ? getPrimitiveBaseType<Expr[\"__element__\"]> : getPrimitiveBaseType<literalToScalarType<Expr>>>>[]>(arg: [Expr, ...Exprs]): $expr_Array<ArrayType<Expr extends TypeSet ? getPrimitiveBaseType<Expr[\"__element__\"]> : getPrimitiveBaseType<literalToScalarType<Expr>>>, cardutil.multiplyCardinalitiesVariadic<getCardsFromExprs<mapLiteralToTypeSet<[Expr, ...Exprs]>>>>;\nexport declare function $tuplePathify(expr: ExpressionRoot): ExpressionRoot;\nexport declare function tuple<Items extends typeutil.tupleOf<BaseType>>(items: Items): TupleType<Items>;\nexport declare function tuple<Item extends TypeSet | scalarLiterals, Items extends typeutil.tupleOf<TypeSet | scalarLiterals>>(items: Items): $expr_Tuple<Items extends typeutil.tupleOf<any> ? mapLiteralToTypeSet<Items> : never>;\nexport declare function tuple<Shape extends NamedTupleShape>(shape: Shape): NamedTupleType<Shape>;\nexport declare function tuple<Shape extends {\n    [k: string]: TypeSet | scalarLiterals;\n}>(shape: Shape): $expr_NamedTuple<mapLiteralToTypeSet<Shape>>;\ntype PropertyNamesFromPointers<Pointers extends ObjectTypePointers> = {\n    [k in keyof Pointers as Pointers[k] extends PropertyDesc ? Pointers[k][\"computed\"] extends true ? never : k : never]: Pointers[k];\n};\nexport declare function $objectTypeToTupleType<Expr extends ObjectTypeExpression>(objectType: Expr): PropertyNamesFromPointers<Expr[\"__element__\"][\"__pointers__\"]> extends infer Pointers ? Pointers extends ObjectTypePointers ? NamedTupleType<{\n    [k in keyof Pointers as k extends \"id\" ? never : k]: Pointers[k][\"target\"];\n}> : never : never;\nexport declare function $objectTypeToTupleType<Expr extends ObjectTypeExpression, Fields extends keyof PropertyNamesFromPointers<Expr[\"__element__\"][\"__pointers__\"]>>(objectType: Expr, includeFields: Fields[]): NamedTupleType<{\n    [k in Fields]: Expr[\"__element__\"][\"__pointers__\"][k] extends PropertyDesc ? Expr[\"__element__\"][\"__pointers__\"][k][\"target\"] : never;\n}>;\nexport {};\n"},{"path":"detached.d.ts","content":"import { ExpressionKind } from \"edgedb/dist/reflection/index\";\nimport type { Expression, TypeSet } from \"./typesystem\";\nexport declare function detached<Expr extends TypeSet>(expr: Expr): $expr_Detached<Expr>;\nexport type $expr_Detached<Expr extends TypeSet = TypeSet> = Expression<{\n    __element__: Expr[\"__element__\"];\n    __cardinality__: Expr[\"__cardinality__\"];\n    __kind__: ExpressionKind.Detached;\n    __expr__: TypeSet;\n}>;\n"},{"path":"external.d.ts","content":"import type { TypeSet, setToTsType } from \"./typesystem\";\nexport { literal } from \"./literal\";\nexport {} from \"./path\";\nexport { set } from \"./set\";\nexport { cast } from \"./cast\";\nexport { ASC, DESC, EMPTY_FIRST, EMPTY_LAST, is, delete, select, } from \"./select\";\nexport { update } from \"./update\";\nexport { insert } from \"./insert\";\nexport { array, tuple, $objectTypeToTupleType as objectTypeToTupleType, } from \"./collections\";\nexport {} from \"./funcops\";\nexport { for } from \"./for\";\nexport { alias, with } from \"./with\";\nexport { optional, params } from \"./params\";\nexport { detached } from \"./detached\";\nexport {} from \"./toEdgeQL\";\nexport type $infer<A extends TypeSet> = setToTsType<A>;\n"},{"path":"for.d.ts","content":"import { Cardinality, ExpressionKind } from \"edgedb/dist/reflection/index\";\nimport { cardutil } from \"./cardinality\";\nimport type { Expression, BaseType, BaseTypeSet } from \"./typesystem\";\nexport type $expr_For<El extends BaseType = BaseType, Card extends Cardinality = Cardinality> = Expression<{\n    __element__: El;\n    __cardinality__: Card;\n    __kind__: ExpressionKind.For;\n    __iterSet__: BaseTypeSet;\n    __forVar__: $expr_ForVar;\n    __expr__: BaseTypeSet;\n}>;\nexport type $expr_ForVar<Type extends BaseType = BaseType> = Expression<{\n    __element__: Type;\n    __cardinality__: Cardinality.One;\n    __kind__: ExpressionKind.ForVar;\n}>;\ndeclare function _for<IteratorSet extends BaseTypeSet, Expr extends BaseTypeSet>(set: IteratorSet, expr: (variable: $expr_ForVar<IteratorSet[\"__element__\"]>) => Expr): $expr_For<Expr[\"__element__\"], cardutil.multiplyCardinalities<IteratorSet[\"__cardinality__\"], Expr[\"__cardinality__\"]>>;\nexport { _for as for };\n"},{"path":"funcops.d.ts","content":"import { Cardinality, type introspect } from \"edgedb/dist/reflection/index\";\nimport type { BaseType, BaseTypeSet, TypeSet, Expression } from \"./typesystem\";\nimport type { ExpressionKind, OperatorKind } from \"edgedb/dist/reflection/index\";\nexport type $expr_Function<El extends BaseType = BaseType, Card extends Cardinality = Cardinality> = Expression<{\n    __element__: El;\n    __cardinality__: Card;\n    __kind__: ExpressionKind.Function;\n    __name__: string;\n    __args__: (BaseTypeSet | undefined)[];\n    __namedargs__: {\n        [key: string]: BaseTypeSet;\n    };\n}>;\nexport type $expr_Operator<El extends BaseType = BaseType, Card extends Cardinality = Cardinality> = Expression<{\n    __element__: El;\n    __cardinality__: Card;\n    __kind__: ExpressionKind.Operator;\n    __name__: string;\n    __opkind__: OperatorKind;\n    __args__: TypeSet[];\n}>;\ninterface OverloadFuncArgDef {\n    typeId: string;\n    optional?: boolean;\n    setoftype?: boolean;\n    variadic?: boolean;\n}\ninterface OverloadFuncDef {\n    kind?: string;\n    args: OverloadFuncArgDef[];\n    namedArgs?: {\n        [key: string]: OverloadFuncArgDef;\n    };\n    returnTypeId: string;\n    returnTypemod?: \"SetOfType\" | \"OptionalType\";\n    preservesOptionality?: boolean;\n}\nexport declare function $resolveOverload(funcName: string, args: any[], typeSpec: introspect.Types, funcDefs: OverloadFuncDef[]): {\n    kind?: string | undefined;\n    returnType: BaseType;\n    cardinality: Cardinality;\n    args: BaseTypeSet[];\n    namedArgs: {\n        [key: string]: BaseTypeSet;\n    };\n};\nexport {};\n"},{"path":"globals.d.ts","content":"import { ExpressionKind, Cardinality } from \"edgedb/dist/reflection/index\";\nimport type { Expression, BaseType } from \"./typesystem\";\nexport declare function makeGlobal<Type extends BaseType, Card extends Cardinality>(name: string, type: Type, card: Card): $expr_Global<Type, Card>;\nexport type $expr_Global<Type extends BaseType = BaseType, Card extends Cardinality = Cardinality> = Expression<{\n    __name__: string;\n    __element__: Type;\n    __cardinality__: Card;\n    __kind__: ExpressionKind.Global;\n}>;\n"},{"path":"group.d.ts","content":"import type { Expression, ObjectType, ObjectTypeSet, TypeSet, BaseType, $scopify, PropertyDesc, LinkDesc } from \"./typesystem\";\nimport { Cardinality, ExpressionKind } from \"edgedb/dist/reflection/index\";\nimport type { $FreeObjectλShape, $str } from \"./modules/std\";\nimport type { normaliseShape, objectTypeToSelectShape } from \"./select\";\ntype SingletonSet = Expression<TypeSet<BaseType, Cardinality.One | Cardinality.AtMostOne>>;\ntype SimpleGroupElements = {\n    [k: string]: SingletonSet;\n};\ntype GroupModifiers = {\n    by: SimpleGroupElements;\n};\ntype NestedGroupElements = {\n    [k: string]: SingletonSet | GroupingSet;\n};\nexport type GroupingSet = {\n    __kind__: \"groupingset\";\n    __settype__: \"set\" | \"tuple\" | \"rollup\" | \"cube\";\n    __elements__: NestedGroupElements;\n    __exprs__: [string, SingletonSet][];\n};\nexport declare function isGroupingSet(arg: any): arg is GroupingSet;\ndeclare const setFuncs: {\n    set: <T extends SimpleGroupElements>(grps: T) => { [k in keyof T]?: T[k] | undefined; };\n    tuple: <T extends SimpleGroupElements>(grps: T) => { [k in keyof T]?: T[k] | undefined; };\n    rollup: <T extends SimpleGroupElements>(grps: T) => { [k in keyof T]?: T[k] | undefined; };\n    cube: <T extends SimpleGroupElements>(grps: T) => { [k in keyof T]?: T[k] | undefined; };\n};\nexport type $expr_Group<Expr extends ObjectTypeSet = ObjectTypeSet, Mods extends GroupModifiers = GroupModifiers, Shape extends object = {\n    id: true;\n}> = Expression<{\n    __element__: ObjectType<\"std::FreeObject\", $FreeObjectλShape & {\n        grouping: PropertyDesc<$str, Cardinality.Many, false, true, true, false>;\n        key: LinkDesc<ObjectType<\"std::FreeObject\", {\n            [k in keyof Mods[\"by\"]]: Mods[\"by\"][k][\"__element__\"] extends ObjectType ? never : PropertyDesc<Mods[\"by\"][k][\"__element__\"], Cardinality.AtMostOne>;\n        }>, Cardinality.One, {}, false, true, true, false>;\n        elements: LinkDesc<Expr[\"__element__\"], Cardinality.Many, {}, false, true, true, false>;\n    }, {\n        grouping: TypeSet<$str, Cardinality.Many>;\n        key: Expression<{\n            __element__: ObjectType<\"std::FreeObject\", $FreeObjectλShape, {\n                [k in keyof Mods[\"by\"]]: Expression<{\n                    __element__: Mods[\"by\"][k][\"__element__\"];\n                    __cardinality__: Cardinality.AtMostOne;\n                }>;\n            }>;\n            __cardinality__: Cardinality.One;\n        }>;\n        elements: Expression<{\n            __element__: ObjectType<Expr[\"__element__\"][\"__name__\"], Expr[\"__element__\"][\"__pointers__\"], normaliseShape<Shape, \"by\">>;\n            __cardinality__: Cardinality.Many;\n        }>;\n    }>;\n    __cardinality__: Cardinality.Many;\n    __modifiers__: Mods;\n    __kind__: ExpressionKind.Group;\n    __expr__: ObjectTypeSet;\n    __scope__: ObjectTypeSet;\n}>;\ntype noUndefined<T> = T extends undefined ? never : T;\ntype groupFunc = <Expr extends ObjectTypeSet, Shape extends {\n    by?: SimpleGroupElements;\n} & objectTypeToSelectShape<Expr[\"__element__\"]>>(expr: Expr, getter: (arg: $scopify<Expr[\"__element__\"]>) => Readonly<Shape>) => $expr_Group<Expr, {\n    by: noUndefined<Shape[\"by\"]>;\n}, normaliseShape<Shape, \"by\">>;\ndeclare const groupFunc: groupFunc;\nexport declare const group: typeof setFuncs & groupFunc;\nexport {};\n"},{"path":"hydrate.d.ts","content":"import type { $ } from \"edgedb\";\nimport type { BaseType, ObjectType, ObjectTypePointers, TupleType } from \"./typesystem\";\nimport type { typeutil } from \"edgedb/dist/reflection/index\";\nexport declare function makeType<T extends BaseType>(spec: $.introspect.Types, id: string, literal: any, anytype?: BaseType): T;\nexport type mergeObjectShapes<A extends ObjectTypePointers, B extends ObjectTypePointers> = typeutil.flatten<{\n    [k in keyof A & keyof B]: A[k] extends B[k] ? B[k] extends A[k] ? A[k] : never : never;\n}>;\nexport type mergeObjectTypes<A extends ObjectType | undefined, B extends ObjectType | undefined> = A extends ObjectType ? B extends ObjectType ? ObjectType<`${A[\"__name__\"]} UNION ${B[\"__name__\"]}`, mergeObjectShapes<A[\"__pointers__\"], B[\"__pointers__\"]>, null> : A : B extends ObjectType ? B : undefined;\nexport declare function $mergeObjectTypes<A extends ObjectType, B extends ObjectType>(a: A, b: B): mergeObjectTypes<A, B>;\nexport declare function $mergeTupleTypes<A extends TupleType, B extends TupleType>(a: A, b: B): TupleType;\n"},{"path":"insert.d.ts","content":"import { Cardinality, ExpressionKind, type typeutil } from \"edgedb/dist/reflection/index\";\nimport type { Expression, LinkDesc, ObjectTypeSet, ObjectTypePointers, PropertyDesc, stripBacklinks, stripNonInsertables, $scopify, stripSet, TypeSet, ObjectType } from \"./typesystem\";\nimport type { pointerToAssignmentExpression } from \"./casting\";\nimport type { $expr_PathNode } from \"./path\";\nimport type { $Object } from \"./modules/std\";\nimport type { scalarLiterals } from \"./castMaps\";\nexport type pointerIsOptional<T extends PropertyDesc | LinkDesc> = T[\"cardinality\"] extends Cardinality.Many | Cardinality.Empty | Cardinality.AtMostOne ? true : false;\nexport type InsertShape<El extends ObjectType> = typeutil.flatten<RawInsertShape<El>>;\nexport type RawInsertShape<El extends ObjectType> = ObjectType extends El ? never : typeutil.stripNever<stripNonInsertables<stripBacklinks<El[\"__pointers__\"]>>> extends infer Shape ? Shape extends ObjectTypePointers ? typeutil.addQuestionMarks<{\n    [k in keyof Shape]: pointerToAssignmentExpression<Shape[k]> | (pointerIsOptional<Shape[k]> extends true ? undefined | null : never) | (Shape[k][\"hasDefault\"] extends true ? undefined : never);\n}> & {\n    [k in `@${string}`]: TypeSet | scalarLiterals;\n} : never : never;\ninterface UnlessConflict {\n    on: TypeSet | null;\n    else?: TypeSet;\n}\ntype InsertBaseExpression<Root extends TypeSet = TypeSet> = {\n    __kind__: ExpressionKind.Insert;\n    __element__: Root[\"__element__\"];\n    __cardinality__: Cardinality.One;\n    __expr__: stripSet<Root>;\n    __shape__: any;\n};\nexport type $expr_Insert<El extends ObjectType = ObjectType> = Expression<{\n    __kind__: ExpressionKind.Insert;\n    __element__: El;\n    __cardinality__: Cardinality.One;\n    __expr__: $expr_PathNode;\n    __shape__: InsertShape<El>;\n    unlessConflict(): $expr_InsertUnlessConflict<El, {\n        on: null;\n    }>;\n    unlessConflict<Conflict extends UnlessConflict>(conflictGetter: (scope: $scopify<El>) => Conflict): $expr_InsertUnlessConflict<El, Conflict>;\n}>;\nexport type $expr_InsertUnlessConflict<El extends ObjectType = ObjectType, Conflict extends UnlessConflict = UnlessConflict> = Expression<{\n    __kind__: ExpressionKind.InsertUnlessConflict;\n    __element__: Conflict[\"else\"] extends TypeSet ? Conflict[\"else\"][\"__element__\"][\"__name__\"] extends El[\"__name__\"] ? El : $Object : El;\n    __cardinality__: Conflict[\"else\"] extends TypeSet ? Conflict[\"else\"][\"__cardinality__\"] : Cardinality.AtMostOne;\n    __expr__: InsertBaseExpression;\n    __conflict__: Conflict;\n}>;\nexport declare function $insertify(expr: Omit<$expr_Insert, \"unlessConflict\">): $expr_Insert;\nexport declare function $normaliseInsertShape(root: ObjectTypeSet, shape: {\n    [key: string]: any;\n}, isUpdate?: boolean): {\n    [key: string]: TypeSet | {\n        \"+=\": TypeSet;\n    } | {\n        \"-=\": TypeSet;\n    };\n};\nexport declare function insert<Root extends $expr_PathNode>(root: Root, shape: InsertShape<Root[\"__element__\"]>): $expr_Insert<Root[\"__element__\"]>;\nexport {};\n"},{"path":"json.d.ts","content":"export declare function jsonifyComplexParams(expr: any, _args: any): any;\n"},{"path":"literal.d.ts","content":"import type { Expression, BaseType, BaseTypeToTsType, ScalarType } from \"./typesystem\";\nimport { Cardinality, ExpressionKind } from \"edgedb/dist/reflection/index\";\nexport type $expr_Literal<Type extends BaseType = BaseType> = Expression<{\n    __element__: Type;\n    __cardinality__: Cardinality.One;\n    __kind__: ExpressionKind.Literal;\n    __value__: any;\n}>;\nexport declare function literal<T extends BaseType>(type: T, value: BaseTypeToTsType<T>): $expr_Literal<T>;\nexport declare const $nameMapping: Map<string, string>;\nexport declare function $getType(id: string): (val: any) => $expr_Literal<ScalarType>;\nexport declare function $getTypeByName(name: string): (val: any) => $expr_Literal<ScalarType>;\n"},{"path":"operators.d.ts","content":"export declare function op(...args: any[]): any;\n"},{"path":"params.d.ts","content":"import type { Executor } from \"edgedb\";\nimport { ExpressionKind, Cardinality } from \"edgedb/dist/reflection/index\";\nimport type { Expression, ParamType, setToTsType, TypeSet, BaseTypeToTsType } from \"./typesystem\";\ntype Param = ParamType | $expr_OptionalParam;\ntype ParamsRecord = Record<string, Param>;\nexport type $expr_OptionalParam<Type extends ParamType = ParamType> = {\n    __kind__: ExpressionKind.OptionalParam;\n    __type__: Type;\n};\nexport declare function optional<Type extends ParamType>(type: Type): $expr_OptionalParam<Type>;\nexport type QueryableWithParamsExpression<Set extends TypeSet = TypeSet, Params extends ParamsRecord = Record<string, never>> = Expression<Set, false> & {\n    run(cxn: Executor, args: paramsToParamArgs<Params>): Promise<setToTsType<Set>>;\n    runJSON(cxn: Executor, args: paramsToParamArgs<Params>): Promise<string>;\n};\nexport type $expr_WithParams<Params extends ParamsRecord = Record<string, never>, Expr extends TypeSet = TypeSet> = QueryableWithParamsExpression<{\n    __kind__: ExpressionKind.WithParams;\n    __element__: Expr[\"__element__\"];\n    __cardinality__: Expr[\"__cardinality__\"];\n    __expr__: Expr;\n    __params__: $expr_Param[];\n}, Params>;\ntype paramsToParamArgs<Params extends ParamsRecord> = {\n    [key in keyof Params as Params[key] extends ParamType ? key : never]: Params[key] extends ParamType ? Readonly<BaseTypeToTsType<Params[key], true>> : never;\n} & {\n    [key in keyof Params as Params[key] extends $expr_OptionalParam ? key : never]?: Params[key] extends $expr_OptionalParam ? Readonly<BaseTypeToTsType<Params[key][\"__type__\"], true> | null> : never;\n};\nexport type $expr_Param<Name extends string | number | symbol = string, Type extends ParamType = ParamType, Optional extends boolean = boolean> = Expression<{\n    __kind__: ExpressionKind.Param;\n    __element__: Type;\n    __cardinality__: Optional extends true ? Cardinality.AtMostOne : Cardinality.One;\n    __name__: Name;\n    __isComplex__: boolean;\n}>;\ntype paramsToParamExprs<Params extends ParamsRecord> = {\n    [key in keyof Params]: Params[key] extends $expr_OptionalParam ? $expr_Param<key, Params[key][\"__type__\"], true> : Params[key] extends ParamType ? $expr_Param<key, Params[key], false> : never;\n};\nexport declare function params<Params extends ParamsRecord = Record<string, never>, Expr extends Expression = Expression>(paramsDef: Params, expr: (params: paramsToParamExprs<Params>) => Expr): $expr_WithParams<Params, Expr>;\nexport {};\n"},{"path":"path.d.ts","content":"import { ExpressionKind, Cardinality, type typeutil } from \"edgedb/dist/reflection/index\";\nimport { cardutil } from \"./cardinality\";\nimport type { BaseType, Expression, LinkDesc, ObjectType, ObjectTypePointers, ObjectTypeSet, PropertyDesc, PropertyShape, TypeSet } from \"./typesystem\";\ntype getChildOfObjectTypeSet<Root extends ObjectTypeSet, ChildKey extends keyof Root[\"__element__\"][\"__pointers__\"]> = TypeSet<Root[\"__element__\"][\"__pointers__\"][ChildKey][\"target\"], cardutil.multiplyCardinalities<Root[\"__cardinality__\"], Root[\"__element__\"][\"__pointers__\"][ChildKey][\"cardinality\"]>>;\nexport interface PathParent<Parent extends ObjectTypeSet = ObjectTypeSet, L extends string = string> {\n    type: Parent;\n    linkName: L;\n}\nexport type $linkPropify<Root extends ObjectTypeSet> = Root extends {\n    __parent__: PathParent<infer Parent, infer L>;\n} ? Parent[\"__element__\"][\"__pointers__\"][L] extends LinkDesc<any, any, infer LinkProps, any, any, any, any> ? pathifyLinkProps<LinkProps, Root, PathParent<Parent, L>> : {} : unknown;\nexport type $pathify<Root extends TypeSet> = Root extends ObjectTypeSet ? ObjectTypeSet extends Root ? {} : pathifyPointers<Root> & pathifyShape<Root> & $linkPropify<Root> : {};\nexport type pathifyPointers<Root extends ObjectTypeSet> = ObjectTypePointers extends Root[\"__element__\"][\"__pointers__\"] ? unknown : {\n    [k in keyof Root[\"__element__\"][\"__pointers__\"] & string]: Root[\"__element__\"][\"__pointers__\"][k] extends PropertyDesc ? $expr_PathLeaf<getChildOfObjectTypeSet<Root, k>, {\n        type: anonymizeObjectTypeSet<Root>;\n        linkName: k;\n    }> : Root[\"__element__\"][\"__pointers__\"][k] extends LinkDesc ? getChildOfObjectTypeSet<Root, k> extends ObjectTypeSet ? $expr_PathNode<getChildOfObjectTypeSet<Root, k>, {\n        type: anonymizeObjectTypeSet<Root>;\n        linkName: k;\n    }> : unknown : unknown;\n};\ntype anonymizeObjectTypeSet<T extends ObjectTypeSet> = typeutil.flatten<{\n    __element__: ObjectType<T[\"__element__\"][\"__name__\"], T[\"__element__\"][\"__pointers__\"], {\n        id: true;\n    }>;\n    __cardinality__: T[\"__cardinality__\"];\n}>;\nexport type pathifyShape<Root extends ObjectTypeSet, Shape extends {\n    [k: string]: any;\n} = Root[\"__element__\"][\"__shape__\"]> = string extends keyof Shape ? {} : {\n    [k in keyof Shape & string]: Shape[k] extends ObjectTypeSet ? $expr_PathNode<TypeSet<Shape[k][\"__element__\"], cardutil.multiplyCardinalities<Root[\"__cardinality__\"], Shape[k][\"__cardinality__\"]>>, {\n        type: Root;\n        linkName: k;\n    }> : Shape[k] extends TypeSet ? $expr_PathLeaf<TypeSet<Shape[k][\"__element__\"], cardutil.multiplyCardinalities<Root[\"__cardinality__\"], Shape[k][\"__cardinality__\"]>>, {\n        type: Root;\n        linkName: k;\n    }> : unknown;\n};\ntype pathifyLinkProps<Props extends PropertyShape, Root extends ObjectTypeSet, Parent extends PathParent | null = null> = {\n    [k in keyof Props & string]: Props[k] extends PropertyDesc ? $expr_PathLeaf<TypeSet<Props[k][\"target\"], cardutil.multiplyCardinalities<Root[\"__cardinality__\"], Props[k][\"cardinality\"]>>, {\n        type: $expr_PathNode<Root, Parent>;\n        linkName: k;\n    }> : unknown;\n};\nexport type getPropsShape<T extends ObjectType> = typeutil.flatten<typeutil.stripNever<{\n    [k in keyof T[\"__pointers__\"]]: T[\"__pointers__\"][k][\"__kind__\"] extends \"property\" ? true : never;\n}>>;\nexport type $expr_PathNode<Root extends ObjectTypeSet = ObjectTypeSet, Parent extends PathParent | null = PathParent | null> = Expression<{\n    __element__: Root[\"__element__\"];\n    __cardinality__: Root[\"__cardinality__\"];\n    __parent__: Parent;\n    __kind__: ExpressionKind.PathNode;\n    \"*\": getPropsShape<Root[\"__element__\"]>;\n}>;\nexport type $expr_TypeIntersection<Card extends Cardinality = Cardinality, Intersection extends ObjectType = ObjectType> = Expression<{\n    __element__: Intersection;\n    __cardinality__: Card;\n    __kind__: ExpressionKind.TypeIntersection;\n    __expr__: TypeSet;\n}>;\nexport type $expr_PathLeaf<Root extends TypeSet = TypeSet, Parent extends PathParent = PathParent> = Expression<{\n    __element__: Root[\"__element__\"];\n    __cardinality__: Root[\"__cardinality__\"];\n    __kind__: ExpressionKind.PathLeaf;\n    __parent__: Parent;\n}>;\nexport type ExpressionRoot = {\n    __element__: BaseType;\n    __cardinality__: Cardinality;\n    __kind__: ExpressionKind;\n};\ndeclare function PathLeaf<Root extends TypeSet, Parent extends PathParent, Exclusive extends boolean = boolean>(root: Root, parent: Parent, exclusive: Exclusive, scopeRoot?: TypeSet | null): $expr_PathLeaf<Root, Parent>;\ndeclare function PathNode<Root extends ObjectTypeSet, Parent extends PathParent | null>(root: Root, parent: Parent, scopeRoot?: TypeSet | null): $expr_PathNode<Root, Parent>;\nexport declare function $pathify<Root extends TypeSet, Parent extends PathParent>(_root: Root): $pathify<Root>;\nexport declare function $assert_single(expr: Expression): any;\nexport declare function $jsonDestructure(_expr: ExpressionRoot): any;\nexport declare function $expressionify<T extends ExpressionRoot>(_expr: T): Expression<T>;\nexport declare function $getScopedExpr<T extends ExpressionRoot>(expr: T, existingScopes?: Set<Expression>): Expression<T>;\nexport { PathLeaf as $PathLeaf, PathNode as $PathNode };\n"},{"path":"query.d.ts","content":"import type * as edgedb from \"edgedb\";\nexport declare const runnableExpressionKinds: Set<edgedb.$.ExpressionKind>;\nexport declare function $queryFunc(this: any, cxn: edgedb.Executor, args: any): Promise<unknown>;\nexport declare function $queryFuncJSON(this: any, cxn: edgedb.Executor, args: any): Promise<string>;\n"},{"path":"range.d.ts","content":"import type { LocalDate, LocalDateTime, Duration } from \"edgedb\";\nimport { Range } from \"edgedb\";\nimport type { cardutil } from \"./cardinality\";\nimport type { RangeType, getPrimitiveBaseType, TypeSet, BaseType } from \"./typesystem\";\nimport type { $expr_Literal } from \"./literal\";\nimport type { $number, $decimal, $datetime, $duration, $bool } from \"./modules/std\";\nimport type { $local_date, $local_datetime } from \"./modules/cal\";\nimport type { literalToScalarType, orScalarLiteral } from \"./castMaps\";\nimport { type $expr_Function } from \"./funcops\";\ntype $anypoint = $number | $local_date | $decimal | $datetime | $local_datetime | $duration;\ndeclare function range<Element extends $anypoint>(element: Element): RangeType<Element>;\ndeclare function range<T extends number | Date | LocalDate | LocalDateTime | Duration>(val: Range<T>): $expr_Literal<RangeType<getPrimitiveBaseType<literalToScalarType<T>>>>;\ndeclare function range<NamedArgs extends {\n    inc_lower?: orScalarLiteral<TypeSet<$bool>>;\n    inc_upper?: orScalarLiteral<TypeSet<$bool>>;\n    empty?: orScalarLiteral<TypeSet<$bool>>;\n}, P1 extends orScalarLiteral<TypeSet<$anypoint>> | undefined, P2 extends orScalarLiteral<TypeSet<BaseType extends literalToScalarType<P1> ? $anypoint : getPrimitiveBaseType<literalToScalarType<P1>>>> | undefined>(namedArgs: NamedArgs, lower?: P1, upper?: P2): $expr_Function<RangeType<literalToScalarType<P1> extends $anypoint ? literalToScalarType<P1> : literalToScalarType<P2> extends $anypoint ? literalToScalarType<P2> : $anypoint>, cardutil.multiplyCardinalities<cardutil.multiplyCardinalities<cardutil.multiplyCardinalities<cardutil.multiplyCardinalities<cardutil.optionalParamCardinality<P1>, cardutil.optionalParamCardinality<P2>>, cardutil.optionalParamCardinality<NamedArgs[\"inc_lower\"]>>, cardutil.optionalParamCardinality<NamedArgs[\"inc_upper\"]>>, cardutil.optionalParamCardinality<NamedArgs[\"empty\"]>>>;\ndeclare function range<P1 extends orScalarLiteral<TypeSet<$anypoint>> | undefined, P2 extends orScalarLiteral<TypeSet<BaseType extends literalToScalarType<P1> ? $anypoint : getPrimitiveBaseType<literalToScalarType<P1>>>> | undefined>(lower?: P1, upper?: P2): $expr_Function<RangeType<literalToScalarType<P1> extends $anypoint ? literalToScalarType<P1> : literalToScalarType<P2> extends $anypoint ? literalToScalarType<P2> : $anypoint>, cardutil.multiplyCardinalities<cardutil.optionalParamCardinality<P1>, cardutil.optionalParamCardinality<P2>>>;\nexport { range as $range };\n"},{"path":"reflection.d.ts","content":"export * from \"edgedb/dist/reflection/index\";\nexport * from \"./typesystem\";\nexport { cardutil } from \"./cardinality\";\nexport type { $expr_Literal } from \"./literal\";\nexport type { $expr_PathNode, $expr_PathLeaf } from \"./path\";\nexport type { $expr_Function, $expr_Operator } from \"./funcops\";\nexport { makeType, $mergeObjectTypes } from \"./hydrate\";\nexport type { mergeObjectTypes } from \"./hydrate\";\n"},{"path":"select.d.ts","content":"import type { $bool, $number } from \"./modules/std\";\nimport { Cardinality, ExpressionKind } from \"edgedb/dist/reflection/index\";\nimport { cardutil } from \"./cardinality\";\nimport type { $expr_PolyShapeElement, $scopify, Expression, LinkDesc, ObjectType, ObjectTypeExpression, ObjectTypePointers, ObjectTypeSet, PrimitiveTypeSet, PropertyDesc, ScalarType, stripSet, TypeSet, BaseType, ExclusiveTuple, orLiteralValue } from \"./typesystem\";\nimport { type $expr_PathLeaf, type $linkPropify, type ExpressionRoot } from \"./path\";\nimport type { anonymizeObject } from \"./casting\";\nimport { type scalarLiterals, type literalToScalarType } from \"./castMaps\";\nexport declare const ASC: \"ASC\";\nexport declare const DESC: \"DESC\";\nexport declare const EMPTY_FIRST: \"EMPTY FIRST\";\nexport declare const EMPTY_LAST: \"EMPTY LAST\";\nexport type OrderByDirection = \"ASC\" | \"DESC\";\nexport type OrderByEmpty = \"EMPTY FIRST\" | \"EMPTY LAST\";\nexport type OrderByExpr = TypeSet<ScalarType | ObjectType, Cardinality>;\nexport type OrderByObjExpr = {\n    expression: OrderByExpr;\n    direction?: OrderByDirection;\n    empty?: OrderByEmpty;\n};\nexport type OrderByExpression = OrderByExpr | OrderByObjExpr | [OrderByExpr | OrderByObjExpr, ...(OrderByExpr | OrderByObjExpr)[]];\nexport type OffsetExpression = TypeSet<$number, Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne>;\nexport type SelectFilterExpression = TypeSet<$bool, Cardinality>;\nexport type LimitOffsetExpression = TypeSet<$number, Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne>;\nexport type LimitExpression = TypeSet<$number, Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne>;\nexport type SelectModifierNames = \"filter\" | \"filter_single\" | \"order_by\" | \"offset\" | \"limit\";\ntype filterSingle<T extends TypeSet> = T extends ObjectTypeSet ? TypeSet<anonymizeObject<T[\"__element__\"]>, T[\"__cardinality__\"]> : orLiteralValue<T>;\nexport type exclusivesToFilterSingle<E extends ExclusiveTuple> = ExclusiveTuple extends E ? never : E extends [] ? never : {\n    [j in keyof E]: {\n        [k in keyof E[j]]: filterSingle<E[j][k]>;\n    };\n}[number];\nexport type SelectModifiers<T extends ObjectType = ObjectType> = {\n    filter?: SelectFilterExpression;\n    filter_single?: exclusivesToFilterSingle<T[\"__exclusives__\"]> | SelectFilterExpression;\n    order_by?: OrderByExpression;\n    offset?: OffsetExpression | number;\n    limit?: LimitExpression | number;\n};\nexport type UnknownSelectModifiers = {\n    [k in keyof SelectModifiers]: unknown;\n};\nexport type NormalisedSelectModifiers = {\n    filter?: SelectFilterExpression;\n    order_by?: OrderByObjExpr[];\n    offset?: OffsetExpression;\n    limit?: LimitExpression;\n    singleton: boolean;\n};\nexport type $expr_Select<Set extends TypeSet = TypeSet> = Expression<{\n    __element__: Set[\"__element__\"];\n    __cardinality__: Set[\"__cardinality__\"];\n    __expr__: TypeSet;\n    __kind__: ExpressionKind.Select;\n    __modifiers__: NormalisedSelectModifiers;\n    __scope__?: ObjectTypeExpression;\n}>;\nexport interface SelectModifierMethods<Root extends TypeSet> {\n    filter<Filter extends SelectFilterExpression>(filter: Filter | ((scope: Root extends ObjectTypeSet ? $scopify<Root[\"__element__\"]> : stripSet<Root>) => Filter)): this;\n    order_by(order_by: OrderByExpression | ((scope: Root extends ObjectTypeSet ? $scopify<Root[\"__element__\"]> : stripSet<Root>) => OrderByExpression)): this;\n    offset(offset: OffsetExpression | number | ((scope: Root extends ObjectTypeSet ? $scopify<Root[\"__element__\"]> : stripSet<Root>) => OffsetExpression | number)): this;\n    limit(limit: LimitExpression | number | ((scope: Root extends ObjectTypeSet ? $scopify<Root[\"__element__\"]> : stripSet<Root>) => LimitExpression | number)): this;\n}\nexport type InferOffsetLimitCardinality<Card extends Cardinality, Modifiers extends UnknownSelectModifiers> = Modifiers[\"limit\"] extends number | LimitExpression ? cardutil.overrideLowerBound<Card, \"Zero\"> : Modifiers[\"offset\"] extends number | OffsetExpression ? cardutil.overrideLowerBound<Card, \"Zero\"> : Card;\nexport type ComputeSelectCardinality<Expr extends ObjectTypeExpression, Modifiers extends UnknownSelectModifiers> = InferOffsetLimitCardinality<undefined extends Modifiers[\"filter_single\"] ? Expr[\"__cardinality__\"] : cardutil.overrideUpperBound<Expr[\"__cardinality__\"], \"One\">, Modifiers>;\nexport declare function is<Expr extends ObjectTypeExpression, Shape extends objectTypeToSelectShape<Expr[\"__element__\"]>>(expr: Expr, shape: Shape): {\n    [k in Exclude<keyof Shape, SelectModifierNames | \"id\">]: $expr_PolyShapeElement<Expr, normaliseElement<Shape[k]>>;\n};\nexport declare function $handleModifiers(modifiers: SelectModifiers, params: {\n    root: TypeSet;\n    scope: TypeSet;\n}): {\n    modifiers: NormalisedSelectModifiers;\n    cardinality: Cardinality;\n    needsAssertSingle: boolean;\n};\nexport type $expr_Delete<Root extends ObjectTypeSet = ObjectTypeSet> = Expression<{\n    __kind__: ExpressionKind.Delete;\n    __element__: Root[\"__element__\"];\n    __cardinality__: Root[\"__cardinality__\"];\n    __expr__: ObjectTypeSet;\n}>;\ndeclare function deleteExpr<Expr extends ObjectTypeExpression, Modifiers extends SelectModifiers<Expr[\"__element__\"]>>(expr: Expr, modifiers?: (scope: $scopify<Expr[\"__element__\"]>) => Readonly<Modifiers>): $expr_Delete<{\n    __element__: ObjectType<Expr[\"__element__\"][\"__name__\"], Expr[\"__element__\"][\"__pointers__\"], {\n        id: true;\n    }>;\n    __cardinality__: ComputeSelectCardinality<Expr, Modifiers>;\n}>;\nexport { deleteExpr as delete };\nexport declare function $selectify<Expr extends ExpressionRoot>(expr: Expr): Expr;\nexport type linkDescToLinkProps<Desc extends LinkDesc> = {\n    [k in keyof Desc[\"properties\"] & string]: $expr_PathLeaf<TypeSet<Desc[\"properties\"][k][\"target\"], Desc[\"properties\"][k][\"cardinality\"]>>;\n};\nexport type pointersToObjectType<P extends ObjectTypePointers> = ObjectType<string, P, object>;\ntype linkDescToShape<L extends LinkDesc> = objectTypeToSelectShape<L[\"target\"]> & objectTypeToSelectShape<pointersToObjectType<L[\"properties\"]>> & SelectModifiers;\ntype linkDescToSelectElement<L extends LinkDesc> = boolean | TypeSet<anonymizeObject<L[\"target\"]>, cardutil.assignable<L[\"cardinality\"]>> | linkDescToShape<L> | ((scope: $scopify<L[\"target\"]> & linkDescToLinkProps<L>) => linkDescToShape<L>);\ntype propDescToSelectElement<P extends PropertyDesc> = boolean | TypeSet<P[\"target\"], cardutil.assignable<P[\"cardinality\"]>> | $expr_PolyShapeElement;\nexport type objectTypeToSelectShape<T extends ObjectType = ObjectType, Pointers extends ObjectTypePointers = T[\"__pointers__\"]> = Partial<{\n    [k in keyof Pointers]: Pointers[k] extends PropertyDesc ? propDescToSelectElement<Pointers[k]> : Pointers[k] extends LinkDesc ? linkDescToSelectElement<Pointers[k]> : any;\n}> & {\n    [k: string]: unknown;\n};\nexport type normaliseElement<El> = El extends boolean ? El : El extends TypeSet ? stripSet<El> : El extends (...scope: any[]) => any ? normaliseShape<ReturnType<El>> : El extends object ? normaliseShape<stripSet<El>> : stripSet<El>;\nexport type normaliseShape<Shape extends object, Strip = SelectModifierNames> = {\n    [k in Exclude<keyof Shape, Strip>]: normaliseElement<Shape[k]>;\n};\nexport declare const $existingScopes: Set<Expression<TypeSet<BaseType, Cardinality>>>;\ndeclare function $shape<Expr extends ObjectTypeExpression, Element extends Expr[\"__element__\"], Shape extends objectTypeToSelectShape<Element> & SelectModifiers<Element>, Scope extends $scopify<Element> & $linkPropify<{\n    [k in keyof Expr]: k extends \"__cardinality__\" ? Cardinality.One : Expr[k];\n}>>(expr: Expr, _shape: (scope: Scope) => Readonly<Shape>): (scope: unknown) => Readonly<Shape>;\nexport { $shape as shape };\nexport declare function select<Expr extends ObjectTypeExpression, Element extends Expr[\"__element__\"], ElementName extends `${Element[\"__name__\"]}`, ElementPointers extends Element[\"__pointers__\"], ElementShape extends Element[\"__shape__\"], Card extends Expr[\"__cardinality__\"]>(expr: Expr): $expr_Select<{\n    __element__: ObjectType<ElementName, ElementPointers, ElementShape>;\n    __cardinality__: Card;\n}>;\nexport declare function select<Expr extends TypeSet>(expr: Expr): $expr_Select<stripSet<Expr>>;\nexport declare function select<Expr extends ObjectTypeExpression, Element extends Expr[\"__element__\"], Shape extends objectTypeToSelectShape<Element> & SelectModifiers<Element>, SelectCard extends ComputeSelectCardinality<Expr, Modifiers>, SelectShape extends normaliseShape<Shape, SelectModifierNames>, Scope extends $scopify<Element> & $linkPropify<{\n    [k in keyof Expr]: k extends \"__cardinality__\" ? Cardinality.One : Expr[k];\n}>, ElementName extends `${Element[\"__name__\"]}`, Modifiers extends UnknownSelectModifiers = Pick<Shape, SelectModifierNames>>(expr: Expr, shape: (scope: Scope) => Readonly<Shape>): $expr_Select<{\n    __element__: ObjectType<ElementName, Element[\"__pointers__\"], SelectShape>;\n    __cardinality__: SelectCard;\n}>;\nexport declare function select<Expr extends PrimitiveTypeSet, Modifiers extends SelectModifiers>(expr: Expr, modifiers: (expr: Expr) => Readonly<Modifiers>): $expr_Select<{\n    __element__: Expr[\"__element__\"];\n    __cardinality__: InferOffsetLimitCardinality<Expr[\"__cardinality__\"], Modifiers>;\n}>;\nexport declare function select<Shape extends {\n    [key: string]: TypeSet;\n}>(shape: Shape): $expr_Select<{\n    __element__: ObjectType<`std::FreeObject`, {\n        [k in keyof Shape]: Shape[k][\"__element__\"] extends ObjectType ? LinkDesc<Shape[k][\"__element__\"], Shape[k][\"__cardinality__\"], {}, false, true, true, false> : PropertyDesc<Shape[k][\"__element__\"], Shape[k][\"__cardinality__\"], false, true, true, false>;\n    }, Shape>;\n    __cardinality__: Cardinality.One;\n}>;\nexport declare function select<Expr extends scalarLiterals>(expr: Expr): $expr_Select<{\n    __element__: literalToScalarType<Expr>;\n    __cardinality__: Cardinality.One;\n}>;\nexport declare function resolveShapeElement(key: any, value: any, scope: ObjectTypeExpression): any;\n"},{"path":"set.d.ts","content":"import type { ExpressionKind, Cardinality } from \"edgedb/dist/reflection/index\";\nimport type { ArrayType, BaseTypeTuple, BaseType, NamedTupleType, ObjectTypeSet, TypeSet, TupleType, Expression, ObjectType, getPrimitiveBaseType, SomeType } from \"./typesystem\";\nimport { type mergeObjectTypes } from \"./hydrate\";\nimport * as castMaps from \"./castMaps\";\nexport declare function getSharedParent(a: SomeType, b: SomeType): SomeType;\nexport { set } from \"./setImpl\";\nexport type $expr_Set<Set extends LooseTypeSet = LooseTypeSet> = Expression<{\n    __element__: Set[\"__element__\"];\n    __cardinality__: Set[\"__cardinality__\"];\n    __exprs__: TypeSet[];\n    __kind__: ExpressionKind.Set;\n}>;\ntype mergeTypeTuples<AItems, BItems> = {\n    [k in keyof AItems]: k extends keyof BItems ? getSharedParentPrimitive<AItems[k], BItems[k]> : never;\n};\nexport type getSharedParentPrimitive<A, B> = A extends undefined ? B extends undefined ? undefined : B : B extends undefined ? A : A extends ArrayType<infer AEl> ? B extends ArrayType<infer BEl> ? ArrayType<castMaps.getSharedParentScalar<AEl, BEl>> : never : A extends NamedTupleType<infer AShape> ? B extends NamedTupleType<infer BShape> ? NamedTupleType<{\n    [k in keyof AShape & keyof BShape]: castMaps.getSharedParentScalar<AShape[k], BShape[k]>;\n}> : never : A extends TupleType<infer AItems> ? B extends TupleType<infer BItems> ? mergeTypeTuples<AItems, BItems> extends BaseTypeTuple ? TupleType<mergeTypeTuples<AItems, BItems>> : never : never : castMaps.getSharedParentScalar<A, B>;\ntype _getSharedParentPrimitiveVariadic<Types extends [any, ...any[]]> = Types extends [infer U] ? U : Types extends [infer A, infer B, ...infer Rest] ? _getSharedParentPrimitiveVariadic<[\n    getSharedParentPrimitive<A, B>,\n    ...Rest\n]> : never;\nexport type getSharedParentPrimitiveVariadic<Types extends [any, ...any[]]> = _getSharedParentPrimitiveVariadic<Types>;\nexport type LooseTypeSet<T extends any = any, C extends Cardinality = Cardinality> = {\n    __element__: T;\n    __cardinality__: C;\n};\nexport type { mergeObjectTypes };\ntype _mergeObjectTypesVariadic<Types extends [ObjectType, ...ObjectType[]]> = Types extends [infer U] ? U : Types extends [infer A, infer B, ...infer Rest] ? A extends ObjectType ? B extends ObjectType ? mergeObjectTypes<A, B> extends BaseType ? mergeObjectTypesVariadic<[mergeObjectTypes<A, B>, ...Rest]> : never : never : never : never;\nexport type mergeObjectTypesVariadic<Types extends [any, ...any[]]> = _mergeObjectTypesVariadic<Types>;\nexport type getTypesFromExprs<Exprs extends [TypeSet, ...TypeSet[]]> = {\n    [k in keyof Exprs]: Exprs[k] extends TypeSet<infer El, any> ? getPrimitiveBaseType<El> : never;\n};\nexport type getTypesFromObjectExprs<Exprs extends [ObjectTypeSet, ...ObjectTypeSet[]]> = {\n    [k in keyof Exprs]: Exprs[k] extends TypeSet<infer El, any> ? El : never;\n};\nexport type getCardsFromExprs<Exprs extends [TypeSet, ...TypeSet[]]> = {\n    [k in keyof Exprs]: Exprs[k] extends TypeSet<any, infer Card> ? Card : never;\n};\n"},{"path":"setImpl.d.ts","content":"export declare function set(...args: any[]): any;\n"},{"path":"syntax.d.ts","content":"import type { TypeSet, setToTsType } from \"./typesystem\";\nexport * from \"./literal\";\nexport * from \"./path\";\nexport * from \"./set\";\nexport * from \"./cast\";\nexport * from \"./select\";\nexport * from \"./update\";\nexport * from \"./insert\";\nexport * from \"./group\";\nexport * from \"./collections\";\nexport * from \"./funcops\";\nexport * from \"./for\";\nexport * from \"./with\";\nexport * from \"./params\";\nexport * from \"./globals\";\nexport * from \"./detached\";\nexport * from \"./toEdgeQL\";\nexport * from \"./range\";\nexport type $infer<A extends TypeSet> = setToTsType<A>;\n"},{"path":"toEdgeQL.d.ts","content":"import { type $expr_Array, type $expr_NamedTuple, type $expr_Tuple, type $expr_TuplePath } from \"./typesystem\";\nimport type { $expr_Literal } from \"./literal\";\nimport type { $expr_PathLeaf, $expr_PathNode, $expr_TypeIntersection } from \"./path\";\nimport type { $expr_Cast } from \"./cast\";\nimport type { $expr_Detached } from \"./detached\";\nimport type { $expr_For, $expr_ForVar } from \"./for\";\nimport type { $expr_Function, $expr_Operator } from \"./funcops\";\nimport type { $expr_Insert, $expr_InsertUnlessConflict } from \"./insert\";\nimport type { $expr_Param, $expr_WithParams } from \"./params\";\nimport type { $expr_Delete, $expr_Select } from \"./select\";\nimport type { $expr_Set } from \"./set\";\nimport type { $expr_Update } from \"./update\";\nimport type { $expr_Alias, $expr_With } from \"./with\";\nimport type { $expr_Group } from \"./group\";\nimport type { $expr_Global } from \"./globals\";\nexport type SomeExpression = $expr_PathNode | $expr_PathLeaf | $expr_Literal | $expr_Set | $expr_Array | $expr_Tuple | $expr_NamedTuple | $expr_TuplePath | $expr_Cast | $expr_Select | $expr_Delete | $expr_Update | $expr_Insert | $expr_InsertUnlessConflict | $expr_Function | $expr_Operator | $expr_For | $expr_ForVar | $expr_TypeIntersection | $expr_Alias | $expr_With | $expr_WithParams | $expr_Param | $expr_Detached | $expr_Group | $expr_Global;\nexport declare function $toEdgeQL(this: any): string;\n"},{"path":"typesystem.d.ts","content":"import type { Executor } from \"edgedb/dist/ifaces\";\nimport type { $expr_PathNode, $expr_TypeIntersection, $pathify } from \"./path\";\nimport type { $expr_Literal } from \"./literal\";\nimport type { $expr_Operator } from \"./funcops\";\nimport type { typeutil, Cardinality, ExpressionKind } from \"edgedb/dist/reflection/index\";\nimport { TypeKind } from \"edgedb/dist/reflection/index\";\nimport type { cardutil } from \"./cardinality\";\nimport type { Range, MultiRange } from \"edgedb\";\nexport interface BaseType {\n    __kind__: TypeKind;\n    __name__: string;\n}\nexport type BaseTypeSet = {\n    __element__: BaseType;\n    __cardinality__: Cardinality;\n};\nexport type BaseTypeTuple = typeutil.tupleOf<BaseType>;\nexport interface ScalarType<Name extends string = string, TsType = any, TsArgType = TsType, TsConstType extends TsType = TsType> extends BaseType {\n    __kind__: TypeKind.scalar;\n    __tstype__: TsType;\n    __tsargtype__: TsArgType;\n    __tsconsttype__: TsConstType;\n    __name__: Name;\n}\nexport type scalarTypeWithConstructor<S extends ScalarType, ExtraTsTypes = never> = S & {\n    <T extends S[\"__tstype__\"] | ExtraTsTypes>(val: T): $expr_Literal<Omit<S, \"__tsconsttype__\"> & {\n        __tsconsttype__: T extends S[\"__tstype__\"] ? T : S[\"__tstype__\"];\n    }>;\n};\ntype $jsonDestructure<Set extends TypeSet> = Set[\"__element__\"] extends ScalarType<\"std::json\"> ? {\n    [path: string]: $expr_Operator<Set[\"__element__\"], Set[\"__cardinality__\"]>;\n} & {\n    destructure<T extends TypeSet<ScalarType<\"std::str\">> | string>(path: T): $expr_Operator<Set[\"__element__\"], cardutil.multiplyCardinalities<Set[\"__cardinality__\"], T extends TypeSet ? T[\"__cardinality__\"] : Cardinality.One>>;\n} : unknown;\nexport interface TypeSet<T extends BaseType = BaseType, Card extends Cardinality = Cardinality> {\n    __element__: T;\n    __cardinality__: Card;\n}\nexport declare function $toSet<Root extends BaseType, Card extends Cardinality>(root: Root, card: Card): TypeSet<Root, Card>;\nexport type Expression<Set extends TypeSet = TypeSet, Runnable extends boolean = true> = Set & (BaseType extends Set[\"__element__\"] ? {\n    run(cxn: Executor): any;\n    runJSON(cxn: Executor): any;\n    toEdgeQL(): string;\n    is: any;\n    assert_single: any;\n} : $pathify<Set> & ExpressionMethods<stripSet<Set>> & (Runnable extends true ? {\n    run(cxn: Executor): Promise<setToTsType<Set>>;\n    runJSON(cxn: Executor): Promise<string>;\n} : {}) & $tuplePathify<Set> & $arrayLikeIndexify<Set> & $jsonDestructure<Set>);\nexport type stripSet<T> = \"__element__\" extends keyof T ? \"__cardinality__\" extends keyof T ? {\n    __element__: T[\"__element__\"];\n    __cardinality__: T[\"__cardinality__\"];\n} : T : T;\nexport type stripSetShape<T> = {\n    [k in keyof T]: stripSet<T[k]>;\n};\nexport type assert_single<El extends BaseType, Card extends Cardinality> = Expression<{\n    __element__: El;\n    __cardinality__: Card;\n    __kind__: ExpressionKind.Function;\n    __name__: \"std::assert_single\";\n    __args__: TypeSet[];\n    __namedargs__: {};\n}>;\nexport type ExpressionMethods<Set extends TypeSet> = {\n    toEdgeQL(): string;\n    is<T extends ObjectTypeSet>(ixn: T): $expr_TypeIntersection<Set[\"__cardinality__\"], ObjectType<T[\"__element__\"][\"__name__\"], T[\"__element__\"][\"__pointers__\"], {\n        id: true;\n    }>>;\n    assert_single(): assert_single<Set[\"__element__\"], Cardinality.AtMostOne>;\n};\nexport interface EnumType<Name extends string = string, Values extends [string, ...string[]] = [string, ...string[]]> extends BaseType {\n    __kind__: TypeKind.enum;\n    __tstype__: Values[number];\n    __name__: Name;\n    __values__: Values;\n}\nexport type ObjectTypeSet = TypeSet<ObjectType, Cardinality>;\nexport type ObjectTypeExpression = TypeSet<ObjectType, Cardinality>;\nexport type ExclusiveTuple = typeutil.tupleOf<{\n    [k: string]: TypeSet;\n}>;\nexport interface ObjectType<Name extends string = string, Pointers extends ObjectTypePointers = ObjectTypePointers, Shape extends object | null = any, Exclusives extends ExclusiveTuple = ExclusiveTuple> extends BaseType {\n    __kind__: TypeKind.object;\n    __name__: Name;\n    __pointers__: Pointers;\n    __shape__: Shape;\n    __exclusives__: Exclusives;\n}\nexport type PropertyTypes = ScalarType | EnumType | ArrayType | TupleType | NamedTupleType;\nexport type SomeType = ScalarType | EnumType | ArrayType | TupleType | ObjectType | NamedTupleType | RangeType | MultiRangeType;\nexport interface PropertyDesc<Type extends BaseType = BaseType, Card extends Cardinality = Cardinality, Exclusive extends boolean = boolean, Computed extends boolean = boolean, Readonly extends boolean = boolean, HasDefault extends boolean = boolean> {\n    __kind__: \"property\";\n    target: Type;\n    cardinality: Card;\n    exclusive: Exclusive;\n    computed: Computed;\n    readonly: Readonly;\n    hasDefault: HasDefault;\n}\nexport type $scopify<Type extends ObjectType> = $expr_PathNode<TypeSet<Type, Cardinality.One>>;\nexport type PropertyShape = {\n    [k: string]: PropertyDesc;\n};\nexport interface LinkDesc<Type extends ObjectType = any, Card extends Cardinality = Cardinality, LinkProps extends PropertyShape = any, Exclusive extends boolean = boolean, Computed extends boolean = boolean, Readonly extends boolean = boolean, HasDefault extends boolean = boolean> {\n    __kind__: \"link\";\n    target: Type;\n    cardinality: Card;\n    properties: LinkProps;\n    exclusive: Exclusive;\n    computed: Computed;\n    readonly: Readonly;\n    hasDefault: HasDefault;\n}\nexport type ObjectTypePointers = {\n    [k: string]: PropertyDesc | LinkDesc;\n};\nexport type stripBacklinks<T extends ObjectTypePointers> = {\n    [k in keyof T]: k extends `<${string}` ? never : T[k];\n};\nexport type omitBacklinks<T extends string | number | symbol> = T extends `<${string}` ? never : T extends string ? T : never;\nexport type stripNonUpdateables<T extends ObjectTypePointers> = {\n    [k in keyof T]: [T[k][\"computed\"]] extends [true] ? never : [T[k][\"readonly\"]] extends [true] ? never : k extends \"__type__\" ? never : k extends \"id\" ? never : T[k];\n};\nexport type stripNonInsertables<T extends ObjectTypePointers> = {\n    [k in keyof T]: [T[k][\"computed\"]] extends [true] ? never : [k] extends [\"__type__\"] ? never : T[k];\n};\ntype shapeElementToTs<Pointer extends PropertyDesc | LinkDesc, Element> = [\n    Element\n] extends [true] ? pointerToTsType<Pointer> : [Element] extends [false] ? never : [Element] extends [boolean] ? pointerToTsType<Pointer> | undefined : Element extends TypeSet ? setToTsType<TypeSet<Element[\"__element__\"], Pointer[\"cardinality\"]>> : Pointer extends LinkDesc ? Element extends object ? computeTsTypeCard<computeObjectShape<Pointer[\"target\"][\"__pointers__\"] & Pointer[\"properties\"], Element>, Pointer[\"cardinality\"]> : never : never;\nexport type $expr_PolyShapeElement<PolyType extends ObjectTypeSet = ObjectTypeSet, ShapeElement extends any = any> = {\n    __kind__: ExpressionKind.PolyShapeElement;\n    __polyType__: PolyType;\n    __shapeElement__: ShapeElement;\n};\nexport type computeObjectShape<Pointers extends ObjectTypePointers, Shape> = typeutil.flatten<keyof Shape extends never ? {\n    id: string;\n} : {\n    [k in keyof Shape]: Shape[k] extends $expr_PolyShapeElement<infer PolyType, infer ShapeEl> ? [k] extends [keyof PolyType[\"__element__\"][\"__pointers__\"]] ? shapeElementToTs<PolyType[\"__element__\"][\"__pointers__\"][k], ShapeEl> | null : never : [k] extends [keyof Pointers] ? shapeElementToTs<Pointers[k], Shape[k]> : Shape[k] extends TypeSet ? setToTsType<Shape[k]> : never;\n}>;\nexport type pointerToTsTypeSimple<El extends PropertyDesc | LinkDesc> = El extends PropertyDesc ? propToTsType<El> : El extends LinkDesc<any, any, any, any> ? {\n    id: string;\n} : never;\nexport type PrimitiveType = ScalarType | EnumType | TupleType | NamedTupleType | ArrayType | RangeType | MultiRangeType;\nexport type PrimitiveTypeSet = TypeSet<PrimitiveType, Cardinality>;\ntype $arrayLikeIndexify<Set extends TypeSet> = Set[\"__element__\"] extends ArrayType | ScalarType<\"std::str\"> | ScalarType<\"std::bytes\"> ? {\n    [index: number]: $expr_Operator<getPrimitiveBaseType<Set[\"__element__\"] extends ArrayType<infer El> ? El : Set[\"__element__\"]>, Set[\"__cardinality__\"]>;\n    [slice: `${number}:${number | \"\"}` | `:${number}`]: $expr_Operator<getPrimitiveBaseType<Set[\"__element__\"]>, Set[\"__cardinality__\"]>;\n    index<T extends TypeSet<ScalarType<\"std::number\">> | number>(index: T): $expr_Operator<getPrimitiveBaseType<Set[\"__element__\"] extends ArrayType<infer El> ? El : Set[\"__element__\"]>, cardutil.multiplyCardinalities<Set[\"__cardinality__\"], T extends TypeSet ? T[\"__cardinality__\"] : Cardinality.One>>;\n    slice<S extends TypeSet<ScalarType<\"std::number\">> | number, E extends TypeSet<ScalarType<\"std::number\">> | number | undefined | null>(start: S, end: E): $expr_Operator<getPrimitiveBaseType<Set[\"__element__\"]>, cardutil.multiplyCardinalities<cardutil.multiplyCardinalities<Set[\"__cardinality__\"], S extends TypeSet ? S[\"__cardinality__\"] : Cardinality.One>, E extends TypeSet<any, infer C> ? C : Cardinality.One>>;\n    slice<E extends TypeSet<ScalarType<\"std::number\">> | number | undefined | null>(start: undefined | null, end: E): $expr_Operator<getPrimitiveBaseType<Set[\"__element__\"]>, cardutil.multiplyCardinalities<Set[\"__cardinality__\"], E extends TypeSet<any, infer C> ? C : Cardinality.One>>;\n} : unknown;\nexport type $expr_Array<Type extends ArrayType = ArrayType, Card extends Cardinality = Cardinality> = Expression<{\n    __kind__: ExpressionKind.Array;\n    __items__: typeutil.tupleOf<TypeSet<Type[\"__element__\"]>>;\n    __element__: Type;\n    __cardinality__: Card;\n}>;\nexport interface ArrayType<Element extends BaseType = BaseType, Name extends string = `array<${Element[\"__name__\"]}>`> extends BaseType {\n    __name__: Name;\n    __kind__: TypeKind.array;\n    __element__: Element;\n}\ntype ArrayTypeToTsType<Type extends ArrayType, isParam extends boolean = false> = BaseTypeToTsType<Type[\"__element__\"], isParam>[];\ntype $tuplePathify<Set extends TypeSet> = Set[\"__element__\"] extends TupleType ? addTuplePaths<Set[\"__element__\"][\"__items__\"], Set[\"__cardinality__\"]> : Set[\"__element__\"] extends NamedTupleType ? addNamedTuplePaths<Set[\"__element__\"][\"__shape__\"], Set[\"__cardinality__\"]> : unknown;\nexport type $expr_TuplePath<ItemType extends BaseType = BaseType, ParentCard extends Cardinality = Cardinality> = Expression<{\n    __kind__: ExpressionKind.TuplePath;\n    __element__: ItemType;\n    __cardinality__: ParentCard;\n    __parent__: $expr_Tuple | $expr_NamedTuple | $expr_TuplePath;\n    __index__: string | number;\n}>;\nexport type baseTupleElementsToTupleType<T extends typeutil.tupleOf<TypeSet>> = {\n    [k in keyof T]: T[k] extends TypeSet ? getPrimitiveBaseType<T[k][\"__element__\"]> : never;\n};\nexport type tupleElementsToTupleType<T extends typeutil.tupleOf<TypeSet>> = baseTupleElementsToTupleType<T> extends BaseTypeTuple ? TupleType<baseTupleElementsToTupleType<T>> : never;\nexport type baseTupleElementsToCardTuple<T> = {\n    [k in keyof T]: T[k] extends TypeSet<any, infer C> ? C : never;\n};\nexport type tupleElementsToCardTuple<T> = baseTupleElementsToCardTuple<T> extends [Cardinality, ...Cardinality[]] ? baseTupleElementsToCardTuple<T> : never;\nexport type $expr_Tuple<Items extends typeutil.tupleOf<TypeSet> = typeutil.tupleOf<TypeSet>> = Expression<{\n    __kind__: ExpressionKind.Tuple;\n    __items__: typeutil.tupleOf<TypeSet>;\n    __element__: tupleElementsToTupleType<Items>;\n    __cardinality__: cardutil.multiplyCardinalitiesVariadic<tupleElementsToCardTuple<Items>>;\n}>;\nexport type indexKeys<T> = T extends `${number}` ? T : never;\ntype addTuplePaths<Items extends BaseType[], ParentCard extends Cardinality> = {\n    [k in indexKeys<keyof Items>]: Items[k] extends BaseType ? $expr_TuplePath<Items[k], ParentCard> : never;\n};\nexport interface TupleType<Items extends BaseTypeTuple = BaseTypeTuple> extends BaseType {\n    __name__: string;\n    __kind__: TypeKind.tuple;\n    __items__: Items;\n}\ntype TupleItemsToTsType<Items extends BaseTypeTuple, isParam extends boolean = false> = {\n    [k in keyof Items]: Items[k] extends BaseType ? BaseTypeToTsType<Items[k], isParam> : never;\n};\ntype literalShapeToType<T extends NamedTupleLiteralShape> = NamedTupleType<{\n    [k in keyof T]: getPrimitiveBaseType<T[k][\"__element__\"]>;\n}>;\ntype shapeCardinalities<Shape extends NamedTupleLiteralShape> = Shape[keyof Shape][\"__cardinality__\"];\ntype inferNamedTupleCardinality<Shape extends NamedTupleLiteralShape> = [\n    Cardinality.Many\n] extends [shapeCardinalities<Shape>] ? Cardinality.Many : [Cardinality.Empty] extends [shapeCardinalities<Shape>] ? Cardinality.Empty : [shapeCardinalities<Shape>] extends [Cardinality.AtMostOne] ? Cardinality.AtMostOne : [shapeCardinalities<Shape>] extends [\n    Cardinality.AtMostOne | Cardinality.One\n] ? Cardinality.One : Cardinality.Many;\nexport type $expr_NamedTuple<Shape extends NamedTupleLiteralShape = NamedTupleLiteralShape> = Expression<{\n    __kind__: ExpressionKind.NamedTuple;\n    __element__: literalShapeToType<Shape>;\n    __cardinality__: inferNamedTupleCardinality<Shape>;\n    __shape__: Shape;\n}>;\ntype addNamedTuplePaths<Shape extends NamedTupleShape, ParentCard extends Cardinality> = {\n    [k in keyof Shape]: Shape[k] extends BaseType ? $expr_TuplePath<Shape[k], ParentCard> : never;\n};\nexport type NamedTupleLiteralShape = {\n    [k: string]: TypeSet;\n};\nexport type NamedTupleShape = {\n    [k: string]: BaseType;\n};\nexport interface NamedTupleType<Shape extends NamedTupleShape = NamedTupleShape> extends BaseType {\n    __name__: string;\n    __kind__: TypeKind.namedtuple;\n    __shape__: Shape;\n}\ntype NamedTupleTypeToTsType<Type extends NamedTupleType, isParam extends boolean = false> = {\n    [k in keyof Type[\"__shape__\"]]: BaseTypeToTsType<Type[\"__shape__\"][k], isParam>;\n};\nexport interface RangeType<Element extends ScalarType = ScalarType, Name extends string = `range<${Element[\"__name__\"]}>`> extends BaseType {\n    __name__: Name;\n    __kind__: TypeKind.range;\n    __element__: Element;\n}\nexport interface MultiRangeType<Element extends ScalarType = ScalarType, Name extends string = `multirange<${Element[\"__name__\"]}>`> extends BaseType {\n    __name__: Name;\n    __kind__: TypeKind.multirange;\n    __element__: Element;\n}\nexport type orLiteralValue<Set extends TypeSet> = Set | (Set[\"__element__\"] extends ObjectType ? never : computeTsType<Set[\"__element__\"], Set[\"__cardinality__\"]>);\nexport type BaseTypeToTsType<Type extends BaseType, isParam extends boolean = false> = Type extends ScalarType ? isParam extends true ? Type[\"__tsargtype__\"] : Type[\"__tsconsttype__\"] : Type extends EnumType ? Type[\"__tstype__\"] : Type extends ArrayType<any> ? ArrayTypeToTsType<Type, isParam> : Type extends RangeType ? Range<Type[\"__element__\"][\"__tsconsttype__\"]> : Type extends MultiRangeType ? MultiRange<Type[\"__element__\"][\"__tsconsttype__\"]> : Type extends TupleType ? TupleItemsToTsType<Type[\"__items__\"], isParam> : Type extends NamedTupleType ? typeutil.flatten<NamedTupleTypeToTsType<Type, isParam>> : Type extends ObjectType ? typeutil.flatten<computeObjectShape<Type[\"__pointers__\"], Type[\"__shape__\"]>> : never;\nexport type setToTsType<Set extends TypeSet> = computeTsType<Set[\"__element__\"], Set[\"__cardinality__\"]>;\nexport type computeTsTypeCard<T extends any, C extends Cardinality> = Cardinality extends C ? unknown : C extends Cardinality.Empty ? null : C extends Cardinality.One ? T : C extends Cardinality.AtLeastOne ? [T, ...T[]] : C extends Cardinality.AtMostOne ? T | null : C extends Cardinality.Many ? T[] : C extends Cardinality ? unknown : never;\nexport type computeTsType<T extends BaseType, C extends Cardinality> = BaseType extends T ? unknown : computeTsTypeCard<BaseTypeToTsType<T>, C>;\nexport type propToTsType<Prop extends PropertyDesc> = Prop extends PropertyDesc<infer Type, infer Card> ? setToTsType<TypeSet<Type, Card>> : never;\nexport type linkToTsType<Link extends LinkDesc> = computeTsType<Link[\"target\"], Link[\"cardinality\"]>;\nexport type pointerToTsType<El extends PropertyDesc | LinkDesc> = El extends PropertyDesc ? propToTsType<El> : El extends LinkDesc<any, any, any, any> ? linkToTsType<El> : never;\nexport type getPrimitiveBaseType<T extends BaseType> = T extends ScalarType ? ScalarType<T[\"__name__\"], T[\"__tstype__\"], T[\"__tsargtype__\"]> : T;\nexport type getPrimitiveNonArrayBaseType<T extends BaseType> = T extends ArrayType ? never : getPrimitiveBaseType<T>;\nexport declare function isScalarType(type: BaseType): type is ScalarType;\nexport declare function isEnumType(type: BaseType): type is EnumType;\nexport declare function isObjectType(type: BaseType): type is ObjectType;\nexport declare function isTupleType(type: BaseType): type is TupleType;\nexport declare function isNamedTupleType(type: BaseType): type is NamedTupleType;\nexport declare function isArrayType(type: BaseType): type is ArrayType;\nexport type NonArrayType = ScalarType | EnumType | ObjectType | TupleType | NamedTupleType | RangeType | MultiRangeType;\nexport type AnyTupleType = TupleType | NamedTupleType;\nexport type AnyObjectType = ObjectType;\nexport type ParamType = ScalarType | EnumType | ArrayType<ScalarType | TupleType<typeutil.tupleOf<ParamType>> | NamedTupleType<{\n    [k: string]: ParamType;\n}> | RangeType | MultiRangeType> | TupleType<typeutil.tupleOf<ParamType>> | NamedTupleType<{\n    [k: string]: ParamType;\n}> | RangeType | MultiRangeType;\nexport {};\n"},{"path":"update.d.ts","content":"import { ExpressionKind, type typeutil, Cardinality } from \"edgedb/dist/reflection/index\";\nimport type { Expression, ObjectTypePointers, TypeSet, ObjectTypeSet, stripBacklinks, stripNonUpdateables, ObjectTypeExpression, ObjectType, $scopify } from \"./typesystem\";\nimport type { pointerToAssignmentExpression } from \"./casting\";\nimport { type SelectModifiers, type NormalisedSelectModifiers, type ComputeSelectCardinality } from \"./select\";\nimport { type pointerIsOptional } from \"./insert\";\nexport type $expr_Update<El extends ObjectType = ObjectType, Card extends Cardinality = Cardinality> = Expression<{\n    __kind__: ExpressionKind.Update;\n    __element__: El;\n    __cardinality__: Card;\n    __expr__: TypeSet;\n    __shape__: any;\n    __modifiers__: NormalisedSelectModifiers;\n    __scope__: ObjectTypeExpression;\n}>;\nexport type UpdateShape<Root extends ObjectTypeSet> = typeutil.stripNever<stripNonUpdateables<stripBacklinks<Root[\"__element__\"][\"__pointers__\"]>>> extends infer Shape ? Shape extends ObjectTypePointers ? {\n    [k in keyof Shape]?: (pointerToAssignmentExpression<Shape[k]> | (Shape[k][\"cardinality\"] extends Cardinality.Many | Cardinality.AtLeastOne ? {\n        \"+=\": pointerToAssignmentExpression<Shape[k], true>;\n    } | {\n        \"-=\": pointerToAssignmentExpression<Shape[k], true>;\n    } : never)) | (pointerIsOptional<Shape[k]> extends true ? undefined | null : never);\n} : never : never;\nexport declare function update<Expr extends ObjectTypeExpression, Shape extends {\n    filter?: SelectModifiers[\"filter\"];\n    filter_single?: SelectModifiers<Expr[\"__element__\"]>[\"filter_single\"];\n    set: UpdateShape<Expr>;\n}>(expr: Expr, shape: (scope: $scopify<Expr[\"__element__\"]>) => Readonly<Shape>): $expr_Update<Expr[\"__element__\"], ComputeSelectCardinality<Expr, Shape>>;\n"},{"path":"with.d.ts","content":"import { ExpressionKind, Cardinality } from \"edgedb/dist/reflection/index\";\nimport type { BaseType, Expression, TypeSet } from \"./typesystem\";\nimport type { $expr_Select } from \"./select\";\nimport type { $expr_For } from \"./for\";\nimport type { $expr_Insert } from \"./insert\";\nimport type { $expr_Update } from \"./update\";\nimport type { $expr_Group } from \"./group\";\nexport type $expr_Alias<El extends BaseType = BaseType, Card extends Cardinality = Cardinality> = Expression<{\n    __element__: El;\n    __cardinality__: Card;\n    __kind__: ExpressionKind.Alias;\n    __expr__: TypeSet;\n}>;\nexport declare function alias<Expr extends Expression>(expr: Expr): $expr_Alias<Expr[\"__element__\"], Expr[\"__cardinality__\"]>;\nexport type WithableExpression = $expr_Select | $expr_For | $expr_Insert | $expr_Update | $expr_Group;\nexport type $expr_With<Expr extends WithableExpression = WithableExpression> = Expression<{\n    __element__: Expr[\"__element__\"];\n    __cardinality__: Expr[\"__cardinality__\"];\n    __kind__: ExpressionKind.With;\n    __expr__: Expr;\n    __refs__: TypeSet[];\n}>;\ndeclare function _with<Expr extends WithableExpression>(refs: Expression[], expr: Expr): $expr_With<Expr>;\nexport { _with as with };\n"},{"path":"__spec__.d.ts","content":"import type { TypeKind } from \"./reflection\";\nexport declare const spec: Map<string, any>;\nexport declare const complexParamKinds: Set<TypeKind>;\n"}],"esm":[{"path":"cardinality.mjs","content":"import { Cardinality } from \"edgedb/dist/reflection/index.js\";\nexport var cardutil;\n(function (cardutil) {\n    function multiplyCardinalities(c1, c2) {\n        if (c1 === Cardinality.Empty)\n            return Cardinality.Empty;\n        if (c1 === Cardinality.One)\n            return c2;\n        if (c1 === Cardinality.AtMostOne) {\n            if (c2 === Cardinality.One)\n                return Cardinality.AtMostOne;\n            if (c2 === Cardinality.AtLeastOne)\n                return Cardinality.Many;\n            return c2;\n        }\n        if (c1 === Cardinality.Many) {\n            if (c2 === Cardinality.Empty)\n                return Cardinality.Empty;\n            return Cardinality.Many;\n        }\n        if (c1 === Cardinality.AtLeastOne) {\n            if (c2 === Cardinality.AtMostOne)\n                return Cardinality.Many;\n            if (c2 === Cardinality.One)\n                return Cardinality.AtLeastOne;\n            return c2;\n        }\n        throw new Error(`Invalid Cardinality ${c1}`);\n    }\n    cardutil.multiplyCardinalities = multiplyCardinalities;\n    function multiplyCardinalitiesVariadic(cards) {\n        if (cards.length === 0)\n            throw new Error(\"Empty tuple not allowed\");\n        if (cards.length === 1)\n            return cards[0];\n        return cards.reduce((product, card) => multiplyCardinalities(product, card), Cardinality.One);\n    }\n    cardutil.multiplyCardinalitiesVariadic = multiplyCardinalitiesVariadic;\n    function mergeCardinalities(a, b) {\n        if (a === Cardinality.Empty)\n            return b;\n        if (b === Cardinality.Empty)\n            return a;\n        if (a === Cardinality.AtLeastOne)\n            return Cardinality.AtLeastOne;\n        if (b === Cardinality.AtLeastOne)\n            return Cardinality.AtLeastOne;\n        if (a === Cardinality.One)\n            return Cardinality.AtLeastOne;\n        if (b === Cardinality.One)\n            return Cardinality.AtLeastOne;\n        return Cardinality.Many;\n    }\n    cardutil.mergeCardinalities = mergeCardinalities;\n    function mergeCardinalitiesVariadic(cards) {\n        if (cards.length === 0)\n            throw new Error(\"Empty tuple not allowed\");\n        if (cards.length === 1)\n            return cards[0];\n        const [first, second, ...rest] = cards;\n        if (cards.length === 2)\n            return mergeCardinalities(first, second);\n        return mergeCardinalitiesVariadic([\n            mergeCardinalities(first, second),\n            ...rest,\n        ]);\n    }\n    cardutil.mergeCardinalitiesVariadic = mergeCardinalitiesVariadic;\n    function orCardinalities(c1, c2) {\n        if (c1 === c2 || c1 === Cardinality.Many)\n            return c1;\n        if (c1 === Cardinality.AtLeastOne) {\n            if (c2 === Cardinality.One)\n                return Cardinality.AtLeastOne;\n            return Cardinality.Many;\n        }\n        if (c1 === Cardinality.AtMostOne) {\n            if (c2 === Cardinality.Many || c2 === Cardinality.AtLeastOne) {\n                return Cardinality.Many;\n            }\n            return c1;\n        }\n        if (c1 === Cardinality.Empty) {\n            if (c2 === Cardinality.AtMostOne || c2 === Cardinality.One) {\n                return Cardinality.AtMostOne;\n            }\n            return Cardinality.Many;\n        }\n        if (c2 === Cardinality.Empty)\n            return Cardinality.AtMostOne;\n        return c2;\n    }\n    cardutil.orCardinalities = orCardinalities;\n    function overrideLowerBound(card, override) {\n        if (override === \"One\") {\n            if (card === Cardinality.Many || card === Cardinality.AtLeastOne) {\n                return Cardinality.AtLeastOne;\n            }\n            else {\n                return Cardinality.One;\n            }\n        }\n        else {\n            if (card === Cardinality.Many || card === Cardinality.AtLeastOne) {\n                return Cardinality.Many;\n            }\n            else if (card === Cardinality.Empty) {\n                return Cardinality.Empty;\n            }\n            else {\n                return Cardinality.AtMostOne;\n            }\n        }\n    }\n    cardutil.overrideLowerBound = overrideLowerBound;\n    function overrideUpperBound(card, override) {\n        if (override === \"One\") {\n            if (card === Cardinality.One || card === Cardinality.AtLeastOne) {\n                return Cardinality.One;\n            }\n            else {\n                return Cardinality.AtMostOne;\n            }\n        }\n        else {\n            if (card === Cardinality.One || card === Cardinality.AtLeastOne) {\n                return Cardinality.AtLeastOne;\n            }\n            else {\n                return Cardinality.Many;\n            }\n        }\n    }\n    cardutil.overrideUpperBound = overrideUpperBound;\n})(cardutil || (cardutil = {}));\n"},{"path":"cast.mjs","content":"import { ExpressionKind, Cardinality } from \"edgedb/dist/reflection/index.js\";\nimport { $expressionify } from \"./path.mjs\";\nimport { literalToTypeSet } from \"./castMaps.mjs\";\nexport function cast(target, expr) {\n    const cleanedExpr = expr === null ? null : literalToTypeSet(expr);\n    return $expressionify({\n        __element__: target.__cardinality__\n            ? target.__element__\n            : target,\n        __cardinality__: cleanedExpr === null ? Cardinality.Empty : cleanedExpr.__cardinality__,\n        __expr__: cleanedExpr,\n        __kind__: ExpressionKind.Cast,\n    });\n}\n"},{"path":"casting.mjs","content":"export {};\n"},{"path":"castMaps.mjs","content":"export { literalToTypeSet };\nexport function getSharedParentScalar(a, b) { }\n"},{"path":"collections.mjs","content":"import { Cardinality, ExpressionKind, TypeKind, } from \"edgedb/dist/reflection/index.js\";\nimport { cardutil } from \"./cardinality.mjs\";\nimport { $expressionify } from \"./path.mjs\";\nimport { literalToTypeSet, } from \"./castMaps.mjs\";\nconst indexSliceRegx = /^(-?\\d+)(?:(:)(-?\\d+)?)?|:(-?\\d+)$/;\nconst arrayLikeProxyHandlers = {\n    get(target, prop, proxy) {\n        const match = typeof prop === \"string\" ? prop.match(indexSliceRegx) : null;\n        if (match) {\n            const start = match[1];\n            const end = match[3] ?? match[4];\n            const isIndex = start && !match[2];\n            return $expressionify({\n                __kind__: ExpressionKind.Operator,\n                __element__: target.__element__.__kind__ === TypeKind.array && isIndex\n                    ? target.__element__.__element__\n                    : target.__element__,\n                __cardinality__: target.__cardinality__,\n                __name__: \"[]\",\n                __opkind__: \"Infix\",\n                __args__: [\n                    proxy,\n                    isIndex\n                        ? literalToTypeSet(Number(start))\n                        : [\n                            start && literalToTypeSet(Number(start)),\n                            end && literalToTypeSet(Number(end)),\n                        ],\n                ],\n            });\n        }\n        return target[prop];\n    },\n};\nfunction arrayLikeIndex(index) {\n    const indexTypeSet = literalToTypeSet(index);\n    return $expressionify({\n        __kind__: ExpressionKind.Operator,\n        __element__: this.__element__.__kind__ === TypeKind.array\n            ? this.__element__.__element__\n            : this.__element__,\n        __cardinality__: cardutil.multiplyCardinalities(this.__cardinality__, indexTypeSet.__cardinality__),\n        __name__: \"[]\",\n        __opkind__: \"Infix\",\n        __args__: [this, indexTypeSet],\n    });\n}\nfunction arrayLikeSlice(start, end) {\n    const startTypeSet = start && literalToTypeSet(start);\n    const endTypeSet = end && literalToTypeSet(end);\n    return $expressionify({\n        __kind__: ExpressionKind.Operator,\n        __element__: this.__element__,\n        __cardinality__: cardutil.multiplyCardinalities(cardutil.multiplyCardinalities(this.__cardinality__, startTypeSet?.__cardinality__ ?? Cardinality.One), endTypeSet?.__cardinality__ ?? Cardinality.One),\n        __name__: \"[]\",\n        __opkind__: \"Infix\",\n        __args__: [this, [startTypeSet, endTypeSet]],\n    });\n}\nexport function $arrayLikeIndexify(_expr) {\n    if (_expr.__element__.__kind__ === TypeKind.array ||\n        (_expr.__element__.__kind__ === TypeKind.scalar &&\n            (_expr.__element__.__name__ === \"std::str\" ||\n                _expr.__element__.__name__ === \"std::bytes\"))) {\n        const expr = new Proxy(_expr, arrayLikeProxyHandlers);\n        expr.index = arrayLikeIndex.bind(expr);\n        expr.slice = arrayLikeSlice.bind(expr);\n        return expr;\n    }\n    return _expr;\n}\nexport function array(arg) {\n    if (Array.isArray(arg)) {\n        const items = arg.map((a) => literalToTypeSet(a));\n        return $expressionify({\n            __kind__: ExpressionKind.Array,\n            __cardinality__: cardutil.multiplyCardinalitiesVariadic(items.map((item) => item.__cardinality__)),\n            __element__: {\n                __kind__: TypeKind.array,\n                __name__: `array<${items[0].__element__.__name__}>`,\n                __element__: items[0].__element__,\n            },\n            __items__: items,\n        });\n    }\n    if (arg.__kind__) {\n        return {\n            __kind__: TypeKind.array,\n            __name__: `array<${arg.__name__}>`,\n            __element__: arg,\n        };\n    }\n    throw new Error(\"Invalid array input.\");\n}\nconst tupleProxyHandlers = {\n    get(target, prop, proxy) {\n        const type = target.__element__;\n        const items = type.__kind__ === TypeKind.tuple\n            ? type.__items__\n            : type.__kind__ === TypeKind.namedtuple\n                ? type.__shape__\n                : null;\n        return items?.hasOwnProperty(prop)\n            ? tuplePath(proxy, items[prop], prop)\n            : target[prop];\n    },\n};\nexport function $tuplePathify(expr) {\n    if (expr.__element__.__kind__ !== TypeKind.tuple &&\n        expr.__element__.__kind__ !== TypeKind.namedtuple) {\n        return expr;\n    }\n    return new Proxy(expr, tupleProxyHandlers);\n}\nfunction tuplePath(parent, itemType, index) {\n    return $expressionify({\n        __kind__: ExpressionKind.TuplePath,\n        __element__: itemType,\n        __cardinality__: parent.__cardinality__,\n        __parent__: parent,\n        __index__: index,\n    });\n}\nfunction makeTupleType(name, items) {\n    return {\n        __kind__: TypeKind.tuple,\n        __name__: name,\n        __items__: items,\n    };\n}\nconst typeKinds = new Set(Object.values(TypeKind));\nexport function tuple(input) {\n    if (Array.isArray(input)) {\n        if (input.every((item) => typeKinds.has(item.__kind__))) {\n            const typeItems = input;\n            const typeName = `tuple<${typeItems\n                .map((item) => item.__name__)\n                .join(\", \")}>`;\n            return makeTupleType(typeName, typeItems);\n        }\n        const items = input.map((item) => literalToTypeSet(item));\n        const name = `tuple<${items\n            .map((item) => item.__element__.__name__)\n            .join(\", \")}>`;\n        return $expressionify({\n            __kind__: ExpressionKind.Tuple,\n            __element__: makeTupleType(name, items.map((item) => item.__element__)),\n            __cardinality__: cardutil.multiplyCardinalitiesVariadic(items.map((i) => i.__cardinality__)),\n            __items__: items,\n        });\n    }\n    else {\n        if (Object.values(input).every((el) => typeKinds.has(el.__kind__))) {\n            const typeName = `tuple<${Object.entries(input)\n                .map(([key, val]) => `${key}: ${val.__name__}`)\n                .join(\", \")}>`;\n            return {\n                __kind__: TypeKind.namedtuple,\n                __name__: typeName,\n                __shape__: input,\n            };\n        }\n        const exprShape = {};\n        const typeShape = {};\n        for (const [key, val] of Object.entries(input)) {\n            const typeSet = literalToTypeSet(val);\n            exprShape[key] = typeSet;\n            typeShape[key] = typeSet.__element__;\n        }\n        const name = `tuple<${Object.entries(exprShape)\n            .map(([key, val]) => `${key}: ${val.__element__.__name__}`)\n            .join(\", \")}>`;\n        return $expressionify({\n            __kind__: ExpressionKind.NamedTuple,\n            __element__: {\n                __kind__: TypeKind.namedtuple,\n                __name__: name,\n                __shape__: typeShape,\n            },\n            __cardinality__: cardutil.multiplyCardinalitiesVariadic(Object.values(exprShape).map((val) => val.__cardinality__)),\n            __shape__: exprShape,\n        });\n    }\n}\nexport function $objectTypeToTupleType(...args) {\n    const [objExpr, fields] = args;\n    const shape = Object.entries(objExpr.__element__.__pointers__).reduce((_shape, [key, val]) => {\n        if (fields?.length\n            ? fields.includes(key)\n            : key !== \"id\" && val.__kind__ === \"property\" && !val.computed) {\n            _shape[key] = val.target;\n        }\n        return _shape;\n    }, {});\n    return tuple(shape);\n}\n"},{"path":"detached.mjs","content":"import { ExpressionKind } from \"edgedb/dist/reflection/index.js\";\nimport { $expressionify } from \"./path.mjs\";\nexport function detached(expr) {\n    return $expressionify({\n        __element__: expr.__element__,\n        __cardinality__: expr.__cardinality__,\n        __expr__: expr,\n        __kind__: ExpressionKind.Detached,\n    });\n}\n"},{"path":"external.mjs","content":"export { literal } from \"./literal.mjs\";\nexport { set } from \"./set.mjs\";\nexport { cast } from \"./cast.mjs\";\nexport { ASC, DESC, EMPTY_FIRST, EMPTY_LAST, is, delete, select, } from \"./select.mjs\";\nexport { update } from \"./update.mjs\";\nexport { insert } from \"./insert.mjs\";\nexport { array, tuple, $objectTypeToTupleType as objectTypeToTupleType, } from \"./collections.mjs\";\nexport { for } from \"./for.mjs\";\nexport { alias, with } from \"./with.mjs\";\nexport { optional, params } from \"./params.mjs\";\nexport { detached } from \"./detached.mjs\";\n"},{"path":"for.mjs","content":"import { Cardinality, ExpressionKind } from \"edgedb/dist/reflection/index.js\";\nimport { cardutil } from \"./cardinality.mjs\";\nimport { $expressionify } from \"./path.mjs\";\nfunction _for(set, expr) {\n    const forVar = $expressionify({\n        __kind__: ExpressionKind.ForVar,\n        __element__: set.__element__,\n        __cardinality__: Cardinality.One,\n    });\n    const returnExpr = expr(forVar);\n    return $expressionify({\n        __kind__: ExpressionKind.For,\n        __element__: returnExpr.__element__,\n        __cardinality__: cardutil.multiplyCardinalities(set.__cardinality__, returnExpr.__cardinality__),\n        __iterSet__: set,\n        __expr__: returnExpr,\n        __forVar__: forVar,\n    });\n}\nexport { _for as for };\n"},{"path":"funcops.mjs","content":"import { Cardinality, TypeKind, } from \"edgedb/dist/reflection/index.js\";\nimport { cardutil } from \"./cardinality.mjs\";\nimport { makeType } from \"./hydrate.mjs\";\nimport { cast } from \"./cast.mjs\";\nimport { isImplicitlyCastableTo, literalToTypeSet } from \"./castMaps.mjs\";\nimport { literal } from \"./literal.mjs\";\nfunction mapLiteralToTypeSet(literals) {\n    if (Array.isArray(literals)) {\n        return literals.map((lit) => (lit != null ? literalToTypeSet(lit) : lit));\n    }\n    const obj = {};\n    for (const key of Object.keys(literals)) {\n        obj[key] =\n            literals[key] != null ? literalToTypeSet(literals[key]) : literals[key];\n    }\n    return obj;\n}\nexport function $resolveOverload(funcName, args, typeSpec, funcDefs) {\n    const positionalArgs = [];\n    let namedArgs;\n    if (args.length) {\n        if (args[0] !== undefined) {\n            try {\n                positionalArgs.push(literalToTypeSet(args[0]));\n            }\n            catch {\n                namedArgs = mapLiteralToTypeSet(args[0]);\n            }\n        }\n        else {\n            positionalArgs.push(undefined);\n        }\n        positionalArgs.push(...mapLiteralToTypeSet(args.slice(1)));\n    }\n    for (const def of funcDefs) {\n        const resolvedOverload = _tryOverload(funcName, positionalArgs, namedArgs, typeSpec, def);\n        if (resolvedOverload !== null) {\n            return resolvedOverload;\n        }\n    }\n    throw new Error(`No function overload found for ${funcName.includes(\"::\")\n        ? `'e.${funcName.split(\"::\").join(\".\")}()'`\n        : `operator '${funcName}'`} with args: ${[...positionalArgs, ...Object.values(namedArgs ?? {})]\n        .filter(Boolean)\n        .map((arg) => `Element: ${arg.__element__.__name__} (${arg.__cardinality__})`)\n        .join(\", \")}`);\n}\nconst ANYTYPE_ARG = Symbol();\nfunction _tryOverload(funcName, args, namedArgs, typeSpec, funcDef) {\n    if ((funcDef.namedArgs === undefined && namedArgs !== undefined) ||\n        (namedArgs === undefined &&\n            funcDef.namedArgs &&\n            Object.values(funcDef.namedArgs).some((arg) => !arg.optional))) {\n        return null;\n    }\n    const lastParamVariadic = funcDef.args[funcDef.args.length - 1]?.variadic;\n    if (!lastParamVariadic && args.length > funcDef.args.length) {\n        return null;\n    }\n    const paramCardinalities = [Cardinality.One];\n    if (namedArgs) {\n        for (const [key, value] of Object.entries(namedArgs)) {\n            const argDef = funcDef.namedArgs?.[key];\n            if (!argDef ||\n                !compareType(typeSpec, argDef.typeId, value.__element__).match) {\n                return null;\n            }\n            paramCardinalities.push(argDef.setoftype\n                ? funcDef.preservesOptionality\n                    ? cardutil.overrideUpperBound(value.__cardinality__, \"One\")\n                    : Cardinality.One\n                : argDef.optional\n                    ? cardutil.overrideLowerBound(value.__cardinality__, \"One\")\n                    : value.__cardinality__);\n        }\n    }\n    let positionalArgs = [];\n    let returnAnytype;\n    let needsAnytypeReplacement = false;\n    for (let i = 0; i < funcDef.args.length; i++) {\n        const argDef = funcDef.args[i];\n        const arg = args[i];\n        if (arg === undefined) {\n            if (!argDef.optional) {\n                return null;\n            }\n            if (i < args.length) {\n                const argTypeName = typeSpec.get(argDef.typeId).name;\n                if (argTypeName.includes(\"anytype\") ||\n                    argTypeName.includes(\"std::anypoint\")) {\n                    if (!returnAnytype) {\n                        positionalArgs.push(ANYTYPE_ARG);\n                        needsAnytypeReplacement = true;\n                    }\n                    else {\n                        positionalArgs.push(cast(returnAnytype, null));\n                    }\n                }\n                else {\n                    const argType = makeType(typeSpec, argDef.typeId, literal);\n                    positionalArgs.push(cast(argType, null));\n                }\n            }\n        }\n        else {\n            const { match, anytype } = compareType(typeSpec, argDef.typeId, arg.__element__);\n            if (!match) {\n                return null;\n            }\n            if (!returnAnytype && anytype) {\n                returnAnytype = anytype;\n            }\n            positionalArgs.push(...(argDef.variadic ? args.slice(i) : [arg]));\n            if (argDef.setoftype) {\n                paramCardinalities.push(funcDef.preservesOptionality\n                    ? cardutil.overrideUpperBound(arg.__cardinality__, \"One\")\n                    : Cardinality.One);\n            }\n            else {\n                const card = argDef.variadic\n                    ? cardutil.multiplyCardinalitiesVariadic(args.slice(i).map((el) => el.__cardinality__))\n                    : arg.__cardinality__;\n                paramCardinalities.push(argDef.optional ? cardutil.overrideLowerBound(card, \"One\") : card);\n            }\n        }\n    }\n    let cardinality;\n    if (funcName === \"if_else\") {\n        cardinality = cardutil.multiplyCardinalities(cardutil.orCardinalities(positionalArgs[0].__cardinality__, positionalArgs[2].__cardinality__), positionalArgs[1].__cardinality__);\n    }\n    else if (funcName === \"std::assert_exists\") {\n        cardinality = cardutil.overrideLowerBound(positionalArgs[0].__cardinality__, \"One\");\n    }\n    else if (funcName === \"union\") {\n        cardinality = cardutil.mergeCardinalities(positionalArgs[0].__cardinality__, positionalArgs[1].__cardinality__);\n    }\n    else if (funcName === \"??\") {\n        cardinality = cardutil.orCardinalities(positionalArgs[0].__cardinality__, positionalArgs[1].__cardinality__);\n    }\n    else if (funcName === \"distinct\") {\n        cardinality = positionalArgs[0].__cardinality__;\n    }\n    else {\n        cardinality =\n            funcDef.returnTypemod === \"SetOfType\"\n                ? Cardinality.Many\n                : cardutil.multiplyCardinalitiesVariadic(paramCardinalities);\n        if (funcDef.returnTypemod === \"OptionalType\" &&\n            !funcDef.preservesOptionality) {\n            cardinality = cardutil.overrideLowerBound(cardinality, \"Zero\");\n        }\n    }\n    if (needsAnytypeReplacement) {\n        if (!returnAnytype) {\n            throw new Error(`could not resolve anytype for ${funcName}`);\n        }\n        positionalArgs = positionalArgs.map((arg) => arg === ANYTYPE_ARG ? cast(returnAnytype, null) : arg);\n    }\n    return {\n        kind: funcDef.kind,\n        returnType: makeType(typeSpec, funcDef.returnTypeId, literal, returnAnytype),\n        cardinality,\n        args: positionalArgs,\n        namedArgs: namedArgs ?? {},\n    };\n}\nconst nameRemapping = {\n    \"std::int16\": \"std::number\",\n    \"std::int32\": \"std::number\",\n    \"std::int64\": \"std::number\",\n    \"std::float32\": \"std::number\",\n    \"std::float64\": \"std::number\",\n};\nconst descendantCache = new Map();\nfunction getDescendantNames(typeSpec, typeId) {\n    if (descendantCache.has(typeId)) {\n        return descendantCache.get(typeId);\n    }\n    const descendants = [\n        ...new Set([...typeSpec.values()]\n            .filter((type) => type.kind === \"scalar\" && type.bases.some(({ id }) => id === typeId))\n            .flatMap((type) => type.is_abstract\n            ? getDescendantNames(typeSpec, type.id)\n            : [nameRemapping[type.name], type.name])),\n    ];\n    descendantCache.set(typeId, descendants);\n    return descendants;\n}\nfunction compareType(typeSpec, typeId, arg) {\n    const type = typeSpec.get(typeId);\n    if (type.name === \"anytype\") {\n        return { match: true, anytype: arg };\n    }\n    if (type.name === \"anyobject\") {\n        return { match: arg.__kind__ === TypeKind.object, anytype: arg };\n    }\n    if (type.name === \"std::anypoint\") {\n        const descendants = getDescendantNames(typeSpec, typeId);\n        if (descendants.includes(arg.__name__)) {\n            return { match: true, anytype: arg };\n        }\n    }\n    if (type.name === \"std::anyenum\") {\n        return { match: arg.__kind__ === TypeKind.enum };\n    }\n    if (type.kind === \"scalar\") {\n        arg = arg.__casttype__ ?? arg;\n        return {\n            match: (arg.__kind__ === TypeKind.scalar || arg.__kind__ === TypeKind.enum) &&\n                (arg.__name__ === type.name ||\n                    isImplicitlyCastableTo(arg.__name__, type.name)),\n        };\n    }\n    if (type.kind === \"array\") {\n        if (arg.__kind__ === TypeKind.array) {\n            return compareType(typeSpec, type.array_element_id, arg.__element__);\n        }\n    }\n    if (type.kind === \"range\") {\n        if (arg.__kind__ === TypeKind.range) {\n            return compareType(typeSpec, type.range_element_id, arg.__element__);\n        }\n    }\n    if (type.kind === \"multirange\") {\n        if (arg.__kind__ === TypeKind.multirange) {\n            return compareType(typeSpec, type.multirange_element_id, arg.__element__);\n        }\n    }\n    if (type.kind === \"object\") {\n        if (arg.__kind__ !== TypeKind.object)\n            return { match: false };\n        const objectArg = arg;\n        let match = true;\n        for (const ptr of type.pointers) {\n            if (objectArg.__pointers__[ptr.name]) {\n                const argPtr = objectArg.__pointers__[ptr.name];\n                const ptrTarget = typeSpec.get(ptr.target_id);\n                if (ptrTarget.name !== argPtr.target.__name__ ||\n                    ptr.card !== argPtr.cardinality) {\n                    match = false;\n                }\n            }\n        }\n        return {\n            match,\n        };\n    }\n    if (type.kind === \"tuple\") {\n        const items = arg.__kind__ === TypeKind.tuple\n            ? arg.__items__\n            : arg.__kind__ === TypeKind.namedtuple\n                ? arg.__shape__\n                : null;\n        if (items) {\n            const keys = Object.keys(items);\n            if (keys.length === type.tuple_elements.length) {\n                let anytype;\n                for (let i = 0; i < keys.length; i++) {\n                    if (keys[i] !== type.tuple_elements[i].name) {\n                        return { match: false };\n                    }\n                    const { match: m, anytype: a } = compareType(typeSpec, type.tuple_elements[i].target_id, items[keys[i]]);\n                    if (!m) {\n                        return { match: false };\n                    }\n                    if (a)\n                        anytype = a;\n                }\n                return { match: true, anytype };\n            }\n        }\n    }\n    return { match: false };\n}\n"},{"path":"globals.mjs","content":"import { ExpressionKind } from \"edgedb/dist/reflection/index.js\";\nimport { $expressionify } from \"./path.mjs\";\nexport function makeGlobal(name, type, card) {\n    return $expressionify({\n        __name__: name,\n        __element__: type,\n        __cardinality__: card,\n        __kind__: ExpressionKind.Global,\n    });\n}\n"},{"path":"group.mjs","content":"import { Cardinality, ExpressionKind, TypeKind, } from \"edgedb/dist/reflection/index.js\";\nimport { makeType } from \"./hydrate.mjs\";\nimport { $expressionify, $getScopedExpr } from \"./path.mjs\";\nimport { spec } from \"./__spec__.mjs\";\nimport { literal } from \"./literal.mjs\";\nimport { resolveShapeElement } from \"./select.mjs\";\nexport function isGroupingSet(arg) {\n    return arg.__kind__ === \"groupingset\";\n}\nconst makeGroupingSet = (prefix) => (grps) => {\n    const seenKeys = new Map();\n    const unfiltered = Object.entries(grps).flatMap(([k, grp]) => isGroupingSet(grp)\n        ? grp.__exprs__\n        : [[k, grp]]);\n    const filtered = unfiltered.filter(([k, expr]) => {\n        if (!seenKeys.has(k)) {\n            seenKeys.set(k, expr);\n            return true;\n        }\n        if (expr !== seenKeys.get(k)) {\n            throw new Error(`Cannot override pre-existing expression with key \"${k}\"`);\n        }\n        return false;\n    });\n    return {\n        [`${Math.round(1000000 * Math.random())}___`]: {\n            __kind__: \"groupingset\",\n            __settype__: prefix,\n            __elements__: grps,\n            __exprs__: filtered,\n        },\n    };\n};\nconst set = makeGroupingSet(\"set\");\nconst tuple = makeGroupingSet(\"tuple\");\nconst rollup = makeGroupingSet(\"rollup\");\nconst cube = makeGroupingSet(\"cube\");\nconst setFuncs = { set, tuple, rollup, cube };\nconst groupFunc = (expr, getter) => {\n    const { shape, scope, modifiers } = resolveShape(getter, expr);\n    const groupSet = tuple(modifiers.by);\n    const key = Object.keys(groupSet)[0];\n    const grouping = groupSet[key];\n    const keyShape = {};\n    const keyPointers = {};\n    const keyShapeElement = {};\n    for (const [k, e] of grouping.__exprs__) {\n        keyShape[k] = $expressionify({\n            __element__: e.__element__,\n            __cardinality__: Cardinality.AtMostOne,\n        });\n        keyPointers[k] = {\n            __kind__: \"property\",\n            target: e.__element__,\n            cardinality: Cardinality.AtMostOne,\n            exclusive: false,\n            computed: false,\n            readonly: false,\n            hasDefault: false,\n        };\n        keyShapeElement[k] = true;\n    }\n    const $FreeObject = makeType(spec, [...spec.values()].find((s) => s.name === \"std::FreeObject\").id, literal);\n    const str = makeType(spec, [...spec.values()].find((s) => s.name === \"std::str\").id, literal);\n    return $expressionify({\n        __element__: {\n            ...$FreeObject,\n            __name__: \"std::FreeObject\",\n            __pointers__: {\n                ...$FreeObject.__pointers__,\n                __name__: \"std::FreeObject\",\n                grouping: {\n                    __kind__: \"property\",\n                    target: str,\n                    cardinality: Cardinality.Many,\n                    exclusive: false,\n                    computed: false,\n                    readonly: false,\n                    hasDefault: false,\n                },\n                key: {\n                    __kind__: \"link\",\n                    target: {\n                        ...$FreeObject,\n                        __name__: \"std::FreeObject\",\n                        __pointers__: {\n                            ...$FreeObject.__pointers__,\n                            ...keyPointers,\n                        },\n                        __shape__: keyShape,\n                    },\n                    properties: {},\n                    cardinality: Cardinality.One,\n                    exclusive: false,\n                    computed: false,\n                    readonly: false,\n                    hasDefault: false,\n                },\n                elements: {\n                    __kind__: \"link\",\n                    target: expr.__element__,\n                    cardinality: Cardinality.Many,\n                    properties: {},\n                    exclusive: false,\n                    computed: false,\n                    readonly: false,\n                    hasDefault: false,\n                },\n            },\n            __shape__: {\n                grouping: $expressionify({\n                    __element__: str,\n                    __cardinality__: Cardinality.Many,\n                }),\n                key: $expressionify({\n                    __element__: {\n                        ...$FreeObject,\n                        __shape__: keyShape,\n                    },\n                    __cardinality__: Cardinality.One,\n                }),\n                elements: $expressionify({\n                    __element__: { ...expr.__element__, __shape__: shape },\n                    __cardinality__: Cardinality.Many,\n                }),\n            },\n        },\n        __cardinality__: Cardinality.Many,\n        __expr__: expr,\n        __modifiers__: { by: grouping },\n        __kind__: ExpressionKind.Group,\n        __scope__: scope,\n    });\n};\nObject.assign(groupFunc, setFuncs);\nfunction resolveShape(shapeGetter, expr) {\n    const modifiers = {};\n    const shape = {};\n    const scope = $getScopedExpr(expr);\n    const selectShape = typeof shapeGetter === \"function\" ? shapeGetter(scope) : shapeGetter;\n    for (const [key, value] of Object.entries(selectShape)) {\n        if (key === \"by\") {\n            modifiers[key] = value;\n        }\n        else {\n            if (expr.__element__.__kind__ !== TypeKind.object) {\n                throw new Error(`Invalid select shape key '${key}' on scalar expression, ` +\n                    `only modifiers are allowed (filter, order_by, offset and limit)`);\n            }\n            shape[key] = resolveShapeElement(key, value, scope);\n        }\n    }\n    if (Object.keys(shape).length === 0) {\n        shape.id = true;\n    }\n    if (!modifiers.by) {\n        throw new Error(\"Must provide a `by` key in `e.group`\");\n    }\n    return { shape, modifiers, scope };\n}\nexport const group = groupFunc;\n"},{"path":"hydrate.mjs","content":"import { util, TypeKind } from \"edgedb/dist/reflection/index.js\";\nconst typeCache = new Map();\nconst _linkProps = Symbol();\nfunction applySpec(spec, type, shape, seen, literal) {\n    const allPointers = [\n        ...type.pointers,\n        ...type.backlinks,\n        ...type.backlink_stubs,\n    ];\n    for (const ptr of allPointers) {\n        if (seen.has(ptr.name)) {\n            continue;\n        }\n        seen.add(ptr.name);\n        if (ptr.kind === \"link\") {\n            shape[ptr.name] = {\n                __kind__: \"link\",\n                cardinality: ptr.card,\n                exclusive: ptr.is_exclusive,\n                computed: ptr.is_computed,\n                readonly: ptr.is_readonly,\n            };\n            util.defineGetter(shape[ptr.name], \"target\", () => makeType(spec, ptr.target_id, literal));\n            util.defineGetter(shape[ptr.name], \"properties\", () => {\n                if (!shape[ptr.name][_linkProps]) {\n                    const linkProperties = (shape[ptr.name][_linkProps] = {});\n                    for (const linkProp of ptr.pointers ?? []) {\n                        if (linkProp.kind !== \"property\") {\n                            return;\n                        }\n                        if (linkProp.name === \"source\" || linkProp.name === \"target\") {\n                            return;\n                        }\n                        const linkPropObject = {\n                            __kind__: \"property\",\n                        };\n                        linkPropObject.cardinality = linkProp.card;\n                        util.defineGetter(linkPropObject, \"target\", () => {\n                            return makeType(spec, linkProp.target_id, literal);\n                        });\n                        linkProperties[linkProp.name] = linkPropObject;\n                    }\n                }\n                return shape[ptr.name][_linkProps];\n            });\n        }\n        else if (ptr.kind === \"property\") {\n            shape[ptr.name] = {\n                __kind__: \"property\",\n                cardinality: ptr.card,\n                exclusive: ptr.is_exclusive,\n                computed: ptr.is_computed,\n                readonly: ptr.is_readonly,\n            };\n            util.defineGetter(shape[ptr.name], \"target\", () => makeType(spec, ptr.target_id, literal));\n        }\n    }\n}\nexport function makeType(spec, id, literal, anytype) {\n    const type = spec.get(id);\n    if (type.name === \"anytype\" || type.name === \"std::anypoint\") {\n        if (anytype)\n            return anytype;\n        throw new Error(\"anytype not provided\");\n    }\n    if (typeCache.has(id)) {\n        return typeCache.get(id);\n    }\n    const obj = {};\n    obj.__name__ = type.name;\n    if (type.kind === \"object\") {\n        obj.__kind__ = TypeKind.object;\n        const pointers = {};\n        const seen = new Set();\n        applySpec(spec, type, pointers, seen, literal);\n        const ancestors = [...type.bases];\n        for (const anc of ancestors) {\n            const ancType = spec.get(anc.id);\n            if (ancType.kind === \"object\" || ancType.kind === \"scalar\") {\n                ancestors.push(...ancType.bases);\n            }\n            if (ancType.kind !== \"object\") {\n                throw new Error(`Not an object: ${id}`);\n            }\n            applySpec(spec, ancType, pointers, seen, literal);\n        }\n        obj.__pointers__ = pointers;\n        obj.__shape__ = {};\n        typeCache.set(id, obj);\n        return obj;\n    }\n    else if (type.kind === \"scalar\") {\n        const scalarObj = type.is_abstract\n            ? {}\n            : type.enum_values\n                ? {}\n                :\n                    ((val) => {\n                        return literal(scalarObj, val);\n                    });\n        if (type.enum_values) {\n            scalarObj.__kind__ = TypeKind.enum;\n            scalarObj.__values__ = type.enum_values;\n            for (const val of type.enum_values) {\n                Object.defineProperty(scalarObj, val, {\n                    get() {\n                        return literal(scalarObj, val);\n                    },\n                });\n            }\n        }\n        else {\n            scalarObj.__kind__ = TypeKind.scalar;\n        }\n        scalarObj.__name__ = type.name;\n        if (type.cast_type) {\n            scalarObj.__casttype__ = makeType(spec, type.cast_type, literal);\n        }\n        typeCache.set(id, scalarObj);\n        return scalarObj;\n    }\n    else if (type.kind === \"array\") {\n        obj.__kind__ = TypeKind.array;\n        util.defineGetter(obj, \"__element__\", () => {\n            return makeType(spec, type.array_element_id, literal, anytype);\n        });\n        util.defineGetter(obj, \"__name__\", () => {\n            return `array<${obj.__element__.__name__}>`;\n        });\n        return obj;\n    }\n    else if (type.kind === \"tuple\") {\n        if (type.tuple_elements[0].name === \"0\") {\n            obj.__kind__ = TypeKind.tuple;\n            util.defineGetter(obj, \"__items__\", () => {\n                return type.tuple_elements.map((el) => makeType(spec, el.target_id, literal, anytype));\n            });\n            util.defineGetter(obj, \"__name__\", () => {\n                return `tuple<${obj.__items__\n                    .map((item) => item.__name__)\n                    .join(\", \")}>`;\n            });\n            return obj;\n        }\n        else {\n            obj.__kind__ = TypeKind.namedtuple;\n            util.defineGetter(obj, \"__shape__\", () => {\n                const shape = {};\n                for (const el of type.tuple_elements) {\n                    shape[el.name] = makeType(spec, el.target_id, literal, anytype);\n                }\n                return shape;\n            });\n            util.defineGetter(obj, \"__name__\", () => {\n                return `tuple<${Object.entries(obj.__shape__)\n                    .map(([key, val]) => `${key}: ${val.__name__}`)\n                    .join(\", \")}>`;\n            });\n            return obj;\n        }\n    }\n    else if (type.kind === \"range\") {\n        obj.__kind__ = TypeKind.range;\n        util.defineGetter(obj, \"__element__\", () => {\n            return makeType(spec, type.range_element_id, literal, anytype);\n        });\n        util.defineGetter(obj, \"__name__\", () => {\n            return `range<${obj.__element__.__name__}>`;\n        });\n        return obj;\n    }\n    else if (type.kind === \"multirange\") {\n        obj.__kind__ = TypeKind.multirange;\n        util.defineGetter(obj, \"__element__\", () => {\n            return makeType(spec, type.multirange_element_id, literal, anytype);\n        });\n        util.defineGetter(obj, \"__name__\", () => {\n            return `multirange<${obj.__element__.__name__}>`;\n        });\n        return obj;\n    }\n    else {\n        throw new Error(`Invalid type: ${JSON.stringify(type, null, 2)}`);\n    }\n}\nexport function $mergeObjectTypes(a, b) {\n    const obj = {\n        __kind__: TypeKind.object,\n        __name__: `${a.__name__} UNION ${b.__name__}`,\n        get __pointers__() {\n            const merged = {};\n            for (const [akey, aitem] of Object.entries(a.__pointers__)) {\n                if (!b.__pointers__[akey])\n                    continue;\n                const bitem = b.__pointers__[akey];\n                if (aitem.cardinality !== bitem.cardinality)\n                    continue;\n                if (aitem.target.__name__ !== bitem.target.__name__)\n                    continue;\n                merged[akey] = aitem;\n            }\n            return merged;\n        },\n        __shape__: {},\n    };\n    return obj;\n}\nexport function $mergeTupleTypes(a, b) {\n    if (a.__items__.length !== b.__items__.length) {\n        throw new Error(\"Incompatible tuple types; lengths differ.\");\n    }\n    return {};\n}\n"},{"path":"insert.mjs","content":"import { Cardinality, ExpressionKind, TypeKind, } from \"edgedb/dist/reflection/index.js\";\nimport { $expressionify, $getScopedExpr } from \"./path.mjs\";\nimport { cast } from \"./cast.mjs\";\nimport { set } from \"./set.mjs\";\nimport { literal } from \"./literal.mjs\";\nimport { $getTypeByName } from \"./literal.mjs\";\nfunction unlessConflict(conflictGetter) {\n    const expr = {\n        __kind__: ExpressionKind.InsertUnlessConflict,\n        __element__: this.__element__,\n        __cardinality__: Cardinality.AtMostOne,\n        __expr__: this,\n    };\n    if (!conflictGetter) {\n        expr.__conflict__ = { on: null };\n        return $expressionify(expr);\n    }\n    else {\n        const scopedExpr = $getScopedExpr(this.__expr__);\n        const conflict = conflictGetter(scopedExpr);\n        expr.__conflict__ = conflict;\n        if (conflict.else) {\n            expr.__cardinality__ = conflict.else.__cardinality__;\n            if (this.__element__.__name__ !== conflict.else.__element__.__name__) {\n                expr.__element__ = $getTypeByName(\"std::Object\");\n            }\n        }\n        return $expressionify(expr);\n    }\n}\nexport function $insertify(expr) {\n    expr.unlessConflict = unlessConflict.bind(expr);\n    return expr;\n}\nexport function $normaliseInsertShape(root, shape, isUpdate = false) {\n    const newShape = {};\n    const _shape = shape.__element__?.__kind__ === TypeKind.namedtuple\n        ? Object.keys(shape.__element__.__shape__).map((key) => [key, shape[key]])\n        : Object.entries(shape);\n    for (const [key, _val] of _shape) {\n        let val = _val;\n        let setModify = null;\n        if (isUpdate && _val != null && typeof _val === \"object\") {\n            const valKeys = Object.keys(_val);\n            if (valKeys.length === 1 &&\n                (valKeys[0] === \"+=\" || valKeys[0] === \"-=\")) {\n                val = _val[valKeys[0]];\n                setModify = valKeys[0];\n            }\n        }\n        const pointer = root.__element__.__pointers__[key];\n        const isLinkProp = key[0] === \"@\";\n        if (!pointer && !isLinkProp) {\n            throw new Error(`Could not find property pointer for ${isUpdate ? \"update\" : \"insert\"} shape key: '${key}'`);\n        }\n        if (val === undefined)\n            continue;\n        if (val?.__kind__) {\n            if (val.__kind__ === ExpressionKind.Literal &&\n                val.__element__.__kind__ === TypeKind.range &&\n                val.__element__.__element__.__name__ === \"std::number\") {\n                newShape[key] = literal(pointer?.target, val.__value__);\n            }\n            else {\n                newShape[key] = _val;\n            }\n            continue;\n        }\n        if (isLinkProp) {\n            throw new Error(`Cannot assign plain data to link property '${key}'. Provide an expression instead.`);\n        }\n        if (!pointer) {\n            throw new Error(\"Code will never reach here, but TypeScript cannot determine\");\n        }\n        if (pointer.__kind__ !== \"property\" && val !== null) {\n            throw new Error(`Must provide subquery when assigning to link '${key}' in ${isUpdate ? \"update\" : \"insert\"} query.`);\n        }\n        const isMulti = pointer.cardinality === Cardinality.AtLeastOne ||\n            pointer.cardinality === Cardinality.Many;\n        if (pointer.__kind__ === \"property\") {\n            if (pointer.target.__name__ === \"std::json\") {\n            }\n        }\n        const wrappedVal = val === null\n            ? cast(pointer.target, null)\n            : isMulti && Array.isArray(val)\n                ? val.length === 0\n                    ? cast(pointer.target, null)\n                    : set(...val.map((v) => literal(pointer.target, v)))\n                : literal(pointer.target, val);\n        newShape[key] = setModify\n            ? { [setModify]: wrappedVal }\n            : wrappedVal;\n    }\n    return newShape;\n}\nexport function insert(root, shape) {\n    if (typeof shape !== \"object\") {\n        throw new Error(`invalid insert shape.${typeof shape === \"function\"\n            ? \" Hint: Insert shape is expected to be an object, \" +\n                \"not a function returning a shape object.\"\n            : \"\"}`);\n    }\n    const expr = {\n        __kind__: ExpressionKind.Insert,\n        __element__: root.__element__,\n        __cardinality__: Cardinality.One,\n        __expr__: root,\n        __shape__: $normaliseInsertShape(root, shape),\n    };\n    expr.unlessConflict = unlessConflict.bind(expr);\n    return $expressionify($insertify(expr));\n}\n"},{"path":"json.mjs","content":"import { ExpressionKind, TypeKind } from \"edgedb/dist/reflection/index.js\";\nimport { encodeB64 } from \"edgedb/dist/primitives/buffer.js\";\nfunction jsonStringify(type, val) {\n    if (type.__kind__ === TypeKind.array) {\n        if (Array.isArray(val)) {\n            return `[${val\n                .map((item) => jsonStringify(type.__element__, item))\n                .join()}]`;\n        }\n        throw new Error(`Param with array type is not an array`);\n    }\n    if (type.__kind__ === TypeKind.tuple) {\n        if (!Array.isArray(val)) {\n            throw new Error(`Param with tuple type is not an array`);\n        }\n        if (val.length !== type.__items__.length) {\n            throw new Error(`Param with tuple type has incorrect number of items. Got ${val.length} expected ${type.__items__.length}`);\n        }\n        return `[${val\n            .map((item, i) => jsonStringify(type.__items__[i], item))\n            .join()}]`;\n    }\n    if (type.__kind__ === TypeKind.namedtuple) {\n        if (typeof val !== \"object\") {\n            throw new Error(`Param with named tuple type is not an object`);\n        }\n        if (Object.keys(val).length !== Object.keys(type.__shape__).length) {\n            throw new Error(`Param with named tuple type has incorrect number of items. Got ${Object.keys(val).length} expected ${Object.keys(type.__shape__).length}`);\n        }\n        return `{${Object.entries(val)\n            .map(([key, item]) => {\n            if (!type.__shape__[key]) {\n                throw new Error(`Unexpected key in named tuple param: ${key}, expected keys: ${Object.keys(type.__shape__).join()}`);\n            }\n            return `\"${key}\": ${jsonStringify(type.__shape__[key], item)}`;\n        })\n            .join()}}`;\n    }\n    if (type.__kind__ === TypeKind.scalar) {\n        switch (type.__name__) {\n            case \"std::bigint\":\n                return val.toString();\n            case \"std::json\":\n                return JSON.stringify(val);\n            case \"std::bytes\":\n                return `\"${encodeB64(val)}\"`;\n            case \"cfg::memory\":\n                return `\"${val.toString()}\"`;\n            default:\n                return JSON.stringify(val);\n        }\n    }\n    if (type.__kind__ === TypeKind.enum) {\n        return JSON.stringify(val);\n    }\n    throw new Error(`Invalid param type: ${type.__kind__}`);\n}\nexport function jsonifyComplexParams(expr, _args) {\n    if (_args && expr.__kind__ === ExpressionKind.WithParams) {\n        const args = { ..._args };\n        for (const param of expr.__params__) {\n            if (param.__isComplex__) {\n                args[param.__name__] = jsonStringify(param.__element__, args[param.__name__]);\n            }\n        }\n        return args;\n    }\n    return _args;\n}\n"},{"path":"literal.mjs","content":"import { $expressionify } from \"./path.mjs\";\nimport { spec } from \"./__spec__.mjs\";\nimport { Cardinality, ExpressionKind } from \"edgedb/dist/reflection/index.js\";\nimport { makeType } from \"./hydrate.mjs\";\nexport function literal(type, value) {\n    return $expressionify({\n        __element__: type,\n        __cardinality__: Cardinality.One,\n        __kind__: ExpressionKind.Literal,\n        __value__: value,\n    });\n}\nexport const $nameMapping = new Map([\n    ...[...spec.values()].map((type) => [type.name, type.id]),\n    [\"std::number\", \"00000000-0000-0000-0000-0000000001ff\"],\n]);\nexport function $getType(id) {\n    return makeType(spec, id, literal);\n}\nexport function $getTypeByName(name) {\n    return makeType(spec, $nameMapping.get(name), literal);\n}\n"},{"path":"operators.mjs","content":"export {};\n"},{"path":"params.mjs","content":"import { ExpressionKind, Cardinality, TypeKind, } from \"edgedb/dist/reflection/index.js\";\nimport { $expressionify } from \"./path.mjs\";\nimport { runnableExpressionKinds } from \"./query.mjs\";\nimport { select } from \"./select.mjs\";\nimport { complexParamKinds } from \"./__spec__.mjs\";\nexport function optional(type) {\n    return {\n        __kind__: ExpressionKind.OptionalParam,\n        __type__: type,\n    };\n}\nexport function params(paramsDef, expr) {\n    const paramExprs = {};\n    for (const [key, param] of Object.entries(paramsDef)) {\n        const paramType = param.__kind__ === ExpressionKind.OptionalParam ? param.__type__ : param;\n        const isComplex = complexParamKinds.has(paramType.__kind__) ||\n            (paramType.__kind__ === TypeKind.array &&\n                complexParamKinds.has(paramType.__element__.__kind__));\n        paramExprs[key] = $expressionify({\n            __kind__: ExpressionKind.Param,\n            __element__: paramType,\n            __cardinality__: param.__kind__ === ExpressionKind.OptionalParam\n                ? Cardinality.AtMostOne\n                : Cardinality.One,\n            __name__: key,\n            __isComplex__: isComplex,\n        });\n    }\n    let returnExpr = expr(paramExprs);\n    if (!runnableExpressionKinds.has(returnExpr.__kind__)) {\n        returnExpr = select(returnExpr);\n    }\n    return $expressionify({\n        __kind__: ExpressionKind.WithParams,\n        __element__: returnExpr.__element__,\n        __cardinality__: returnExpr.__cardinality__,\n        __expr__: returnExpr,\n        __params__: Object.values(paramExprs),\n    });\n}\n"},{"path":"path.mjs","content":"import { ExpressionKind, TypeKind, Cardinality, } from \"edgedb/dist/reflection/index.js\";\nimport { cardutil } from \"./cardinality.mjs\";\nimport { literalToTypeSet } from \"./castMaps.mjs\";\nimport { $arrayLikeIndexify, $tuplePathify } from \"./collections.mjs\";\nimport { $toEdgeQL } from \"./toEdgeQL.mjs\";\nimport { $queryFunc, $queryFuncJSON } from \"./query.mjs\";\nfunction PathLeaf(root, parent, exclusive, scopeRoot = null) {\n    return $expressionify({\n        __kind__: ExpressionKind.PathLeaf,\n        __element__: root.__element__,\n        __cardinality__: root.__cardinality__,\n        __parent__: parent,\n        __scopeRoot__: scopeRoot,\n    });\n}\nfunction getStarShapeFromPointers(pointers) {\n    const shape = {};\n    for (const [key, ptr] of Object.entries(pointers)) {\n        if (ptr.__kind__ === \"property\") {\n            shape[key] = true;\n        }\n    }\n    return shape;\n}\nfunction PathNode(root, parent, scopeRoot = null) {\n    const obj = {\n        __kind__: ExpressionKind.PathNode,\n        __element__: root.__element__,\n        __cardinality__: root.__cardinality__,\n        __parent__: parent,\n        __scopeRoot__: scopeRoot,\n    };\n    Object.defineProperty(obj, \"*\", {\n        writable: false,\n        value: getStarShapeFromPointers(obj.__element__.__pointers__),\n    });\n    return $expressionify(obj);\n}\nconst _pathCache = Symbol();\nconst _pointers = Symbol();\nconst pathifyProxyHandlers = {\n    get(target, prop, proxy) {\n        const ptr = target[_pointers][prop];\n        if (ptr) {\n            return (target[_pathCache][prop] ??\n                (target[_pathCache][prop] = (ptr.__kind__ === \"property\" ? PathLeaf : PathNode)({\n                    __element__: ptr.target,\n                    __cardinality__: cardutil.multiplyCardinalities(target.__cardinality__, ptr.cardinality),\n                }, {\n                    linkName: prop,\n                    type: proxy,\n                }, ptr.exclusive ?? false, target.__scopeRoot__ ?? (scopeRoots.has(proxy) ? proxy : null))));\n        }\n        return target[prop];\n    },\n};\nexport function $pathify(_root) {\n    if (_root.__element__.__kind__ !== TypeKind.object) {\n        return _root;\n    }\n    const root = _root;\n    let pointers = {\n        ...root.__element__.__pointers__,\n    };\n    if (root.__parent__) {\n        const { type, linkName } = root.__parent__;\n        const parentPointer = type.__element__.__pointers__[linkName];\n        if (parentPointer?.__kind__ === \"link\") {\n            pointers = { ...pointers, ...parentPointer.properties };\n        }\n    }\n    for (const [key, val] of Object.entries(root.__element__.__shape__ || { id: true })) {\n        if (pointers[key])\n            continue;\n        const valType = val?.__element__;\n        if (!valType)\n            continue;\n        pointers[key] = {\n            __kind__: valType.__kind__ === TypeKind.object ? \"link\" : \"property\",\n            properties: {},\n            target: val.__element__,\n            cardinality: val.__cardinality__,\n            exclusive: false,\n            computed: true,\n            readonly: true,\n            hasDefault: false,\n        };\n    }\n    root[_pointers] = pointers;\n    root[_pathCache] = {};\n    return new Proxy(root, pathifyProxyHandlers);\n}\nfunction isFunc(expr) {\n    return $expressionify({\n        __kind__: ExpressionKind.TypeIntersection,\n        __cardinality__: this.__cardinality__,\n        __element__: {\n            ...expr.__element__,\n            __shape__: { id: true },\n        },\n        __expr__: this,\n    });\n}\nexport function $assert_single(expr) {\n    return $expressionify({\n        __kind__: ExpressionKind.Function,\n        __element__: expr.__element__,\n        __cardinality__: cardutil.overrideUpperBound(expr.__cardinality__, \"One\"),\n        __name__: \"std::assert_single\",\n        __args__: [expr],\n        __namedargs__: {},\n    });\n}\nconst jsonDestructureProxyHandlers = {\n    get(target, prop, proxy) {\n        if (typeof prop === \"string\" && !(prop in target)) {\n            const parsedProp = Number.isInteger(Number(prop)) ? Number(prop) : prop;\n            return jsonDestructure.call(proxy, parsedProp);\n        }\n        return target[prop];\n    },\n};\nfunction jsonDestructure(path) {\n    const pathTypeSet = literalToTypeSet(path);\n    return $expressionify({\n        __kind__: ExpressionKind.Operator,\n        __element__: this.__element__,\n        __cardinality__: cardutil.multiplyCardinalities(this.__cardinality__, pathTypeSet.__cardinality__),\n        __name__: \"[]\",\n        __opkind__: \"Infix\",\n        __args__: [this, pathTypeSet],\n    });\n}\nexport function $jsonDestructure(_expr) {\n    if (_expr.__element__.__kind__ === TypeKind.scalar &&\n        _expr.__element__.__name__ === \"std::json\") {\n        const expr = new Proxy(_expr, jsonDestructureProxyHandlers);\n        expr.destructure = jsonDestructure.bind(expr);\n        return expr;\n    }\n    return _expr;\n}\nexport function $expressionify(_expr) {\n    const expr = $pathify($jsonDestructure($arrayLikeIndexify($tuplePathify(_expr))));\n    expr.run = $queryFunc.bind(expr);\n    expr.runJSON = $queryFuncJSON.bind(expr);\n    expr.is = isFunc.bind(expr);\n    expr.toEdgeQL = $toEdgeQL.bind(expr);\n    expr.assert_single = () => $assert_single(expr);\n    return Object.freeze(expr);\n}\nconst scopedExprCache = new WeakMap();\nconst scopeRoots = new WeakSet();\nexport function $getScopedExpr(expr, existingScopes) {\n    let scopedExpr = scopedExprCache.get(expr);\n    if (!scopedExpr || existingScopes?.has(scopedExpr)) {\n        const isFreeObject = expr.__cardinality__ === Cardinality.One &&\n            expr.__element__.__name__ === \"std::FreeObject\";\n        scopedExpr = isFreeObject\n            ? expr\n            : $expressionify({\n                ...expr,\n                __cardinality__: Cardinality.One,\n                __scopedFrom__: expr,\n                ...(expr.__element__.__kind__ === TypeKind.object\n                    ? {\n                        \"*\": getStarShapeFromPointers(expr.__element__.__pointers__),\n                    }\n                    : {}),\n            });\n        scopeRoots.add(scopedExpr);\n        const uncached = !scopedExpr;\n        if (uncached) {\n            scopedExprCache.set(expr, scopedExpr);\n        }\n    }\n    existingScopes?.add(scopedExpr);\n    return scopedExpr;\n}\nexport { PathLeaf as $PathLeaf, PathNode as $PathNode };\n"},{"path":"query.mjs","content":"import { Cardinality, ExpressionKind } from \"edgedb/dist/reflection/index.js\";\nimport { jsonifyComplexParams } from \"./json.mjs\";\nimport { select } from \"./select.mjs\";\nexport const runnableExpressionKinds = new Set([\n    ExpressionKind.Select,\n    ExpressionKind.Update,\n    ExpressionKind.Insert,\n    ExpressionKind.InsertUnlessConflict,\n    ExpressionKind.Delete,\n    ExpressionKind.Group,\n    ExpressionKind.For,\n    ExpressionKind.With,\n    ExpressionKind.WithParams,\n]);\nconst wrappedExprCache = new WeakMap();\nexport async function $queryFunc(cxn, args) {\n    const expr = runnableExpressionKinds.has(this.__kind__)\n        ? this\n        : wrappedExprCache.get(this) ??\n            wrappedExprCache.set(this, select(this)).get(this);\n    const _args = jsonifyComplexParams(expr, args);\n    const query = expr.toEdgeQL();\n    if (expr.__cardinality__ === Cardinality.One ||\n        expr.__cardinality__ === Cardinality.AtMostOne ||\n        expr.__cardinality__ === Cardinality.Empty) {\n        return cxn.querySingle(query, _args);\n    }\n    else {\n        return cxn.query(query, _args);\n    }\n}\nexport async function $queryFuncJSON(cxn, args) {\n    const expr = runnableExpressionKinds.has(this.__kind__)\n        ? this\n        : wrappedExprCache.get(this) ??\n            wrappedExprCache.set(this, select(this)).get(this);\n    const _args = jsonifyComplexParams(expr, args);\n    if (expr.__cardinality__ === Cardinality.One ||\n        expr.__cardinality__ === Cardinality.AtMostOne) {\n        return cxn.querySingleJSON(expr.toEdgeQL(), _args);\n    }\n    else {\n        return cxn.queryJSON(expr.toEdgeQL(), _args);\n    }\n}\n"},{"path":"range.mjs","content":"import { Range } from \"edgedb\";\nimport { TypeKind, ExpressionKind } from \"edgedb/dist/reflection/index.js\";\nimport { literalToTypeSet } from \"./castMaps.mjs\";\nimport { spec } from \"./__spec__.mjs\";\nimport { literal, $nameMapping } from \"./literal.mjs\";\nimport { $resolveOverload } from \"./funcops.mjs\";\nimport { $expressionify } from \"./path.mjs\";\nfunction range(...args) {\n    if (args.length === 1) {\n        const arg = args[0];\n        if (arg instanceof Range) {\n            if (arg.lower === null && arg.upper === null) {\n                throw new Error(`Can't create literal expression from unbounded range. Try this instead:\\n\\n  e.range(e.cast(e.int64, e.set()), e.cast(e.int64, e.set()))`);\n            }\n            if (arg.isEmpty) {\n                throw new Error(`Can't create literal expression from empty range.`);\n            }\n            return literal(range(literalToTypeSet(arg.lower ?? arg.upper).__element__), arg);\n        }\n        if (arg.__kind__ && !arg.__element__) {\n            return {\n                __kind__: TypeKind.range,\n                __name__: `range<${arg.__name__}>`,\n                __element__: arg,\n            };\n        }\n    }\n    const { returnType, cardinality, args: positionalArgs, namedArgs, } = $resolveOverload(\"std::range\", args, spec, [\n        {\n            args: [\n                {\n                    typeId: $nameMapping.get(\"std::anypoint\"),\n                    optional: true,\n                    setoftype: false,\n                    variadic: false,\n                },\n                {\n                    typeId: $nameMapping.get(\"std::anypoint\"),\n                    optional: true,\n                    setoftype: false,\n                    variadic: false,\n                },\n            ],\n            namedArgs: {\n                inc_lower: {\n                    typeId: $nameMapping.get(\"std::bool\"),\n                    optional: true,\n                    setoftype: false,\n                    variadic: false,\n                },\n                inc_upper: {\n                    typeId: $nameMapping.get(\"std::bool\"),\n                    optional: true,\n                    setoftype: false,\n                    variadic: false,\n                },\n                empty: {\n                    typeId: $nameMapping.get(\"std::bool\"),\n                    optional: true,\n                    setoftype: false,\n                    variadic: false,\n                },\n            },\n            returnTypeId: $nameMapping.get(\"range<std::anypoint>\"),\n        },\n    ]);\n    return $expressionify({\n        __kind__: ExpressionKind.Function,\n        __element__: returnType,\n        __cardinality__: cardinality,\n        __name__: \"std::range\",\n        __args__: positionalArgs,\n        __namedargs__: namedArgs,\n    });\n}\nexport { range as $range };\n"},{"path":"reflection.mjs","content":"export * from \"edgedb/dist/reflection/index.js\";\nexport * from \"./typesystem.mjs\";\nexport { cardutil } from \"./cardinality.mjs\";\nexport { makeType, $mergeObjectTypes } from \"./hydrate.mjs\";\n"},{"path":"select.mjs","content":"import { LocalDateTime, LocalDate, LocalTime, Duration, RelativeDuration, ConfigMemory, DateDuration, } from \"edgedb\";\nimport { Cardinality, ExpressionKind, TypeKind, OperatorKind, } from \"edgedb/dist/reflection/index.js\";\nimport { makeType } from \"./hydrate.mjs\";\nimport { cardutil } from \"./cardinality.mjs\";\nimport { $assert_single, } from \"./path.mjs\";\nimport { $expressionify, $getScopedExpr } from \"./path.mjs\";\nimport { $getTypeByName, literal } from \"./literal.mjs\";\nimport { spec } from \"./__spec__.mjs\";\nimport { literalToTypeSet, } from \"./castMaps.mjs\";\nexport const ASC = \"ASC\";\nexport const DESC = \"DESC\";\nexport const EMPTY_FIRST = \"EMPTY FIRST\";\nexport const EMPTY_LAST = \"EMPTY LAST\";\nexport function is(expr, shape) {\n    const mappedShape = {};\n    for (const [key, value] of Object.entries(shape)) {\n        if (key === \"id\")\n            continue;\n        mappedShape[key] = {\n            __kind__: ExpressionKind.PolyShapeElement,\n            __polyType__: expr,\n            __shapeElement__: value,\n        };\n    }\n    return mappedShape;\n}\nexport function $handleModifiers(modifiers, params) {\n    const { root, scope } = params;\n    const mods = {\n        singleton: !!modifiers[\"filter_single\"],\n    };\n    let card = root.__cardinality__;\n    let needsAssertSingle = false;\n    if (modifiers.filter) {\n        mods.filter = modifiers.filter;\n    }\n    if (modifiers.filter_single) {\n        if (root.__element__.__kind__ !== TypeKind.object) {\n            throw new Error(\"filter_single can only be used with object types\");\n        }\n        card = Cardinality.AtMostOne;\n        const fs = modifiers.filter_single;\n        if (fs.__element__) {\n            mods.filter = modifiers.filter_single;\n            needsAssertSingle = true;\n        }\n        else {\n            const exprs = Object.keys(fs).map((key) => {\n                const val = fs[key].__element__\n                    ? fs[key]\n                    : literal(root.__element__[\"__pointers__\"][key][\"target\"], fs[key]);\n                return $expressionify({\n                    __element__: {\n                        __name__: \"std::bool\",\n                        __kind__: TypeKind.scalar,\n                    },\n                    __cardinality__: Cardinality.One,\n                    __kind__: ExpressionKind.Operator,\n                    __opkind__: OperatorKind.Infix,\n                    __name__: \"=\",\n                    __args__: [scope[key], val],\n                });\n            });\n            if (exprs.length === 1) {\n                mods.filter = exprs[0];\n            }\n            else {\n                mods.filter = exprs.reduce((a, b) => {\n                    return $expressionify({\n                        __element__: {\n                            __name__: \"std::bool\",\n                            __kind__: TypeKind.scalar,\n                        },\n                        __cardinality__: Cardinality.One,\n                        __kind__: ExpressionKind.Operator,\n                        __opkind__: OperatorKind.Infix,\n                        __name__: \"and\",\n                        __args__: [a, b],\n                    });\n                });\n            }\n        }\n    }\n    if (modifiers.order_by) {\n        const orderExprs = Array.isArray(modifiers.order_by)\n            ? modifiers.order_by\n            : [modifiers.order_by];\n        mods.order_by = orderExprs.map((expr) => typeof expr.__element__ === \"undefined\"\n            ? expr\n            : { expression: expr });\n    }\n    if (modifiers.offset) {\n        mods.offset =\n            typeof modifiers.offset === \"number\"\n                ? $getTypeByName(\"std::number\")(modifiers.offset)\n                : modifiers.offset;\n        card = cardutil.overrideLowerBound(card, \"Zero\");\n    }\n    if (modifiers.limit) {\n        let expr;\n        if (typeof modifiers.limit === \"number\") {\n            expr = $getTypeByName(\"std::number\")(modifiers.limit);\n        }\n        else {\n            const type = modifiers.limit.__element__.__casttype__ ??\n                modifiers.limit.__element__;\n            if (type.__kind__ === TypeKind.scalar &&\n                type.__name__ === \"std::number\") {\n                expr = modifiers.limit;\n            }\n            else {\n                throw new Error(\"Invalid value for `limit` modifier\");\n            }\n        }\n        mods.limit = expr;\n        card = cardutil.overrideLowerBound(card, \"Zero\");\n    }\n    return {\n        modifiers: mods,\n        cardinality: card,\n        needsAssertSingle,\n    };\n}\nfunction deleteExpr(expr, modifiersGetter) {\n    const selectExpr = select(expr, modifiersGetter);\n    return $expressionify({\n        __kind__: ExpressionKind.Delete,\n        __element__: selectExpr.__element__,\n        __cardinality__: selectExpr.__cardinality__,\n        __expr__: selectExpr,\n    });\n}\nexport { deleteExpr as delete };\nexport function $selectify(expr) {\n    return expr;\n}\nconst $FreeObject = makeType(spec, [...spec.values()].find((s) => s.name === \"std::FreeObject\").id, literal);\nconst FreeObject = {\n    __kind__: ExpressionKind.PathNode,\n    __element__: $FreeObject,\n    __cardinality__: Cardinality.One,\n    __parent__: null,\n    __exclusive__: true,\n    __scopeRoot__: null,\n};\nexport const $existingScopes = new Set();\nfunction $shape(_a, b) {\n    return b;\n}\nexport { $shape as shape };\nexport function select(...args) {\n    const firstArg = args[0];\n    if (typeof firstArg !== \"object\" ||\n        firstArg instanceof Uint8Array ||\n        firstArg instanceof Date ||\n        firstArg instanceof Duration ||\n        firstArg instanceof LocalDateTime ||\n        firstArg instanceof LocalDate ||\n        firstArg instanceof LocalTime ||\n        firstArg instanceof RelativeDuration ||\n        firstArg instanceof DateDuration ||\n        firstArg instanceof ConfigMemory ||\n        firstArg instanceof Float32Array) {\n        const literalExpr = literalToTypeSet(firstArg);\n        return $expressionify($selectify({\n            __kind__: ExpressionKind.Select,\n            __element__: literalExpr.__element__,\n            __cardinality__: literalExpr.__cardinality__,\n            __expr__: literalExpr,\n            __modifiers__: {},\n        }));\n    }\n    const exprPair = typeof args[0].__element__ !== \"undefined\"\n        ? args\n        : [FreeObject, () => args[0]];\n    let expr = exprPair[0];\n    const shapeGetter = exprPair[1];\n    if (expr === FreeObject) {\n        const freeObjectPtrs = {};\n        for (const [k, v] of Object.entries(args[0])) {\n            freeObjectPtrs[k] = {\n                __kind__: v.__element__.__kind__ === TypeKind.object ? \"link\" : \"property\",\n                target: v.__element__,\n                cardinality: v.__cardinality__,\n                exclusive: false,\n                computed: true,\n                readonly: true,\n                hasDefault: false,\n                properties: {},\n            };\n        }\n        expr = {\n            ...FreeObject,\n            __element__: {\n                ...FreeObject.__element__,\n                __pointers__: {\n                    ...FreeObject.__element__.__pointers__,\n                    ...freeObjectPtrs,\n                },\n            },\n        };\n    }\n    if (!shapeGetter) {\n        if (expr.__element__.__kind__ === TypeKind.object) {\n            const objectExpr = expr;\n            return $expressionify($selectify({\n                __kind__: ExpressionKind.Select,\n                __element__: {\n                    __kind__: TypeKind.object,\n                    __name__: `${objectExpr.__element__.__name__}`,\n                    __pointers__: objectExpr.__element__.__pointers__,\n                    __shape__: objectExpr.__element__.__shape__,\n                },\n                __cardinality__: objectExpr.__cardinality__,\n                __expr__: objectExpr,\n                __modifiers__: {},\n            }));\n        }\n        else {\n            return $expressionify($selectify({\n                __kind__: ExpressionKind.Select,\n                __element__: expr.__element__,\n                __cardinality__: expr.__cardinality__,\n                __expr__: expr,\n                __modifiers__: {},\n            }));\n        }\n    }\n    const cleanScopedExprs = $existingScopes.size === 0;\n    const { modifiers: mods, shape, scope } = resolveShape(shapeGetter, expr);\n    if (cleanScopedExprs) {\n        $existingScopes.clear();\n    }\n    const { modifiers, cardinality, needsAssertSingle } = $handleModifiers(mods, {\n        root: expr,\n        scope,\n    });\n    const selectExpr = $selectify({\n        __kind__: ExpressionKind.Select,\n        __element__: expr.__element__.__kind__ === TypeKind.object\n            ? {\n                __kind__: TypeKind.object,\n                __name__: `${expr.__element__.__name__}`,\n                __pointers__: expr.__element__.__pointers__,\n                __shape__: shape,\n            }\n            : expr.__element__,\n        __cardinality__: cardinality,\n        __expr__: expr,\n        __modifiers__: modifiers,\n        __scope__: expr !== scope ? scope : undefined,\n    });\n    return needsAssertSingle\n        ? $assert_single(selectExpr)\n        : $expressionify(selectExpr);\n}\nfunction resolveShape(shapeGetter, expr) {\n    const modifiers = {};\n    const shape = {};\n    const scope = expr.__element__.__kind__ === TypeKind.object\n        ? $getScopedExpr(expr, $existingScopes)\n        : expr;\n    const selectShape = typeof shapeGetter === \"function\" ? shapeGetter(scope) : shapeGetter;\n    for (const [key, value] of Object.entries(selectShape)) {\n        if (key === \"filter\" ||\n            key === \"filter_single\" ||\n            key === \"order_by\" ||\n            key === \"offset\" ||\n            key === \"limit\") {\n            modifiers[key] = value;\n        }\n        else {\n            if (expr.__element__.__kind__ !== TypeKind.object) {\n                throw new Error(`Invalid select shape key '${key}' on scalar expression, ` +\n                    `only modifiers are allowed (filter, order_by, offset and limit)`);\n            }\n            shape[key] = resolveShapeElement(key, value, scope);\n        }\n    }\n    return { shape, modifiers, scope };\n}\nexport function resolveShapeElement(key, value, scope) {\n    const isSubshape = typeof value === \"object\" && typeof value.__kind__ === \"undefined\";\n    const isClosure = typeof value === \"function\" &&\n        scope.__element__.__pointers__[key]?.__kind__ === \"link\";\n    if (isSubshape || isClosure) {\n        const childExpr = scope[key];\n        if (!childExpr) {\n            throw new Error(`Invalid shape element \"${key}\" for type ${scope.__element__.__name__}`);\n        }\n        const { shape: childShape, scope: childScope, modifiers: mods, } = resolveShape(value, childExpr);\n        const { modifiers, needsAssertSingle } = $handleModifiers(mods, {\n            root: childExpr,\n            scope: childScope,\n        });\n        const selectExpr = {\n            __kind__: ExpressionKind.Select,\n            __element__: {\n                __kind__: TypeKind.object,\n                __name__: `${childExpr.__element__.__name__}`,\n                __pointers__: childExpr.__element__.__pointers__,\n                __shape__: childShape,\n            },\n            __cardinality__: scope.__element__.__pointers__?.[key]?.cardinality ||\n                scope.__element__.__shape__?.[key]?.__cardinality__,\n            __expr__: childExpr,\n            __modifiers__: modifiers,\n            __scope__: childExpr !== childScope ? childScope : undefined,\n        };\n        return needsAssertSingle ? $assert_single(selectExpr) : selectExpr;\n    }\n    else if (value?.__kind__ === ExpressionKind.PolyShapeElement) {\n        const polyElement = value;\n        const polyScope = scope.is(polyElement.__polyType__);\n        return {\n            __kind__: ExpressionKind.PolyShapeElement,\n            __polyType__: polyScope,\n            __shapeElement__: resolveShapeElement(key, polyElement.__shapeElement__, polyScope),\n        };\n    }\n    else if (typeof value === \"boolean\" && key.startsWith(\"@\")) {\n        const linkProp = scope[key];\n        if (!linkProp) {\n            throw new Error(scope.__parent__\n                ? `link property '${key}' does not exist on link ${scope.__parent__.linkName}`\n                : `cannot select link property '${key}' on an object (${scope.__element__.__name__})`);\n        }\n        return value ? linkProp : false;\n    }\n    else {\n        return value;\n    }\n}\n"},{"path":"set.mjs","content":"import { TypeKind } from \"edgedb/dist/reflection/index.js\";\nimport { $mergeObjectTypes } from \"./hydrate.mjs\";\nimport * as castMaps from \"./castMaps.mjs\";\nexport function getSharedParent(a, b) {\n    if (a.__kind__ !== b.__kind__) {\n        throw new Error(`Incompatible array types: ${a.__name__} and ${b.__name__}`);\n    }\n    if (a.__kind__ === TypeKind.scalar && b.__kind__ === TypeKind.scalar) {\n        return castMaps.getSharedParentScalar(a, b);\n    }\n    else if (a.__kind__ === TypeKind.object && b.__kind__ === TypeKind.object) {\n        return $mergeObjectTypes(a, b);\n    }\n    else if (a.__kind__ === TypeKind.tuple && b.__kind__ === TypeKind.tuple) {\n        if (a.__items__.length !== b.__items__.length) {\n            throw new Error(`Incompatible tuple types: ${a.__name__} and ${b.__name__}`);\n        }\n        try {\n            const items = a.__items__.map((_, i) => {\n                if (!a.__items__[i] || !b.__items__[i]) {\n                    throw new Error();\n                }\n                return getSharedParent(a.__items__[i], b.__items__[i]);\n            });\n            return {\n                __kind__: TypeKind.tuple,\n                __name__: `tuple<${items.map((item) => item.__name__).join(\", \")}>`,\n                __items__: items,\n            };\n        }\n        catch (err) {\n            throw new Error(`Incompatible tuple types: ${a.__name__} and ${b.__name__}`);\n        }\n    }\n    else if (a.__kind__ === TypeKind.namedtuple &&\n        b.__kind__ === TypeKind.namedtuple) {\n        const aKeys = Object.keys(a);\n        const bKeys = new Set(Object.keys(b));\n        const sameKeys = aKeys.length === bKeys.size && aKeys.every((k) => bKeys.has(k));\n        if (!sameKeys) {\n            throw new Error(`Incompatible tuple types: ${a.__name__} and ${b.__name__}`);\n        }\n        try {\n            const items = {};\n            for (const [i] of Object.entries(a.__shape__)) {\n                if (!a.__shape__[i] || !b.__shape__[i]) {\n                    throw new Error();\n                }\n                items[i] = getSharedParent(a.__shape__[i], b.__shape__[i]);\n            }\n            return {\n                __kind__: TypeKind.namedtuple,\n                __name__: `tuple<${Object.entries(items)\n                    .map(([key, val]) => `${key}: ${val.__name__}`)\n                    .join(\", \")}>`,\n                __shape__: items,\n            };\n        }\n        catch (err) {\n            throw new Error(`Incompatible tuple types: ${a.__name__} and ${b.__name__}`);\n        }\n    }\n    else if (a.__kind__ === TypeKind.array && b.__kind__ === TypeKind.array) {\n        try {\n            const mergedEl = getSharedParent(a.__element__, b.__element__);\n            return {\n                __kind__: TypeKind.array,\n                __name__: a.__name__,\n                __element__: mergedEl,\n            };\n        }\n        catch (err) {\n            throw new Error(`Incompatible array types: ${a.__name__} and ${b.__name__}`);\n        }\n    }\n    else if (a.__kind__ === TypeKind.enum && b.__kind__ === TypeKind.enum) {\n        if (a.__name__ === b.__name__)\n            return a;\n        throw new Error(`Incompatible array types: ${a.__name__} and ${b.__name__}`);\n    }\n    else {\n        throw new Error(`Incompatible array types: ${a.__name__} and ${b.__name__}`);\n    }\n}\nexport { set } from \"./setImpl.mjs\";\n"},{"path":"setImpl.mjs","content":"export function set(...args) { }\n"},{"path":"syntax.mjs","content":"export * from \"./literal.mjs\";\nexport * from \"./path.mjs\";\nexport * from \"./set.mjs\";\nexport * from \"./cast.mjs\";\nexport * from \"./select.mjs\";\nexport * from \"./update.mjs\";\nexport * from \"./insert.mjs\";\nexport * from \"./group.mjs\";\nexport * from \"./collections.mjs\";\nexport * from \"./funcops.mjs\";\nexport * from \"./for.mjs\";\nexport * from \"./with.mjs\";\nexport * from \"./params.mjs\";\nexport * from \"./globals.mjs\";\nexport * from \"./detached.mjs\";\nexport * from \"./toEdgeQL.mjs\";\nexport * from \"./range.mjs\";\n"},{"path":"toEdgeQL.mjs","content":"import { Duration, LocalDate, LocalDateTime, LocalTime, RelativeDuration, DateDuration, Range, } from \"edgedb\";\nimport { Cardinality, ExpressionKind, OperatorKind, TypeKind, util, } from \"edgedb/dist/reflection/index.js\";\nimport { isArrayType, isNamedTupleType, isObjectType, isTupleType, } from \"./typesystem.mjs\";\nimport { reservedKeywords } from \"edgedb/dist/reflection/index.js\";\nexport function $toEdgeQL() {\n    const walkExprCtx = {\n        seen: new Map(),\n        rootScope: null,\n    };\n    walkExprTree(this, null, walkExprCtx);\n    const withBlocks = new Map();\n    const withVars = new Map();\n    const seen = new Map(walkExprCtx.seen);\n    const linkProps = new Map();\n    for (const [expr, refData] of seen) {\n        seen.delete(expr);\n        if (refData.linkProps.length) {\n            linkProps.set(expr, refData.linkProps.map((linkProp) => linkProp.__parent__.linkName.slice(1)));\n        }\n        if (withVars.has(expr)) {\n            continue;\n        }\n        if (!refData.boundScope &&\n            (expr.__kind__ === ExpressionKind.PathLeaf ||\n                expr.__kind__ === ExpressionKind.PathNode ||\n                expr.__kind__ === ExpressionKind.TypeIntersection)) {\n            continue;\n        }\n        if (expr.__kind__ === ExpressionKind.ForVar ||\n            expr.__kind__ === ExpressionKind.Param) {\n            continue;\n        }\n        if ((expr.__kind__ === ExpressionKind.Select ||\n            expr.__kind__ === ExpressionKind.Update ||\n            expr.__kind__ === ExpressionKind.Group) &&\n            expr.__scope__ &&\n            !withVars.has(expr.__scope__)) {\n            const withBlock = expr;\n            const scopeVar = expr.__scope__;\n            const scopeVarName = `__scope_${withVars.size}_${scopeVar.__element__.__name__.replace(/[^A-Za-z]/g, \"\")}`;\n            withVars.set(scopeVar, {\n                name: scopeVarName,\n                scope: withBlock,\n                childExprs: new Set(),\n                scopedExpr: expr.__element__.__kind__ === TypeKind.object\n                    ? expr.__expr__\n                    : undefined,\n            });\n        }\n        if (refData.refCount > 1 ||\n            refData.boundScope ||\n            refData.aliases.length > 0) {\n            let withBlock = refData.boundScope;\n            const parentScopes = [...refData.parentScopes];\n            if (!withBlock) {\n                if (parentScopes.some((parentScope) => parentScope && seen.has(parentScope))) {\n                    seen.set(expr, refData);\n                    continue;\n                }\n                if (parentScopes.some((scope) => scope == null)) {\n                    throw new Error(`Cannot extract repeated expression into 'WITH' block, ` +\n                        `expression used outside of 'WITH'able expression`);\n                }\n                const [firstParentScopeChain, ...parentScopeChains] = parentScopes.map((scope) => {\n                    const scopes = [scope];\n                    const pendingScopes = [scope];\n                    while (pendingScopes.length) {\n                        const currentScope = pendingScopes.shift();\n                        pendingScopes.push(...[...walkExprCtx.seen.get(currentScope).parentScopes].filter((s) => s !== null));\n                        if (!scopes.includes(currentScope)) {\n                            scopes.push(currentScope);\n                        }\n                    }\n                    return scopes;\n                });\n                const commonParentScope = firstParentScopeChain\n                    ? firstParentScopeChain.find((scope) => parentScopeChains.every((otherScope) => otherScope.includes(scope)))\n                    : null;\n                withBlock = commonParentScope ?? walkExprCtx.rootScope;\n            }\n            if (!withBlock) {\n                throw new Error(`Cannot extract repeated expression into 'WITH' block, ` +\n                    `expression does not appear within common 'WITH'able expression`);\n            }\n            if (!withBlocks.has(withBlock)) {\n                withBlocks.set(withBlock, new Set());\n            }\n            const validScopes = new Set([\n                withBlock,\n                ...walkExprCtx.seen.get(withBlock).childExprs,\n            ]);\n            for (const scope of [\n                ...refData.parentScopes,\n                ...util.flatMap(refData.aliases, (alias) => [\n                    ...walkExprCtx.seen.get(alias).parentScopes,\n                ]),\n            ]) {\n                if (scope === null || !validScopes.has(scope)) {\n                    throw new Error(refData.boundScope\n                        ? `Expr or its aliases used outside of declared 'WITH' block scope`\n                        : `Cannot extract repeated or aliased expression into 'WITH' block, ` +\n                            `expression or its aliases appear outside root scope`);\n                }\n            }\n            for (const withVar of [expr, ...refData.aliases]) {\n                const withVarBoundScope = walkExprCtx.seen.get(withVar).boundScope;\n                if (withVarBoundScope && withVarBoundScope !== refData.boundScope) {\n                    continue;\n                }\n                const withVarName = `__withVar_${withVars.size}`;\n                withBlocks.get(withBlock).add(withVar);\n                withVars.set(withVar, {\n                    name: withVarName,\n                    scope: withBlock,\n                    childExprs: new Set(walkExprCtx.seen.get(withVar).childExprs),\n                });\n            }\n        }\n    }\n    let edgeQL = renderEdgeQL(this, {\n        withBlocks,\n        withVars,\n        forVars: new Map(),\n        linkProps,\n    });\n    if (edgeQL.startsWith(\"(\") &&\n        edgeQL.endsWith(\")\") &&\n        !(this.__kind__ === ExpressionKind.Tuple ||\n            this.__kind__ === ExpressionKind.NamedTuple ||\n            this.__kind__ === ExpressionKind.Literal)) {\n        edgeQL = edgeQL.slice(1, -1);\n    }\n    return edgeQL;\n}\nfunction walkExprTree(_expr, parentScope, ctx) {\n    if (!_expr.__kind__) {\n        throw new Error(`Expected a valid querybuilder expression, ` +\n            `instead received ${typeof _expr}${typeof _expr !== \"undefined\" ? `: '${_expr}'` : \"\"}.` +\n            getErrorHint(_expr));\n    }\n    const expr = _expr;\n    function walkShape(shape) {\n        for (let param of Object.values(shape)) {\n            if (param.__kind__ === ExpressionKind.PolyShapeElement) {\n                param = param.__shapeElement__;\n            }\n            if (typeof param === \"object\") {\n                if (!!param.__kind__) {\n                    childExprs.push(...walkExprTree(param, expr, ctx));\n                }\n                else {\n                    walkShape(param);\n                }\n            }\n        }\n    }\n    if (!ctx.rootScope && parentScope) {\n        ctx.rootScope = parentScope;\n    }\n    const seenExpr = ctx.seen.get(expr);\n    if (seenExpr) {\n        seenExpr.refCount += 1;\n        seenExpr.parentScopes.add(parentScope);\n        return [expr, ...seenExpr.childExprs];\n    }\n    const childExprs = [];\n    ctx.seen.set(expr, {\n        refCount: 1,\n        parentScopes: new Set([parentScope]),\n        childExprs,\n        boundScope: null,\n        aliases: [],\n        linkProps: [],\n    });\n    switch (expr.__kind__) {\n        case ExpressionKind.Alias:\n            childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n            ctx.seen.get(expr.__expr__).aliases.push(expr);\n            break;\n        case ExpressionKind.With:\n            childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n            for (const refExpr of expr.__refs__) {\n                walkExprTree(refExpr, expr.__expr__, ctx);\n                const seenRef = ctx.seen.get(refExpr);\n                if (seenRef.boundScope) {\n                    throw new Error(`Expression bound to multiple 'WITH' blocks`);\n                }\n                seenRef.boundScope = expr.__expr__;\n            }\n            break;\n        case ExpressionKind.Literal:\n        case ExpressionKind.ForVar:\n        case ExpressionKind.Param:\n            break;\n        case ExpressionKind.PathLeaf:\n        case ExpressionKind.PathNode:\n            if (expr.__parent__) {\n                if (expr.__parent__.type.__scopedFrom__) {\n                    childExprs.push(expr.__parent__.type);\n                }\n                else {\n                    childExprs.push(...walkExprTree(expr.__parent__.type, parentScope, ctx));\n                }\n                if (expr.__kind__ === ExpressionKind.PathLeaf &&\n                    expr.__parent__.linkName.startsWith(\"@\")) {\n                    const parentScopeVar = parentScope.__scope__;\n                    if (parentScopeVar === expr.__parent__.type) {\n                        ctx.seen.get(parentScope)?.linkProps.push(expr);\n                    }\n                }\n            }\n            break;\n        case ExpressionKind.Cast:\n            if (expr.__expr__ === null)\n                break;\n            childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n            break;\n        case ExpressionKind.Set:\n            for (const subExpr of expr.__exprs__) {\n                childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n            }\n            break;\n        case ExpressionKind.Array:\n            for (const subExpr of expr.__items__) {\n                childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n            }\n            break;\n        case ExpressionKind.Tuple:\n            for (const subExpr of expr.__items__) {\n                childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n            }\n            break;\n        case ExpressionKind.NamedTuple:\n            for (const subExpr of Object.values(expr.__shape__)) {\n                childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n            }\n            break;\n        case ExpressionKind.TuplePath:\n            childExprs.push(...walkExprTree(expr.__parent__, parentScope, ctx));\n            break;\n        case ExpressionKind.Select:\n        case ExpressionKind.Update: {\n            const modifiers = expr.__modifiers__;\n            if (modifiers.filter) {\n                childExprs.push(...walkExprTree(modifiers.filter, expr, ctx));\n            }\n            if (modifiers.order_by) {\n                for (const orderExpr of modifiers.order_by) {\n                    childExprs.push(...walkExprTree(orderExpr.expression, expr, ctx));\n                }\n            }\n            if (modifiers.offset) {\n                childExprs.push(...walkExprTree(modifiers.offset, expr, ctx));\n            }\n            if (modifiers.limit) {\n                childExprs.push(...walkExprTree(modifiers.limit, expr, ctx));\n            }\n            if (expr.__kind__ === ExpressionKind.Select) {\n                if (isObjectType(expr.__element__) &&\n                    expr.__element__.__shape__ !==\n                        expr.__expr__.__element__.__shape__) {\n                    walkShape(expr.__element__.__shape__ ?? {});\n                }\n            }\n            else {\n                const shape = expr.__shape__ ?? {};\n                for (const _element of Object.values(shape)) {\n                    let element = _element;\n                    if (!element.__element__) {\n                        if (element[\"+=\"])\n                            element = element[\"+=\"];\n                        else if (element[\"-=\"])\n                            element = element[\"-=\"];\n                    }\n                    childExprs.push(...walkExprTree(element, expr, ctx));\n                }\n            }\n            childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\n            break;\n        }\n        case ExpressionKind.Delete: {\n            childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n            break;\n        }\n        case ExpressionKind.Insert: {\n            const shape = expr.__shape__ ?? {};\n            for (const element of Object.values(shape)) {\n                childExprs.push(...walkExprTree(element, expr, ctx));\n            }\n            childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\n            break;\n        }\n        case ExpressionKind.InsertUnlessConflict: {\n            const insertChildExprs = [];\n            if (expr.__conflict__.on) {\n                insertChildExprs.push(...walkExprTree(expr.__conflict__.on, expr.__expr__, ctx));\n            }\n            if (expr.__conflict__.else) {\n                insertChildExprs.push(...walkExprTree(expr.__conflict__.else, expr.__expr__, ctx));\n            }\n            walkExprTree(expr.__expr__, parentScope, ctx);\n            ctx.seen\n                .get(expr.__expr__)\n                .childExprs.push(...insertChildExprs);\n            break;\n        }\n        case ExpressionKind.Group: {\n            const groupingSet = expr.__modifiers__.by;\n            for (const [_k, groupExpr] of groupingSet.__exprs__) {\n                const seen = new Set();\n                if (!seen.has(expr)) {\n                    childExprs.push(...walkExprTree(groupExpr, expr, ctx));\n                    seen.add(expr);\n                }\n            }\n            if (!expr.__element__.__shape__.elements.__element__.__shape__) {\n                throw new Error(\"Missing shape in GROUP statement\");\n            }\n            walkShape(expr.__element__.__shape__.elements.__element__.__shape__);\n            childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\n            break;\n        }\n        case ExpressionKind.TypeIntersection:\n            childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n            break;\n        case ExpressionKind.Operator:\n        case ExpressionKind.Function:\n            for (const subExpr of expr.__args__) {\n                if (Array.isArray(subExpr)) {\n                    for (const arg of subExpr) {\n                        if (arg)\n                            childExprs.push(...walkExprTree(arg, parentScope, ctx));\n                    }\n                }\n                else {\n                    childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n                }\n            }\n            if (expr.__kind__ === ExpressionKind.Function) {\n                for (const subExpr of Object.values(expr.__namedargs__)) {\n                    childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n                }\n            }\n            break;\n        case ExpressionKind.For: {\n            childExprs.push(...walkExprTree(expr.__iterSet__, expr, ctx));\n            childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\n            break;\n        }\n        case ExpressionKind.WithParams: {\n            if (parentScope !== null) {\n                throw new Error(`'withParams' does not support being used as a nested expression`);\n            }\n            childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n            break;\n        }\n        case ExpressionKind.Detached: {\n            childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n            break;\n        }\n        case ExpressionKind.Global:\n            break;\n        default:\n            util.assertNever(expr, new Error(`Unrecognized expression kind: \"${expr.__kind__}\"`));\n    }\n    return [expr, ...childExprs];\n}\nfunction renderEdgeQL(_expr, ctx, renderShape = true, noImplicitDetached = false) {\n    if (!_expr.__kind__) {\n        throw new Error(\"Invalid expression.\");\n    }\n    const expr = _expr;\n    const withVar = ctx.withVars.get(expr);\n    if (withVar && ctx.renderWithVar !== expr) {\n        return renderShape &&\n            expr.__kind__ === ExpressionKind.Select &&\n            isObjectType(expr.__element__)\n            ? `(${withVar.name} ${shapeToEdgeQL((expr.__element__.__shape__ || {}), ctx, null, true)})`\n            : withVar.name;\n    }\n    function renderWithBlockExpr(varExpr, _noImplicitDetached) {\n        const withBlockElement = ctx.withVars.get(varExpr);\n        let renderedExpr = renderEdgeQL(withBlockElement.scopedExpr ?? varExpr, {\n            ...ctx,\n            renderWithVar: varExpr,\n        }, !withBlockElement.scopedExpr, _noImplicitDetached);\n        const renderedExprNoDetached = renderEdgeQL(withBlockElement.scopedExpr ?? varExpr, {\n            ...ctx,\n            renderWithVar: varExpr,\n        }, !withBlockElement.scopedExpr, true);\n        if (ctx.linkProps.has(expr)) {\n            renderedExpr = `(SELECT ${renderedExpr} {\\n${ctx.linkProps\n                .get(expr)\n                .map((linkPropName) => `  __linkprop_${linkPropName} := ${renderedExprNoDetached}@${linkPropName}`)\n                .join(\",\\n\")}\\n})`;\n        }\n        return `  ${withBlockElement.name} := ${renderedExpr.includes(\"\\n\")\n            ? `(\\n${indent(renderedExpr[0] === \"(\" &&\n                renderedExpr[renderedExpr.length - 1] === \")\"\n                ? renderedExpr.slice(1, -1)\n                : renderedExpr, 4)}\\n  )`\n            : renderedExpr}`;\n    }\n    const scopeExpr = (expr.__kind__ === ExpressionKind.Select ||\n        expr.__kind__ === ExpressionKind.Update ||\n        expr.__kind__ === ExpressionKind.Group) &&\n        ctx.withVars.has(expr.__scope__)\n        ? expr.__scope__\n        : undefined;\n    const scopeExprVar = [];\n    const unscopedWithBlock = [];\n    const scopedWithBlock = [];\n    if (ctx.withBlocks.has(expr) || scopeExpr) {\n        const sortedBlockVars = topoSortWithVars(ctx.withBlocks.get(expr) ?? new Set(), ctx);\n        if (!scopeExpr) {\n            unscopedWithBlock.push(...sortedBlockVars.map((blockVar) => renderWithBlockExpr(blockVar)));\n        }\n        else {\n            const scopeVar = ctx.withVars.get(scopeExpr);\n            const scopedVars = sortedBlockVars.filter((blockVarExpr) => ctx.withVars.get(blockVarExpr)?.childExprs.has(scopeExpr));\n            unscopedWithBlock.push(...sortedBlockVars\n                .filter((blockVar) => !scopedVars.includes(blockVar))\n                .map((blockVar) => renderWithBlockExpr(blockVar)));\n            if (!scopedVars.length) {\n                scopeExprVar.push(renderWithBlockExpr(scopeExpr, noImplicitDetached));\n            }\n            else {\n                const scopeName = scopeVar.name;\n                scopeVar.name = scopeName + \"_expr\";\n                scopeExprVar.push(renderWithBlockExpr(scopeExpr, noImplicitDetached));\n                scopeVar.name = scopeName + \"_inner\";\n                scopeExprVar.push(`  ${scopeName} := (FOR ${scopeVar.name} IN {${scopeName + \"_expr\"}} UNION (\\n    WITH\\n${indent(scopedVars\n                    .map((blockVar) => renderWithBlockExpr(blockVar))\n                    .join(\",\\n\"), 4)}\\n    SELECT ${scopeVar.name} {\\n${scopedVars\n                    .map((blockVar) => {\n                    const name = ctx.withVars.get(blockVar).name;\n                    return `      ${name} := ${name}`;\n                })\n                    .join(\",\\n\")}\\n    }\\n  ))`);\n                scopeVar.name = scopeName;\n                for (const blockVarExpr of scopedVars) {\n                    const blockVar = ctx.withVars.get(blockVarExpr);\n                    blockVar.name = `${scopeName}.${blockVar.name}`;\n                }\n            }\n        }\n    }\n    const withBlockElements = [\n        ...unscopedWithBlock,\n        ...scopeExprVar,\n        ...scopedWithBlock,\n    ];\n    const withBlock = withBlockElements.length\n        ? `WITH\\n${withBlockElements.join(\",\\n\")}\\n`\n        : \"\";\n    if (expr.__kind__ === ExpressionKind.With) {\n        return renderEdgeQL(expr.__expr__, ctx);\n    }\n    else if (expr.__kind__ === ExpressionKind.WithParams) {\n        return `(WITH\\n${expr.__params__\n            .map((param) => {\n            const optional = param.__cardinality__ === Cardinality.AtMostOne ? \"OPTIONAL \" : \"\";\n            let paramExpr;\n            if (param.__isComplex__) {\n                let cast = param.__element__.__name__;\n                cast = cast.includes(\"std::decimal\")\n                    ? `<${cast}><${cast.replace(/std::decimal/g, \"std::str\")}>`\n                    : `<${cast}>`;\n                paramExpr = `${cast}to_json(<${optional}str>$${param.__name__})`;\n            }\n            else {\n                paramExpr = `<${optional}${param.__element__.__name__}>$${param.__name__}`;\n            }\n            return `  __param__${param.__name__} := ${paramExpr}`;\n        })\n            .join(\",\\n\")}\\nSELECT ${renderEdgeQL(expr.__expr__, ctx)})`;\n    }\n    else if (expr.__kind__ === ExpressionKind.Alias) {\n        const aliasedExprVar = ctx.withVars.get(expr.__expr__);\n        if (!aliasedExprVar) {\n            throw new Error(`Expression referenced by alias does not exist in 'WITH' block`);\n        }\n        return aliasedExprVar.name;\n    }\n    else if (expr.__kind__ === ExpressionKind.PathNode ||\n        expr.__kind__ === ExpressionKind.PathLeaf) {\n        if (!expr.__parent__) {\n            return `${noImplicitDetached ? \"\" : \"DETACHED \"}${expr.__element__.__name__}`;\n        }\n        else {\n            const isScopedLinkProp = expr.__parent__.linkName.startsWith(\"@\") &&\n                ctx.withVars.has(expr.__parent__.type);\n            const linkName = isScopedLinkProp\n                ? `__linkprop_${expr.__parent__.linkName.slice(1)}`\n                : expr.__parent__.linkName;\n            const parent = renderEdgeQL(expr.__parent__.type, ctx, false, noImplicitDetached);\n            return `${parent}${linkName.startsWith(\"@\") ? \"\" : \".\"}${q(linkName)}`;\n        }\n    }\n    else if (expr.__kind__ === ExpressionKind.Literal) {\n        return literalToEdgeQL(expr.__element__, expr.__value__);\n    }\n    else if (expr.__kind__ === ExpressionKind.Set) {\n        const exprs = expr.__exprs__;\n        if (exprs.every((ex) => ex.__element__.__kind__ === TypeKind.object) ||\n            exprs.every((ex) => ex.__element__.__kind__ !== TypeKind.object)) {\n            if (exprs.length === 0)\n                return `<${expr.__element__.__name__}>{}`;\n            return `{ ${exprs.map((ex) => renderEdgeQL(ex, ctx)).join(\", \")} }`;\n        }\n        else {\n            throw new Error(`Invalid arguments to set constructor: ${exprs\n                .map((ex) => ex.__element__.__name__)\n                .join(\", \")}`);\n        }\n    }\n    else if (expr.__kind__ === ExpressionKind.Array) {\n        return `[${expr.__items__\n            .map((item) => renderEdgeQL(item, ctx))\n            .join(\", \")}]`;\n    }\n    else if (expr.__kind__ === ExpressionKind.Tuple) {\n        return `(\\n${expr.__items__\n            .map((item) => `  ` + renderEdgeQL(item, ctx, renderShape, noImplicitDetached))\n            .join(\",\\n\")}${expr.__items__.length === 1 ? \",\" : \"\"}\\n)`;\n    }\n    else if (expr.__kind__ === ExpressionKind.NamedTuple) {\n        return `(\\n${Object.keys(expr.__shape__)\n            .map((key) => `  ${key} := ${renderEdgeQL(expr.__shape__[key], ctx, renderShape, noImplicitDetached)}`)\n            .join(\",\\n\")}\\n)`;\n    }\n    else if (expr.__kind__ === ExpressionKind.TuplePath) {\n        return `${renderEdgeQL(expr.__parent__, ctx)}.${expr.__index__}`;\n    }\n    else if (expr.__kind__ === ExpressionKind.Cast) {\n        const typeName = expr.__element__.__name__ === \"std::number\"\n            ? \"std::float64\"\n            : expr.__element__.__name__;\n        if (expr.__expr__ === null) {\n            return `<${typeName}>{}`;\n        }\n        return `<${typeName}>(${renderEdgeQL(expr.__expr__, ctx)})`;\n    }\n    else if (expr.__kind__ === ExpressionKind.Select) {\n        const lines = [];\n        if (isObjectType(expr.__element__)) {\n            const selectionTarget = renderEdgeQL(expr.__scope__ ?? expr.__expr__, ctx, false);\n            lines.push(`SELECT${selectionTarget === \"DETACHED std::FreeObject\"\n                ? \"\"\n                : ` ${selectionTarget}`}`);\n            if (expr.__element__.__shape__ !==\n                expr.__expr__.__element__.__shape__) {\n                lines.push(shapeToEdgeQL((expr.__element__.__shape__ || {}), ctx, expr.__element__));\n            }\n        }\n        else {\n            const needsScalarVar = (expr.__modifiers__.filter ||\n                expr.__modifiers__.order_by ||\n                expr.__modifiers__.offset ||\n                expr.__modifiers__.limit) &&\n                !ctx.withVars.has(expr.__expr__);\n            lines.push(`SELECT ${needsScalarVar ? \"_ := \" : \"\"}${renderEdgeQL(expr.__expr__, ctx)}`);\n            if (needsScalarVar) {\n                ctx = { ...ctx, withVars: new Map(ctx.withVars) };\n                ctx.withVars.set(expr.__expr__, {\n                    name: \"_\",\n                    childExprs: new Set(),\n                    scope: expr,\n                });\n            }\n        }\n        const modifiers = [];\n        if (expr.__modifiers__.filter) {\n            modifiers.push(`FILTER ${renderEdgeQL(expr.__modifiers__.filter, ctx)}`);\n        }\n        if (expr.__modifiers__.order_by) {\n            modifiers.push(...expr.__modifiers__.order_by.map(({ expression, direction, empty }, i) => {\n                return `${i === 0 ? \"ORDER BY\" : \"  THEN\"} ${renderEdgeQL(expression, ctx)}${direction ? \" \" + direction : \"\"}${empty ? \" \" + empty : \"\"}`;\n            }));\n        }\n        if (expr.__modifiers__.offset) {\n            modifiers.push(`OFFSET ${renderEdgeQL(expr.__modifiers__.offset, ctx)}`);\n        }\n        if (expr.__modifiers__.limit) {\n            modifiers.push(`LIMIT ${renderEdgeQL(expr.__modifiers__.limit, ctx)}`);\n        }\n        return (\"(\" +\n            withBlock +\n            lines.join(\" \") +\n            (modifiers.length ? \"\\n\" + modifiers.join(\"\\n\") : \"\") +\n            \")\");\n    }\n    else if (expr.__kind__ === ExpressionKind.Update) {\n        return `(${withBlock}UPDATE ${renderEdgeQL(expr.__scope__, ctx, false)}${expr.__modifiers__.filter\n            ? `\\nFILTER ${renderEdgeQL(expr.__modifiers__.filter, ctx)}\\n`\n            : \" \"}SET ${shapeToEdgeQL(expr.__shape__, ctx, null, false, false)})`;\n    }\n    else if (expr.__kind__ === ExpressionKind.Delete) {\n        return `(${withBlock}DELETE ${renderEdgeQL(expr.__expr__, ctx, undefined, noImplicitDetached)})`;\n    }\n    else if (expr.__kind__ === ExpressionKind.Insert) {\n        return `(${withBlock}INSERT ${renderEdgeQL(expr.__expr__, ctx, false, true)} ${shapeToEdgeQL(expr.__shape__, ctx, null, false, false)})`;\n    }\n    else if (expr.__kind__ === ExpressionKind.InsertUnlessConflict) {\n        const $on = expr.__conflict__.on;\n        const $else = expr.__conflict__.else;\n        const clause = [];\n        if (!$on) {\n            clause.push(\"\\nUNLESS CONFLICT\");\n        }\n        if ($on) {\n            clause.push(`\\nUNLESS CONFLICT ON ${renderEdgeQL($on, ctx, false, true)}`);\n        }\n        if ($else) {\n            clause.push(`\\nELSE (${renderEdgeQL($else, ctx, true, true)})`);\n        }\n        return `(${renderEdgeQL(expr.__expr__, ctx, false, true).slice(1, -1)}${clause.join(\"\")})`;\n    }\n    else if (expr.__kind__ === ExpressionKind.Group) {\n        const groupingSet = expr.__modifiers__.by;\n        const elementsShape = expr.__element__.__shape__.elements.__element__.__shape__;\n        const selectStatement = [];\n        const groupStatement = [];\n        const groupTarget = renderEdgeQL(expr.__scope__, ctx, false);\n        groupStatement.push(`GROUP ${groupTarget}`);\n        const combinedBlock = [\n            ...groupingSet.__exprs__.map(([k, v]) => `  ${k} := ${renderEdgeQL(v, ctx)}`),\n        ];\n        groupStatement.push(`USING\\n${combinedBlock.join(\",\\n\")}`);\n        let by = renderGroupingSet(groupingSet).trim();\n        if (by[0] === \"(\" && by[by.length - 1] === \")\") {\n            by = by.slice(1, by.length - 1);\n        }\n        groupStatement.push(`BY ` + by);\n        const selectTarget = `${groupTarget}_groups`;\n        selectStatement.push(`WITH\\n${[\n            ...unscopedWithBlock,\n            ...scopeExprVar,\n        ].join(\",\\n\")},\r\n  ${selectTarget} := (\r\n${indent(groupStatement.join(\"\\n\"), 4)}\r\n)`);\n        const scopeVar = ctx.withVars.get(expr.__scope__);\n        const elementsShapeQuery = indent(shapeToEdgeQL(elementsShape, { ...ctx }, expr.__element__), 2)\n            .trim()\n            .split(scopeVar.name + \".\")\n            .join(`${selectTarget}.elements.`);\n        selectStatement.push(`SELECT ${selectTarget} {\r\n  key: {${groupingSet.__exprs__.map((e) => e[0]).join(\", \")}},\r\n  grouping,\r\n  elements: ${elementsShapeQuery}\r\n}`);\n        return `(${selectStatement.join(\"\\n\")})`;\n    }\n    else if (expr.__kind__ === ExpressionKind.Function) {\n        const args = expr.__args__.map((arg) => `${renderEdgeQL(arg, ctx, false)}`);\n        for (const [key, arg] of Object.entries(expr.__namedargs__)) {\n            args.push(`${q(key)} := ${renderEdgeQL(arg, ctx, false)}`);\n        }\n        return `${expr.__name__}(${args.join(\", \")})`;\n    }\n    else if (expr.__kind__ === ExpressionKind.Operator) {\n        const operator = expr.__name__;\n        const args = expr.__args__;\n        switch (expr.__opkind__) {\n            case OperatorKind.Infix:\n                if (operator === \"[]\") {\n                    let index = \"\";\n                    if (Array.isArray(args[1])) {\n                        const [start, end] = args[1];\n                        if (start) {\n                            index += renderEdgeQL(start, ctx);\n                        }\n                        index += \":\";\n                        if (end) {\n                            index += renderEdgeQL(end, ctx);\n                        }\n                    }\n                    else {\n                        index = renderEdgeQL(args[1], ctx);\n                    }\n                    return `${renderEdgeQL(args[0], ctx)}[${index}]`;\n                }\n                return `(${renderEdgeQL(args[0], ctx)} ${operator} ${renderEdgeQL(args[1], ctx)})`;\n            case OperatorKind.Postfix:\n                return `(${renderEdgeQL(args[0], ctx)} ${operator})`;\n            case OperatorKind.Prefix:\n                return `(${operator} ${renderEdgeQL(args[0], ctx)})`;\n            case OperatorKind.Ternary:\n                if (operator === \"if_else\") {\n                    return `(${renderEdgeQL(args[0], ctx)} IF ${renderEdgeQL(args[1], ctx)} ELSE ${renderEdgeQL(args[2], ctx)})`;\n                }\n                else {\n                    throw new Error(`Unknown operator: ${operator}`);\n                }\n            default:\n                util.assertNever(expr.__opkind__, new Error(`Unknown operator kind: ${expr.__opkind__}`));\n        }\n    }\n    else if (expr.__kind__ === ExpressionKind.TypeIntersection) {\n        return `${renderEdgeQL(expr.__expr__, ctx)}[IS ${expr.__element__.__name__}]`;\n    }\n    else if (expr.__kind__ === ExpressionKind.For) {\n        ctx.forVars.set(expr.__forVar__, `__forVar__${ctx.forVars.size}`);\n        return `(${withBlock}FOR ${ctx.forVars.get(expr.__forVar__)} IN {${renderEdgeQL(expr.__iterSet__, ctx)}}\r\nUNION (\\n${indent(renderEdgeQL(expr.__expr__, ctx), 2)}\\n))`;\n    }\n    else if (expr.__kind__ === ExpressionKind.ForVar) {\n        const forVar = ctx.forVars.get(expr);\n        if (!forVar) {\n            throw new Error(`'FOR' loop variable used outside of 'FOR' loop`);\n        }\n        return forVar;\n    }\n    else if (expr.__kind__ === ExpressionKind.Param) {\n        return `__param__${expr.__name__}`;\n    }\n    else if (expr.__kind__ === ExpressionKind.Detached) {\n        return `(DETACHED ${renderEdgeQL(expr.__expr__, {\n            ...ctx,\n            renderWithVar: expr.__expr__,\n        }, undefined, true)})`;\n    }\n    else if (expr.__kind__ === ExpressionKind.Global) {\n        return `(GLOBAL ${expr.__name__})`;\n    }\n    else {\n        util.assertNever(expr, new Error(`Unrecognized expression kind: \"${expr.__kind__}\"`));\n    }\n}\nfunction isGroupingSet(arg) {\n    return arg.__kind__ === \"groupingset\";\n}\nfunction renderGroupingSet(set) {\n    const contents = Object.entries(set.__elements__)\n        .map(([k, v]) => {\n        return isGroupingSet(v) ? renderGroupingSet(v) : k;\n    })\n        .join(\", \");\n    if (set.__settype__ === \"tuple\") {\n        return `(${contents})`;\n    }\n    else if (set.__settype__ === \"set\") {\n        return `{${contents}}`;\n    }\n    else if (set.__settype__ === \"cube\") {\n        return `cube(${contents})`;\n    }\n    else if (set.__settype__ === \"rollup\") {\n        return `rollup(${contents})`;\n    }\n    else {\n        throw new Error(`Unrecognized set type: \"${set.__settype__}\"`);\n    }\n}\nfunction shapeToEdgeQL(shape, ctx, type = null, keysOnly = false, injectImplicitId = true) {\n    const pointers = type?.__pointers__ || null;\n    const isFreeObject = type?.__name__ === \"std::FreeObject\";\n    if (shape === null) {\n        return ``;\n    }\n    const lines = [];\n    const addLine = (line) => lines.push(`${keysOnly ? \"\" : \"  \"}${line}`);\n    const seen = new Set();\n    for (const key in shape) {\n        if (!shape.hasOwnProperty(key))\n            continue;\n        if (seen.has(key)) {\n            console.warn(`Invalid: duplicate key \"${key}\"`);\n            continue;\n        }\n        seen.add(key);\n        let val = shape[key];\n        let operator = \":=\";\n        let polyType = null;\n        if (typeof val === \"object\" && !val.__element__) {\n            if (!!val[\"+=\"]) {\n                operator = \"+=\";\n                val = val[\"+=\"];\n            }\n            else if (!!val[\"-=\"]) {\n                operator = \"-=\";\n                val = val[\"-=\"];\n            }\n        }\n        if (val.__kind__ === ExpressionKind.PolyShapeElement) {\n            polyType = val.__polyType__;\n            val = val.__shapeElement__;\n        }\n        const polyIntersection = polyType\n            ? `[IS ${polyType.__element__.__name__}].`\n            : \"\";\n        const ptr = pointers?.[key];\n        const addCardinalityAnnotations = pointers && (!ptr || isFreeObject);\n        const expectedCardinality = addCardinalityAnnotations && val.hasOwnProperty(\"__cardinality__\")\n            ? val.__cardinality__ === Cardinality.Many ||\n                val.__cardinality__ === Cardinality.AtLeastOne\n                ? \"multi \"\n                : \"single \"\n            : \"\";\n        const wrapAssertExists = ptr?.cardinality === Cardinality.AtLeastOne;\n        if (typeof val === \"boolean\") {\n            if (!pointers?.[key] &&\n                key[0] !== \"@\" &&\n                type &&\n                type?.__name__ !== \"std::FreeObject\" &&\n                !polyIntersection) {\n                throw new Error(`Field \"${key}\" does not exist in ${type?.__name__}`);\n            }\n            if (val) {\n                addLine(`${polyIntersection}${q(key)}`);\n            }\n            continue;\n        }\n        if (typeof val !== \"object\") {\n            throw new Error(`Invalid shape element at \"${key}\".`);\n        }\n        const valIsExpression = val.hasOwnProperty(\"__kind__\");\n        if (!valIsExpression) {\n            addLine(`${polyIntersection}${q(key, false)}: ${indent(shapeToEdgeQL(val, ctx, ptr?.target), 2).trim()}`);\n            continue;\n        }\n        if (keysOnly) {\n            addLine(q(key, false) +\n                (isObjectType(val.__element__)\n                    ? `: ${shapeToEdgeQL(val.__element__.__shape__, ctx, null, true)}`\n                    : \"\"));\n            continue;\n        }\n        const renderedExpr = renderEdgeQL(val, ctx);\n        addLine(`${expectedCardinality}${q(key, false)} ${operator} ${wrapAssertExists ? \"assert_exists(\" : \"\"}${renderedExpr.includes(\"\\n\")\n            ? `(\\n${indent(renderedExpr[0] === \"(\" &&\n                renderedExpr[renderedExpr.length - 1] === \")\"\n                ? renderedExpr.slice(1, -1)\n                : renderedExpr, 4)}\\n  )`\n            : renderedExpr}${wrapAssertExists ? \")\" : \"\"}`);\n    }\n    if (lines.length === 0 && injectImplicitId) {\n        addLine(\"id\");\n    }\n    return keysOnly ? `{${lines.join(\", \")}}` : `{\\n${lines.join(\",\\n\")}\\n}`;\n}\nfunction topoSortWithVars(vars, ctx) {\n    if (!vars.size) {\n        return [];\n    }\n    const sorted = [];\n    const unvisited = new Set(vars);\n    const visiting = new Set();\n    for (const withVar of unvisited) {\n        visit(withVar);\n    }\n    function visit(withVar) {\n        if (!unvisited.has(withVar)) {\n            return;\n        }\n        if (visiting.has(withVar)) {\n            throw new Error(`'WITH' variables contain a cyclic dependency`);\n        }\n        visiting.add(withVar);\n        for (const child of ctx.withVars.get(withVar).childExprs) {\n            if (vars.has(child)) {\n                visit(child);\n            }\n        }\n        visiting.delete(withVar);\n        unvisited.delete(withVar);\n        sorted.push(withVar);\n    }\n    return sorted;\n}\nconst numericalTypes = {\n    \"std::number\": true,\n    \"std::int16\": true,\n    \"std::int32\": true,\n    \"std::int64\": true,\n    \"std::float32\": true,\n    \"std::float64\": true,\n};\nfunction literalToEdgeQL(type, val) {\n    const typename = type.__casttype__?.__name__ ?? type.__name__;\n    let skipCast = false;\n    let stringRep;\n    if (typename === \"std::json\") {\n        skipCast = true;\n        stringRep = `to_json($$${JSON.stringify(val)}$$)`;\n    }\n    else if (typeof val === \"string\") {\n        if (numericalTypes[typename]) {\n            skipCast = typename === type.__name__;\n            stringRep = val;\n        }\n        else if (type.__kind__ === TypeKind.enum) {\n            skipCast = true;\n            const vals = type.__values__;\n            if (vals.includes(val)) {\n                skipCast = true;\n                if (val.includes(\" \")) {\n                    stringRep = `<${type.__name__}>\"${val}\"`;\n                }\n                else {\n                    stringRep = `${type.__name__}.${q(val)}`;\n                }\n            }\n            else {\n                throw new Error(`Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`);\n            }\n        }\n        else {\n            if (typename === \"std::str\") {\n                skipCast = true;\n            }\n            stringRep = JSON.stringify(val);\n        }\n    }\n    else if (typeof val === \"number\") {\n        if (numericalTypes[typename]) {\n            skipCast = typename === type.__name__;\n        }\n        else {\n            throw new Error(`Unknown numerical type: ${type.__name__}!`);\n        }\n        stringRep = `${val.toString()}`;\n    }\n    else if (typeof val === \"boolean\") {\n        stringRep = `${val.toString()}`;\n        skipCast = true;\n    }\n    else if (typeof val === \"bigint\") {\n        stringRep = `${val.toString()}n`;\n    }\n    else if (Array.isArray(val)) {\n        skipCast = val.length !== 0;\n        if (isArrayType(type)) {\n            stringRep = `[${val\n                .map((el) => literalToEdgeQL(type.__element__, el))\n                .join(\", \")}]`;\n        }\n        else if (isTupleType(type)) {\n            stringRep = `( ${val\n                .map((el, j) => literalToEdgeQL(type.__items__[j], el))\n                .join(\", \")}${type.__items__.length === 1 ? \",\" : \"\"} )`;\n        }\n        else {\n            throw new Error(`Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`);\n        }\n    }\n    else if (val instanceof Date) {\n        stringRep = `'${val.toISOString()}'`;\n    }\n    else if (val instanceof LocalDate ||\n        val instanceof LocalDateTime ||\n        val instanceof LocalTime ||\n        val instanceof Duration ||\n        val instanceof RelativeDuration ||\n        val instanceof DateDuration) {\n        stringRep = `'${val.toString()}'`;\n    }\n    else if (val instanceof Uint8Array) {\n        stringRep = bufferToStringRep(val);\n        skipCast = true;\n    }\n    else if (val instanceof Float32Array) {\n        stringRep = `[${val.join(\",\")}]`;\n    }\n    else if (val instanceof Range) {\n        const elType = type.__element__;\n        const elTypeName = elType.__name__ === \"std::number\" ? \"std::int64\" : elType.__name__;\n        return `std::range(${val.lower === null\n            ? `<${elTypeName}>{}`\n            : literalToEdgeQL(elType, val.lower)}, ${val.upper === null\n            ? `<${elTypeName}>{}`\n            : literalToEdgeQL(elType, val.upper)}, inc_lower := ${val.incLower}, inc_upper := ${val.incUpper})`;\n    }\n    else if (typeof val === \"object\") {\n        if (isNamedTupleType(type)) {\n            stringRep = `( ${Object.entries(val).map(([key, value]) => `${key} := ${literalToEdgeQL(type.__shape__[key], value)}`)} )`;\n            skipCast = true;\n        }\n        else {\n            throw new Error(`Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`);\n        }\n    }\n    else {\n        throw new Error(`Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`);\n    }\n    if (skipCast) {\n        return stringRep;\n    }\n    return `<${type.__name__}>${stringRep}`;\n}\nfunction indent(str, depth) {\n    return str\n        .split(\"\\n\")\n        .map((line) => \" \".repeat(depth) + line)\n        .join(\"\\n\");\n}\nfunction q(ident, allowBacklinks = true) {\n    if (!ident ||\n        ident.startsWith(\"@\") ||\n        (allowBacklinks && (ident.startsWith(\"<\") || ident.includes(\"::\")))) {\n        return ident;\n    }\n    const isAlphaNum = /^([^\\W\\d]\\w*|([1-9]\\d*|0))$/.test(ident);\n    if (isAlphaNum) {\n        const lident = ident.toLowerCase();\n        const isReserved = lident !== \"__type__\" &&\n            lident !== \"__std__\" &&\n            reservedKeywords.has(lident);\n        if (!isReserved) {\n            return ident;\n        }\n    }\n    return \"`\" + ident.replace(/`/g, \"``\") + \"`\";\n}\nfunction bufferToStringRep(buf) {\n    let stringRep = \"\";\n    for (const byte of buf) {\n        if (byte < 32 || byte > 126) {\n            switch (byte) {\n                case 8:\n                    stringRep += \"\\\\b\";\n                    break;\n                case 9:\n                    stringRep += \"\\\\t\";\n                    break;\n                case 10:\n                    stringRep += \"\\\\n\";\n                    break;\n                case 12:\n                    stringRep += \"\\\\f\";\n                    break;\n                case 13:\n                    stringRep += \"\\\\r\";\n                    break;\n                default:\n                    stringRep += `\\\\x${byte.toString(16).padStart(2, \"0\")}`;\n            }\n        }\n        else {\n            stringRep +=\n                (byte === 39 || byte === 92 ? \"\\\\\" : \"\") + String.fromCharCode(byte);\n        }\n    }\n    return `b'${stringRep}'`;\n}\nfunction getErrorHint(expr) {\n    let literalConstructor = null;\n    switch (typeof expr) {\n        case \"string\":\n            literalConstructor = \"e.str()\";\n            break;\n        case \"number\":\n            literalConstructor = Number.isInteger(expr) ? \"e.int64()\" : \"e.float64()\";\n            break;\n        case \"bigint\":\n            literalConstructor = \"e.bigint()\";\n            break;\n        case \"boolean\":\n            literalConstructor = \"e.bool()\";\n            break;\n    }\n    switch (true) {\n        case expr instanceof Date:\n            literalConstructor = \"e.datetime()\";\n            break;\n        case expr instanceof Duration:\n            literalConstructor = \"e.duration()\";\n            break;\n        case expr instanceof LocalDate:\n            literalConstructor = \"e.cal.local_date()\";\n            break;\n        case expr instanceof LocalDateTime:\n            literalConstructor = \"e.cal.local_datetime()\";\n            break;\n        case expr instanceof LocalTime:\n            literalConstructor = \"e.cal.local_time()\";\n            break;\n        case expr instanceof RelativeDuration:\n            literalConstructor = \"e.cal.relative_duration()\";\n            break;\n        case expr instanceof DateDuration:\n            literalConstructor = \"e.cal.date_duration()\";\n            break;\n    }\n    return literalConstructor\n        ? `\\nHint: Maybe you meant to wrap the value in ` +\n            `a '${literalConstructor}' expression?`\n        : \"\";\n}\n"},{"path":"typesystem.mjs","content":"import { TypeKind } from \"edgedb/dist/reflection/index.js\";\nexport function $toSet(root, card) {\n    return {\n        __element__: root,\n        __cardinality__: card,\n    };\n}\nexport function isScalarType(type) {\n    return type.__kind__ === TypeKind.scalar;\n}\nexport function isEnumType(type) {\n    return type.__kind__ === TypeKind.enum;\n}\nexport function isObjectType(type) {\n    return type.__kind__ === TypeKind.object;\n}\nexport function isTupleType(type) {\n    return type.__kind__ === TypeKind.tuple;\n}\nexport function isNamedTupleType(type) {\n    return type.__kind__ === TypeKind.namedtuple;\n}\nexport function isArrayType(type) {\n    return type.__kind__ === TypeKind.array;\n}\n"},{"path":"update.mjs","content":"import { ExpressionKind, } from \"edgedb/dist/reflection/index.js\";\nimport { $expressionify, $getScopedExpr, $assert_single } from \"./path.mjs\";\nimport { $existingScopes, $handleModifiers, } from \"./select.mjs\";\nimport { $normaliseInsertShape } from \"./insert.mjs\";\nexport function update(expr, shape) {\n    const cleanScopedExprs = $existingScopes.size === 0;\n    const scope = $getScopedExpr(expr, $existingScopes);\n    const resolvedShape = shape(scope);\n    if (cleanScopedExprs) {\n        $existingScopes.clear();\n    }\n    const mods = {};\n    let updateShape;\n    for (const [key, val] of Object.entries(resolvedShape)) {\n        if (key === \"filter\" || key === \"filter_single\") {\n            mods[key] = val;\n        }\n        else if (key === \"set\") {\n            updateShape = val;\n        }\n        else {\n            throw new Error(`Invalid update shape key '${key}', only 'filter', 'filter_single', ` +\n                `and 'set' are allowed`);\n        }\n    }\n    if (!updateShape) {\n        throw new Error(`Update shape must contain 'set' shape`);\n    }\n    const { modifiers, cardinality, needsAssertSingle } = $handleModifiers(mods, {\n        root: expr,\n        scope,\n    });\n    const updateExpr = {\n        __kind__: ExpressionKind.Update,\n        __element__: expr.__element__,\n        __cardinality__: cardinality,\n        __expr__: expr,\n        __shape__: $normaliseInsertShape(expr, updateShape, true),\n        __modifiers__: modifiers,\n        __scope__: scope,\n    };\n    return needsAssertSingle\n        ? $assert_single(updateExpr)\n        : $expressionify(updateExpr);\n}\n"},{"path":"with.mjs","content":"import { ExpressionKind } from \"edgedb/dist/reflection/index.js\";\nimport { $expressionify } from \"./path.mjs\";\nexport function alias(expr) {\n    return $expressionify({\n        __kind__: ExpressionKind.Alias,\n        __element__: expr.__element__,\n        __cardinality__: expr.__cardinality__,\n        __expr__: expr,\n    });\n}\nfunction _with(refs, expr) {\n    return $expressionify({\n        __kind__: ExpressionKind.With,\n        __element__: expr.__element__,\n        __cardinality__: expr.__cardinality__,\n        __refs__: refs,\n        __expr__: expr,\n    });\n}\nexport { _with as with };\n"},{"path":"__spec__.mjs","content":"export {};\n"},{"path":"cardinality.d.ts","content":"import { Cardinality } from \"edgedb/dist/reflection/index\";\nimport type { TypeSet } from \"./typesystem\";\nexport declare namespace cardutil {\n    export type multiplyCardinalities<C1 extends Cardinality, C2 extends Cardinality> = C1 extends Cardinality.Empty ? Cardinality.Empty : C1 extends Cardinality.One ? C2 : C1 extends Cardinality.AtMostOne ? C2 extends Cardinality.One ? Cardinality.AtMostOne : C2 extends Cardinality.AtLeastOne ? Cardinality.Many : C2 : C1 extends Cardinality.Many ? C2 extends Cardinality.Empty ? Cardinality.Empty : Cardinality.Many : C1 extends Cardinality.AtLeastOne ? C2 extends Cardinality.AtMostOne ? Cardinality.Many : C2 extends Cardinality.One ? Cardinality.AtLeastOne : C2 : never;\n    export function multiplyCardinalities(c1: Cardinality, c2: Cardinality): Cardinality;\n    type _multiplyCardinalitiesVariadic<Cards extends [Cardinality, ...Cardinality[]]> = Cards extends [infer Card] ? Card : Cards extends [infer A, infer B, ...infer Rest] ? A extends Cardinality ? B extends Cardinality ? Rest extends Cardinality[] ? multiplyCardinalities<A, B> extends Cardinality ? _multiplyCardinalitiesVariadic<[\n        multiplyCardinalities<A, B>,\n        ...Rest\n    ]> : never : never : never : never : never;\n    export type multiplyCardinalitiesVariadic<Cards extends [Cardinality, ...Cardinality[]]> = _multiplyCardinalitiesVariadic<Cards> extends Cardinality ? _multiplyCardinalitiesVariadic<Cards> : never;\n    export function multiplyCardinalitiesVariadic<Cards extends [Cardinality, ...Cardinality[]]>(cards: Cards): multiplyCardinalitiesVariadic<Cards>;\n    export type mergeCardinalities<A extends Cardinality, B extends Cardinality> = A extends Cardinality.Empty ? B : B extends Cardinality.Empty ? A : A extends Cardinality.AtLeastOne ? Cardinality.AtLeastOne : B extends Cardinality.AtLeastOne ? Cardinality.AtLeastOne : A extends Cardinality.One ? Cardinality.AtLeastOne : B extends Cardinality.One ? Cardinality.AtLeastOne : Cardinality.Many;\n    export function mergeCardinalities<A extends Cardinality, B extends Cardinality>(a: A, b: B): mergeCardinalities<A, B>;\n    type _mergeCardinalitiesVariadic<Cards extends [Cardinality, ...Cardinality[]]> = Cards extends [infer Card] ? Card : Cards extends [infer A, infer B, ...infer Rest] ? A extends Cardinality ? B extends Cardinality ? Rest extends Cardinality[] ? mergeCardinalities<A, B> extends Cardinality ? _mergeCardinalitiesVariadic<[mergeCardinalities<A, B>, ...Rest]> : never : never : never : never : never;\n    export type mergeCardinalitiesVariadic<Cards extends [Cardinality, ...Cardinality[]]> = _mergeCardinalitiesVariadic<Cards> extends Cardinality ? _mergeCardinalitiesVariadic<Cards> : never;\n    export function mergeCardinalitiesVariadic<Cards extends [Cardinality, ...Cardinality[]]>(cards: Cards): mergeCardinalitiesVariadic<Cards>;\n    export type orCardinalities<C1 extends Cardinality, C2 extends Cardinality> = C1 extends C2 ? C1 : C1 extends Cardinality.Many ? C1 : C1 extends Cardinality.AtMostOne ? C2 extends Cardinality.Many ? C2 : C2 extends Cardinality.AtLeastOne ? Cardinality.Many : C1 : C1 extends Cardinality.AtLeastOne ? C2 extends Cardinality.One ? Cardinality.AtLeastOne : Cardinality.Many : C1 extends Cardinality.Empty ? C2 extends Cardinality.AtMostOne ? Cardinality.AtMostOne : C2 extends Cardinality.One ? Cardinality.AtMostOne : Cardinality.Many : C2 extends Cardinality.Empty ? Cardinality.AtMostOne : C2;\n    export function orCardinalities(c1: Cardinality, c2: Cardinality): Cardinality;\n    export type overrideLowerBound<C extends Cardinality, O extends \"One\" | \"Zero\"> = O extends \"One\" ? C extends Cardinality.Many ? Cardinality.AtLeastOne : C extends Cardinality.AtLeastOne ? Cardinality.AtLeastOne : Cardinality.One : C extends Cardinality.Empty ? Cardinality.Empty : C extends Cardinality.Many ? Cardinality.Many : C extends Cardinality.AtLeastOne ? Cardinality.Many : Cardinality.AtMostOne;\n    export function overrideLowerBound<C extends Cardinality, O extends \"One\" | \"Zero\">(card: C, override: O): overrideLowerBound<C, O>;\n    export type overrideUpperBound<C extends Cardinality, O extends \"One\" | \"Many\"> = O extends \"One\" ? C extends Cardinality.Many ? Cardinality.AtMostOne : C extends Cardinality.AtLeastOne ? Cardinality.One : C extends Cardinality.Empty ? Cardinality.AtMostOne : C : C extends Cardinality.One ? Cardinality.AtLeastOne : C extends Cardinality.AtMostOne ? Cardinality.Many : C extends Cardinality.Empty ? Cardinality.Many : C;\n    export function overrideUpperBound<C extends Cardinality, O extends \"One\" | \"Many\">(card: C, override: O): overrideUpperBound<C, O>;\n    export type paramCardinality<P> = [P] extends [TypeSet] ? [\n        Cardinality\n    ] extends [P[\"__cardinality__\"]] ? Cardinality.One : P[\"__cardinality__\"] : Cardinality.One;\n    export type optionalParamCardinality<P> = overrideLowerBound<paramCardinality<P>, \"One\">;\n    type _paramArrayCardinality<T> = {\n        [K in keyof T]: T[K] extends TypeSet ? T[K][\"__cardinality__\"] : Cardinality.One;\n    };\n    export type paramArrayCardinality<T extends [any, ...any[]]> = multiplyCardinalitiesVariadic<_paramArrayCardinality<T>>;\n    export type assignable<C extends Cardinality> = C extends Cardinality.Empty ? Cardinality.Empty : C extends Cardinality.One ? Cardinality.One : C extends Cardinality.AtMostOne ? Cardinality.One | Cardinality.AtMostOne | Cardinality.Empty : C extends Cardinality.AtLeastOne ? Cardinality.One | Cardinality.AtLeastOne | Cardinality.Many : C extends Cardinality.Many ? Cardinality : never;\n    export {};\n}\n"},{"path":"cast.d.ts","content":"import { ExpressionKind, Cardinality } from \"edgedb/dist/reflection/index\";\nimport type { Expression, BaseType, TypeSet, ObjectTypeExpression } from \"./typesystem\";\nimport type { orScalarLiteral } from \"./castMaps\";\nexport declare function cast<Target extends BaseType | ObjectTypeExpression>(target: Target, arg: null): $expr_Cast<Target extends BaseType ? Target : Target extends ObjectTypeExpression ? Target[\"__element__\"] : never, Cardinality.Empty>;\nexport declare function cast<Target extends BaseType, Expr extends TypeSet>(target: Target, expr: orScalarLiteral<Expr>): $expr_Cast<Target, Cardinality extends Expr[\"__cardinality__\"] ? Cardinality.One : Expr[\"__cardinality__\"]>;\nexport type $expr_Cast<Target extends BaseType = BaseType, Card extends Cardinality = Cardinality> = Expression<{\n    __element__: Target;\n    __cardinality__: Card;\n    __kind__: ExpressionKind.Cast;\n    __expr__: TypeSet | null;\n}>;\n"},{"path":"casting.d.ts","content":"import type { Cardinality } from \"edgedb/dist/reflection/index\";\nimport type { ArrayType, BaseType, BaseTypeTuple, BaseTypeToTsType, EnumType, LinkDesc, NamedTupleType, ObjectType, ObjectTypeSet, PrimitiveTypeSet, PropertyDesc, ScalarType, TupleType, TypeSet, RangeType, MultiRangeType } from \"./typesystem\";\nimport type { cardutil } from \"./cardinality\";\nimport type { scalarCastableFrom, scalarAssignableBy } from \"./castMaps\";\nexport type anonymizeObject<T extends ObjectType> = ObjectType<string, T[\"__pointers__\"], any>;\ntype assignableTuple<Items extends BaseTypeTuple> = {\n    [k in keyof Items]: Items[k] extends BaseType ? assignableBy<Items[k]> : never;\n} extends infer NewItems ? NewItems extends BaseTypeTuple ? NewItems : never : never;\nexport type assignableBy<T extends BaseType> = T extends ScalarType ? scalarAssignableBy<T> : T extends ObjectType ? anonymizeObject<T> : T extends EnumType ? T : T extends ArrayType ? ArrayType<assignableBy<T[\"__element__\"]>> : T extends TupleType ? TupleType<assignableTuple<T[\"__items__\"]>> : T extends NamedTupleType ? NamedTupleType<{\n    [k in keyof T[\"__shape__\"]]: assignableBy<T[\"__shape__\"][k]>;\n}> : T extends RangeType ? RangeType<scalarAssignableBy<T[\"__element__\"]> extends ScalarType ? scalarAssignableBy<T[\"__element__\"]> : never> : T extends MultiRangeType ? MultiRangeType<scalarAssignableBy<T[\"__element__\"]> extends ScalarType ? scalarAssignableBy<T[\"__element__\"]> : never> : never;\nexport type pointerToAssignmentExpression<Pointer extends PropertyDesc | LinkDesc, IsSetModifier extends boolean = false> = setToAssignmentExpression<TypeSet<Pointer[\"target\"], Pointer[\"cardinality\"]>, IsSetModifier>;\nexport type setToAssignmentExpression<Set extends TypeSet, IsSetModifier extends boolean> = [Set] extends [PrimitiveTypeSet] ? TypeSet<assignableBy<Set[\"__element__\"]>, cardutil.assignable<cardutil.overrideLowerBound<Set[\"__cardinality__\"], \"Zero\">>> | getAssignmentLiteral<Set, IsSetModifier> : [Set] extends [ObjectTypeSet] ? TypeSet<ObjectType<string, Set[\"__element__\"][\"__pointers__\"]>, cardutil.assignable<cardutil.overrideLowerBound<Set[\"__cardinality__\"], \"Zero\">>> : never;\ntype getAssignmentLiteral<Set extends PrimitiveTypeSet, IsSetModifier extends boolean> = BaseTypeToTsType<Set[\"__element__\"]> extends infer TsType ? TsType | (Set[\"__cardinality__\"] extends Cardinality.Many ? TsType[] : Set[\"__cardinality__\"] extends Cardinality.AtLeastOne ? IsSetModifier extends true ? TsType[] : [TsType, ...TsType[]] : never) : never;\ntype castableTuple<Items extends BaseTypeTuple> = {\n    [k in keyof Items]: Items[k] extends BaseType ? castableFrom<Items[k]> : never;\n} extends infer NewItems ? NewItems extends BaseTypeTuple ? NewItems : never : never;\nexport type castableFrom<T extends BaseType> = T extends ScalarType ? scalarCastableFrom<T> : T extends ObjectType ? anonymizeObject<T> : T extends ArrayType ? ArrayType<castableFrom<T[\"__element__\"]>> : T extends TupleType ? TupleType<castableTuple<T[\"__items__\"]>> : T extends NamedTupleType ? NamedTupleType<{\n    [k in keyof T[\"__shape__\"]]: castableFrom<T[\"__shape__\"][k]>;\n}> : never;\nexport type pointerToCastableExpression<Pointer extends PropertyDesc | LinkDesc> = [Pointer] extends [PropertyDesc] ? {\n    __element__: castableFrom<Pointer[\"target\"]>;\n    __cardinality__: cardutil.assignable<Pointer[\"cardinality\"]>;\n} : [Pointer] extends [LinkDesc] ? TypeSet<ObjectType<string, Pointer[\"target\"][\"__pointers__\"]>, cardutil.assignable<Pointer[\"cardinality\"]>> : never;\nexport {};\n"},{"path":"castMaps.d.ts","content":"export type scalarCastableFrom<T extends any> = any;\nexport type scalarAssignableBy<T extends any> = any;\nexport type orScalarLiteral<T extends any> = any;\nexport type scalarLiterals = any;\nexport type literalToScalarType<T extends any> = any;\ntype literalToTypeSet<T extends any> = any;\nexport type mapLiteralToTypeSet<T> = {\n    [k in keyof T]: literalToTypeSet<T[k]>;\n};\ndeclare function literalToTypeSet(t: any): any;\nexport { literalToTypeSet };\nexport declare function isImplicitlyCastableTo(from: string, to: string): boolean;\nexport declare function getSharedParentScalar(a: any, b: any): any;\nexport type getSharedParentScalar<A, B> = any;\n"},{"path":"collections.d.ts","content":"import { type typeutil } from \"edgedb/dist/reflection/index\";\nimport { cardutil } from \"./cardinality\";\nimport type { $expr_Array, $expr_NamedTuple, $expr_Tuple, ArrayType, BaseType, getPrimitiveBaseType, NamedTupleShape, NamedTupleType, NonArrayType, ObjectTypeExpression, ObjectTypePointers, PropertyDesc, TupleType, TypeSet } from \"./typesystem\";\nimport { type ExpressionRoot } from \"./path\";\nimport type { getCardsFromExprs } from \"./set\";\nimport { type literalToScalarType, type mapLiteralToTypeSet, type orScalarLiteral, type scalarLiterals } from \"./castMaps\";\nexport declare function $arrayLikeIndexify(_expr: ExpressionRoot): any;\nexport declare function array<Element extends NonArrayType>(element: Element): ArrayType<Element>;\nexport declare function array<Expr extends TypeSet<NonArrayType> | scalarLiterals, Exprs extends orScalarLiteral<TypeSet<Expr extends TypeSet ? getPrimitiveBaseType<Expr[\"__element__\"]> : getPrimitiveBaseType<literalToScalarType<Expr>>>>[]>(arg: [Expr, ...Exprs]): $expr_Array<ArrayType<Expr extends TypeSet ? getPrimitiveBaseType<Expr[\"__element__\"]> : getPrimitiveBaseType<literalToScalarType<Expr>>>, cardutil.multiplyCardinalitiesVariadic<getCardsFromExprs<mapLiteralToTypeSet<[Expr, ...Exprs]>>>>;\nexport declare function $tuplePathify(expr: ExpressionRoot): ExpressionRoot;\nexport declare function tuple<Items extends typeutil.tupleOf<BaseType>>(items: Items): TupleType<Items>;\nexport declare function tuple<Item extends TypeSet | scalarLiterals, Items extends typeutil.tupleOf<TypeSet | scalarLiterals>>(items: Items): $expr_Tuple<Items extends typeutil.tupleOf<any> ? mapLiteralToTypeSet<Items> : never>;\nexport declare function tuple<Shape extends NamedTupleShape>(shape: Shape): NamedTupleType<Shape>;\nexport declare function tuple<Shape extends {\n    [k: string]: TypeSet | scalarLiterals;\n}>(shape: Shape): $expr_NamedTuple<mapLiteralToTypeSet<Shape>>;\ntype PropertyNamesFromPointers<Pointers extends ObjectTypePointers> = {\n    [k in keyof Pointers as Pointers[k] extends PropertyDesc ? Pointers[k][\"computed\"] extends true ? never : k : never]: Pointers[k];\n};\nexport declare function $objectTypeToTupleType<Expr extends ObjectTypeExpression>(objectType: Expr): PropertyNamesFromPointers<Expr[\"__element__\"][\"__pointers__\"]> extends infer Pointers ? Pointers extends ObjectTypePointers ? NamedTupleType<{\n    [k in keyof Pointers as k extends \"id\" ? never : k]: Pointers[k][\"target\"];\n}> : never : never;\nexport declare function $objectTypeToTupleType<Expr extends ObjectTypeExpression, Fields extends keyof PropertyNamesFromPointers<Expr[\"__element__\"][\"__pointers__\"]>>(objectType: Expr, includeFields: Fields[]): NamedTupleType<{\n    [k in Fields]: Expr[\"__element__\"][\"__pointers__\"][k] extends PropertyDesc ? Expr[\"__element__\"][\"__pointers__\"][k][\"target\"] : never;\n}>;\nexport {};\n"},{"path":"detached.d.ts","content":"import { ExpressionKind } from \"edgedb/dist/reflection/index\";\nimport type { Expression, TypeSet } from \"./typesystem\";\nexport declare function detached<Expr extends TypeSet>(expr: Expr): $expr_Detached<Expr>;\nexport type $expr_Detached<Expr extends TypeSet = TypeSet> = Expression<{\n    __element__: Expr[\"__element__\"];\n    __cardinality__: Expr[\"__cardinality__\"];\n    __kind__: ExpressionKind.Detached;\n    __expr__: TypeSet;\n}>;\n"},{"path":"external.d.ts","content":"import type { TypeSet, setToTsType } from \"./typesystem\";\nexport { literal } from \"./literal\";\nexport {} from \"./path\";\nexport { set } from \"./set\";\nexport { cast } from \"./cast\";\nexport { ASC, DESC, EMPTY_FIRST, EMPTY_LAST, is, delete, select, } from \"./select\";\nexport { update } from \"./update\";\nexport { insert } from \"./insert\";\nexport { array, tuple, $objectTypeToTupleType as objectTypeToTupleType, } from \"./collections\";\nexport {} from \"./funcops\";\nexport { for } from \"./for\";\nexport { alias, with } from \"./with\";\nexport { optional, params } from \"./params\";\nexport { detached } from \"./detached\";\nexport {} from \"./toEdgeQL\";\nexport type $infer<A extends TypeSet> = setToTsType<A>;\n"},{"path":"for.d.ts","content":"import { Cardinality, ExpressionKind } from \"edgedb/dist/reflection/index\";\nimport { cardutil } from \"./cardinality\";\nimport type { Expression, BaseType, BaseTypeSet } from \"./typesystem\";\nexport type $expr_For<El extends BaseType = BaseType, Card extends Cardinality = Cardinality> = Expression<{\n    __element__: El;\n    __cardinality__: Card;\n    __kind__: ExpressionKind.For;\n    __iterSet__: BaseTypeSet;\n    __forVar__: $expr_ForVar;\n    __expr__: BaseTypeSet;\n}>;\nexport type $expr_ForVar<Type extends BaseType = BaseType> = Expression<{\n    __element__: Type;\n    __cardinality__: Cardinality.One;\n    __kind__: ExpressionKind.ForVar;\n}>;\ndeclare function _for<IteratorSet extends BaseTypeSet, Expr extends BaseTypeSet>(set: IteratorSet, expr: (variable: $expr_ForVar<IteratorSet[\"__element__\"]>) => Expr): $expr_For<Expr[\"__element__\"], cardutil.multiplyCardinalities<IteratorSet[\"__cardinality__\"], Expr[\"__cardinality__\"]>>;\nexport { _for as for };\n"},{"path":"funcops.d.ts","content":"import { Cardinality, type introspect } from \"edgedb/dist/reflection/index\";\nimport type { BaseType, BaseTypeSet, TypeSet, Expression } from \"./typesystem\";\nimport type { ExpressionKind, OperatorKind } from \"edgedb/dist/reflection/index\";\nexport type $expr_Function<El extends BaseType = BaseType, Card extends Cardinality = Cardinality> = Expression<{\n    __element__: El;\n    __cardinality__: Card;\n    __kind__: ExpressionKind.Function;\n    __name__: string;\n    __args__: (BaseTypeSet | undefined)[];\n    __namedargs__: {\n        [key: string]: BaseTypeSet;\n    };\n}>;\nexport type $expr_Operator<El extends BaseType = BaseType, Card extends Cardinality = Cardinality> = Expression<{\n    __element__: El;\n    __cardinality__: Card;\n    __kind__: ExpressionKind.Operator;\n    __name__: string;\n    __opkind__: OperatorKind;\n    __args__: TypeSet[];\n}>;\ninterface OverloadFuncArgDef {\n    typeId: string;\n    optional?: boolean;\n    setoftype?: boolean;\n    variadic?: boolean;\n}\ninterface OverloadFuncDef {\n    kind?: string;\n    args: OverloadFuncArgDef[];\n    namedArgs?: {\n        [key: string]: OverloadFuncArgDef;\n    };\n    returnTypeId: string;\n    returnTypemod?: \"SetOfType\" | \"OptionalType\";\n    preservesOptionality?: boolean;\n}\nexport declare function $resolveOverload(funcName: string, args: any[], typeSpec: introspect.Types, funcDefs: OverloadFuncDef[]): {\n    kind?: string | undefined;\n    returnType: BaseType;\n    cardinality: Cardinality;\n    args: BaseTypeSet[];\n    namedArgs: {\n        [key: string]: BaseTypeSet;\n    };\n};\nexport {};\n"},{"path":"globals.d.ts","content":"import { ExpressionKind, Cardinality } from \"edgedb/dist/reflection/index\";\nimport type { Expression, BaseType } from \"./typesystem\";\nexport declare function makeGlobal<Type extends BaseType, Card extends Cardinality>(name: string, type: Type, card: Card): $expr_Global<Type, Card>;\nexport type $expr_Global<Type extends BaseType = BaseType, Card extends Cardinality = Cardinality> = Expression<{\n    __name__: string;\n    __element__: Type;\n    __cardinality__: Card;\n    __kind__: ExpressionKind.Global;\n}>;\n"},{"path":"group.d.ts","content":"import type { Expression, ObjectType, ObjectTypeSet, TypeSet, BaseType, $scopify, PropertyDesc, LinkDesc } from \"./typesystem\";\nimport { Cardinality, ExpressionKind } from \"edgedb/dist/reflection/index\";\nimport type { $FreeObjectλShape, $str } from \"./modules/std\";\nimport type { normaliseShape, objectTypeToSelectShape } from \"./select\";\ntype SingletonSet = Expression<TypeSet<BaseType, Cardinality.One | Cardinality.AtMostOne>>;\ntype SimpleGroupElements = {\n    [k: string]: SingletonSet;\n};\ntype GroupModifiers = {\n    by: SimpleGroupElements;\n};\ntype NestedGroupElements = {\n    [k: string]: SingletonSet | GroupingSet;\n};\nexport type GroupingSet = {\n    __kind__: \"groupingset\";\n    __settype__: \"set\" | \"tuple\" | \"rollup\" | \"cube\";\n    __elements__: NestedGroupElements;\n    __exprs__: [string, SingletonSet][];\n};\nexport declare function isGroupingSet(arg: any): arg is GroupingSet;\ndeclare const setFuncs: {\n    set: <T extends SimpleGroupElements>(grps: T) => { [k in keyof T]?: T[k] | undefined; };\n    tuple: <T extends SimpleGroupElements>(grps: T) => { [k in keyof T]?: T[k] | undefined; };\n    rollup: <T extends SimpleGroupElements>(grps: T) => { [k in keyof T]?: T[k] | undefined; };\n    cube: <T extends SimpleGroupElements>(grps: T) => { [k in keyof T]?: T[k] | undefined; };\n};\nexport type $expr_Group<Expr extends ObjectTypeSet = ObjectTypeSet, Mods extends GroupModifiers = GroupModifiers, Shape extends object = {\n    id: true;\n}> = Expression<{\n    __element__: ObjectType<\"std::FreeObject\", $FreeObjectλShape & {\n        grouping: PropertyDesc<$str, Cardinality.Many, false, true, true, false>;\n        key: LinkDesc<ObjectType<\"std::FreeObject\", {\n            [k in keyof Mods[\"by\"]]: Mods[\"by\"][k][\"__element__\"] extends ObjectType ? never : PropertyDesc<Mods[\"by\"][k][\"__element__\"], Cardinality.AtMostOne>;\n        }>, Cardinality.One, {}, false, true, true, false>;\n        elements: LinkDesc<Expr[\"__element__\"], Cardinality.Many, {}, false, true, true, false>;\n    }, {\n        grouping: TypeSet<$str, Cardinality.Many>;\n        key: Expression<{\n            __element__: ObjectType<\"std::FreeObject\", $FreeObjectλShape, {\n                [k in keyof Mods[\"by\"]]: Expression<{\n                    __element__: Mods[\"by\"][k][\"__element__\"];\n                    __cardinality__: Cardinality.AtMostOne;\n                }>;\n            }>;\n            __cardinality__: Cardinality.One;\n        }>;\n        elements: Expression<{\n            __element__: ObjectType<Expr[\"__element__\"][\"__name__\"], Expr[\"__element__\"][\"__pointers__\"], normaliseShape<Shape, \"by\">>;\n            __cardinality__: Cardinality.Many;\n        }>;\n    }>;\n    __cardinality__: Cardinality.Many;\n    __modifiers__: Mods;\n    __kind__: ExpressionKind.Group;\n    __expr__: ObjectTypeSet;\n    __scope__: ObjectTypeSet;\n}>;\ntype noUndefined<T> = T extends undefined ? never : T;\ntype groupFunc = <Expr extends ObjectTypeSet, Shape extends {\n    by?: SimpleGroupElements;\n} & objectTypeToSelectShape<Expr[\"__element__\"]>>(expr: Expr, getter: (arg: $scopify<Expr[\"__element__\"]>) => Readonly<Shape>) => $expr_Group<Expr, {\n    by: noUndefined<Shape[\"by\"]>;\n}, normaliseShape<Shape, \"by\">>;\ndeclare const groupFunc: groupFunc;\nexport declare const group: typeof setFuncs & groupFunc;\nexport {};\n"},{"path":"hydrate.d.ts","content":"import type { $ } from \"edgedb\";\nimport type { BaseType, ObjectType, ObjectTypePointers, TupleType } from \"./typesystem\";\nimport type { typeutil } from \"edgedb/dist/reflection/index\";\nexport declare function makeType<T extends BaseType>(spec: $.introspect.Types, id: string, literal: any, anytype?: BaseType): T;\nexport type mergeObjectShapes<A extends ObjectTypePointers, B extends ObjectTypePointers> = typeutil.flatten<{\n    [k in keyof A & keyof B]: A[k] extends B[k] ? B[k] extends A[k] ? A[k] : never : never;\n}>;\nexport type mergeObjectTypes<A extends ObjectType | undefined, B extends ObjectType | undefined> = A extends ObjectType ? B extends ObjectType ? ObjectType<`${A[\"__name__\"]} UNION ${B[\"__name__\"]}`, mergeObjectShapes<A[\"__pointers__\"], B[\"__pointers__\"]>, null> : A : B extends ObjectType ? B : undefined;\nexport declare function $mergeObjectTypes<A extends ObjectType, B extends ObjectType>(a: A, b: B): mergeObjectTypes<A, B>;\nexport declare function $mergeTupleTypes<A extends TupleType, B extends TupleType>(a: A, b: B): TupleType;\n"},{"path":"insert.d.ts","content":"import { Cardinality, ExpressionKind, type typeutil } from \"edgedb/dist/reflection/index\";\nimport type { Expression, LinkDesc, ObjectTypeSet, ObjectTypePointers, PropertyDesc, stripBacklinks, stripNonInsertables, $scopify, stripSet, TypeSet, ObjectType } from \"./typesystem\";\nimport type { pointerToAssignmentExpression } from \"./casting\";\nimport type { $expr_PathNode } from \"./path\";\nimport type { $Object } from \"./modules/std\";\nimport type { scalarLiterals } from \"./castMaps\";\nexport type pointerIsOptional<T extends PropertyDesc | LinkDesc> = T[\"cardinality\"] extends Cardinality.Many | Cardinality.Empty | Cardinality.AtMostOne ? true : false;\nexport type InsertShape<El extends ObjectType> = typeutil.flatten<RawInsertShape<El>>;\nexport type RawInsertShape<El extends ObjectType> = ObjectType extends El ? never : typeutil.stripNever<stripNonInsertables<stripBacklinks<El[\"__pointers__\"]>>> extends infer Shape ? Shape extends ObjectTypePointers ? typeutil.addQuestionMarks<{\n    [k in keyof Shape]: pointerToAssignmentExpression<Shape[k]> | (pointerIsOptional<Shape[k]> extends true ? undefined | null : never) | (Shape[k][\"hasDefault\"] extends true ? undefined : never);\n}> & {\n    [k in `@${string}`]: TypeSet | scalarLiterals;\n} : never : never;\ninterface UnlessConflict {\n    on: TypeSet | null;\n    else?: TypeSet;\n}\ntype InsertBaseExpression<Root extends TypeSet = TypeSet> = {\n    __kind__: ExpressionKind.Insert;\n    __element__: Root[\"__element__\"];\n    __cardinality__: Cardinality.One;\n    __expr__: stripSet<Root>;\n    __shape__: any;\n};\nexport type $expr_Insert<El extends ObjectType = ObjectType> = Expression<{\n    __kind__: ExpressionKind.Insert;\n    __element__: El;\n    __cardinality__: Cardinality.One;\n    __expr__: $expr_PathNode;\n    __shape__: InsertShape<El>;\n    unlessConflict(): $expr_InsertUnlessConflict<El, {\n        on: null;\n    }>;\n    unlessConflict<Conflict extends UnlessConflict>(conflictGetter: (scope: $scopify<El>) => Conflict): $expr_InsertUnlessConflict<El, Conflict>;\n}>;\nexport type $expr_InsertUnlessConflict<El extends ObjectType = ObjectType, Conflict extends UnlessConflict = UnlessConflict> = Expression<{\n    __kind__: ExpressionKind.InsertUnlessConflict;\n    __element__: Conflict[\"else\"] extends TypeSet ? Conflict[\"else\"][\"__element__\"][\"__name__\"] extends El[\"__name__\"] ? El : $Object : El;\n    __cardinality__: Conflict[\"else\"] extends TypeSet ? Conflict[\"else\"][\"__cardinality__\"] : Cardinality.AtMostOne;\n    __expr__: InsertBaseExpression;\n    __conflict__: Conflict;\n}>;\nexport declare function $insertify(expr: Omit<$expr_Insert, \"unlessConflict\">): $expr_Insert;\nexport declare function $normaliseInsertShape(root: ObjectTypeSet, shape: {\n    [key: string]: any;\n}, isUpdate?: boolean): {\n    [key: string]: TypeSet | {\n        \"+=\": TypeSet;\n    } | {\n        \"-=\": TypeSet;\n    };\n};\nexport declare function insert<Root extends $expr_PathNode>(root: Root, shape: InsertShape<Root[\"__element__\"]>): $expr_Insert<Root[\"__element__\"]>;\nexport {};\n"},{"path":"json.d.ts","content":"export declare function jsonifyComplexParams(expr: any, _args: any): any;\n"},{"path":"literal.d.ts","content":"import type { Expression, BaseType, BaseTypeToTsType, ScalarType } from \"./typesystem\";\nimport { Cardinality, ExpressionKind } from \"edgedb/dist/reflection/index\";\nexport type $expr_Literal<Type extends BaseType = BaseType> = Expression<{\n    __element__: Type;\n    __cardinality__: Cardinality.One;\n    __kind__: ExpressionKind.Literal;\n    __value__: any;\n}>;\nexport declare function literal<T extends BaseType>(type: T, value: BaseTypeToTsType<T>): $expr_Literal<T>;\nexport declare const $nameMapping: Map<string, string>;\nexport declare function $getType(id: string): (val: any) => $expr_Literal<ScalarType>;\nexport declare function $getTypeByName(name: string): (val: any) => $expr_Literal<ScalarType>;\n"},{"path":"operators.d.ts","content":"export declare function op(...args: any[]): any;\n"},{"path":"params.d.ts","content":"import type { Executor } from \"edgedb\";\nimport { ExpressionKind, Cardinality } from \"edgedb/dist/reflection/index\";\nimport type { Expression, ParamType, setToTsType, TypeSet, BaseTypeToTsType } from \"./typesystem\";\ntype Param = ParamType | $expr_OptionalParam;\ntype ParamsRecord = Record<string, Param>;\nexport type $expr_OptionalParam<Type extends ParamType = ParamType> = {\n    __kind__: ExpressionKind.OptionalParam;\n    __type__: Type;\n};\nexport declare function optional<Type extends ParamType>(type: Type): $expr_OptionalParam<Type>;\nexport type QueryableWithParamsExpression<Set extends TypeSet = TypeSet, Params extends ParamsRecord = Record<string, never>> = Expression<Set, false> & {\n    run(cxn: Executor, args: paramsToParamArgs<Params>): Promise<setToTsType<Set>>;\n    runJSON(cxn: Executor, args: paramsToParamArgs<Params>): Promise<string>;\n};\nexport type $expr_WithParams<Params extends ParamsRecord = Record<string, never>, Expr extends TypeSet = TypeSet> = QueryableWithParamsExpression<{\n    __kind__: ExpressionKind.WithParams;\n    __element__: Expr[\"__element__\"];\n    __cardinality__: Expr[\"__cardinality__\"];\n    __expr__: Expr;\n    __params__: $expr_Param[];\n}, Params>;\ntype paramsToParamArgs<Params extends ParamsRecord> = {\n    [key in keyof Params as Params[key] extends ParamType ? key : never]: Params[key] extends ParamType ? Readonly<BaseTypeToTsType<Params[key], true>> : never;\n} & {\n    [key in keyof Params as Params[key] extends $expr_OptionalParam ? key : never]?: Params[key] extends $expr_OptionalParam ? Readonly<BaseTypeToTsType<Params[key][\"__type__\"], true> | null> : never;\n};\nexport type $expr_Param<Name extends string | number | symbol = string, Type extends ParamType = ParamType, Optional extends boolean = boolean> = Expression<{\n    __kind__: ExpressionKind.Param;\n    __element__: Type;\n    __cardinality__: Optional extends true ? Cardinality.AtMostOne : Cardinality.One;\n    __name__: Name;\n    __isComplex__: boolean;\n}>;\ntype paramsToParamExprs<Params extends ParamsRecord> = {\n    [key in keyof Params]: Params[key] extends $expr_OptionalParam ? $expr_Param<key, Params[key][\"__type__\"], true> : Params[key] extends ParamType ? $expr_Param<key, Params[key], false> : never;\n};\nexport declare function params<Params extends ParamsRecord = Record<string, never>, Expr extends Expression = Expression>(paramsDef: Params, expr: (params: paramsToParamExprs<Params>) => Expr): $expr_WithParams<Params, Expr>;\nexport {};\n"},{"path":"path.d.ts","content":"import { ExpressionKind, Cardinality, type typeutil } from \"edgedb/dist/reflection/index\";\nimport { cardutil } from \"./cardinality\";\nimport type { BaseType, Expression, LinkDesc, ObjectType, ObjectTypePointers, ObjectTypeSet, PropertyDesc, PropertyShape, TypeSet } from \"./typesystem\";\ntype getChildOfObjectTypeSet<Root extends ObjectTypeSet, ChildKey extends keyof Root[\"__element__\"][\"__pointers__\"]> = TypeSet<Root[\"__element__\"][\"__pointers__\"][ChildKey][\"target\"], cardutil.multiplyCardinalities<Root[\"__cardinality__\"], Root[\"__element__\"][\"__pointers__\"][ChildKey][\"cardinality\"]>>;\nexport interface PathParent<Parent extends ObjectTypeSet = ObjectTypeSet, L extends string = string> {\n    type: Parent;\n    linkName: L;\n}\nexport type $linkPropify<Root extends ObjectTypeSet> = Root extends {\n    __parent__: PathParent<infer Parent, infer L>;\n} ? Parent[\"__element__\"][\"__pointers__\"][L] extends LinkDesc<any, any, infer LinkProps, any, any, any, any> ? pathifyLinkProps<LinkProps, Root, PathParent<Parent, L>> : {} : unknown;\nexport type $pathify<Root extends TypeSet> = Root extends ObjectTypeSet ? ObjectTypeSet extends Root ? {} : pathifyPointers<Root> & pathifyShape<Root> & $linkPropify<Root> : {};\nexport type pathifyPointers<Root extends ObjectTypeSet> = ObjectTypePointers extends Root[\"__element__\"][\"__pointers__\"] ? unknown : {\n    [k in keyof Root[\"__element__\"][\"__pointers__\"] & string]: Root[\"__element__\"][\"__pointers__\"][k] extends PropertyDesc ? $expr_PathLeaf<getChildOfObjectTypeSet<Root, k>, {\n        type: anonymizeObjectTypeSet<Root>;\n        linkName: k;\n    }> : Root[\"__element__\"][\"__pointers__\"][k] extends LinkDesc ? getChildOfObjectTypeSet<Root, k> extends ObjectTypeSet ? $expr_PathNode<getChildOfObjectTypeSet<Root, k>, {\n        type: anonymizeObjectTypeSet<Root>;\n        linkName: k;\n    }> : unknown : unknown;\n};\ntype anonymizeObjectTypeSet<T extends ObjectTypeSet> = typeutil.flatten<{\n    __element__: ObjectType<T[\"__element__\"][\"__name__\"], T[\"__element__\"][\"__pointers__\"], {\n        id: true;\n    }>;\n    __cardinality__: T[\"__cardinality__\"];\n}>;\nexport type pathifyShape<Root extends ObjectTypeSet, Shape extends {\n    [k: string]: any;\n} = Root[\"__element__\"][\"__shape__\"]> = string extends keyof Shape ? {} : {\n    [k in keyof Shape & string]: Shape[k] extends ObjectTypeSet ? $expr_PathNode<TypeSet<Shape[k][\"__element__\"], cardutil.multiplyCardinalities<Root[\"__cardinality__\"], Shape[k][\"__cardinality__\"]>>, {\n        type: Root;\n        linkName: k;\n    }> : Shape[k] extends TypeSet ? $expr_PathLeaf<TypeSet<Shape[k][\"__element__\"], cardutil.multiplyCardinalities<Root[\"__cardinality__\"], Shape[k][\"__cardinality__\"]>>, {\n        type: Root;\n        linkName: k;\n    }> : unknown;\n};\ntype pathifyLinkProps<Props extends PropertyShape, Root extends ObjectTypeSet, Parent extends PathParent | null = null> = {\n    [k in keyof Props & string]: Props[k] extends PropertyDesc ? $expr_PathLeaf<TypeSet<Props[k][\"target\"], cardutil.multiplyCardinalities<Root[\"__cardinality__\"], Props[k][\"cardinality\"]>>, {\n        type: $expr_PathNode<Root, Parent>;\n        linkName: k;\n    }> : unknown;\n};\nexport type getPropsShape<T extends ObjectType> = typeutil.flatten<typeutil.stripNever<{\n    [k in keyof T[\"__pointers__\"]]: T[\"__pointers__\"][k][\"__kind__\"] extends \"property\" ? true : never;\n}>>;\nexport type $expr_PathNode<Root extends ObjectTypeSet = ObjectTypeSet, Parent extends PathParent | null = PathParent | null> = Expression<{\n    __element__: Root[\"__element__\"];\n    __cardinality__: Root[\"__cardinality__\"];\n    __parent__: Parent;\n    __kind__: ExpressionKind.PathNode;\n    \"*\": getPropsShape<Root[\"__element__\"]>;\n}>;\nexport type $expr_TypeIntersection<Card extends Cardinality = Cardinality, Intersection extends ObjectType = ObjectType> = Expression<{\n    __element__: Intersection;\n    __cardinality__: Card;\n    __kind__: ExpressionKind.TypeIntersection;\n    __expr__: TypeSet;\n}>;\nexport type $expr_PathLeaf<Root extends TypeSet = TypeSet, Parent extends PathParent = PathParent> = Expression<{\n    __element__: Root[\"__element__\"];\n    __cardinality__: Root[\"__cardinality__\"];\n    __kind__: ExpressionKind.PathLeaf;\n    __parent__: Parent;\n}>;\nexport type ExpressionRoot = {\n    __element__: BaseType;\n    __cardinality__: Cardinality;\n    __kind__: ExpressionKind;\n};\ndeclare function PathLeaf<Root extends TypeSet, Parent extends PathParent, Exclusive extends boolean = boolean>(root: Root, parent: Parent, exclusive: Exclusive, scopeRoot?: TypeSet | null): $expr_PathLeaf<Root, Parent>;\ndeclare function PathNode<Root extends ObjectTypeSet, Parent extends PathParent | null>(root: Root, parent: Parent, scopeRoot?: TypeSet | null): $expr_PathNode<Root, Parent>;\nexport declare function $pathify<Root extends TypeSet, Parent extends PathParent>(_root: Root): $pathify<Root>;\nexport declare function $assert_single(expr: Expression): any;\nexport declare function $jsonDestructure(_expr: ExpressionRoot): any;\nexport declare function $expressionify<T extends ExpressionRoot>(_expr: T): Expression<T>;\nexport declare function $getScopedExpr<T extends ExpressionRoot>(expr: T, existingScopes?: Set<Expression>): Expression<T>;\nexport { PathLeaf as $PathLeaf, PathNode as $PathNode };\n"},{"path":"query.d.ts","content":"import type * as edgedb from \"edgedb\";\nexport declare const runnableExpressionKinds: Set<edgedb.$.ExpressionKind>;\nexport declare function $queryFunc(this: any, cxn: edgedb.Executor, args: any): Promise<unknown>;\nexport declare function $queryFuncJSON(this: any, cxn: edgedb.Executor, args: any): Promise<string>;\n"},{"path":"range.d.ts","content":"import type { LocalDate, LocalDateTime, Duration } from \"edgedb\";\nimport { Range } from \"edgedb\";\nimport type { cardutil } from \"./cardinality\";\nimport type { RangeType, getPrimitiveBaseType, TypeSet, BaseType } from \"./typesystem\";\nimport type { $expr_Literal } from \"./literal\";\nimport type { $number, $decimal, $datetime, $duration, $bool } from \"./modules/std\";\nimport type { $local_date, $local_datetime } from \"./modules/cal\";\nimport type { literalToScalarType, orScalarLiteral } from \"./castMaps\";\nimport { type $expr_Function } from \"./funcops\";\ntype $anypoint = $number | $local_date | $decimal | $datetime | $local_datetime | $duration;\ndeclare function range<Element extends $anypoint>(element: Element): RangeType<Element>;\ndeclare function range<T extends number | Date | LocalDate | LocalDateTime | Duration>(val: Range<T>): $expr_Literal<RangeType<getPrimitiveBaseType<literalToScalarType<T>>>>;\ndeclare function range<NamedArgs extends {\n    inc_lower?: orScalarLiteral<TypeSet<$bool>>;\n    inc_upper?: orScalarLiteral<TypeSet<$bool>>;\n    empty?: orScalarLiteral<TypeSet<$bool>>;\n}, P1 extends orScalarLiteral<TypeSet<$anypoint>> | undefined, P2 extends orScalarLiteral<TypeSet<BaseType extends literalToScalarType<P1> ? $anypoint : getPrimitiveBaseType<literalToScalarType<P1>>>> | undefined>(namedArgs: NamedArgs, lower?: P1, upper?: P2): $expr_Function<RangeType<literalToScalarType<P1> extends $anypoint ? literalToScalarType<P1> : literalToScalarType<P2> extends $anypoint ? literalToScalarType<P2> : $anypoint>, cardutil.multiplyCardinalities<cardutil.multiplyCardinalities<cardutil.multiplyCardinalities<cardutil.multiplyCardinalities<cardutil.optionalParamCardinality<P1>, cardutil.optionalParamCardinality<P2>>, cardutil.optionalParamCardinality<NamedArgs[\"inc_lower\"]>>, cardutil.optionalParamCardinality<NamedArgs[\"inc_upper\"]>>, cardutil.optionalParamCardinality<NamedArgs[\"empty\"]>>>;\ndeclare function range<P1 extends orScalarLiteral<TypeSet<$anypoint>> | undefined, P2 extends orScalarLiteral<TypeSet<BaseType extends literalToScalarType<P1> ? $anypoint : getPrimitiveBaseType<literalToScalarType<P1>>>> | undefined>(lower?: P1, upper?: P2): $expr_Function<RangeType<literalToScalarType<P1> extends $anypoint ? literalToScalarType<P1> : literalToScalarType<P2> extends $anypoint ? literalToScalarType<P2> : $anypoint>, cardutil.multiplyCardinalities<cardutil.optionalParamCardinality<P1>, cardutil.optionalParamCardinality<P2>>>;\nexport { range as $range };\n"},{"path":"reflection.d.ts","content":"export * from \"edgedb/dist/reflection/index\";\nexport * from \"./typesystem\";\nexport { cardutil } from \"./cardinality\";\nexport type { $expr_Literal } from \"./literal\";\nexport type { $expr_PathNode, $expr_PathLeaf } from \"./path\";\nexport type { $expr_Function, $expr_Operator } from \"./funcops\";\nexport { makeType, $mergeObjectTypes } from \"./hydrate\";\nexport type { mergeObjectTypes } from \"./hydrate\";\n"},{"path":"select.d.ts","content":"import type { $bool, $number } from \"./modules/std\";\nimport { Cardinality, ExpressionKind } from \"edgedb/dist/reflection/index\";\nimport { cardutil } from \"./cardinality\";\nimport type { $expr_PolyShapeElement, $scopify, Expression, LinkDesc, ObjectType, ObjectTypeExpression, ObjectTypePointers, ObjectTypeSet, PrimitiveTypeSet, PropertyDesc, ScalarType, stripSet, TypeSet, BaseType, ExclusiveTuple, orLiteralValue } from \"./typesystem\";\nimport { type $expr_PathLeaf, type $linkPropify, type ExpressionRoot } from \"./path\";\nimport type { anonymizeObject } from \"./casting\";\nimport { type scalarLiterals, type literalToScalarType } from \"./castMaps\";\nexport declare const ASC: \"ASC\";\nexport declare const DESC: \"DESC\";\nexport declare const EMPTY_FIRST: \"EMPTY FIRST\";\nexport declare const EMPTY_LAST: \"EMPTY LAST\";\nexport type OrderByDirection = \"ASC\" | \"DESC\";\nexport type OrderByEmpty = \"EMPTY FIRST\" | \"EMPTY LAST\";\nexport type OrderByExpr = TypeSet<ScalarType | ObjectType, Cardinality>;\nexport type OrderByObjExpr = {\n    expression: OrderByExpr;\n    direction?: OrderByDirection;\n    empty?: OrderByEmpty;\n};\nexport type OrderByExpression = OrderByExpr | OrderByObjExpr | [OrderByExpr | OrderByObjExpr, ...(OrderByExpr | OrderByObjExpr)[]];\nexport type OffsetExpression = TypeSet<$number, Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne>;\nexport type SelectFilterExpression = TypeSet<$bool, Cardinality>;\nexport type LimitOffsetExpression = TypeSet<$number, Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne>;\nexport type LimitExpression = TypeSet<$number, Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne>;\nexport type SelectModifierNames = \"filter\" | \"filter_single\" | \"order_by\" | \"offset\" | \"limit\";\ntype filterSingle<T extends TypeSet> = T extends ObjectTypeSet ? TypeSet<anonymizeObject<T[\"__element__\"]>, T[\"__cardinality__\"]> : orLiteralValue<T>;\nexport type exclusivesToFilterSingle<E extends ExclusiveTuple> = ExclusiveTuple extends E ? never : E extends [] ? never : {\n    [j in keyof E]: {\n        [k in keyof E[j]]: filterSingle<E[j][k]>;\n    };\n}[number];\nexport type SelectModifiers<T extends ObjectType = ObjectType> = {\n    filter?: SelectFilterExpression;\n    filter_single?: exclusivesToFilterSingle<T[\"__exclusives__\"]> | SelectFilterExpression;\n    order_by?: OrderByExpression;\n    offset?: OffsetExpression | number;\n    limit?: LimitExpression | number;\n};\nexport type UnknownSelectModifiers = {\n    [k in keyof SelectModifiers]: unknown;\n};\nexport type NormalisedSelectModifiers = {\n    filter?: SelectFilterExpression;\n    order_by?: OrderByObjExpr[];\n    offset?: OffsetExpression;\n    limit?: LimitExpression;\n    singleton: boolean;\n};\nexport type $expr_Select<Set extends TypeSet = TypeSet> = Expression<{\n    __element__: Set[\"__element__\"];\n    __cardinality__: Set[\"__cardinality__\"];\n    __expr__: TypeSet;\n    __kind__: ExpressionKind.Select;\n    __modifiers__: NormalisedSelectModifiers;\n    __scope__?: ObjectTypeExpression;\n}>;\nexport interface SelectModifierMethods<Root extends TypeSet> {\n    filter<Filter extends SelectFilterExpression>(filter: Filter | ((scope: Root extends ObjectTypeSet ? $scopify<Root[\"__element__\"]> : stripSet<Root>) => Filter)): this;\n    order_by(order_by: OrderByExpression | ((scope: Root extends ObjectTypeSet ? $scopify<Root[\"__element__\"]> : stripSet<Root>) => OrderByExpression)): this;\n    offset(offset: OffsetExpression | number | ((scope: Root extends ObjectTypeSet ? $scopify<Root[\"__element__\"]> : stripSet<Root>) => OffsetExpression | number)): this;\n    limit(limit: LimitExpression | number | ((scope: Root extends ObjectTypeSet ? $scopify<Root[\"__element__\"]> : stripSet<Root>) => LimitExpression | number)): this;\n}\nexport type InferOffsetLimitCardinality<Card extends Cardinality, Modifiers extends UnknownSelectModifiers> = Modifiers[\"limit\"] extends number | LimitExpression ? cardutil.overrideLowerBound<Card, \"Zero\"> : Modifiers[\"offset\"] extends number | OffsetExpression ? cardutil.overrideLowerBound<Card, \"Zero\"> : Card;\nexport type ComputeSelectCardinality<Expr extends ObjectTypeExpression, Modifiers extends UnknownSelectModifiers> = InferOffsetLimitCardinality<undefined extends Modifiers[\"filter_single\"] ? Expr[\"__cardinality__\"] : cardutil.overrideUpperBound<Expr[\"__cardinality__\"], \"One\">, Modifiers>;\nexport declare function is<Expr extends ObjectTypeExpression, Shape extends objectTypeToSelectShape<Expr[\"__element__\"]>>(expr: Expr, shape: Shape): {\n    [k in Exclude<keyof Shape, SelectModifierNames | \"id\">]: $expr_PolyShapeElement<Expr, normaliseElement<Shape[k]>>;\n};\nexport declare function $handleModifiers(modifiers: SelectModifiers, params: {\n    root: TypeSet;\n    scope: TypeSet;\n}): {\n    modifiers: NormalisedSelectModifiers;\n    cardinality: Cardinality;\n    needsAssertSingle: boolean;\n};\nexport type $expr_Delete<Root extends ObjectTypeSet = ObjectTypeSet> = Expression<{\n    __kind__: ExpressionKind.Delete;\n    __element__: Root[\"__element__\"];\n    __cardinality__: Root[\"__cardinality__\"];\n    __expr__: ObjectTypeSet;\n}>;\ndeclare function deleteExpr<Expr extends ObjectTypeExpression, Modifiers extends SelectModifiers<Expr[\"__element__\"]>>(expr: Expr, modifiers?: (scope: $scopify<Expr[\"__element__\"]>) => Readonly<Modifiers>): $expr_Delete<{\n    __element__: ObjectType<Expr[\"__element__\"][\"__name__\"], Expr[\"__element__\"][\"__pointers__\"], {\n        id: true;\n    }>;\n    __cardinality__: ComputeSelectCardinality<Expr, Modifiers>;\n}>;\nexport { deleteExpr as delete };\nexport declare function $selectify<Expr extends ExpressionRoot>(expr: Expr): Expr;\nexport type linkDescToLinkProps<Desc extends LinkDesc> = {\n    [k in keyof Desc[\"properties\"] & string]: $expr_PathLeaf<TypeSet<Desc[\"properties\"][k][\"target\"], Desc[\"properties\"][k][\"cardinality\"]>>;\n};\nexport type pointersToObjectType<P extends ObjectTypePointers> = ObjectType<string, P, object>;\ntype linkDescToShape<L extends LinkDesc> = objectTypeToSelectShape<L[\"target\"]> & objectTypeToSelectShape<pointersToObjectType<L[\"properties\"]>> & SelectModifiers;\ntype linkDescToSelectElement<L extends LinkDesc> = boolean | TypeSet<anonymizeObject<L[\"target\"]>, cardutil.assignable<L[\"cardinality\"]>> | linkDescToShape<L> | ((scope: $scopify<L[\"target\"]> & linkDescToLinkProps<L>) => linkDescToShape<L>);\ntype propDescToSelectElement<P extends PropertyDesc> = boolean | TypeSet<P[\"target\"], cardutil.assignable<P[\"cardinality\"]>> | $expr_PolyShapeElement;\nexport type objectTypeToSelectShape<T extends ObjectType = ObjectType, Pointers extends ObjectTypePointers = T[\"__pointers__\"]> = Partial<{\n    [k in keyof Pointers]: Pointers[k] extends PropertyDesc ? propDescToSelectElement<Pointers[k]> : Pointers[k] extends LinkDesc ? linkDescToSelectElement<Pointers[k]> : any;\n}> & {\n    [k: string]: unknown;\n};\nexport type normaliseElement<El> = El extends boolean ? El : El extends TypeSet ? stripSet<El> : El extends (...scope: any[]) => any ? normaliseShape<ReturnType<El>> : El extends object ? normaliseShape<stripSet<El>> : stripSet<El>;\nexport type normaliseShape<Shape extends object, Strip = SelectModifierNames> = {\n    [k in Exclude<keyof Shape, Strip>]: normaliseElement<Shape[k]>;\n};\nexport declare const $existingScopes: Set<Expression<TypeSet<BaseType, Cardinality>>>;\ndeclare function $shape<Expr extends ObjectTypeExpression, Element extends Expr[\"__element__\"], Shape extends objectTypeToSelectShape<Element> & SelectModifiers<Element>, Scope extends $scopify<Element> & $linkPropify<{\n    [k in keyof Expr]: k extends \"__cardinality__\" ? Cardinality.One : Expr[k];\n}>>(expr: Expr, _shape: (scope: Scope) => Readonly<Shape>): (scope: unknown) => Readonly<Shape>;\nexport { $shape as shape };\nexport declare function select<Expr extends ObjectTypeExpression, Element extends Expr[\"__element__\"], ElementName extends `${Element[\"__name__\"]}`, ElementPointers extends Element[\"__pointers__\"], ElementShape extends Element[\"__shape__\"], Card extends Expr[\"__cardinality__\"]>(expr: Expr): $expr_Select<{\n    __element__: ObjectType<ElementName, ElementPointers, ElementShape>;\n    __cardinality__: Card;\n}>;\nexport declare function select<Expr extends TypeSet>(expr: Expr): $expr_Select<stripSet<Expr>>;\nexport declare function select<Expr extends ObjectTypeExpression, Element extends Expr[\"__element__\"], Shape extends objectTypeToSelectShape<Element> & SelectModifiers<Element>, SelectCard extends ComputeSelectCardinality<Expr, Modifiers>, SelectShape extends normaliseShape<Shape, SelectModifierNames>, Scope extends $scopify<Element> & $linkPropify<{\n    [k in keyof Expr]: k extends \"__cardinality__\" ? Cardinality.One : Expr[k];\n}>, ElementName extends `${Element[\"__name__\"]}`, Modifiers extends UnknownSelectModifiers = Pick<Shape, SelectModifierNames>>(expr: Expr, shape: (scope: Scope) => Readonly<Shape>): $expr_Select<{\n    __element__: ObjectType<ElementName, Element[\"__pointers__\"], SelectShape>;\n    __cardinality__: SelectCard;\n}>;\nexport declare function select<Expr extends PrimitiveTypeSet, Modifiers extends SelectModifiers>(expr: Expr, modifiers: (expr: Expr) => Readonly<Modifiers>): $expr_Select<{\n    __element__: Expr[\"__element__\"];\n    __cardinality__: InferOffsetLimitCardinality<Expr[\"__cardinality__\"], Modifiers>;\n}>;\nexport declare function select<Shape extends {\n    [key: string]: TypeSet;\n}>(shape: Shape): $expr_Select<{\n    __element__: ObjectType<`std::FreeObject`, {\n        [k in keyof Shape]: Shape[k][\"__element__\"] extends ObjectType ? LinkDesc<Shape[k][\"__element__\"], Shape[k][\"__cardinality__\"], {}, false, true, true, false> : PropertyDesc<Shape[k][\"__element__\"], Shape[k][\"__cardinality__\"], false, true, true, false>;\n    }, Shape>;\n    __cardinality__: Cardinality.One;\n}>;\nexport declare function select<Expr extends scalarLiterals>(expr: Expr): $expr_Select<{\n    __element__: literalToScalarType<Expr>;\n    __cardinality__: Cardinality.One;\n}>;\nexport declare function resolveShapeElement(key: any, value: any, scope: ObjectTypeExpression): any;\n"},{"path":"set.d.ts","content":"import type { ExpressionKind, Cardinality } from \"edgedb/dist/reflection/index\";\nimport type { ArrayType, BaseTypeTuple, BaseType, NamedTupleType, ObjectTypeSet, TypeSet, TupleType, Expression, ObjectType, getPrimitiveBaseType, SomeType } from \"./typesystem\";\nimport { type mergeObjectTypes } from \"./hydrate\";\nimport * as castMaps from \"./castMaps\";\nexport declare function getSharedParent(a: SomeType, b: SomeType): SomeType;\nexport { set } from \"./setImpl\";\nexport type $expr_Set<Set extends LooseTypeSet = LooseTypeSet> = Expression<{\n    __element__: Set[\"__element__\"];\n    __cardinality__: Set[\"__cardinality__\"];\n    __exprs__: TypeSet[];\n    __kind__: ExpressionKind.Set;\n}>;\ntype mergeTypeTuples<AItems, BItems> = {\n    [k in keyof AItems]: k extends keyof BItems ? getSharedParentPrimitive<AItems[k], BItems[k]> : never;\n};\nexport type getSharedParentPrimitive<A, B> = A extends undefined ? B extends undefined ? undefined : B : B extends undefined ? A : A extends ArrayType<infer AEl> ? B extends ArrayType<infer BEl> ? ArrayType<castMaps.getSharedParentScalar<AEl, BEl>> : never : A extends NamedTupleType<infer AShape> ? B extends NamedTupleType<infer BShape> ? NamedTupleType<{\n    [k in keyof AShape & keyof BShape]: castMaps.getSharedParentScalar<AShape[k], BShape[k]>;\n}> : never : A extends TupleType<infer AItems> ? B extends TupleType<infer BItems> ? mergeTypeTuples<AItems, BItems> extends BaseTypeTuple ? TupleType<mergeTypeTuples<AItems, BItems>> : never : never : castMaps.getSharedParentScalar<A, B>;\ntype _getSharedParentPrimitiveVariadic<Types extends [any, ...any[]]> = Types extends [infer U] ? U : Types extends [infer A, infer B, ...infer Rest] ? _getSharedParentPrimitiveVariadic<[\n    getSharedParentPrimitive<A, B>,\n    ...Rest\n]> : never;\nexport type getSharedParentPrimitiveVariadic<Types extends [any, ...any[]]> = _getSharedParentPrimitiveVariadic<Types>;\nexport type LooseTypeSet<T extends any = any, C extends Cardinality = Cardinality> = {\n    __element__: T;\n    __cardinality__: C;\n};\nexport type { mergeObjectTypes };\ntype _mergeObjectTypesVariadic<Types extends [ObjectType, ...ObjectType[]]> = Types extends [infer U] ? U : Types extends [infer A, infer B, ...infer Rest] ? A extends ObjectType ? B extends ObjectType ? mergeObjectTypes<A, B> extends BaseType ? mergeObjectTypesVariadic<[mergeObjectTypes<A, B>, ...Rest]> : never : never : never : never;\nexport type mergeObjectTypesVariadic<Types extends [any, ...any[]]> = _mergeObjectTypesVariadic<Types>;\nexport type getTypesFromExprs<Exprs extends [TypeSet, ...TypeSet[]]> = {\n    [k in keyof Exprs]: Exprs[k] extends TypeSet<infer El, any> ? getPrimitiveBaseType<El> : never;\n};\nexport type getTypesFromObjectExprs<Exprs extends [ObjectTypeSet, ...ObjectTypeSet[]]> = {\n    [k in keyof Exprs]: Exprs[k] extends TypeSet<infer El, any> ? El : never;\n};\nexport type getCardsFromExprs<Exprs extends [TypeSet, ...TypeSet[]]> = {\n    [k in keyof Exprs]: Exprs[k] extends TypeSet<any, infer Card> ? Card : never;\n};\n"},{"path":"setImpl.d.ts","content":"export declare function set(...args: any[]): any;\n"},{"path":"syntax.d.ts","content":"import type { TypeSet, setToTsType } from \"./typesystem\";\nexport * from \"./literal\";\nexport * from \"./path\";\nexport * from \"./set\";\nexport * from \"./cast\";\nexport * from \"./select\";\nexport * from \"./update\";\nexport * from \"./insert\";\nexport * from \"./group\";\nexport * from \"./collections\";\nexport * from \"./funcops\";\nexport * from \"./for\";\nexport * from \"./with\";\nexport * from \"./params\";\nexport * from \"./globals\";\nexport * from \"./detached\";\nexport * from \"./toEdgeQL\";\nexport * from \"./range\";\nexport type $infer<A extends TypeSet> = setToTsType<A>;\n"},{"path":"toEdgeQL.d.ts","content":"import { type $expr_Array, type $expr_NamedTuple, type $expr_Tuple, type $expr_TuplePath } from \"./typesystem\";\nimport type { $expr_Literal } from \"./literal\";\nimport type { $expr_PathLeaf, $expr_PathNode, $expr_TypeIntersection } from \"./path\";\nimport type { $expr_Cast } from \"./cast\";\nimport type { $expr_Detached } from \"./detached\";\nimport type { $expr_For, $expr_ForVar } from \"./for\";\nimport type { $expr_Function, $expr_Operator } from \"./funcops\";\nimport type { $expr_Insert, $expr_InsertUnlessConflict } from \"./insert\";\nimport type { $expr_Param, $expr_WithParams } from \"./params\";\nimport type { $expr_Delete, $expr_Select } from \"./select\";\nimport type { $expr_Set } from \"./set\";\nimport type { $expr_Update } from \"./update\";\nimport type { $expr_Alias, $expr_With } from \"./with\";\nimport type { $expr_Group } from \"./group\";\nimport type { $expr_Global } from \"./globals\";\nexport type SomeExpression = $expr_PathNode | $expr_PathLeaf | $expr_Literal | $expr_Set | $expr_Array | $expr_Tuple | $expr_NamedTuple | $expr_TuplePath | $expr_Cast | $expr_Select | $expr_Delete | $expr_Update | $expr_Insert | $expr_InsertUnlessConflict | $expr_Function | $expr_Operator | $expr_For | $expr_ForVar | $expr_TypeIntersection | $expr_Alias | $expr_With | $expr_WithParams | $expr_Param | $expr_Detached | $expr_Group | $expr_Global;\nexport declare function $toEdgeQL(this: any): string;\n"},{"path":"typesystem.d.ts","content":"import type { Executor } from \"edgedb/dist/ifaces\";\nimport type { $expr_PathNode, $expr_TypeIntersection, $pathify } from \"./path\";\nimport type { $expr_Literal } from \"./literal\";\nimport type { $expr_Operator } from \"./funcops\";\nimport type { typeutil, Cardinality, ExpressionKind } from \"edgedb/dist/reflection/index\";\nimport { TypeKind } from \"edgedb/dist/reflection/index\";\nimport type { cardutil } from \"./cardinality\";\nimport type { Range, MultiRange } from \"edgedb\";\nexport interface BaseType {\n    __kind__: TypeKind;\n    __name__: string;\n}\nexport type BaseTypeSet = {\n    __element__: BaseType;\n    __cardinality__: Cardinality;\n};\nexport type BaseTypeTuple = typeutil.tupleOf<BaseType>;\nexport interface ScalarType<Name extends string = string, TsType = any, TsArgType = TsType, TsConstType extends TsType = TsType> extends BaseType {\n    __kind__: TypeKind.scalar;\n    __tstype__: TsType;\n    __tsargtype__: TsArgType;\n    __tsconsttype__: TsConstType;\n    __name__: Name;\n}\nexport type scalarTypeWithConstructor<S extends ScalarType, ExtraTsTypes = never> = S & {\n    <T extends S[\"__tstype__\"] | ExtraTsTypes>(val: T): $expr_Literal<Omit<S, \"__tsconsttype__\"> & {\n        __tsconsttype__: T extends S[\"__tstype__\"] ? T : S[\"__tstype__\"];\n    }>;\n};\ntype $jsonDestructure<Set extends TypeSet> = Set[\"__element__\"] extends ScalarType<\"std::json\"> ? {\n    [path: string]: $expr_Operator<Set[\"__element__\"], Set[\"__cardinality__\"]>;\n} & {\n    destructure<T extends TypeSet<ScalarType<\"std::str\">> | string>(path: T): $expr_Operator<Set[\"__element__\"], cardutil.multiplyCardinalities<Set[\"__cardinality__\"], T extends TypeSet ? T[\"__cardinality__\"] : Cardinality.One>>;\n} : unknown;\nexport interface TypeSet<T extends BaseType = BaseType, Card extends Cardinality = Cardinality> {\n    __element__: T;\n    __cardinality__: Card;\n}\nexport declare function $toSet<Root extends BaseType, Card extends Cardinality>(root: Root, card: Card): TypeSet<Root, Card>;\nexport type Expression<Set extends TypeSet = TypeSet, Runnable extends boolean = true> = Set & (BaseType extends Set[\"__element__\"] ? {\n    run(cxn: Executor): any;\n    runJSON(cxn: Executor): any;\n    toEdgeQL(): string;\n    is: any;\n    assert_single: any;\n} : $pathify<Set> & ExpressionMethods<stripSet<Set>> & (Runnable extends true ? {\n    run(cxn: Executor): Promise<setToTsType<Set>>;\n    runJSON(cxn: Executor): Promise<string>;\n} : {}) & $tuplePathify<Set> & $arrayLikeIndexify<Set> & $jsonDestructure<Set>);\nexport type stripSet<T> = \"__element__\" extends keyof T ? \"__cardinality__\" extends keyof T ? {\n    __element__: T[\"__element__\"];\n    __cardinality__: T[\"__cardinality__\"];\n} : T : T;\nexport type stripSetShape<T> = {\n    [k in keyof T]: stripSet<T[k]>;\n};\nexport type assert_single<El extends BaseType, Card extends Cardinality> = Expression<{\n    __element__: El;\n    __cardinality__: Card;\n    __kind__: ExpressionKind.Function;\n    __name__: \"std::assert_single\";\n    __args__: TypeSet[];\n    __namedargs__: {};\n}>;\nexport type ExpressionMethods<Set extends TypeSet> = {\n    toEdgeQL(): string;\n    is<T extends ObjectTypeSet>(ixn: T): $expr_TypeIntersection<Set[\"__cardinality__\"], ObjectType<T[\"__element__\"][\"__name__\"], T[\"__element__\"][\"__pointers__\"], {\n        id: true;\n    }>>;\n    assert_single(): assert_single<Set[\"__element__\"], Cardinality.AtMostOne>;\n};\nexport interface EnumType<Name extends string = string, Values extends [string, ...string[]] = [string, ...string[]]> extends BaseType {\n    __kind__: TypeKind.enum;\n    __tstype__: Values[number];\n    __name__: Name;\n    __values__: Values;\n}\nexport type ObjectTypeSet = TypeSet<ObjectType, Cardinality>;\nexport type ObjectTypeExpression = TypeSet<ObjectType, Cardinality>;\nexport type ExclusiveTuple = typeutil.tupleOf<{\n    [k: string]: TypeSet;\n}>;\nexport interface ObjectType<Name extends string = string, Pointers extends ObjectTypePointers = ObjectTypePointers, Shape extends object | null = any, Exclusives extends ExclusiveTuple = ExclusiveTuple> extends BaseType {\n    __kind__: TypeKind.object;\n    __name__: Name;\n    __pointers__: Pointers;\n    __shape__: Shape;\n    __exclusives__: Exclusives;\n}\nexport type PropertyTypes = ScalarType | EnumType | ArrayType | TupleType | NamedTupleType;\nexport type SomeType = ScalarType | EnumType | ArrayType | TupleType | ObjectType | NamedTupleType | RangeType | MultiRangeType;\nexport interface PropertyDesc<Type extends BaseType = BaseType, Card extends Cardinality = Cardinality, Exclusive extends boolean = boolean, Computed extends boolean = boolean, Readonly extends boolean = boolean, HasDefault extends boolean = boolean> {\n    __kind__: \"property\";\n    target: Type;\n    cardinality: Card;\n    exclusive: Exclusive;\n    computed: Computed;\n    readonly: Readonly;\n    hasDefault: HasDefault;\n}\nexport type $scopify<Type extends ObjectType> = $expr_PathNode<TypeSet<Type, Cardinality.One>>;\nexport type PropertyShape = {\n    [k: string]: PropertyDesc;\n};\nexport interface LinkDesc<Type extends ObjectType = any, Card extends Cardinality = Cardinality, LinkProps extends PropertyShape = any, Exclusive extends boolean = boolean, Computed extends boolean = boolean, Readonly extends boolean = boolean, HasDefault extends boolean = boolean> {\n    __kind__: \"link\";\n    target: Type;\n    cardinality: Card;\n    properties: LinkProps;\n    exclusive: Exclusive;\n    computed: Computed;\n    readonly: Readonly;\n    hasDefault: HasDefault;\n}\nexport type ObjectTypePointers = {\n    [k: string]: PropertyDesc | LinkDesc;\n};\nexport type stripBacklinks<T extends ObjectTypePointers> = {\n    [k in keyof T]: k extends `<${string}` ? never : T[k];\n};\nexport type omitBacklinks<T extends string | number | symbol> = T extends `<${string}` ? never : T extends string ? T : never;\nexport type stripNonUpdateables<T extends ObjectTypePointers> = {\n    [k in keyof T]: [T[k][\"computed\"]] extends [true] ? never : [T[k][\"readonly\"]] extends [true] ? never : k extends \"__type__\" ? never : k extends \"id\" ? never : T[k];\n};\nexport type stripNonInsertables<T extends ObjectTypePointers> = {\n    [k in keyof T]: [T[k][\"computed\"]] extends [true] ? never : [k] extends [\"__type__\"] ? never : T[k];\n};\ntype shapeElementToTs<Pointer extends PropertyDesc | LinkDesc, Element> = [\n    Element\n] extends [true] ? pointerToTsType<Pointer> : [Element] extends [false] ? never : [Element] extends [boolean] ? pointerToTsType<Pointer> | undefined : Element extends TypeSet ? setToTsType<TypeSet<Element[\"__element__\"], Pointer[\"cardinality\"]>> : Pointer extends LinkDesc ? Element extends object ? computeTsTypeCard<computeObjectShape<Pointer[\"target\"][\"__pointers__\"] & Pointer[\"properties\"], Element>, Pointer[\"cardinality\"]> : never : never;\nexport type $expr_PolyShapeElement<PolyType extends ObjectTypeSet = ObjectTypeSet, ShapeElement extends any = any> = {\n    __kind__: ExpressionKind.PolyShapeElement;\n    __polyType__: PolyType;\n    __shapeElement__: ShapeElement;\n};\nexport type computeObjectShape<Pointers extends ObjectTypePointers, Shape> = typeutil.flatten<keyof Shape extends never ? {\n    id: string;\n} : {\n    [k in keyof Shape]: Shape[k] extends $expr_PolyShapeElement<infer PolyType, infer ShapeEl> ? [k] extends [keyof PolyType[\"__element__\"][\"__pointers__\"]] ? shapeElementToTs<PolyType[\"__element__\"][\"__pointers__\"][k], ShapeEl> | null : never : [k] extends [keyof Pointers] ? shapeElementToTs<Pointers[k], Shape[k]> : Shape[k] extends TypeSet ? setToTsType<Shape[k]> : never;\n}>;\nexport type pointerToTsTypeSimple<El extends PropertyDesc | LinkDesc> = El extends PropertyDesc ? propToTsType<El> : El extends LinkDesc<any, any, any, any> ? {\n    id: string;\n} : never;\nexport type PrimitiveType = ScalarType | EnumType | TupleType | NamedTupleType | ArrayType | RangeType | MultiRangeType;\nexport type PrimitiveTypeSet = TypeSet<PrimitiveType, Cardinality>;\ntype $arrayLikeIndexify<Set extends TypeSet> = Set[\"__element__\"] extends ArrayType | ScalarType<\"std::str\"> | ScalarType<\"std::bytes\"> ? {\n    [index: number]: $expr_Operator<getPrimitiveBaseType<Set[\"__element__\"] extends ArrayType<infer El> ? El : Set[\"__element__\"]>, Set[\"__cardinality__\"]>;\n    [slice: `${number}:${number | \"\"}` | `:${number}`]: $expr_Operator<getPrimitiveBaseType<Set[\"__element__\"]>, Set[\"__cardinality__\"]>;\n    index<T extends TypeSet<ScalarType<\"std::number\">> | number>(index: T): $expr_Operator<getPrimitiveBaseType<Set[\"__element__\"] extends ArrayType<infer El> ? El : Set[\"__element__\"]>, cardutil.multiplyCardinalities<Set[\"__cardinality__\"], T extends TypeSet ? T[\"__cardinality__\"] : Cardinality.One>>;\n    slice<S extends TypeSet<ScalarType<\"std::number\">> | number, E extends TypeSet<ScalarType<\"std::number\">> | number | undefined | null>(start: S, end: E): $expr_Operator<getPrimitiveBaseType<Set[\"__element__\"]>, cardutil.multiplyCardinalities<cardutil.multiplyCardinalities<Set[\"__cardinality__\"], S extends TypeSet ? S[\"__cardinality__\"] : Cardinality.One>, E extends TypeSet<any, infer C> ? C : Cardinality.One>>;\n    slice<E extends TypeSet<ScalarType<\"std::number\">> | number | undefined | null>(start: undefined | null, end: E): $expr_Operator<getPrimitiveBaseType<Set[\"__element__\"]>, cardutil.multiplyCardinalities<Set[\"__cardinality__\"], E extends TypeSet<any, infer C> ? C : Cardinality.One>>;\n} : unknown;\nexport type $expr_Array<Type extends ArrayType = ArrayType, Card extends Cardinality = Cardinality> = Expression<{\n    __kind__: ExpressionKind.Array;\n    __items__: typeutil.tupleOf<TypeSet<Type[\"__element__\"]>>;\n    __element__: Type;\n    __cardinality__: Card;\n}>;\nexport interface ArrayType<Element extends BaseType = BaseType, Name extends string = `array<${Element[\"__name__\"]}>`> extends BaseType {\n    __name__: Name;\n    __kind__: TypeKind.array;\n    __element__: Element;\n}\ntype ArrayTypeToTsType<Type extends ArrayType, isParam extends boolean = false> = BaseTypeToTsType<Type[\"__element__\"], isParam>[];\ntype $tuplePathify<Set extends TypeSet> = Set[\"__element__\"] extends TupleType ? addTuplePaths<Set[\"__element__\"][\"__items__\"], Set[\"__cardinality__\"]> : Set[\"__element__\"] extends NamedTupleType ? addNamedTuplePaths<Set[\"__element__\"][\"__shape__\"], Set[\"__cardinality__\"]> : unknown;\nexport type $expr_TuplePath<ItemType extends BaseType = BaseType, ParentCard extends Cardinality = Cardinality> = Expression<{\n    __kind__: ExpressionKind.TuplePath;\n    __element__: ItemType;\n    __cardinality__: ParentCard;\n    __parent__: $expr_Tuple | $expr_NamedTuple | $expr_TuplePath;\n    __index__: string | number;\n}>;\nexport type baseTupleElementsToTupleType<T extends typeutil.tupleOf<TypeSet>> = {\n    [k in keyof T]: T[k] extends TypeSet ? getPrimitiveBaseType<T[k][\"__element__\"]> : never;\n};\nexport type tupleElementsToTupleType<T extends typeutil.tupleOf<TypeSet>> = baseTupleElementsToTupleType<T> extends BaseTypeTuple ? TupleType<baseTupleElementsToTupleType<T>> : never;\nexport type baseTupleElementsToCardTuple<T> = {\n    [k in keyof T]: T[k] extends TypeSet<any, infer C> ? C : never;\n};\nexport type tupleElementsToCardTuple<T> = baseTupleElementsToCardTuple<T> extends [Cardinality, ...Cardinality[]] ? baseTupleElementsToCardTuple<T> : never;\nexport type $expr_Tuple<Items extends typeutil.tupleOf<TypeSet> = typeutil.tupleOf<TypeSet>> = Expression<{\n    __kind__: ExpressionKind.Tuple;\n    __items__: typeutil.tupleOf<TypeSet>;\n    __element__: tupleElementsToTupleType<Items>;\n    __cardinality__: cardutil.multiplyCardinalitiesVariadic<tupleElementsToCardTuple<Items>>;\n}>;\nexport type indexKeys<T> = T extends `${number}` ? T : never;\ntype addTuplePaths<Items extends BaseType[], ParentCard extends Cardinality> = {\n    [k in indexKeys<keyof Items>]: Items[k] extends BaseType ? $expr_TuplePath<Items[k], ParentCard> : never;\n};\nexport interface TupleType<Items extends BaseTypeTuple = BaseTypeTuple> extends BaseType {\n    __name__: string;\n    __kind__: TypeKind.tuple;\n    __items__: Items;\n}\ntype TupleItemsToTsType<Items extends BaseTypeTuple, isParam extends boolean = false> = {\n    [k in keyof Items]: Items[k] extends BaseType ? BaseTypeToTsType<Items[k], isParam> : never;\n};\ntype literalShapeToType<T extends NamedTupleLiteralShape> = NamedTupleType<{\n    [k in keyof T]: getPrimitiveBaseType<T[k][\"__element__\"]>;\n}>;\ntype shapeCardinalities<Shape extends NamedTupleLiteralShape> = Shape[keyof Shape][\"__cardinality__\"];\ntype inferNamedTupleCardinality<Shape extends NamedTupleLiteralShape> = [\n    Cardinality.Many\n] extends [shapeCardinalities<Shape>] ? Cardinality.Many : [Cardinality.Empty] extends [shapeCardinalities<Shape>] ? Cardinality.Empty : [shapeCardinalities<Shape>] extends [Cardinality.AtMostOne] ? Cardinality.AtMostOne : [shapeCardinalities<Shape>] extends [\n    Cardinality.AtMostOne | Cardinality.One\n] ? Cardinality.One : Cardinality.Many;\nexport type $expr_NamedTuple<Shape extends NamedTupleLiteralShape = NamedTupleLiteralShape> = Expression<{\n    __kind__: ExpressionKind.NamedTuple;\n    __element__: literalShapeToType<Shape>;\n    __cardinality__: inferNamedTupleCardinality<Shape>;\n    __shape__: Shape;\n}>;\ntype addNamedTuplePaths<Shape extends NamedTupleShape, ParentCard extends Cardinality> = {\n    [k in keyof Shape]: Shape[k] extends BaseType ? $expr_TuplePath<Shape[k], ParentCard> : never;\n};\nexport type NamedTupleLiteralShape = {\n    [k: string]: TypeSet;\n};\nexport type NamedTupleShape = {\n    [k: string]: BaseType;\n};\nexport interface NamedTupleType<Shape extends NamedTupleShape = NamedTupleShape> extends BaseType {\n    __name__: string;\n    __kind__: TypeKind.namedtuple;\n    __shape__: Shape;\n}\ntype NamedTupleTypeToTsType<Type extends NamedTupleType, isParam extends boolean = false> = {\n    [k in keyof Type[\"__shape__\"]]: BaseTypeToTsType<Type[\"__shape__\"][k], isParam>;\n};\nexport interface RangeType<Element extends ScalarType = ScalarType, Name extends string = `range<${Element[\"__name__\"]}>`> extends BaseType {\n    __name__: Name;\n    __kind__: TypeKind.range;\n    __element__: Element;\n}\nexport interface MultiRangeType<Element extends ScalarType = ScalarType, Name extends string = `multirange<${Element[\"__name__\"]}>`> extends BaseType {\n    __name__: Name;\n    __kind__: TypeKind.multirange;\n    __element__: Element;\n}\nexport type orLiteralValue<Set extends TypeSet> = Set | (Set[\"__element__\"] extends ObjectType ? never : computeTsType<Set[\"__element__\"], Set[\"__cardinality__\"]>);\nexport type BaseTypeToTsType<Type extends BaseType, isParam extends boolean = false> = Type extends ScalarType ? isParam extends true ? Type[\"__tsargtype__\"] : Type[\"__tsconsttype__\"] : Type extends EnumType ? Type[\"__tstype__\"] : Type extends ArrayType<any> ? ArrayTypeToTsType<Type, isParam> : Type extends RangeType ? Range<Type[\"__element__\"][\"__tsconsttype__\"]> : Type extends MultiRangeType ? MultiRange<Type[\"__element__\"][\"__tsconsttype__\"]> : Type extends TupleType ? TupleItemsToTsType<Type[\"__items__\"], isParam> : Type extends NamedTupleType ? typeutil.flatten<NamedTupleTypeToTsType<Type, isParam>> : Type extends ObjectType ? typeutil.flatten<computeObjectShape<Type[\"__pointers__\"], Type[\"__shape__\"]>> : never;\nexport type setToTsType<Set extends TypeSet> = computeTsType<Set[\"__element__\"], Set[\"__cardinality__\"]>;\nexport type computeTsTypeCard<T extends any, C extends Cardinality> = Cardinality extends C ? unknown : C extends Cardinality.Empty ? null : C extends Cardinality.One ? T : C extends Cardinality.AtLeastOne ? [T, ...T[]] : C extends Cardinality.AtMostOne ? T | null : C extends Cardinality.Many ? T[] : C extends Cardinality ? unknown : never;\nexport type computeTsType<T extends BaseType, C extends Cardinality> = BaseType extends T ? unknown : computeTsTypeCard<BaseTypeToTsType<T>, C>;\nexport type propToTsType<Prop extends PropertyDesc> = Prop extends PropertyDesc<infer Type, infer Card> ? setToTsType<TypeSet<Type, Card>> : never;\nexport type linkToTsType<Link extends LinkDesc> = computeTsType<Link[\"target\"], Link[\"cardinality\"]>;\nexport type pointerToTsType<El extends PropertyDesc | LinkDesc> = El extends PropertyDesc ? propToTsType<El> : El extends LinkDesc<any, any, any, any> ? linkToTsType<El> : never;\nexport type getPrimitiveBaseType<T extends BaseType> = T extends ScalarType ? ScalarType<T[\"__name__\"], T[\"__tstype__\"], T[\"__tsargtype__\"]> : T;\nexport type getPrimitiveNonArrayBaseType<T extends BaseType> = T extends ArrayType ? never : getPrimitiveBaseType<T>;\nexport declare function isScalarType(type: BaseType): type is ScalarType;\nexport declare function isEnumType(type: BaseType): type is EnumType;\nexport declare function isObjectType(type: BaseType): type is ObjectType;\nexport declare function isTupleType(type: BaseType): type is TupleType;\nexport declare function isNamedTupleType(type: BaseType): type is NamedTupleType;\nexport declare function isArrayType(type: BaseType): type is ArrayType;\nexport type NonArrayType = ScalarType | EnumType | ObjectType | TupleType | NamedTupleType | RangeType | MultiRangeType;\nexport type AnyTupleType = TupleType | NamedTupleType;\nexport type AnyObjectType = ObjectType;\nexport type ParamType = ScalarType | EnumType | ArrayType<ScalarType | TupleType<typeutil.tupleOf<ParamType>> | NamedTupleType<{\n    [k: string]: ParamType;\n}> | RangeType | MultiRangeType> | TupleType<typeutil.tupleOf<ParamType>> | NamedTupleType<{\n    [k: string]: ParamType;\n}> | RangeType | MultiRangeType;\nexport {};\n"},{"path":"update.d.ts","content":"import { ExpressionKind, type typeutil, Cardinality } from \"edgedb/dist/reflection/index\";\nimport type { Expression, ObjectTypePointers, TypeSet, ObjectTypeSet, stripBacklinks, stripNonUpdateables, ObjectTypeExpression, ObjectType, $scopify } from \"./typesystem\";\nimport type { pointerToAssignmentExpression } from \"./casting\";\nimport { type SelectModifiers, type NormalisedSelectModifiers, type ComputeSelectCardinality } from \"./select\";\nimport { type pointerIsOptional } from \"./insert\";\nexport type $expr_Update<El extends ObjectType = ObjectType, Card extends Cardinality = Cardinality> = Expression<{\n    __kind__: ExpressionKind.Update;\n    __element__: El;\n    __cardinality__: Card;\n    __expr__: TypeSet;\n    __shape__: any;\n    __modifiers__: NormalisedSelectModifiers;\n    __scope__: ObjectTypeExpression;\n}>;\nexport type UpdateShape<Root extends ObjectTypeSet> = typeutil.stripNever<stripNonUpdateables<stripBacklinks<Root[\"__element__\"][\"__pointers__\"]>>> extends infer Shape ? Shape extends ObjectTypePointers ? {\n    [k in keyof Shape]?: (pointerToAssignmentExpression<Shape[k]> | (Shape[k][\"cardinality\"] extends Cardinality.Many | Cardinality.AtLeastOne ? {\n        \"+=\": pointerToAssignmentExpression<Shape[k], true>;\n    } | {\n        \"-=\": pointerToAssignmentExpression<Shape[k], true>;\n    } : never)) | (pointerIsOptional<Shape[k]> extends true ? undefined | null : never);\n} : never : never;\nexport declare function update<Expr extends ObjectTypeExpression, Shape extends {\n    filter?: SelectModifiers[\"filter\"];\n    filter_single?: SelectModifiers<Expr[\"__element__\"]>[\"filter_single\"];\n    set: UpdateShape<Expr>;\n}>(expr: Expr, shape: (scope: $scopify<Expr[\"__element__\"]>) => Readonly<Shape>): $expr_Update<Expr[\"__element__\"], ComputeSelectCardinality<Expr, Shape>>;\n"},{"path":"with.d.ts","content":"import { ExpressionKind, Cardinality } from \"edgedb/dist/reflection/index\";\nimport type { BaseType, Expression, TypeSet } from \"./typesystem\";\nimport type { $expr_Select } from \"./select\";\nimport type { $expr_For } from \"./for\";\nimport type { $expr_Insert } from \"./insert\";\nimport type { $expr_Update } from \"./update\";\nimport type { $expr_Group } from \"./group\";\nexport type $expr_Alias<El extends BaseType = BaseType, Card extends Cardinality = Cardinality> = Expression<{\n    __element__: El;\n    __cardinality__: Card;\n    __kind__: ExpressionKind.Alias;\n    __expr__: TypeSet;\n}>;\nexport declare function alias<Expr extends Expression>(expr: Expr): $expr_Alias<Expr[\"__element__\"], Expr[\"__cardinality__\"]>;\nexport type WithableExpression = $expr_Select | $expr_For | $expr_Insert | $expr_Update | $expr_Group;\nexport type $expr_With<Expr extends WithableExpression = WithableExpression> = Expression<{\n    __element__: Expr[\"__element__\"];\n    __cardinality__: Expr[\"__cardinality__\"];\n    __kind__: ExpressionKind.With;\n    __expr__: Expr;\n    __refs__: TypeSet[];\n}>;\ndeclare function _with<Expr extends WithableExpression>(refs: Expression[], expr: Expr): $expr_With<Expr>;\nexport { _with as with };\n"},{"path":"__spec__.d.ts","content":"import type { TypeKind } from \"./reflection\";\nexport declare const spec: Map<string, any>;\nexport declare const complexParamKinds: Set<TypeKind>;\n"}],"mts":[{"path":"cardinality.mts","content":"import { Cardinality } from \"edgedb/dist/reflection/index.js\";\r\nimport type { TypeSet } from \"./typesystem.mjs\";\r\n\r\n// Computing cardinality of path\r\n// From base set cadinality and pointer cardinality\r\n// Used in path expressions\r\n// Cardinality  Empty  AtMostOne  One         Many  AtLeastOne\r\n// Empty        0      0          0           0     0\r\n// AtMostOne    0      AtMostOne  AtMostOne   Many  Many\r\n// One          0      AtMostOne  One         Many  AtLeastOne\r\n// Many         0      Many       Many        Many  Many\r\n// AtLeastOne   0      Many       AtLeastOne  Many  AtLeastOne\r\nexport namespace cardutil {\r\n  export type multiplyCardinalities<\r\n    C1 extends Cardinality,\r\n    C2 extends Cardinality\r\n  > = C1 extends Cardinality.Empty\r\n    ? Cardinality.Empty\r\n    : C1 extends Cardinality.One\r\n    ? C2\r\n    : C1 extends Cardinality.AtMostOne\r\n    ? C2 extends Cardinality.One\r\n      ? Cardinality.AtMostOne\r\n      : C2 extends Cardinality.AtLeastOne\r\n      ? Cardinality.Many\r\n      : C2\r\n    : C1 extends Cardinality.Many\r\n    ? C2 extends Cardinality.Empty\r\n      ? Cardinality.Empty\r\n      : Cardinality.Many\r\n    : C1 extends Cardinality.AtLeastOne\r\n    ? C2 extends Cardinality.AtMostOne\r\n      ? Cardinality.Many\r\n      : C2 extends Cardinality.One\r\n      ? Cardinality.AtLeastOne\r\n      : C2\r\n    : never;\r\n\r\n  export function multiplyCardinalities(\r\n    c1: Cardinality,\r\n    c2: Cardinality\r\n  ): Cardinality {\r\n    if (c1 === Cardinality.Empty) return Cardinality.Empty;\r\n\r\n    if (c1 === Cardinality.One) return c2;\r\n    if (c1 === Cardinality.AtMostOne) {\r\n      if (c2 === Cardinality.One) return Cardinality.AtMostOne;\r\n      if (c2 === Cardinality.AtLeastOne) return Cardinality.Many;\r\n      return c2;\r\n    }\r\n    if (c1 === Cardinality.Many) {\r\n      if (c2 === Cardinality.Empty) return Cardinality.Empty;\r\n      return Cardinality.Many;\r\n    }\r\n    if (c1 === Cardinality.AtLeastOne) {\r\n      if (c2 === Cardinality.AtMostOne) return Cardinality.Many;\r\n      if (c2 === Cardinality.One) return Cardinality.AtLeastOne;\r\n      return c2;\r\n    }\r\n    throw new Error(`Invalid Cardinality ${c1}`);\r\n  }\r\n\r\n  type _multiplyCardinalitiesVariadic<\r\n    Cards extends [Cardinality, ...Cardinality[]]\r\n  > = Cards extends [infer Card]\r\n    ? Card\r\n    : Cards extends [infer A, infer B, ...infer Rest]\r\n    ? A extends Cardinality\r\n      ? B extends Cardinality\r\n        ? Rest extends Cardinality[]\r\n          ? multiplyCardinalities<A, B> extends Cardinality\r\n            ? _multiplyCardinalitiesVariadic<\r\n                [multiplyCardinalities<A, B>, ...Rest]\r\n              >\r\n            : never\r\n          : never\r\n        : never\r\n      : never\r\n    : never;\r\n\r\n  export type multiplyCardinalitiesVariadic<\r\n    Cards extends [Cardinality, ...Cardinality[]]\r\n  > = _multiplyCardinalitiesVariadic<Cards> extends Cardinality\r\n    ? _multiplyCardinalitiesVariadic<Cards>\r\n    : never;\r\n\r\n  export function multiplyCardinalitiesVariadic<\r\n    Cards extends [Cardinality, ...Cardinality[]]\r\n  >(cards: Cards): multiplyCardinalitiesVariadic<Cards> {\r\n    if (cards.length === 0) throw new Error(\"Empty tuple not allowed\");\r\n    if (cards.length === 1) return cards[0] as any;\r\n    return cards.reduce(\r\n      (product, card) => multiplyCardinalities(product, card),\r\n      Cardinality.One\r\n    ) as any;\r\n  }\r\n\r\n  // Merging two sets\r\n  // Used in set constructor\r\n  // Cardinality  Empty       AtMostOne  One         Many        AtLeastOne\r\n  // Empty        Empty       AtMostOne  One         Many        AtLeastOne\r\n  // AtMostOne    AtMostOne   Many       AtLeastOne  Many        AtLeastOne\r\n  // One          One         AtLeastOne AtLeastOne  AtLeastOne  AtLeastOne\r\n  // Many         Many        Many       AtLeastOne  Many        AtLeastOne\r\n  // AtLeastOne   AtLeastOne  AtLeastOne AtLeastOne  AtLeastOne  AtLeastOne\r\n\r\n  export type mergeCardinalities<\r\n    A extends Cardinality,\r\n    B extends Cardinality\r\n  > = A extends Cardinality.Empty\r\n    ? B\r\n    : B extends Cardinality.Empty\r\n    ? A\r\n    : A extends Cardinality.AtLeastOne\r\n    ? Cardinality.AtLeastOne\r\n    : B extends Cardinality.AtLeastOne\r\n    ? Cardinality.AtLeastOne\r\n    : A extends Cardinality.One\r\n    ? Cardinality.AtLeastOne\r\n    : B extends Cardinality.One\r\n    ? Cardinality.AtLeastOne\r\n    : Cardinality.Many;\r\n\r\n  export function mergeCardinalities<\r\n    A extends Cardinality,\r\n    B extends Cardinality\r\n  >(a: A, b: B): mergeCardinalities<A, B> {\r\n    if (a === Cardinality.Empty) return b as any;\r\n    if (b === Cardinality.Empty) return a as any;\r\n    if (a === Cardinality.AtLeastOne) return Cardinality.AtLeastOne as any;\r\n    if (b === Cardinality.AtLeastOne) return Cardinality.AtLeastOne as any;\r\n    if (a === Cardinality.One) return Cardinality.AtLeastOne as any;\r\n    if (b === Cardinality.One) return Cardinality.AtLeastOne as any;\r\n    return Cardinality.Many as any;\r\n  }\r\n\r\n  type _mergeCardinalitiesVariadic<\r\n    Cards extends [Cardinality, ...Cardinality[]]\r\n  > = Cards extends [infer Card]\r\n    ? Card\r\n    : Cards extends [infer A, infer B, ...infer Rest]\r\n    ? A extends Cardinality\r\n      ? B extends Cardinality\r\n        ? Rest extends Cardinality[]\r\n          ? mergeCardinalities<A, B> extends Cardinality\r\n            ? _mergeCardinalitiesVariadic<[mergeCardinalities<A, B>, ...Rest]>\r\n            : never\r\n          : never\r\n        : never\r\n      : never\r\n    : never;\r\n\r\n  export type mergeCardinalitiesVariadic<\r\n    Cards extends [Cardinality, ...Cardinality[]]\r\n  > = _mergeCardinalitiesVariadic<Cards> extends Cardinality\r\n    ? _mergeCardinalitiesVariadic<Cards>\r\n    : never;\r\n  export function mergeCardinalitiesVariadic<\r\n    Cards extends [Cardinality, ...Cardinality[]]\r\n  >(cards: Cards): mergeCardinalitiesVariadic<Cards> {\r\n    if (cards.length === 0) throw new Error(\"Empty tuple not allowed\");\r\n    if (cards.length === 1) return cards[0] as any;\r\n    const [first, second, ...rest] = cards as unknown as [\r\n      Cardinality,\r\n      Cardinality,\r\n      ...Cardinality[]\r\n    ];\r\n    if (cards.length === 2) return mergeCardinalities(first, second) as any;\r\n    return mergeCardinalitiesVariadic([\r\n      mergeCardinalities(first, second),\r\n      ...rest,\r\n    ]);\r\n  }\r\n\r\n  // 'or' cardinalities together\r\n  // used in the IF ELSE operator, for expr (a IF bool ELSE b)\r\n  // result cardinality is 'a' cardinality *or* 'b' cardinality\r\n  // Cardinality  Empty       AtMostOne   One         Many        AtLeastOne\r\n  // Empty        0           AtMostOne   AtMostOne   Many        Many\r\n  // AtMostOne    AtMostOne   AtMostOne   AtMostOne   Many        Many\r\n  // One          AtMostOne   AtMostOne   One         Many        AtLeastOne\r\n  // Many         Many        Many        Many        Many        Many\r\n  // AtLeastOne   Many        Many        AtLeastOne  Many        AtLeastOne\r\n\r\n  export type orCardinalities<\r\n    C1 extends Cardinality,\r\n    C2 extends Cardinality\r\n  > = C1 extends C2\r\n    ? C1\r\n    : C1 extends Cardinality.Many\r\n    ? C1\r\n    : C1 extends Cardinality.AtMostOne\r\n    ? C2 extends Cardinality.Many\r\n      ? C2\r\n      : C2 extends Cardinality.AtLeastOne\r\n      ? Cardinality.Many\r\n      : C1\r\n    : C1 extends Cardinality.AtLeastOne\r\n    ? C2 extends Cardinality.One\r\n      ? Cardinality.AtLeastOne\r\n      : Cardinality.Many\r\n    : C1 extends Cardinality.Empty\r\n    ? C2 extends Cardinality.AtMostOne\r\n      ? Cardinality.AtMostOne\r\n      : C2 extends Cardinality.One\r\n      ? Cardinality.AtMostOne\r\n      : Cardinality.Many\r\n    : C2 extends Cardinality.Empty\r\n    ? Cardinality.AtMostOne\r\n    : C2;\r\n\r\n  export function orCardinalities(\r\n    c1: Cardinality,\r\n    c2: Cardinality\r\n  ): Cardinality {\r\n    if (c1 === c2 || c1 === Cardinality.Many) return c1;\r\n    if (c1 === Cardinality.AtLeastOne) {\r\n      if (c2 === Cardinality.One) return Cardinality.AtLeastOne;\r\n      return Cardinality.Many;\r\n    }\r\n    if (c1 === Cardinality.AtMostOne) {\r\n      if (c2 === Cardinality.Many || c2 === Cardinality.AtLeastOne) {\r\n        return Cardinality.Many;\r\n      }\r\n      return c1;\r\n    }\r\n    if (c1 === Cardinality.Empty) {\r\n      if (c2 === Cardinality.AtMostOne || c2 === Cardinality.One) {\r\n        return Cardinality.AtMostOne;\r\n      }\r\n      return Cardinality.Many;\r\n    }\r\n    if (c2 === Cardinality.Empty) return Cardinality.AtMostOne;\r\n    return c2;\r\n  }\r\n\r\n  //          Empty  AtMostOne  One         Many        AtLeastOne\r\n  // One      One    One        One         AtLeastOne  AtLeastOne\r\n  // Zero     0      AtMostOne  AtMostOne   Many        Many\r\n\r\n  export type overrideLowerBound<\r\n    C extends Cardinality,\r\n    O extends \"One\" | \"Zero\"\r\n  > = O extends \"One\"\r\n    ? C extends Cardinality.Many\r\n      ? Cardinality.AtLeastOne\r\n      : C extends Cardinality.AtLeastOne\r\n      ? Cardinality.AtLeastOne\r\n      : Cardinality.One\r\n    : C extends Cardinality.Empty\r\n    ? Cardinality.Empty\r\n    : C extends Cardinality.Many\r\n    ? Cardinality.Many\r\n    : C extends Cardinality.AtLeastOne\r\n    ? Cardinality.Many\r\n    : Cardinality.AtMostOne;\r\n\r\n  export function overrideLowerBound<\r\n    C extends Cardinality,\r\n    O extends \"One\" | \"Zero\"\r\n  >(card: C, override: O): overrideLowerBound<C, O> {\r\n    if (override === \"One\") {\r\n      if (card === Cardinality.Many || card === Cardinality.AtLeastOne) {\r\n        return Cardinality.AtLeastOne as any;\r\n      } else {\r\n        return Cardinality.One as any;\r\n      }\r\n    } else {\r\n      if (card === Cardinality.Many || card === Cardinality.AtLeastOne) {\r\n        return Cardinality.Many as any;\r\n      } else if (card === Cardinality.Empty) {\r\n        return Cardinality.Empty as any;\r\n      } else {\r\n        return Cardinality.AtMostOne as any;\r\n      }\r\n    }\r\n  }\r\n\r\n  //          Empty      AtMostOne  One         Many        AtLeastOne\r\n  // One      AtMostOne  AtMostOne  One         AtMostOne   One\r\n  // Many     Many       Many       AtLeastOne  Many        AtLeastOne\r\n\r\n  export type overrideUpperBound<\r\n    C extends Cardinality,\r\n    O extends \"One\" | \"Many\"\r\n  > = O extends \"One\"\r\n    ? C extends Cardinality.Many\r\n      ? Cardinality.AtMostOne\r\n      : C extends Cardinality.AtLeastOne\r\n      ? Cardinality.One\r\n      : C extends Cardinality.Empty\r\n      ? Cardinality.AtMostOne\r\n      : C\r\n    : C extends Cardinality.One\r\n    ? Cardinality.AtLeastOne\r\n    : C extends Cardinality.AtMostOne\r\n    ? Cardinality.Many\r\n    : C extends Cardinality.Empty\r\n    ? Cardinality.Many\r\n    : C;\r\n\r\n  export function overrideUpperBound<\r\n    C extends Cardinality,\r\n    O extends \"One\" | \"Many\"\r\n  >(card: C, override: O): overrideUpperBound<C, O> {\r\n    if (override === \"One\") {\r\n      if (card === Cardinality.One || card === Cardinality.AtLeastOne) {\r\n        return Cardinality.One as any;\r\n      } else {\r\n        return Cardinality.AtMostOne as any;\r\n      }\r\n    } else {\r\n      if (card === Cardinality.One || card === Cardinality.AtLeastOne) {\r\n        return Cardinality.AtLeastOne as any;\r\n      } else {\r\n        return Cardinality.Many as any;\r\n      }\r\n    }\r\n  }\r\n\r\n  export type paramCardinality<P> = [P] extends [TypeSet]\r\n    ? // default to one\r\n      // fixes multiplyCardinalities bug for func with optional args\r\n      [Cardinality] extends [P[\"__cardinality__\"]]\r\n      ? Cardinality.One\r\n      : P[\"__cardinality__\"]\r\n    : Cardinality.One;\r\n\r\n  export type optionalParamCardinality<P> = overrideLowerBound<\r\n    paramCardinality<P>,\r\n    \"One\"\r\n  >;\r\n\r\n  type _paramArrayCardinality<T> = {\r\n    [K in keyof T]: T[K] extends TypeSet\r\n      ? T[K][\"__cardinality__\"]\r\n      : Cardinality.One;\r\n  };\r\n\r\n  export type paramArrayCardinality<T extends [any, ...any[]]> =\r\n    multiplyCardinalitiesVariadic<_paramArrayCardinality<T>>;\r\n\r\n  export type assignable<C extends Cardinality> = C extends Cardinality.Empty\r\n    ? Cardinality.Empty\r\n    : C extends Cardinality.One\r\n    ? Cardinality.One\r\n    : C extends Cardinality.AtMostOne\r\n    ? Cardinality.One | Cardinality.AtMostOne | Cardinality.Empty\r\n    : C extends Cardinality.AtLeastOne\r\n    ? Cardinality.One | Cardinality.AtLeastOne | Cardinality.Many\r\n    : C extends Cardinality.Many\r\n    ? Cardinality\r\n    : never;\r\n}\r\n"},{"path":"cast.mts","content":"import { ExpressionKind, Cardinality } from \"edgedb/dist/reflection/index.js\";\r\nimport type {\r\n  Expression,\r\n  BaseType,\r\n  TypeSet,\r\n  ObjectTypeExpression,\r\n} from \"./typesystem.mjs\";\r\nimport { $expressionify } from \"./path.mjs\";\r\nimport type { orScalarLiteral } from \"./castMaps.mjs\";\r\nimport { literalToTypeSet } from \"./castMaps.mjs\";\r\n\r\nexport function cast<Target extends BaseType | ObjectTypeExpression>(\r\n  target: Target,\r\n  arg: null\r\n): $expr_Cast<\r\n  Target extends BaseType\r\n    ? Target\r\n    : Target extends ObjectTypeExpression\r\n    ? Target[\"__element__\"]\r\n    : never,\r\n  Cardinality.Empty\r\n>;\r\nexport function cast<Target extends BaseType, Expr extends TypeSet>(\r\n  target: Target,\r\n  expr: orScalarLiteral<Expr>\r\n): $expr_Cast<\r\n  Target,\r\n  Cardinality extends Expr[\"__cardinality__\"]\r\n    ? Cardinality.One\r\n    : Expr[\"__cardinality__\"]\r\n>;\r\nexport function cast(target: BaseType, expr: any) {\r\n  const cleanedExpr = expr === null ? null : literalToTypeSet(expr);\r\n  return $expressionify({\r\n    __element__: (target as any).__cardinality__\r\n      ? (target as any).__element__\r\n      : target,\r\n    __cardinality__:\r\n      cleanedExpr === null ? Cardinality.Empty : cleanedExpr.__cardinality__,\r\n    __expr__: cleanedExpr,\r\n    __kind__: ExpressionKind.Cast,\r\n  }) as any;\r\n}\r\n\r\nexport type $expr_Cast<\r\n  Target extends BaseType = BaseType,\r\n  Card extends Cardinality = Cardinality\r\n> = Expression<{\r\n  __element__: Target;\r\n  __cardinality__: Card;\r\n  __kind__: ExpressionKind.Cast;\r\n  __expr__: TypeSet | null;\r\n}>;\r\n"},{"path":"casting.mts","content":"import type { Cardinality } from \"edgedb/dist/reflection/index.js\";\r\nimport type {\r\n  ArrayType,\r\n  BaseType,\r\n  BaseTypeTuple,\r\n  BaseTypeToTsType,\r\n  EnumType,\r\n  LinkDesc,\r\n  NamedTupleType,\r\n  ObjectType,\r\n  ObjectTypeSet,\r\n  PrimitiveTypeSet,\r\n  PropertyDesc,\r\n  ScalarType,\r\n  TupleType,\r\n  TypeSet,\r\n  RangeType,\r\n  MultiRangeType,\r\n} from \"./typesystem.mjs\";\r\nimport type { cardutil } from \"./cardinality.mjs\";\r\n\r\nimport type { scalarCastableFrom, scalarAssignableBy } from \"./castMaps.mjs\";\r\n\r\nexport type anonymizeObject<T extends ObjectType> = ObjectType<\r\n  string,\r\n  T[\"__pointers__\"],\r\n  any\r\n>;\r\n\r\n////////////////\r\n// ASSIGNABLE\r\n////////////////\r\n\r\ntype assignableTuple<Items extends BaseTypeTuple> = {\r\n  [k in keyof Items]: Items[k] extends BaseType\r\n    ? assignableBy<Items[k]>\r\n    : never;\r\n} extends infer NewItems\r\n  ? NewItems extends BaseTypeTuple\r\n    ? NewItems\r\n    : never\r\n  : never;\r\n\r\nexport type assignableBy<T extends BaseType> = T extends ScalarType\r\n  ? scalarAssignableBy<T>\r\n  : T extends ObjectType\r\n  ? anonymizeObject<T>\r\n  : T extends EnumType\r\n  ? T\r\n  : T extends ArrayType\r\n  ? ArrayType<assignableBy<T[\"__element__\"]>>\r\n  : T extends TupleType\r\n  ? TupleType<assignableTuple<T[\"__items__\"]>>\r\n  : T extends NamedTupleType\r\n  ? NamedTupleType<{\r\n      [k in keyof T[\"__shape__\"]]: assignableBy<T[\"__shape__\"][k]>;\r\n    }>\r\n  : T extends RangeType\r\n  ? RangeType<\r\n      scalarAssignableBy<T[\"__element__\"]> extends ScalarType\r\n        ? scalarAssignableBy<T[\"__element__\"]>\r\n        : never\r\n    >\r\n  : T extends MultiRangeType\r\n  ? MultiRangeType<\r\n      scalarAssignableBy<T[\"__element__\"]> extends ScalarType\r\n        ? scalarAssignableBy<T[\"__element__\"]>\r\n        : never\r\n    >\r\n  : never;\r\n\r\nexport type pointerToAssignmentExpression<\r\n  Pointer extends PropertyDesc | LinkDesc,\r\n  IsSetModifier extends boolean = false\r\n> = setToAssignmentExpression<\r\n  TypeSet<Pointer[\"target\"], Pointer[\"cardinality\"]>,\r\n  IsSetModifier\r\n>;\r\n\r\nexport type setToAssignmentExpression<\r\n  Set extends TypeSet,\r\n  IsSetModifier extends boolean\r\n> = [Set] extends [PrimitiveTypeSet]\r\n  ?\r\n      | TypeSet<\r\n          assignableBy<Set[\"__element__\"]>,\r\n          cardutil.assignable<\r\n            // Set[\"__cardinality__\"]\r\n            cardutil.overrideLowerBound<Set[\"__cardinality__\"], \"Zero\">\r\n          >\r\n        >\r\n      | getAssignmentLiteral<Set, IsSetModifier>\r\n  : [Set] extends [ObjectTypeSet]\r\n  ? TypeSet<\r\n      ObjectType<\r\n        // anonymize the object type\r\n        string,\r\n        Set[\"__element__\"][\"__pointers__\"]\r\n      >,\r\n      cardutil.assignable<\r\n        // Allow expressions with AtMostOne or Many cardinality in\r\n        // insert/update shape even when link is required since EdgeDB will\r\n        // assert cardinality at runtime\r\n        cardutil.overrideLowerBound<Set[\"__cardinality__\"], \"Zero\">\r\n      >\r\n    >\r\n  : never;\r\n\r\ntype getAssignmentLiteral<\r\n  Set extends PrimitiveTypeSet,\r\n  IsSetModifier extends boolean\r\n> = BaseTypeToTsType<Set[\"__element__\"]> extends infer TsType\r\n  ?\r\n      | TsType\r\n      | (Set[\"__cardinality__\"] extends Cardinality.Many\r\n          ? TsType[]\r\n          : Set[\"__cardinality__\"] extends Cardinality.AtLeastOne\r\n          ? IsSetModifier extends true\r\n            ? TsType[]\r\n            : [TsType, ...TsType[]]\r\n          : never)\r\n  : never;\r\n\r\n////////////////\r\n// CASTABLES\r\n////////////////\r\n\r\ntype castableTuple<Items extends BaseTypeTuple> = {\r\n  [k in keyof Items]: Items[k] extends BaseType\r\n    ? castableFrom<Items[k]>\r\n    : never;\r\n} extends infer NewItems\r\n  ? NewItems extends BaseTypeTuple\r\n    ? NewItems\r\n    : never\r\n  : never;\r\n\r\nexport type castableFrom<T extends BaseType> = T extends ScalarType\r\n  ? scalarCastableFrom<T>\r\n  : T extends ObjectType\r\n  ? anonymizeObject<T>\r\n  : T extends ArrayType\r\n  ? ArrayType<castableFrom<T[\"__element__\"]>>\r\n  : T extends TupleType\r\n  ? TupleType<castableTuple<T[\"__items__\"]>>\r\n  : T extends NamedTupleType\r\n  ? NamedTupleType<{\r\n      [k in keyof T[\"__shape__\"]]: castableFrom<T[\"__shape__\"][k]>;\r\n    }>\r\n  : never;\r\n\r\nexport type pointerToCastableExpression<\r\n  Pointer extends PropertyDesc | LinkDesc\r\n> = [Pointer] extends [PropertyDesc]\r\n  ? {\r\n      __element__: castableFrom<Pointer[\"target\"]>;\r\n      __cardinality__: cardutil.assignable<Pointer[\"cardinality\"]>;\r\n    }\r\n  : [Pointer] extends [LinkDesc]\r\n  ? TypeSet<\r\n      ObjectType<\r\n        // anonymize the object type\r\n        string,\r\n        Pointer[\"target\"][\"__pointers__\"]\r\n      >,\r\n      cardutil.assignable<Pointer[\"cardinality\"]>\r\n    >\r\n  : never;\r\n"},{"path":"castMaps.mts","content":"export type scalarCastableFrom<T extends any> = any;\r\nexport type scalarAssignableBy<T extends any> = any;\r\nexport type orScalarLiteral<T extends any> = any;\r\nexport type scalarLiterals = any;\r\nexport type literalToScalarType<T extends any> = any;\r\ntype literalToTypeSet<T extends any> = any;\r\nexport type mapLiteralToTypeSet<T> = {\r\n  [k in keyof T]: literalToTypeSet<T[k]>;\r\n};\r\ndeclare function literalToTypeSet(t: any): any;\r\nexport { literalToTypeSet };\r\nexport declare function isImplicitlyCastableTo(\r\n  from: string,\r\n  to: string\r\n): boolean;\r\nexport function getSharedParentScalar(a: any, b: any): any {}\r\nexport type getSharedParentScalar<A, B> = any;\r\n"},{"path":"collections.mts","content":"import {\r\n  Cardinality,\r\n  ExpressionKind,\r\n  TypeKind,\r\n  type typeutil,\r\n} from \"edgedb/dist/reflection/index.js\";\r\nimport { cardutil } from \"./cardinality.mjs\";\r\nimport type {\r\n  $expr_Array,\r\n  $expr_NamedTuple,\r\n  $expr_Tuple,\r\n  $expr_TuplePath,\r\n  ArrayType,\r\n  BaseType,\r\n  getPrimitiveBaseType,\r\n  NamedTupleLiteralShape,\r\n  NamedTupleShape,\r\n  NamedTupleType,\r\n  NonArrayType,\r\n  ObjectTypeExpression,\r\n  ObjectTypePointers,\r\n  PropertyDesc,\r\n  TupleType,\r\n  TypeSet,\r\n} from \"./typesystem.mjs\";\r\n\r\nimport { $expressionify, type ExpressionRoot } from \"./path.mjs\";\r\nimport type { getCardsFromExprs } from \"./set.mjs\";\r\nimport {\r\n  type literalToScalarType,\r\n  literalToTypeSet,\r\n  type mapLiteralToTypeSet,\r\n  type orScalarLiteral,\r\n  type scalarLiterals,\r\n} from \"./castMaps.mjs\";\r\n\r\nconst indexSliceRegx = /^(-?\\d+)(?:(:)(-?\\d+)?)?|:(-?\\d+)$/;\r\n\r\nconst arrayLikeProxyHandlers: ProxyHandler<ExpressionRoot> = {\r\n  get(target: ExpressionRoot, prop: string | symbol, proxy: any) {\r\n    const match = typeof prop === \"string\" ? prop.match(indexSliceRegx) : null;\r\n    if (match) {\r\n      const start = match[1];\r\n      const end = match[3] ?? match[4];\r\n      const isIndex = start && !match[2];\r\n      return $expressionify({\r\n        __kind__: ExpressionKind.Operator,\r\n        __element__:\r\n          target.__element__.__kind__ === TypeKind.array && isIndex\r\n            ? (target.__element__ as ArrayType).__element__\r\n            : target.__element__,\r\n        __cardinality__: target.__cardinality__,\r\n        __name__: \"[]\",\r\n        __opkind__: \"Infix\",\r\n        __args__: [\r\n          proxy,\r\n          isIndex\r\n            ? literalToTypeSet(Number(start))\r\n            : [\r\n                start && literalToTypeSet(Number(start)),\r\n                end && literalToTypeSet(Number(end)),\r\n              ],\r\n        ],\r\n      }) as any;\r\n    }\r\n    return (target as any)[prop];\r\n  },\r\n};\r\n\r\nfunction arrayLikeIndex(this: ExpressionRoot, index: any) {\r\n  const indexTypeSet = literalToTypeSet(index);\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.Operator,\r\n    __element__:\r\n      this.__element__.__kind__ === TypeKind.array\r\n        ? (this.__element__ as ArrayType).__element__\r\n        : this.__element__,\r\n    __cardinality__: cardutil.multiplyCardinalities(\r\n      this.__cardinality__,\r\n      indexTypeSet.__cardinality__\r\n    ),\r\n    __name__: \"[]\",\r\n    __opkind__: \"Infix\",\r\n    __args__: [this, indexTypeSet],\r\n  }) as any;\r\n}\r\n\r\nfunction arrayLikeSlice(this: ExpressionRoot, start: any, end: any) {\r\n  const startTypeSet = start && literalToTypeSet(start);\r\n  const endTypeSet = end && literalToTypeSet(end);\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.Operator,\r\n    __element__: this.__element__,\r\n    __cardinality__: cardutil.multiplyCardinalities(\r\n      cardutil.multiplyCardinalities(\r\n        this.__cardinality__,\r\n        startTypeSet?.__cardinality__ ?? Cardinality.One\r\n      ),\r\n      endTypeSet?.__cardinality__ ?? Cardinality.One\r\n    ),\r\n    __name__: \"[]\",\r\n    __opkind__: \"Infix\",\r\n    __args__: [this, [startTypeSet, endTypeSet]],\r\n  }) as any;\r\n}\r\n\r\nexport function $arrayLikeIndexify(_expr: ExpressionRoot) {\r\n  if (\r\n    _expr.__element__.__kind__ === TypeKind.array ||\r\n    (_expr.__element__.__kind__ === TypeKind.scalar &&\r\n      (_expr.__element__.__name__ === \"std::str\" ||\r\n        _expr.__element__.__name__ === \"std::bytes\"))\r\n  ) {\r\n    const expr = new Proxy(_expr, arrayLikeProxyHandlers) as any;\r\n\r\n    expr.index = arrayLikeIndex.bind(expr);\r\n    expr.slice = arrayLikeSlice.bind(expr);\r\n\r\n    return expr;\r\n  }\r\n\r\n  return _expr;\r\n}\r\n\r\n// ARRAY\r\nexport function array<Element extends NonArrayType>(\r\n  element: Element\r\n): ArrayType<Element>;\r\nexport function array<\r\n  Expr extends TypeSet<NonArrayType> | scalarLiterals,\r\n  Exprs extends orScalarLiteral<\r\n    TypeSet<\r\n      Expr extends TypeSet\r\n        ? getPrimitiveBaseType<Expr[\"__element__\"]>\r\n        : getPrimitiveBaseType<literalToScalarType<Expr>>\r\n    >\r\n  >[]\r\n>(\r\n  arg: [Expr, ...Exprs]\r\n): $expr_Array<\r\n  ArrayType<\r\n    Expr extends TypeSet\r\n      ? getPrimitiveBaseType<Expr[\"__element__\"]>\r\n      : getPrimitiveBaseType<literalToScalarType<Expr>>\r\n  >,\r\n  cardutil.multiplyCardinalitiesVariadic<\r\n    getCardsFromExprs<mapLiteralToTypeSet<[Expr, ...Exprs]>>\r\n  >\r\n>;\r\nexport function array(arg: any) {\r\n  if (Array.isArray(arg)) {\r\n    const items = arg.map((a) => literalToTypeSet(a));\r\n    return $expressionify({\r\n      __kind__: ExpressionKind.Array,\r\n      __cardinality__: cardutil.multiplyCardinalitiesVariadic(\r\n        items.map((item) => item.__cardinality__) as any\r\n      ),\r\n      __element__: {\r\n        __kind__: TypeKind.array,\r\n        __name__: `array<${items[0]!.__element__.__name__}>`,\r\n        __element__: items[0]!.__element__,\r\n      } as any,\r\n      __items__: items,\r\n    });\r\n  }\r\n  if (arg.__kind__) {\r\n    return {\r\n      __kind__: TypeKind.array,\r\n      __name__: `array<${arg.__name__}>`,\r\n      __element__: arg,\r\n    } as any;\r\n  }\r\n\r\n  throw new Error(\"Invalid array input.\");\r\n}\r\n\r\n// TUPLE\r\n\r\nconst tupleProxyHandlers: ProxyHandler<ExpressionRoot> = {\r\n  get(target: ExpressionRoot, prop: string | symbol, proxy: any) {\r\n    const type = target.__element__;\r\n    const items =\r\n      type.__kind__ === TypeKind.tuple\r\n        ? (type as TupleType).__items__\r\n        : type.__kind__ === TypeKind.namedtuple\r\n        ? (type as NamedTupleType).__shape__\r\n        : null;\r\n    return items?.hasOwnProperty(prop)\r\n      ? tuplePath(proxy, (items as any)[prop], prop as any)\r\n      : (target as any)[prop];\r\n  },\r\n};\r\n\r\nexport function $tuplePathify(expr: ExpressionRoot) {\r\n  if (\r\n    expr.__element__.__kind__ !== TypeKind.tuple &&\r\n    expr.__element__.__kind__ !== TypeKind.namedtuple\r\n  ) {\r\n    return expr;\r\n  }\r\n\r\n  return new Proxy(expr, tupleProxyHandlers);\r\n}\r\n\r\nfunction tuplePath(\r\n  parent: $expr_Tuple | $expr_TuplePath,\r\n  itemType: BaseType,\r\n  index: string\r\n): $expr_TuplePath {\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.TuplePath,\r\n    __element__: itemType,\r\n    __cardinality__: parent.__cardinality__,\r\n    __parent__: parent,\r\n    __index__: index,\r\n  }) as any;\r\n}\r\n\r\nfunction makeTupleType(name: string, items: BaseType[]) {\r\n  return {\r\n    __kind__: TypeKind.tuple,\r\n    __name__: name,\r\n    __items__: items,\r\n  } as any;\r\n}\r\n\r\nconst typeKinds = new Set(Object.values(TypeKind));\r\n\r\nexport function tuple<Items extends typeutil.tupleOf<BaseType>>(\r\n  items: Items\r\n): TupleType<Items>;\r\nexport function tuple<\r\n  Item extends TypeSet | scalarLiterals,\r\n  Items extends typeutil.tupleOf<TypeSet | scalarLiterals>\r\n>(\r\n  items: Items\r\n): $expr_Tuple<\r\n  Items extends typeutil.tupleOf<any> ? mapLiteralToTypeSet<Items> : never\r\n>;\r\nexport function tuple<Shape extends NamedTupleShape>(\r\n  shape: Shape\r\n): NamedTupleType<Shape>;\r\nexport function tuple<Shape extends { [k: string]: TypeSet | scalarLiterals }>(\r\n  shape: Shape\r\n): $expr_NamedTuple<mapLiteralToTypeSet<Shape>>;\r\nexport function tuple(input: any) {\r\n  if (Array.isArray(input)) {\r\n    // is tuple\r\n    if (input.every((item) => typeKinds.has(item.__kind__))) {\r\n      const typeItems = input as BaseType[];\r\n      const typeName = `tuple<${typeItems\r\n        .map((item) => item.__name__)\r\n        .join(\", \")}>`;\r\n      return makeTupleType(typeName, typeItems);\r\n    }\r\n\r\n    const items = input.map((item) => literalToTypeSet(item));\r\n    const name = `tuple<${items\r\n      .map((item) => item.__element__.__name__)\r\n      .join(\", \")}>`;\r\n    return $expressionify({\r\n      __kind__: ExpressionKind.Tuple,\r\n      __element__: makeTupleType(\r\n        name,\r\n        items.map((item) => item.__element__)\r\n      ),\r\n      __cardinality__: cardutil.multiplyCardinalitiesVariadic(\r\n        items.map((i) => i.__cardinality__) as any\r\n      ),\r\n      __items__: items,\r\n    }) as any;\r\n  } else {\r\n    // is named tuple\r\n    if (Object.values(input).every((el: any) => typeKinds.has(el.__kind__))) {\r\n      const typeName = `tuple<${Object.entries(input)\r\n        .map(([key, val]: [string, any]) => `${key}: ${val.__name__}`)\r\n        .join(\", \")}>`;\r\n      return {\r\n        __kind__: TypeKind.namedtuple,\r\n        __name__: typeName,\r\n        __shape__: input,\r\n      } as any;\r\n    }\r\n\r\n    const exprShape: NamedTupleLiteralShape = {};\r\n    const typeShape: NamedTupleShape = {};\r\n    for (const [key, val] of Object.entries(input)) {\r\n      const typeSet = literalToTypeSet(val);\r\n      exprShape[key] = typeSet;\r\n      typeShape[key] = typeSet.__element__;\r\n    }\r\n    const name = `tuple<${Object.entries(exprShape)\r\n      .map(([key, val]) => `${key}: ${val.__element__.__name__}`)\r\n      .join(\", \")}>`;\r\n    return $expressionify({\r\n      __kind__: ExpressionKind.NamedTuple,\r\n      __element__: {\r\n        __kind__: TypeKind.namedtuple,\r\n        __name__: name,\r\n        __shape__: typeShape,\r\n      } as any,\r\n      __cardinality__: cardutil.multiplyCardinalitiesVariadic(\r\n        Object.values(exprShape).map((val) => val.__cardinality__) as any\r\n      ),\r\n      __shape__: exprShape,\r\n    }) as any;\r\n  }\r\n}\r\n\r\ntype PropertyNamesFromPointers<Pointers extends ObjectTypePointers> = {\r\n  [k in keyof Pointers as Pointers[k] extends PropertyDesc\r\n    ? Pointers[k][\"computed\"] extends true\r\n      ? never\r\n      : k\r\n    : never]: Pointers[k];\r\n};\r\n\r\nexport function $objectTypeToTupleType<Expr extends ObjectTypeExpression>(\r\n  objectType: Expr\r\n): PropertyNamesFromPointers<\r\n  Expr[\"__element__\"][\"__pointers__\"]\r\n> extends infer Pointers\r\n  ? Pointers extends ObjectTypePointers\r\n    ? NamedTupleType<{\r\n        [k in keyof Pointers as k extends \"id\"\r\n          ? never\r\n          : k]: Pointers[k][\"target\"];\r\n      }>\r\n    : never\r\n  : never;\r\nexport function $objectTypeToTupleType<\r\n  Expr extends ObjectTypeExpression,\r\n  Fields extends keyof PropertyNamesFromPointers<\r\n    Expr[\"__element__\"][\"__pointers__\"]\r\n  >\r\n>(\r\n  objectType: Expr,\r\n  includeFields: Fields[]\r\n): NamedTupleType<{\r\n  [k in Fields]: Expr[\"__element__\"][\"__pointers__\"][k] extends PropertyDesc\r\n    ? Expr[\"__element__\"][\"__pointers__\"][k][\"target\"]\r\n    : never;\r\n}>;\r\nexport function $objectTypeToTupleType(...args: any[]): any {\r\n  const [objExpr, fields] = args as [\r\n    ObjectTypeExpression,\r\n    string[] | undefined\r\n  ];\r\n  const shape = Object.entries(objExpr.__element__.__pointers__).reduce(\r\n    (_shape, [key, val]) => {\r\n      if (\r\n        fields?.length\r\n          ? fields.includes(key)\r\n          : key !== \"id\" && val.__kind__ === \"property\" && !val.computed\r\n      ) {\r\n        _shape[key] = val.target;\r\n      }\r\n      return _shape;\r\n    },\r\n    {} as NamedTupleShape\r\n  );\r\n  return tuple(shape);\r\n}\r\n"},{"path":"detached.mts","content":"import { ExpressionKind } from \"edgedb/dist/reflection/index.js\";\r\nimport type { Expression, TypeSet } from \"./typesystem.mjs\";\r\nimport { $expressionify } from \"./path.mjs\";\r\n\r\nexport function detached<Expr extends TypeSet>(\r\n  expr: Expr\r\n): $expr_Detached<Expr> {\r\n  return $expressionify({\r\n    __element__: expr.__element__,\r\n    __cardinality__: expr.__cardinality__,\r\n    __expr__: expr,\r\n    __kind__: ExpressionKind.Detached,\r\n  }) as any;\r\n}\r\n\r\nexport type $expr_Detached<Expr extends TypeSet = TypeSet> = Expression<{\r\n  __element__: Expr[\"__element__\"];\r\n  __cardinality__: Expr[\"__cardinality__\"];\r\n  __kind__: ExpressionKind.Detached;\r\n  __expr__: TypeSet;\r\n}>;\r\n"},{"path":"external.mts","content":"import type { TypeSet, setToTsType } from \"./typesystem.mjs\";\r\n\r\nexport { literal } from \"./literal.mjs\";\r\nexport {} from \"./path.mjs\";\r\nexport { set } from \"./set.mjs\";\r\nexport { cast } from \"./cast.mjs\";\r\nexport {\r\n  ASC,\r\n  DESC,\r\n  EMPTY_FIRST,\r\n  EMPTY_LAST,\r\n  is,\r\n  delete,\r\n  select,\r\n} from \"./select.mjs\";\r\nexport { update } from \"./update.mjs\";\r\nexport { insert } from \"./insert.mjs\";\r\nexport {\r\n  array,\r\n  tuple,\r\n  $objectTypeToTupleType as objectTypeToTupleType,\r\n} from \"./collections.mjs\";\r\nexport {} from \"./funcops.mjs\";\r\nexport { for } from \"./for.mjs\";\r\nexport { alias, with } from \"./with.mjs\";\r\nexport { optional, params } from \"./params.mjs\";\r\nexport { detached } from \"./detached.mjs\";\r\nexport {} from \"./toEdgeQL.mjs\";\r\n\r\nexport type $infer<A extends TypeSet> = setToTsType<A>;\r\n"},{"path":"for.mts","content":"import { Cardinality, ExpressionKind } from \"edgedb/dist/reflection/index.js\";\r\nimport { cardutil } from \"./cardinality.mjs\";\r\nimport type { Expression, BaseType, BaseTypeSet } from \"./typesystem.mjs\";\r\nimport { $expressionify } from \"./path.mjs\";\r\n\r\nexport type $expr_For<\r\n  El extends BaseType = BaseType,\r\n  Card extends Cardinality = Cardinality\r\n  // IterSet extends BaseTypeSet = BaseTypeSet,\r\n  // Expr extends BaseTypeSet = BaseTypeSet\r\n> = Expression<{\r\n  __element__: El;\r\n  __cardinality__: Card;\r\n  __kind__: ExpressionKind.For;\r\n  __iterSet__: BaseTypeSet;\r\n  __forVar__: $expr_ForVar;\r\n  __expr__: BaseTypeSet;\r\n}>;\r\n\r\nexport type $expr_ForVar<Type extends BaseType = BaseType> = Expression<{\r\n  __element__: Type;\r\n  __cardinality__: Cardinality.One;\r\n  __kind__: ExpressionKind.ForVar;\r\n}>;\r\n\r\nfunction _for<IteratorSet extends BaseTypeSet, Expr extends BaseTypeSet>(\r\n  set: IteratorSet,\r\n  expr: (variable: $expr_ForVar<IteratorSet[\"__element__\"]>) => Expr\r\n): $expr_For<\r\n  Expr[\"__element__\"],\r\n  cardutil.multiplyCardinalities<\r\n    IteratorSet[\"__cardinality__\"],\r\n    Expr[\"__cardinality__\"]\r\n  >\r\n> {\r\n  const forVar = $expressionify({\r\n    __kind__: ExpressionKind.ForVar,\r\n    __element__: set.__element__,\r\n    __cardinality__: Cardinality.One,\r\n  }) as $expr_ForVar<IteratorSet[\"__element__\"]>;\r\n\r\n  const returnExpr = expr(forVar);\r\n\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.For,\r\n    __element__: returnExpr.__element__,\r\n    __cardinality__: cardutil.multiplyCardinalities(\r\n      set.__cardinality__,\r\n      returnExpr.__cardinality__\r\n    ),\r\n    __iterSet__: set,\r\n    __expr__: returnExpr,\r\n    __forVar__: forVar,\r\n  }) as any;\r\n}\r\n\r\nexport { _for as for };\r\n"},{"path":"funcops.mts","content":"import {\r\n  Cardinality,\r\n  type introspect,\r\n  TypeKind,\r\n} from \"edgedb/dist/reflection/index.js\";\r\nimport { cardutil } from \"./cardinality.mjs\";\r\nimport { makeType } from \"./hydrate.mjs\";\r\nimport type {\r\n  BaseType,\r\n  BaseTypeSet,\r\n  ArrayType,\r\n  ObjectType,\r\n  TypeSet,\r\n  RangeType,\r\n  Expression,\r\n  MultiRangeType,\r\n} from \"./typesystem.mjs\";\r\nimport { cast } from \"./cast.mjs\";\r\nimport { isImplicitlyCastableTo, literalToTypeSet } from \"./castMaps.mjs\";\r\nimport { literal } from \"./literal.mjs\";\r\n\r\nimport type {\r\n  ExpressionKind,\r\n  OperatorKind,\r\n} from \"edgedb/dist/reflection/index.js\";\r\n\r\nexport type $expr_Function<\r\n  // Name extends string = string,\r\n  // Args extends (BaseTypeSet | undefined)[] = (BaseTypeSet | undefined)[],\r\n  // NamedArgs extends {[key: string]: BaseTypeSet} = {\r\n  //   [key: string]: BaseTypeSet;\r\n  // },\r\n  // ReturnType extends BaseTypeSet = BaseTypeSet,\r\n  El extends BaseType = BaseType,\r\n  Card extends Cardinality = Cardinality\r\n> = Expression<{\r\n  __element__: El;\r\n  __cardinality__: Card;\r\n  __kind__: ExpressionKind.Function;\r\n  __name__: string;\r\n  __args__: (BaseTypeSet | undefined)[];\r\n  __namedargs__: { [key: string]: BaseTypeSet };\r\n}>;\r\n\r\nexport type $expr_Operator<\r\n  // Name extends string = string,\r\n  // OpKind extends OperatorKind = OperatorKind,\r\n  // Args extends TypeSet[] = TypeSet[],\r\n  // ReturnType extends TypeSet = TypeSet,\r\n  El extends BaseType = BaseType,\r\n  Card extends Cardinality = Cardinality\r\n> = Expression<{\r\n  __element__: El;\r\n  __cardinality__: Card;\r\n  __kind__: ExpressionKind.Operator;\r\n  __name__: string;\r\n  __opkind__: OperatorKind;\r\n  __args__: TypeSet[];\r\n}>;\r\n\r\ninterface OverloadFuncArgDef {\r\n  typeId: string;\r\n  optional?: boolean;\r\n  setoftype?: boolean;\r\n  variadic?: boolean;\r\n}\r\n\r\ninterface OverloadFuncDef {\r\n  kind?: string;\r\n  args: OverloadFuncArgDef[];\r\n  namedArgs?: { [key: string]: OverloadFuncArgDef };\r\n  returnTypeId: string;\r\n  returnTypemod?: \"SetOfType\" | \"OptionalType\";\r\n  preservesOptionality?: boolean;\r\n}\r\n\r\nfunction mapLiteralToTypeSet(literals: any[]): TypeSet[];\r\nfunction mapLiteralToTypeSet(literals: { [key: string]: any }): {\r\n  [key: string]: TypeSet;\r\n};\r\nfunction mapLiteralToTypeSet(literals: any[] | { [key: string]: any }) {\r\n  if (Array.isArray(literals)) {\r\n    return literals.map((lit) => (lit != null ? literalToTypeSet(lit) : lit));\r\n  }\r\n  const obj: { [key: string]: TypeSet } = {};\r\n  for (const key of Object.keys(literals)) {\r\n    obj[key] =\r\n      literals[key] != null ? literalToTypeSet(literals[key]) : literals[key];\r\n  }\r\n  return obj;\r\n}\r\n\r\nexport function $resolveOverload(\r\n  funcName: string,\r\n  args: any[],\r\n  typeSpec: introspect.Types,\r\n  funcDefs: OverloadFuncDef[]\r\n) {\r\n  const positionalArgs: (TypeSet | undefined)[] = [];\r\n  let namedArgs: { [key: string]: TypeSet } | undefined;\r\n  if (args.length) {\r\n    if (args[0] !== undefined) {\r\n      try {\r\n        positionalArgs.push(literalToTypeSet(args[0]));\r\n      } catch {\r\n        // first arg is not a expr or literal type, so assume named args object\r\n        namedArgs = mapLiteralToTypeSet(args[0] as object);\r\n      }\r\n    } else {\r\n      positionalArgs.push(undefined);\r\n    }\r\n    positionalArgs.push(...mapLiteralToTypeSet(args.slice(1)));\r\n  }\r\n\r\n  for (const def of funcDefs) {\r\n    const resolvedOverload = _tryOverload(\r\n      funcName,\r\n      positionalArgs,\r\n      namedArgs,\r\n      typeSpec,\r\n      def\r\n    );\r\n    if (resolvedOverload !== null) {\r\n      return resolvedOverload;\r\n    }\r\n  }\r\n\r\n  throw new Error(\r\n    `No function overload found for ${\r\n      funcName.includes(\"::\")\r\n        ? `'e.${funcName.split(\"::\").join(\".\")}()'`\r\n        : `operator '${funcName}'`\r\n    } with args: ${[...positionalArgs, ...Object.values(namedArgs ?? {})]\r\n      .filter(Boolean)\r\n      .map(\r\n        (arg) =>\r\n          `Element: ${arg!.__element__.__name__} (${arg!.__cardinality__})`\r\n      )\r\n      .join(\", \")}`\r\n  );\r\n}\r\n\r\nconst ANYTYPE_ARG = Symbol();\r\n\r\nfunction _tryOverload(\r\n  funcName: string,\r\n  args: (BaseTypeSet | undefined)[],\r\n  namedArgs: { [key: string]: BaseTypeSet } | undefined,\r\n  typeSpec: introspect.Types,\r\n  funcDef: OverloadFuncDef\r\n): {\r\n  kind?: string;\r\n  returnType: BaseType;\r\n  cardinality: Cardinality;\r\n  args: BaseTypeSet[];\r\n  namedArgs: { [key: string]: BaseTypeSet };\r\n} | null {\r\n  if (\r\n    (funcDef.namedArgs === undefined && namedArgs !== undefined) ||\r\n    (namedArgs === undefined &&\r\n      funcDef.namedArgs &&\r\n      Object.values(funcDef.namedArgs).some((arg) => !arg.optional))\r\n  ) {\r\n    return null;\r\n  }\r\n\r\n  const lastParamVariadic = funcDef.args[funcDef.args.length - 1]?.variadic;\r\n  if (!lastParamVariadic && args.length > funcDef.args.length) {\r\n    return null;\r\n  }\r\n\r\n  const paramCardinalities: [Cardinality, ...Cardinality[]] = [Cardinality.One];\r\n\r\n  if (namedArgs) {\r\n    for (const [key, value] of Object.entries(namedArgs)) {\r\n      const argDef = funcDef.namedArgs?.[key];\r\n      if (\r\n        !argDef ||\r\n        !compareType(typeSpec, argDef.typeId, value.__element__).match\r\n      ) {\r\n        return null;\r\n      }\r\n\r\n      paramCardinalities.push(\r\n        argDef.setoftype\r\n          ? funcDef.preservesOptionality\r\n            ? cardutil.overrideUpperBound(value.__cardinality__, \"One\")\r\n            : Cardinality.One\r\n          : argDef.optional\r\n          ? cardutil.overrideLowerBound(value.__cardinality__, \"One\")\r\n          : value.__cardinality__\r\n      );\r\n    }\r\n  }\r\n\r\n  let positionalArgs: BaseTypeSet[] = [];\r\n\r\n  let returnAnytype: BaseType | undefined;\r\n  let needsAnytypeReplacement = false;\r\n\r\n  for (let i = 0; i < funcDef.args.length; i++) {\r\n    const argDef = funcDef.args[i]!;\r\n    const arg = args[i];\r\n\r\n    if (arg === undefined) {\r\n      if (!argDef.optional) {\r\n        return null;\r\n      }\r\n\r\n      if (i < args.length) {\r\n        // arg is explicitly undefined, inject empty set\r\n        const argTypeName = typeSpec.get(argDef.typeId).name;\r\n        if (\r\n          argTypeName.includes(\"anytype\") ||\r\n          argTypeName.includes(\"std::anypoint\")\r\n        ) {\r\n          if (!returnAnytype) {\r\n            positionalArgs.push(ANYTYPE_ARG as any);\r\n            needsAnytypeReplacement = true;\r\n          } else {\r\n            positionalArgs.push(cast(returnAnytype, null));\r\n          }\r\n        } else {\r\n          const argType = makeType<any>(typeSpec, argDef.typeId, literal);\r\n          positionalArgs.push(cast(argType, null));\r\n        }\r\n      }\r\n    } else {\r\n      const { match, anytype } = compareType(\r\n        typeSpec,\r\n        argDef.typeId,\r\n        arg.__element__\r\n      );\r\n\r\n      if (!match) {\r\n        return null;\r\n      }\r\n      if (!returnAnytype && anytype) {\r\n        returnAnytype = anytype;\r\n      }\r\n\r\n      positionalArgs.push(\r\n        ...(argDef.variadic ? (args.slice(i) as BaseTypeSet[]) : [arg])\r\n      );\r\n      if (argDef.setoftype) {\r\n        paramCardinalities.push(\r\n          funcDef.preservesOptionality\r\n            ? cardutil.overrideUpperBound(arg.__cardinality__, \"One\")\r\n            : Cardinality.One\r\n        );\r\n      } else {\r\n        const card = argDef.variadic\r\n          ? cardutil.multiplyCardinalitiesVariadic(\r\n              (args.slice(i) as BaseTypeSet[]).map(\r\n                (el) => el.__cardinality__\r\n              ) as [Cardinality, ...Cardinality[]]\r\n            )\r\n          : arg.__cardinality__;\r\n\r\n        paramCardinalities.push(\r\n          argDef.optional ? cardutil.overrideLowerBound(card, \"One\") : card\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  let cardinality: Cardinality;\r\n  if (funcName === \"if_else\") {\r\n    cardinality = cardutil.multiplyCardinalities(\r\n      cardutil.orCardinalities(\r\n        positionalArgs[0]!.__cardinality__,\r\n        positionalArgs[2]!.__cardinality__\r\n      ),\r\n      positionalArgs[1]!.__cardinality__\r\n    );\r\n  } else if (funcName === \"std::assert_exists\") {\r\n    cardinality = cardutil.overrideLowerBound(\r\n      positionalArgs[0]!.__cardinality__,\r\n      \"One\"\r\n    );\r\n  } else if (funcName === \"union\") {\r\n    cardinality = cardutil.mergeCardinalities(\r\n      positionalArgs[0]!.__cardinality__,\r\n      positionalArgs[1]!.__cardinality__\r\n    );\r\n  } else if (funcName === \"??\") {\r\n    cardinality = cardutil.orCardinalities(\r\n      positionalArgs[0]!.__cardinality__,\r\n      positionalArgs[1]!.__cardinality__\r\n    );\r\n  } else if (funcName === \"distinct\") {\r\n    cardinality = positionalArgs[0]!.__cardinality__;\r\n  } else {\r\n    cardinality =\r\n      funcDef.returnTypemod === \"SetOfType\"\r\n        ? Cardinality.Many\r\n        : cardutil.multiplyCardinalitiesVariadic(paramCardinalities);\r\n\r\n    if (\r\n      funcDef.returnTypemod === \"OptionalType\" &&\r\n      !funcDef.preservesOptionality\r\n    ) {\r\n      cardinality = cardutil.overrideLowerBound(cardinality, \"Zero\");\r\n    }\r\n  }\r\n\r\n  if (needsAnytypeReplacement) {\r\n    if (!returnAnytype) {\r\n      throw new Error(`could not resolve anytype for ${funcName}`);\r\n    }\r\n    positionalArgs = positionalArgs.map((arg) =>\r\n      (arg as any) === ANYTYPE_ARG ? cast(returnAnytype!, null) : arg\r\n    );\r\n  }\r\n\r\n  return {\r\n    kind: funcDef.kind,\r\n    returnType: makeType(\r\n      typeSpec,\r\n      funcDef.returnTypeId,\r\n      literal,\r\n      returnAnytype\r\n    ),\r\n    cardinality,\r\n    args: positionalArgs,\r\n    namedArgs: namedArgs ?? {},\r\n  };\r\n}\r\n\r\nconst nameRemapping: { [key: string]: string } = {\r\n  \"std::int16\": \"std::number\",\r\n  \"std::int32\": \"std::number\",\r\n  \"std::int64\": \"std::number\",\r\n  \"std::float32\": \"std::number\",\r\n  \"std::float64\": \"std::number\",\r\n};\r\nconst descendantCache = new Map<string, string[]>();\r\nfunction getDescendantNames(typeSpec: introspect.Types, typeId: string) {\r\n  if (descendantCache.has(typeId)) {\r\n    return descendantCache.get(typeId)!;\r\n  }\r\n  const descendants: string[] = [\r\n    ...new Set(\r\n      [...typeSpec.values()]\r\n        .filter(\r\n          (type) =>\r\n            type.kind === \"scalar\" && type.bases.some(({ id }) => id === typeId)\r\n        )\r\n        .flatMap((type) =>\r\n          type.is_abstract\r\n            ? getDescendantNames(typeSpec, type.id)\r\n            : [nameRemapping[type.name]!, type.name]\r\n        )\r\n    ),\r\n  ];\r\n  descendantCache.set(typeId, descendants);\r\n  return descendants;\r\n}\r\n\r\nfunction compareType(\r\n  typeSpec: introspect.Types,\r\n  typeId: string,\r\n  arg: BaseType\r\n): { match: boolean; anytype?: BaseType } {\r\n  const type = typeSpec.get(typeId);\r\n\r\n  if (type.name === \"anytype\") {\r\n    return { match: true, anytype: arg };\r\n  }\r\n\r\n  if (type.name === \"anyobject\") {\r\n    return { match: arg.__kind__ === TypeKind.object, anytype: arg };\r\n  }\r\n\r\n  if (type.name === \"std::anypoint\") {\r\n    const descendants = getDescendantNames(typeSpec, typeId);\r\n    if (descendants.includes(arg.__name__)) {\r\n      return { match: true, anytype: arg };\r\n    }\r\n  }\r\n\r\n  if (type.name === \"std::anyenum\") {\r\n    return { match: arg.__kind__ === TypeKind.enum };\r\n  }\r\n\r\n  if (type.kind === \"scalar\") {\r\n    arg = (arg as any).__casttype__ ?? arg;\r\n    return {\r\n      match:\r\n        (arg.__kind__ === TypeKind.scalar || arg.__kind__ === TypeKind.enum) &&\r\n        (arg.__name__ === type.name ||\r\n          isImplicitlyCastableTo(arg.__name__, type.name)),\r\n    };\r\n  }\r\n  if (type.kind === \"array\") {\r\n    if (arg.__kind__ === TypeKind.array) {\r\n      return compareType(\r\n        typeSpec,\r\n        type.array_element_id,\r\n        (arg as any as ArrayType).__element__ as BaseType\r\n      );\r\n    }\r\n  }\r\n  if (type.kind === \"range\") {\r\n    if (arg.__kind__ === TypeKind.range) {\r\n      return compareType(\r\n        typeSpec,\r\n        type.range_element_id,\r\n        (arg as any as RangeType).__element__ as BaseType\r\n      );\r\n    }\r\n  }\r\n  if (type.kind === \"multirange\") {\r\n    if (arg.__kind__ === TypeKind.multirange) {\r\n      return compareType(\r\n        typeSpec,\r\n        type.multirange_element_id,\r\n        (arg as any as MultiRangeType).__element__ as BaseType\r\n      );\r\n    }\r\n  }\r\n  if (type.kind === \"object\") {\r\n    if (arg.__kind__ !== TypeKind.object) return { match: false };\r\n\r\n    const objectArg = arg as ObjectType;\r\n    let match = true;\r\n\r\n    // shape comparison\r\n    for (const ptr of type.pointers) {\r\n      if (objectArg.__pointers__[ptr.name]) {\r\n        const argPtr = objectArg.__pointers__[ptr.name]!;\r\n        const ptrTarget = typeSpec.get(ptr.target_id);\r\n        if (\r\n          ptrTarget.name !== argPtr.target.__name__ ||\r\n          ptr.card !== argPtr.cardinality\r\n        ) {\r\n          match = false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      match,\r\n    };\r\n  }\r\n  if (type.kind === \"tuple\") {\r\n    const items =\r\n      arg.__kind__ === TypeKind.tuple\r\n        ? (arg as any).__items__\r\n        : arg.__kind__ === TypeKind.namedtuple\r\n        ? (arg as any).__shape__\r\n        : null;\r\n    if (items) {\r\n      const keys = Object.keys(items);\r\n\r\n      if (keys.length === type.tuple_elements.length) {\r\n        let anytype: BaseType | undefined;\r\n        for (let i = 0; i < keys.length; i++) {\r\n          if (keys[i] !== type.tuple_elements[i]!.name) {\r\n            return { match: false };\r\n          }\r\n          const { match: m, anytype: a } = compareType(\r\n            typeSpec,\r\n            type.tuple_elements[i]!.target_id,\r\n            (items as any)[keys[i]!]\r\n          );\r\n          if (!m) {\r\n            return { match: false };\r\n          }\r\n          if (a) anytype = a;\r\n        }\r\n        return { match: true, anytype };\r\n      }\r\n    }\r\n  }\r\n\r\n  return { match: false };\r\n}\r\n"},{"path":"globals.mts","content":"import { ExpressionKind, Cardinality } from \"edgedb/dist/reflection/index.js\";\r\nimport type { Expression, BaseType } from \"./typesystem.mjs\";\r\nimport { $expressionify } from \"./path.mjs\";\r\n\r\nexport function makeGlobal<\r\n  // Name extends string,\r\n  Type extends BaseType,\r\n  Card extends Cardinality\r\n>(name: string, type: Type, card: Card): $expr_Global<Type, Card> {\r\n  return $expressionify({\r\n    __name__: name,\r\n    __element__: type,\r\n    __cardinality__: card,\r\n    __kind__: ExpressionKind.Global,\r\n  });\r\n}\r\n\r\nexport type $expr_Global<\r\n  // Name extends string = string,\r\n  Type extends BaseType = BaseType,\r\n  Card extends Cardinality = Cardinality\r\n> = Expression<{\r\n  __name__: string;\r\n  __element__: Type;\r\n  __cardinality__: Card;\r\n  __kind__: ExpressionKind.Global;\r\n}>;\r\n"},{"path":"group.mts","content":"import type {\r\n  Expression,\r\n  ObjectType,\r\n  ObjectTypeSet,\r\n  TypeSet,\r\n  BaseType,\r\n  $scopify,\r\n  PropertyDesc,\r\n  LinkDesc,\r\n} from \"./typesystem.mjs\";\r\nimport {\r\n  Cardinality,\r\n  ExpressionKind,\r\n  TypeKind,\r\n} from \"edgedb/dist/reflection/index.js\";\r\nimport { makeType } from \"./hydrate.mjs\";\r\n\r\nimport { $expressionify, $getScopedExpr } from \"./path.mjs\";\r\n// @ts-ignore\r\nimport type { $FreeObjectλShape, $str } from \"./modules/std.mjs\";\r\nimport { spec } from \"./__spec__.mjs\";\r\nimport { literal } from \"./literal.mjs\";\r\nimport { resolveShapeElement } from \"./select.mjs\";\r\nimport type {\r\n  normaliseShape,\r\n  // normaliseElement,\r\n  objectTypeToSelectShape,\r\n} from \"./select.mjs\";\r\n\r\ntype SingletonSet = Expression<\r\n  TypeSet<BaseType, Cardinality.One | Cardinality.AtMostOne>\r\n>;\r\ntype SimpleGroupElements = { [k: string]: SingletonSet };\r\ntype GroupModifiers = { by: SimpleGroupElements };\r\ntype NestedGroupElements = {\r\n  [k: string]: SingletonSet | GroupingSet;\r\n};\r\n\r\nexport type GroupingSet = {\r\n  __kind__: \"groupingset\";\r\n  __settype__: \"set\" | \"tuple\" | \"rollup\" | \"cube\";\r\n  __elements__: NestedGroupElements;\r\n  __exprs__: [string, SingletonSet][];\r\n};\r\nexport function isGroupingSet(arg: any): arg is GroupingSet {\r\n  return arg.__kind__ === \"groupingset\";\r\n}\r\n\r\n// result is partial to prevent \"X is specified more than once\" errors\r\n// the return type is a lie, this function returns a grouping set\r\n// but it pretends to return a SimpleGroupElements\r\n// to make the static computatation of `key` easier\r\nconst makeGroupingSet =\r\n  (prefix: string) =>\r\n  <T extends SimpleGroupElements>(grps: T): { [k in keyof T]?: T[k] } => {\r\n    const seenKeys = new Map<string, SingletonSet>();\r\n    const unfiltered = Object.entries(grps as NestedGroupElements).flatMap(\r\n      ([k, grp]) =>\r\n        isGroupingSet(grp)\r\n          ? grp.__exprs__\r\n          : ([[k, grp]] as [string, SingletonSet][])\r\n    );\r\n    const filtered = unfiltered.filter(([k, expr]) => {\r\n      if (!seenKeys.has(k)) {\r\n        seenKeys.set(k, expr);\r\n        return true;\r\n      }\r\n\r\n      if (expr !== seenKeys.get(k)) {\r\n        throw new Error(\r\n          `Cannot override pre-existing expression with key \"${k}\"`\r\n        );\r\n      }\r\n\r\n      return false;\r\n    });\r\n\r\n    return {\r\n      [`${Math.round(1000000 * Math.random())}___`]: {\r\n        __kind__: \"groupingset\",\r\n        __settype__: prefix,\r\n        __elements__: grps,\r\n        __exprs__: filtered,\r\n      } as GroupingSet,\r\n    } as any;\r\n  };\r\nconst set = makeGroupingSet(\"set\");\r\nconst tuple = makeGroupingSet(\"tuple\");\r\nconst rollup = makeGroupingSet(\"rollup\");\r\nconst cube = makeGroupingSet(\"cube\");\r\n\r\nconst setFuncs = { set, tuple, rollup, cube };\r\n\r\nexport type $expr_Group<\r\n  Expr extends ObjectTypeSet = ObjectTypeSet,\r\n  Mods extends GroupModifiers = GroupModifiers,\r\n  Shape extends object = { id: true }\r\n> = Expression<{\r\n  __element__: ObjectType<\r\n    \"std::FreeObject\",\r\n    $FreeObjectλShape & {\r\n      // adding free shape elements into __pointers__\r\n      // because objectTypeToSelectShape doesn't allow shapes on computeds\r\n      // and setToTsType can't handle that currently\r\n      grouping: PropertyDesc<$str, Cardinality.Many, false, true, true, false>;\r\n      key: LinkDesc<\r\n        ObjectType<\r\n          \"std::FreeObject\",\r\n          {\r\n            // tslint:disable-next-line\r\n            [k in keyof Mods[\"by\"]]: Mods[\"by\"][k][\"__element__\"] extends ObjectType\r\n              ? never\r\n              : PropertyDesc<\r\n                  Mods[\"by\"][k][\"__element__\"],\r\n                  Cardinality.AtMostOne\r\n                >;\r\n          }\r\n        >,\r\n        Cardinality.One,\r\n        {},\r\n        false,\r\n        true,\r\n        true,\r\n        false\r\n      >;\r\n      elements: LinkDesc<\r\n        Expr[\"__element__\"],\r\n        Cardinality.Many,\r\n        {},\r\n        false,\r\n        true,\r\n        true,\r\n        false\r\n      >;\r\n    },\r\n    {\r\n      // grouping: true;\r\n      // key: {[k in keyof Mods[\"by\"]]: true};\r\n      // elements: normaliseShape<Shape, \"by\">;\r\n      grouping: TypeSet<$str, Cardinality.Many>;\r\n      key: Expression<{\r\n        __element__: ObjectType<\r\n          \"std::FreeObject\",\r\n          $FreeObjectλShape,\r\n          {\r\n            [k in keyof Mods[\"by\"]]: Expression<{\r\n              __element__: Mods[\"by\"][k][\"__element__\"];\r\n              __cardinality__: Cardinality.AtMostOne;\r\n            }>;\r\n          }\r\n        >;\r\n        __cardinality__: Cardinality.One;\r\n      }>;\r\n      elements: Expression<{\r\n        __element__: ObjectType<\r\n          Expr[\"__element__\"][\"__name__\"],\r\n          Expr[\"__element__\"][\"__pointers__\"],\r\n          // Omit<normaliseShape<Shape>, \"by\">\r\n          normaliseShape<Shape, \"by\">\r\n        >;\r\n        __cardinality__: Cardinality.Many;\r\n      }>;\r\n    }\r\n  >;\r\n  __cardinality__: Cardinality.Many;\r\n  // bit of a lie, this is a GroupingSet at runtime\r\n  __modifiers__: Mods;\r\n  __kind__: ExpressionKind.Group;\r\n  __expr__: ObjectTypeSet;\r\n  __scope__: ObjectTypeSet;\r\n}>;\r\n\r\n// type modifierKeys = \"by\";\r\ntype noUndefined<T> = T extends undefined ? never : T;\r\ntype groupFunc = <\r\n  Expr extends ObjectTypeSet,\r\n  // Shape extends GroupModifiers\r\n  // Grps extends SimpleGroupElements,\r\n  Shape extends { by?: SimpleGroupElements } & objectTypeToSelectShape<\r\n    Expr[\"__element__\"]\r\n  >\r\n  // Mods extends GroupModifiers = {by: Shape[\"by\"]}\r\n>(\r\n  expr: Expr,\r\n  getter: (arg: $scopify<Expr[\"__element__\"]>) => Readonly<Shape>\r\n) => $expr_Group<\r\n  Expr,\r\n  { by: noUndefined<Shape[\"by\"]> },\r\n  normaliseShape<Shape, \"by\">\r\n>;\r\n\r\nconst groupFunc: groupFunc = (expr, getter) => {\r\n  const { shape, scope, modifiers } = resolveShape(getter, expr);\r\n  // const scope = $getScopedExpr(expr as any);\r\n  // const rawGroupings = getter(scope);\r\n  const groupSet = tuple(modifiers.by);\r\n\r\n  // only one key in object returned from makeGroupingSet\r\n  const key = Object.keys(groupSet)[0]!;\r\n  const grouping = groupSet[key] as any as GroupingSet;\r\n  const keyShape: any = {};\r\n  const keyPointers: any = {};\r\n  const keyShapeElement: any = {};\r\n\r\n  for (const [k, e] of grouping.__exprs__) {\r\n    keyShape[k] = $expressionify({\r\n      __element__: e.__element__,\r\n      __cardinality__: Cardinality.AtMostOne,\r\n    } as any);\r\n    keyPointers[k] = {\r\n      __kind__: \"property\",\r\n      target: e.__element__,\r\n      cardinality: Cardinality.AtMostOne,\r\n      exclusive: false,\r\n      computed: false,\r\n      readonly: false,\r\n      hasDefault: false,\r\n    } as PropertyDesc;\r\n    keyShapeElement[k] = true;\r\n  }\r\n\r\n  const $FreeObject = makeType(\r\n    spec,\r\n    [...spec.values()].find((s) => s.name === \"std::FreeObject\")!.id,\r\n    literal\r\n  );\r\n\r\n  const str = makeType(\r\n    spec,\r\n    [...spec.values()].find((s) => s.name === \"std::str\")!.id,\r\n    literal\r\n  );\r\n\r\n  return $expressionify({\r\n    __element__: {\r\n      ...$FreeObject,\r\n      __name__: \"std::FreeObject\",\r\n      __pointers__: {\r\n        ...($FreeObject as any).__pointers__,\r\n        __name__: \"std::FreeObject\",\r\n        grouping: {\r\n          __kind__: \"property\",\r\n          target: str,\r\n          cardinality: Cardinality.Many,\r\n          exclusive: false,\r\n          computed: false,\r\n          readonly: false,\r\n          hasDefault: false,\r\n        } as PropertyDesc,\r\n        key: {\r\n          __kind__: \"link\",\r\n          target: {\r\n            ...$FreeObject,\r\n            __name__: \"std::FreeObject\",\r\n            __pointers__: {\r\n              ...($FreeObject as any).__pointers__,\r\n              ...keyPointers,\r\n            },\r\n            __shape__: keyShape,\r\n          },\r\n          properties: {},\r\n          cardinality: Cardinality.One,\r\n          exclusive: false,\r\n          computed: false,\r\n          readonly: false,\r\n          hasDefault: false,\r\n        } as LinkDesc,\r\n\r\n        elements: {\r\n          __kind__: \"link\",\r\n          target: expr.__element__,\r\n          cardinality: Cardinality.Many,\r\n          properties: {},\r\n          exclusive: false,\r\n          computed: false,\r\n          readonly: false,\r\n          hasDefault: false,\r\n        } as LinkDesc,\r\n      },\r\n      __shape__: {\r\n        grouping: $expressionify({\r\n          __element__: str,\r\n          __cardinality__: Cardinality.Many,\r\n        } as any),\r\n        key: $expressionify({\r\n          __element__: {\r\n            ...$FreeObject,\r\n            __shape__: keyShape,\r\n          },\r\n          __cardinality__: Cardinality.One,\r\n        } as any),\r\n        elements: $expressionify({\r\n          __element__: { ...expr.__element__, __shape__: shape } as any,\r\n          __cardinality__: Cardinality.Many,\r\n        } as any),\r\n      },\r\n    },\r\n\r\n    __cardinality__: Cardinality.Many,\r\n    __expr__: expr,\r\n    __modifiers__: { by: grouping },\r\n    __kind__: ExpressionKind.Group,\r\n    __scope__: scope,\r\n  }) as any;\r\n};\r\nObject.assign(groupFunc, setFuncs);\r\n\r\nfunction resolveShape(\r\n  shapeGetter: ((scope: any) => any) | any,\r\n  expr: TypeSet\r\n): { modifiers: { by: SimpleGroupElements }; shape: any; scope: TypeSet } {\r\n  const modifiers: { by: SimpleGroupElements } = {} as any;\r\n  const shape: any = {};\r\n\r\n  // get scoped object if expression is objecttypeset\r\n  const scope = $getScopedExpr(expr as any) as ObjectTypeSet;\r\n\r\n  // execute getter with scope\r\n  const selectShape =\r\n    typeof shapeGetter === \"function\" ? shapeGetter(scope) : shapeGetter;\r\n\r\n  for (const [key, value] of Object.entries(selectShape)) {\r\n    // handle modifier keys\r\n    if (key === \"by\") {\r\n      modifiers[key] = value as any;\r\n    } else {\r\n      // for scalar expressions, scope === expr\r\n      // shape keys are not allowed\r\n      if (expr.__element__.__kind__ !== TypeKind.object) {\r\n        throw new Error(\r\n          `Invalid select shape key '${key}' on scalar expression, ` +\r\n            `only modifiers are allowed (filter, order_by, offset and limit)`\r\n        );\r\n      }\r\n      shape[key] = resolveShapeElement(key, value, scope);\r\n    }\r\n  }\r\n  if (Object.keys(shape).length === 0) {\r\n    shape.id = true;\r\n  }\r\n  if (!modifiers.by) {\r\n    throw new Error(\"Must provide a `by` key in `e.group`\");\r\n  }\r\n  return { shape, modifiers, scope };\r\n}\r\nexport const group: typeof setFuncs & groupFunc = groupFunc as any;\r\n"},{"path":"hydrate.mts","content":"import type { $ } from \"edgedb\";\r\n\r\nimport type {\r\n  BaseType,\r\n  ObjectType,\r\n  ObjectTypePointers,\r\n  LinkDesc,\r\n  PropertyDesc,\r\n  TupleType,\r\n} from \"./typesystem.mjs\";\r\n\r\nimport { util, TypeKind } from \"edgedb/dist/reflection/index.js\";\r\nimport type { typeutil } from \"edgedb/dist/reflection/index.js\";\r\n\r\nconst typeCache = new Map<string, BaseType>();\r\n\r\nconst _linkProps = Symbol();\r\n\r\nfunction applySpec(\r\n  spec: $.introspect.Types,\r\n  type: $.introspect.ObjectType,\r\n  shape: any,\r\n  seen: Set<string>,\r\n  literal: any\r\n): void {\r\n  const allPointers = [\r\n    ...type.pointers,\r\n    ...type.backlinks,\r\n    ...type.backlink_stubs,\r\n  ];\r\n  for (const ptr of allPointers) {\r\n    if (seen.has(ptr.name)) {\r\n      continue;\r\n    }\r\n    seen.add(ptr.name);\r\n\r\n    if (ptr.kind === \"link\") {\r\n      shape[ptr.name] = {\r\n        __kind__: \"link\",\r\n        cardinality: ptr.card,\r\n        exclusive: ptr.is_exclusive,\r\n        computed: ptr.is_computed,\r\n        readonly: ptr.is_readonly,\r\n      } as LinkDesc;\r\n      util.defineGetter(shape[ptr.name], \"target\", () =>\r\n        makeType(spec, ptr.target_id, literal)\r\n      );\r\n      util.defineGetter(shape[ptr.name], \"properties\", () => {\r\n        if (!shape[ptr.name][_linkProps]) {\r\n          const linkProperties: { [k: string]: any } = (shape[ptr.name][\r\n            _linkProps\r\n          ] = {});\r\n          for (const linkProp of ptr.pointers ?? []) {\r\n            // We only support \"link properties\" in EdgeDB, currently.\r\n            if (linkProp.kind !== \"property\") {\r\n              return;\r\n            }\r\n            // No use for them reflected, at the moment.\r\n            if (linkProp.name === \"source\" || linkProp.name === \"target\") {\r\n              return;\r\n            }\r\n\r\n            const linkPropObject: any = {\r\n              __kind__: \"property\",\r\n            };\r\n            linkPropObject.cardinality = linkProp.card;\r\n            util.defineGetter(linkPropObject, \"target\", () => {\r\n              return makeType(spec, linkProp.target_id, literal);\r\n            });\r\n            linkProperties[linkProp.name] = linkPropObject;\r\n          }\r\n        }\r\n        return shape[ptr.name][_linkProps];\r\n      });\r\n    } else if (ptr.kind === \"property\") {\r\n      shape[ptr.name] = {\r\n        __kind__: \"property\",\r\n        cardinality: ptr.card,\r\n        exclusive: ptr.is_exclusive,\r\n        computed: ptr.is_computed,\r\n        readonly: ptr.is_readonly,\r\n      } as PropertyDesc;\r\n      util.defineGetter(shape[ptr.name], \"target\", () =>\r\n        makeType(spec, ptr.target_id, literal)\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nexport function makeType<T extends BaseType>(\r\n  spec: $.introspect.Types,\r\n  id: string,\r\n  // should be (type: any, val: any) => any, but causes\r\n  // 'Type instantiation is excessively deep and possibly infinite' error\r\n  // in typescript 4.5\r\n  literal: any,\r\n  anytype?: BaseType\r\n): T {\r\n  const type = spec.get(id);\r\n\r\n  if (type.name === \"anytype\" || type.name === \"std::anypoint\") {\r\n    if (anytype) return anytype as unknown as T;\r\n    throw new Error(\"anytype not provided\");\r\n  }\r\n\r\n  if (typeCache.has(id)) {\r\n    return typeCache.get(id) as T;\r\n  }\r\n\r\n  const obj: any = {};\r\n  obj.__name__ = type.name;\r\n\r\n  if (type.kind === \"object\") {\r\n    obj.__kind__ = TypeKind.object;\r\n\r\n    const pointers: any = {};\r\n    const seen = new Set<string>();\r\n    applySpec(spec, type, pointers, seen, literal);\r\n    const ancestors = [...type.bases];\r\n    for (const anc of ancestors) {\r\n      const ancType = spec.get(anc.id);\r\n      if (ancType.kind === \"object\" || ancType.kind === \"scalar\") {\r\n        ancestors.push(...ancType.bases);\r\n      }\r\n      if (ancType.kind !== \"object\") {\r\n        throw new Error(`Not an object: ${id}`);\r\n      }\r\n      applySpec(spec, ancType, pointers, seen, literal);\r\n    }\r\n\r\n    obj.__pointers__ = pointers;\r\n    obj.__shape__ = {};\r\n    typeCache.set(id, obj);\r\n    return obj;\r\n  } else if (type.kind === \"scalar\") {\r\n    const scalarObj = type.is_abstract\r\n      ? {}\r\n      : type.enum_values\r\n      ? {}\r\n      : // : type.name === \"std::json\"\r\n        // ? (((val: any) => {\r\n        //     return literal(scalarObj, JSON.stringify(val));\r\n        //   }) as any)\r\n        (((val: any) => {\r\n          return literal(scalarObj, val);\r\n        }) as any);\r\n\r\n    if (type.enum_values) {\r\n      scalarObj.__kind__ = TypeKind.enum;\r\n      scalarObj.__values__ = type.enum_values;\r\n      for (const val of type.enum_values) {\r\n        Object.defineProperty(scalarObj, val, {\r\n          get() {\r\n            return literal(scalarObj, val);\r\n          },\r\n        });\r\n      }\r\n    } else {\r\n      scalarObj.__kind__ = TypeKind.scalar;\r\n    }\r\n    scalarObj.__name__ = type.name;\r\n\r\n    if (type.cast_type) {\r\n      scalarObj.__casttype__ = makeType(spec, type.cast_type, literal);\r\n    }\r\n    typeCache.set(id, scalarObj);\r\n    return scalarObj;\r\n  } else if (type.kind === \"array\") {\r\n    obj.__kind__ = TypeKind.array;\r\n    util.defineGetter(obj, \"__element__\", () => {\r\n      return makeType(spec, type.array_element_id, literal, anytype);\r\n    });\r\n    util.defineGetter(obj, \"__name__\", () => {\r\n      return `array<${obj.__element__.__name__}>`;\r\n    });\r\n    return obj;\r\n  } else if (type.kind === \"tuple\") {\r\n    if (type.tuple_elements[0]!.name === \"0\") {\r\n      // unnamed tuple\r\n      obj.__kind__ = TypeKind.tuple;\r\n\r\n      util.defineGetter(obj, \"__items__\", () => {\r\n        return type.tuple_elements.map((el) =>\r\n          makeType(spec, el.target_id, literal, anytype)\r\n        ) as any;\r\n      });\r\n      util.defineGetter(obj, \"__name__\", () => {\r\n        return `tuple<${obj.__items__\r\n          .map((item: any) => item.__name__)\r\n          .join(\", \")}>`;\r\n      });\r\n      return obj;\r\n    } else {\r\n      // named tuple\r\n      obj.__kind__ = TypeKind.namedtuple;\r\n\r\n      util.defineGetter(obj, \"__shape__\", () => {\r\n        const shape: any = {};\r\n        for (const el of type.tuple_elements) {\r\n          shape[el.name] = makeType(spec, el.target_id, literal, anytype);\r\n        }\r\n        return shape;\r\n      });\r\n      util.defineGetter(obj, \"__name__\", () => {\r\n        return `tuple<${Object.entries(obj.__shape__)\r\n          .map(([key, val]: [string, any]) => `${key}: ${val.__name__}`)\r\n          .join(\", \")}>`;\r\n      });\r\n      return obj;\r\n    }\r\n  } else if (type.kind === \"range\") {\r\n    obj.__kind__ = TypeKind.range;\r\n    util.defineGetter(obj, \"__element__\", () => {\r\n      return makeType(spec, type.range_element_id, literal, anytype);\r\n    });\r\n    util.defineGetter(obj, \"__name__\", () => {\r\n      return `range<${obj.__element__.__name__}>`;\r\n    });\r\n    return obj;\r\n  } else if (type.kind === \"multirange\") {\r\n    obj.__kind__ = TypeKind.multirange;\r\n    util.defineGetter(obj, \"__element__\", () => {\r\n      return makeType(spec, type.multirange_element_id, literal, anytype);\r\n    });\r\n    util.defineGetter(obj, \"__name__\", () => {\r\n      return `multirange<${obj.__element__.__name__}>`;\r\n    });\r\n    return obj;\r\n  } else {\r\n    throw new Error(`Invalid type: ${JSON.stringify(type, null, 2)}`);\r\n  }\r\n}\r\nexport type mergeObjectShapes<\r\n  A extends ObjectTypePointers,\r\n  B extends ObjectTypePointers\r\n> = typeutil.flatten<{\r\n  [k in keyof A & keyof B]: A[k] extends B[k] // possible performance issue?\r\n    ? B[k] extends A[k]\r\n      ? A[k]\r\n      : never\r\n    : never;\r\n}>;\r\n\r\nexport type mergeObjectTypes<\r\n  A extends ObjectType | undefined,\r\n  B extends ObjectType | undefined\r\n> = A extends ObjectType\r\n  ? B extends ObjectType\r\n    ? ObjectType<\r\n        `${A[\"__name__\"]} UNION ${B[\"__name__\"]}`,\r\n        mergeObjectShapes<A[\"__pointers__\"], B[\"__pointers__\"]>,\r\n        null\r\n      >\r\n    : A\r\n  : B extends ObjectType\r\n  ? B\r\n  : undefined;\r\n\r\nexport function $mergeObjectTypes<A extends ObjectType, B extends ObjectType>(\r\n  a: A,\r\n  b: B\r\n): mergeObjectTypes<A, B> {\r\n  const obj = {\r\n    __kind__: TypeKind.object,\r\n    __name__: `${a.__name__} UNION ${b.__name__}`,\r\n    get __pointers__() {\r\n      const merged: any = {};\r\n      for (const [akey, aitem] of Object.entries(a.__pointers__)) {\r\n        if (!b.__pointers__[akey]) continue;\r\n\r\n        const bitem = b.__pointers__[akey]!;\r\n        if (aitem.cardinality !== bitem.cardinality) continue;\r\n        // names must reflect full type\r\n        if (aitem.target.__name__ !== bitem.target.__name__) continue;\r\n        merged[akey] = aitem;\r\n      }\r\n      return merged;\r\n    },\r\n    __shape__: {},\r\n  };\r\n  return obj as any;\r\n}\r\n\r\nexport function $mergeTupleTypes<A extends TupleType, B extends TupleType>(\r\n  a: A,\r\n  b: B\r\n): TupleType {\r\n  if (a.__items__.length !== b.__items__.length) {\r\n    throw new Error(\"Incompatible tuple types; lengths differ.\");\r\n  }\r\n  return {} as TupleType;\r\n}\r\n"},{"path":"insert.mts","content":"import {\r\n  Cardinality,\r\n  ExpressionKind,\r\n  type typeutil,\r\n  TypeKind,\r\n} from \"edgedb/dist/reflection/index.js\";\r\nimport type {\r\n  Expression,\r\n  LinkDesc,\r\n  ObjectTypeSet,\r\n  ObjectTypePointers,\r\n  PropertyDesc,\r\n  stripBacklinks,\r\n  stripNonInsertables,\r\n  $scopify,\r\n  stripSet,\r\n  TypeSet,\r\n  ObjectType,\r\n  NamedTupleType,\r\n} from \"./typesystem.mjs\";\r\nimport type { pointerToAssignmentExpression } from \"./casting.mjs\";\r\nimport { $expressionify, $getScopedExpr } from \"./path.mjs\";\r\nimport { cast } from \"./cast.mjs\";\r\nimport { set } from \"./set.mjs\";\r\nimport { literal } from \"./literal.mjs\";\r\nimport { $getTypeByName } from \"./literal.mjs\";\r\nimport type { $expr_PathNode } from \"./path.mjs\";\r\nimport type { $Object } from \"./modules/std.mjs\";\r\nimport type { scalarLiterals } from \"./castMaps.mjs\";\r\n\r\nexport type pointerIsOptional<T extends PropertyDesc | LinkDesc> =\r\n  T[\"cardinality\"] extends\r\n    | Cardinality.Many\r\n    | Cardinality.Empty\r\n    | Cardinality.AtMostOne\r\n    ? true\r\n    : false;\r\n\r\nexport type InsertShape<El extends ObjectType> = typeutil.flatten<\r\n  RawInsertShape<El>\r\n>;\r\n\r\nexport type RawInsertShape<El extends ObjectType> =\r\n  // short-circuit infinitely deep\r\n  ObjectType extends El\r\n    ? never\r\n    : typeutil.stripNever<\r\n        stripNonInsertables<stripBacklinks<El[\"__pointers__\"]>>\r\n      > extends infer Shape\r\n    ? Shape extends ObjectTypePointers\r\n      ? typeutil.addQuestionMarks<{\r\n          [k in keyof Shape]:\r\n            | pointerToAssignmentExpression<Shape[k]>\r\n            | (pointerIsOptional<Shape[k]> extends true\r\n                ? undefined | null\r\n                : never)\r\n            | (Shape[k][\"hasDefault\"] extends true ? undefined : never);\r\n        }> & { [k in `@${string}`]: TypeSet | scalarLiterals }\r\n      : never\r\n    : never;\r\n\r\ninterface UnlessConflict {\r\n  on: TypeSet | null;\r\n  else?: TypeSet;\r\n}\r\n\r\ntype InsertBaseExpression<Root extends TypeSet = TypeSet> = {\r\n  __kind__: ExpressionKind.Insert;\r\n  __element__: Root[\"__element__\"];\r\n  __cardinality__: Cardinality.One;\r\n  __expr__: stripSet<Root>;\r\n  __shape__: any;\r\n};\r\nexport type $expr_Insert<\r\n  // Root extends $expr_PathNode = $expr_PathNode\r\n  El extends ObjectType = ObjectType\r\n  // Conflict = UnlessConflict | null\r\n  // Shape extends InsertShape<Root> = any\r\n> = Expression<{\r\n  __kind__: ExpressionKind.Insert;\r\n  __element__: El;\r\n  __cardinality__: Cardinality.One;\r\n  __expr__: $expr_PathNode;\r\n  __shape__: InsertShape<El>;\r\n\r\n  unlessConflict(): $expr_InsertUnlessConflict<\r\n    El,\r\n    // Expression<{\r\n    //   __kind__: ExpressionKind.Insert;\r\n    //   __element__: El;\r\n    //   __cardinality__: Cardinality.One;\r\n    //   __expr__: $expr_PathNode;\r\n    //   __shape__: InsertShape<El>;\r\n    // }>,\r\n    { on: null }\r\n  >;\r\n  unlessConflict<Conflict extends UnlessConflict>(\r\n    conflictGetter: (scope: $scopify<El>) => Conflict\r\n  ): $expr_InsertUnlessConflict<\r\n    El,\r\n    // Expression<{\r\n    //   __kind__: ExpressionKind.Insert;\r\n    //   __element__: El;\r\n    //   __cardinality__: Cardinality.One;\r\n    //   __expr__: $expr_PathNode;\r\n    //   __shape__: InsertShape<El>;\r\n    // }>,\r\n    Conflict\r\n  >;\r\n}>;\r\n\r\nexport type $expr_InsertUnlessConflict<\r\n  El extends ObjectType = ObjectType,\r\n  // Root extends InsertBaseExpression = InsertBaseExpression,\r\n  Conflict extends UnlessConflict = UnlessConflict\r\n> = Expression<{\r\n  __kind__: ExpressionKind.InsertUnlessConflict;\r\n  __element__: Conflict[\"else\"] extends TypeSet\r\n    ? Conflict[\"else\"][\"__element__\"][\"__name__\"] extends El[\"__name__\"]\r\n      ? El\r\n      : $Object\r\n    : El;\r\n  __cardinality__: Conflict[\"else\"] extends TypeSet\r\n    ? Conflict[\"else\"][\"__cardinality__\"]\r\n    : Cardinality.AtMostOne;\r\n  __expr__: InsertBaseExpression;\r\n  __conflict__: Conflict;\r\n}>;\r\n\r\nfunction unlessConflict(\r\n  this: $expr_Insert,\r\n  conflictGetter?: (scope: TypeSet) => UnlessConflict\r\n) {\r\n  const expr: any = {\r\n    __kind__: ExpressionKind.InsertUnlessConflict,\r\n    __element__: this.__element__,\r\n    __cardinality__: Cardinality.AtMostOne,\r\n    __expr__: this,\r\n    // __conflict__: Conflict;\r\n  };\r\n\r\n  if (!conflictGetter) {\r\n    expr.__conflict__ = { on: null };\r\n    return $expressionify(expr);\r\n  } else {\r\n    const scopedExpr = $getScopedExpr(this.__expr__);\r\n    const conflict = conflictGetter(scopedExpr);\r\n    expr.__conflict__ = conflict;\r\n    if (conflict.else) {\r\n      expr.__cardinality__ = conflict.else.__cardinality__;\r\n      if (this.__element__.__name__ !== conflict.else.__element__.__name__) {\r\n        expr.__element__ = $getTypeByName(\"std::Object\");\r\n      }\r\n    }\r\n    return $expressionify(expr);\r\n  }\r\n}\r\n\r\nexport function $insertify(\r\n  expr: Omit<$expr_Insert, \"unlessConflict\">\r\n): $expr_Insert {\r\n  (expr as any).unlessConflict = unlessConflict.bind(expr as any);\r\n  return expr as any;\r\n}\r\n\r\nexport function $normaliseInsertShape(\r\n  root: ObjectTypeSet,\r\n  shape: { [key: string]: any },\r\n  isUpdate: boolean = false\r\n): { [key: string]: TypeSet | { \"+=\": TypeSet } | { \"-=\": TypeSet } } {\r\n  const newShape: {\r\n    [key: string]: TypeSet | { \"+=\": TypeSet } | { \"-=\": TypeSet };\r\n  } = {};\r\n\r\n  const _shape: [string, any][] =\r\n    shape.__element__?.__kind__ === TypeKind.namedtuple\r\n      ? Object.keys((shape.__element__ as NamedTupleType).__shape__).map(\r\n          (key) => [key, shape[key]]\r\n        )\r\n      : Object.entries(shape);\r\n  for (const [key, _val] of _shape) {\r\n    let val = _val;\r\n    let setModify: string | null = null;\r\n    if (isUpdate && _val != null && typeof _val === \"object\") {\r\n      const valKeys = Object.keys(_val);\r\n      if (\r\n        valKeys.length === 1 &&\r\n        (valKeys[0] === \"+=\" || valKeys[0] === \"-=\")\r\n      ) {\r\n        val = _val[valKeys[0]];\r\n        setModify = valKeys[0];\r\n      }\r\n    }\r\n\r\n    const pointer = root.__element__.__pointers__[key];\r\n\r\n    // no pointer, not a link property\r\n    const isLinkProp = key[0] === \"@\";\r\n    if (!pointer && !isLinkProp) {\r\n      throw new Error(\r\n        `Could not find property pointer for ${\r\n          isUpdate ? \"update\" : \"insert\"\r\n        } shape key: '${key}'`\r\n      );\r\n    }\r\n\r\n    // skip undefined vals\r\n    if (val === undefined) continue;\r\n\r\n    // is val is expression, assign to newShape\r\n    if (val?.__kind__) {\r\n      // ranges can contain null values, so if the type is 'std::number'\r\n      // we need to set the type to the exact number type of the pointer\r\n      // so null casts are correct\r\n      if (\r\n        val.__kind__ === ExpressionKind.Literal &&\r\n        val.__element__.__kind__ === TypeKind.range &&\r\n        val.__element__.__element__.__name__ === \"std::number\"\r\n      ) {\r\n        newShape[key] = (literal as any)(pointer?.target, val.__value__);\r\n      } else {\r\n        newShape[key] = _val;\r\n      }\r\n      continue;\r\n    }\r\n\r\n    // handle link props\r\n    // after this guard, pointer definitely is defined\r\n    if (isLinkProp) {\r\n      throw new Error(\r\n        `Cannot assign plain data to link property '${key}'. Provide an expression instead.`\r\n      );\r\n    }\r\n    // Workaround to tell TypeScript pointer definitely is defined\r\n    if (!pointer) {\r\n      throw new Error(\r\n        \"Code will never reach here, but TypeScript cannot determine\"\r\n      );\r\n    }\r\n\r\n    // trying to assign plain data to a link\r\n    if (pointer.__kind__ !== \"property\" && val !== null) {\r\n      throw new Error(\r\n        `Must provide subquery when assigning to link '${key}' in ${\r\n          isUpdate ? \"update\" : \"insert\"\r\n        } query.`\r\n      );\r\n    }\r\n\r\n    // val is plain data\r\n    // key corresponds to pointer or starts with \"@\"\r\n    const isMulti =\r\n      pointer.cardinality === Cardinality.AtLeastOne ||\r\n      pointer.cardinality === Cardinality.Many;\r\n    if (pointer.__kind__ === \"property\") {\r\n      if (pointer.target.__name__ === \"std::json\") {\r\n      }\r\n    }\r\n\r\n    const wrappedVal =\r\n      val === null\r\n        ? cast(pointer.target, null)\r\n        : isMulti && Array.isArray(val)\r\n        ? val.length === 0\r\n          ? cast(pointer.target, null)\r\n          : set(...val.map((v) => (literal as any)(pointer.target, v)))\r\n        : (literal as any)(pointer.target, val);\r\n    newShape[key] = setModify\r\n      ? ({ [setModify]: wrappedVal } as any)\r\n      : wrappedVal;\r\n  }\r\n  return newShape;\r\n}\r\n\r\nexport function insert<Root extends $expr_PathNode>(\r\n  root: Root,\r\n  shape: InsertShape<Root[\"__element__\"]>\r\n): $expr_Insert<Root[\"__element__\"]> {\r\n  if (typeof shape !== \"object\") {\r\n    throw new Error(\r\n      `invalid insert shape.${\r\n        typeof shape === \"function\"\r\n          ? \" Hint: Insert shape is expected to be an object, \" +\r\n            \"not a function returning a shape object.\"\r\n          : \"\"\r\n      }`\r\n    );\r\n  }\r\n  const expr: any = {\r\n    __kind__: ExpressionKind.Insert,\r\n    __element__: root.__element__,\r\n    __cardinality__: Cardinality.One,\r\n    __expr__: root,\r\n    __shape__: $normaliseInsertShape(root, shape),\r\n  };\r\n  (expr as any).unlessConflict = unlessConflict.bind(expr);\r\n  return $expressionify($insertify(expr)) as any;\r\n}\r\n"},{"path":"json.mts","content":"import { ExpressionKind, TypeKind } from \"edgedb/dist/reflection/index.js\";\r\nimport type { ParamType } from \"./typesystem.mjs\";\r\nimport { encodeB64 } from \"edgedb/dist/primitives/buffer.js\";\r\nimport type { $expr_WithParams } from \"./params.mjs\";\r\n\r\nfunction jsonStringify(type: ParamType, val: any): string {\r\n  if (type.__kind__ === TypeKind.array) {\r\n    if (Array.isArray(val)) {\r\n      return `[${val\r\n        .map((item) => jsonStringify(type.__element__, item))\r\n        .join()}]`;\r\n    }\r\n    throw new Error(`Param with array type is not an array`);\r\n  }\r\n  if (type.__kind__ === TypeKind.tuple) {\r\n    if (!Array.isArray(val)) {\r\n      throw new Error(`Param with tuple type is not an array`);\r\n    }\r\n    if (val.length !== type.__items__.length) {\r\n      throw new Error(\r\n        `Param with tuple type has incorrect number of items. Got ${val.length} expected ${type.__items__.length}`\r\n      );\r\n    }\r\n    return `[${val\r\n      .map((item, i) => jsonStringify(type.__items__[i]!, item))\r\n      .join()}]`;\r\n  }\r\n  if (type.__kind__ === TypeKind.namedtuple) {\r\n    if (typeof val !== \"object\") {\r\n      throw new Error(`Param with named tuple type is not an object`);\r\n    }\r\n    if (Object.keys(val).length !== Object.keys(type.__shape__).length) {\r\n      throw new Error(\r\n        `Param with named tuple type has incorrect number of items. Got ${\r\n          Object.keys(val).length\r\n        } expected ${Object.keys(type.__shape__).length}`\r\n      );\r\n    }\r\n    return `{${Object.entries(val)\r\n      .map(([key, item]) => {\r\n        if (!type.__shape__[key]) {\r\n          throw new Error(\r\n            `Unexpected key in named tuple param: ${key}, expected keys: ${Object.keys(\r\n              type.__shape__\r\n            ).join()}`\r\n          );\r\n        }\r\n        return `\"${key}\": ${jsonStringify(type.__shape__[key]!, item)}`;\r\n      })\r\n      .join()}}`;\r\n  }\r\n  if (\r\n    type.__kind__ === TypeKind.scalar\r\n    // || type.__kind__ === TypeKind.castonlyscalar\r\n  ) {\r\n    switch (type.__name__) {\r\n      case \"std::bigint\":\r\n        return val.toString();\r\n      case \"std::json\":\r\n        return JSON.stringify(val);\r\n      case \"std::bytes\":\r\n        return `\"${encodeB64(val)}\"`;\r\n      case \"cfg::memory\":\r\n        return `\"${val.toString()}\"`;\r\n      default:\r\n        return JSON.stringify(val);\r\n    }\r\n  }\r\n  if (type.__kind__ === TypeKind.enum) {\r\n    return JSON.stringify(val);\r\n  }\r\n  throw new Error(`Invalid param type: ${(type as any).__kind__}`);\r\n}\r\n\r\nexport function jsonifyComplexParams(expr: any, _args: any) {\r\n  if (_args && expr.__kind__ === ExpressionKind.WithParams) {\r\n    const args = { ..._args };\r\n    for (const param of (expr as $expr_WithParams).__params__) {\r\n      if (param.__isComplex__) {\r\n        args[param.__name__] = jsonStringify(\r\n          param.__element__ as any,\r\n          args[param.__name__]\r\n        );\r\n      }\r\n    }\r\n\r\n    return args;\r\n  }\r\n  return _args;\r\n}\r\n"},{"path":"literal.mts","content":"import type {\r\n  Expression,\r\n  BaseType,\r\n  BaseTypeToTsType,\r\n  ScalarType,\r\n} from \"./typesystem.mjs\";\r\n\r\n// import {\r\n//   Cardinality,\r\n//   ExpressionKind,\r\n//   BaseType,\r\n//   BaseTypeToTsType,\r\n//   makeType,\r\n//   ScalarType\r\n// } from \"edgedb/dist/reflection/index.js\";\r\n\r\n// import type {$expr_Literal} from \"./literal.mjs\";\r\nimport { $expressionify } from \"./path.mjs\";\r\nimport { spec } from \"./__spec__.mjs\";\r\nimport { Cardinality, ExpressionKind } from \"edgedb/dist/reflection/index.js\";\r\nimport { makeType } from \"./hydrate.mjs\";\r\n\r\nexport type $expr_Literal<Type extends BaseType = BaseType> = Expression<{\r\n  __element__: Type;\r\n  __cardinality__: Cardinality.One;\r\n  __kind__: ExpressionKind.Literal;\r\n  __value__: any;\r\n}>;\r\n\r\nexport function literal<T extends BaseType>(\r\n  type: T,\r\n  value: BaseTypeToTsType<T>\r\n): $expr_Literal<T> {\r\n  return $expressionify({\r\n    __element__: type,\r\n    __cardinality__: Cardinality.One,\r\n    __kind__: ExpressionKind.Literal,\r\n    __value__: value,\r\n  }) as any;\r\n}\r\n\r\nexport const $nameMapping = new Map<string, string>([\r\n  ...([...spec.values()].map((type) => [type.name, type.id]) as any),\r\n  [\"std::number\", \"00000000-0000-0000-0000-0000000001ff\"],\r\n]);\r\n\r\nexport function $getType(id: string): (val: any) => $expr_Literal<ScalarType> {\r\n  return makeType(spec, id, literal) as any;\r\n}\r\n\r\nexport function $getTypeByName(\r\n  name: string\r\n): (val: any) => $expr_Literal<ScalarType> {\r\n  return makeType(spec, $nameMapping.get(name)!, literal) as any;\r\n}\r\n"},{"path":"operators.mts","content":"export declare function op(...args: any[]): any;\r\n"},{"path":"params.mts","content":"import type { Executor } from \"edgedb\";\r\nimport {\r\n  ExpressionKind,\r\n  Cardinality,\r\n  TypeKind,\r\n} from \"edgedb/dist/reflection/index.js\";\r\nimport type {\r\n  Expression,\r\n  ParamType,\r\n  setToTsType,\r\n  TypeSet,\r\n  BaseTypeToTsType,\r\n} from \"./typesystem.mjs\";\r\nimport { $expressionify } from \"./path.mjs\";\r\nimport { runnableExpressionKinds } from \"./query.mjs\";\r\nimport { select } from \"./select.mjs\";\r\nimport { complexParamKinds } from \"./__spec__.mjs\";\r\n\r\ntype Param = ParamType | $expr_OptionalParam;\r\n\r\ntype ParamsRecord = Record<string, Param>;\r\n\r\nexport type $expr_OptionalParam<Type extends ParamType = ParamType> = {\r\n  __kind__: ExpressionKind.OptionalParam;\r\n  __type__: Type;\r\n};\r\n\r\nexport function optional<Type extends ParamType>(\r\n  type: Type\r\n): $expr_OptionalParam<Type> {\r\n  return {\r\n    __kind__: ExpressionKind.OptionalParam,\r\n    __type__: type,\r\n  };\r\n}\r\n\r\nexport type QueryableWithParamsExpression<\r\n  Set extends TypeSet = TypeSet,\r\n  Params extends ParamsRecord = Record<string, never>\r\n> = Expression<Set, false> & {\r\n  run(\r\n    cxn: Executor,\r\n    args: paramsToParamArgs<Params>\r\n  ): Promise<setToTsType<Set>>;\r\n  runJSON(cxn: Executor, args: paramsToParamArgs<Params>): Promise<string>;\r\n};\r\n\r\nexport type $expr_WithParams<\r\n  Params extends ParamsRecord = Record<string, never>,\r\n  Expr extends TypeSet = TypeSet\r\n> = QueryableWithParamsExpression<\r\n  {\r\n    __kind__: ExpressionKind.WithParams;\r\n    __element__: Expr[\"__element__\"];\r\n    __cardinality__: Expr[\"__cardinality__\"];\r\n    __expr__: Expr;\r\n    __params__: $expr_Param[];\r\n  },\r\n  Params\r\n>;\r\n\r\ntype paramsToParamArgs<Params extends ParamsRecord> = {\r\n  [key in keyof Params as Params[key] extends ParamType\r\n    ? key\r\n    : never]: Params[key] extends ParamType\r\n    ? Readonly<BaseTypeToTsType<Params[key], true>>\r\n    : never;\r\n} & {\r\n  [key in keyof Params as Params[key] extends $expr_OptionalParam\r\n    ? key\r\n    : never]?: Params[key] extends $expr_OptionalParam\r\n    ? Readonly<BaseTypeToTsType<Params[key][\"__type__\"], true> | null>\r\n    : never;\r\n};\r\n\r\nexport type $expr_Param<\r\n  Name extends string | number | symbol = string,\r\n  Type extends ParamType = ParamType,\r\n  Optional extends boolean = boolean\r\n> = Expression<{\r\n  __kind__: ExpressionKind.Param;\r\n  __element__: Type;\r\n  __cardinality__: Optional extends true\r\n    ? Cardinality.AtMostOne\r\n    : Cardinality.One;\r\n  __name__: Name;\r\n  __isComplex__: boolean;\r\n}>;\r\n\r\ntype paramsToParamExprs<Params extends ParamsRecord> = {\r\n  [key in keyof Params]: Params[key] extends $expr_OptionalParam\r\n    ? $expr_Param<key, Params[key][\"__type__\"], true>\r\n    : Params[key] extends ParamType\r\n    ? $expr_Param<key, Params[key], false>\r\n    : never;\r\n};\r\n\r\nexport function params<\r\n  Params extends ParamsRecord = Record<string, never>,\r\n  Expr extends Expression = Expression\r\n>(\r\n  paramsDef: Params,\r\n  expr: (params: paramsToParamExprs<Params>) => Expr\r\n): $expr_WithParams<Params, Expr> {\r\n  const paramExprs: { [key: string]: $expr_Param } = {};\r\n  for (const [key, param] of Object.entries(paramsDef)) {\r\n    const paramType =\r\n      param.__kind__ === ExpressionKind.OptionalParam ? param.__type__ : param;\r\n    const isComplex =\r\n      complexParamKinds.has(paramType.__kind__) ||\r\n      (paramType.__kind__ === TypeKind.array &&\r\n        complexParamKinds.has(paramType.__element__.__kind__));\r\n    paramExprs[key] = $expressionify({\r\n      __kind__: ExpressionKind.Param,\r\n      __element__: paramType,\r\n      __cardinality__:\r\n        param.__kind__ === ExpressionKind.OptionalParam\r\n          ? Cardinality.AtMostOne\r\n          : Cardinality.One,\r\n      __name__: key,\r\n      __isComplex__: isComplex,\r\n    }) as any;\r\n  }\r\n\r\n  let returnExpr = expr(paramExprs as any);\r\n\r\n  if (!runnableExpressionKinds.has((returnExpr as any).__kind__)) {\r\n    returnExpr = select(returnExpr) as any;\r\n  }\r\n\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.WithParams,\r\n    __element__: returnExpr.__element__,\r\n    __cardinality__: returnExpr.__cardinality__,\r\n    __expr__: returnExpr,\r\n    __params__: Object.values(paramExprs),\r\n  }) as any;\r\n}\r\n"},{"path":"path.mts","content":"import {\r\n  // cardutil,\r\n  // ObjectTypeSet,\r\n  // TypeSet,\r\n  // Expression,\r\n  ExpressionKind,\r\n  TypeKind,\r\n  // LinkDesc,\r\n  // PropertyDesc,\r\n  Cardinality,\r\n  // BaseType,\r\n  type typeutil,\r\n} from \"edgedb/dist/reflection/index.js\";\r\n\r\nimport { cardutil } from \"./cardinality.mjs\";\r\n\r\nimport { literalToTypeSet } from \"./castMaps.mjs\";\r\nimport { $arrayLikeIndexify, $tuplePathify } from \"./collections.mjs\";\r\nimport { $toEdgeQL } from \"./toEdgeQL.mjs\";\r\nimport { $queryFunc, $queryFuncJSON } from \"./query.mjs\";\r\n\r\nimport type {\r\n  BaseType,\r\n  Expression,\r\n  LinkDesc,\r\n  ObjectType,\r\n  ObjectTypePointers,\r\n  ObjectTypeSet,\r\n  PropertyDesc,\r\n  PropertyShape,\r\n  TypeSet,\r\n} from \"./typesystem.mjs\";\r\n// import {typeutil} from \"./typeutil.mjs\";\r\n// import {cardutil} from \"./cardinality.mjs\";\r\n\r\n// get the set representing the result of a path traversal\r\n// including cardinality merging\r\ntype getChildOfObjectTypeSet<\r\n  Root extends ObjectTypeSet,\r\n  ChildKey extends keyof Root[\"__element__\"][\"__pointers__\"]\r\n> = TypeSet<\r\n  Root[\"__element__\"][\"__pointers__\"][ChildKey][\"target\"],\r\n  cardutil.multiplyCardinalities<\r\n    Root[\"__cardinality__\"],\r\n    Root[\"__element__\"][\"__pointers__\"][ChildKey][\"cardinality\"]\r\n  >\r\n>;\r\n\r\n// path parent must be object expression\r\nexport interface PathParent<\r\n  Parent extends ObjectTypeSet = ObjectTypeSet,\r\n  L extends string = string\r\n> {\r\n  type: Parent;\r\n  linkName: L;\r\n}\r\n\r\nexport type $linkPropify<Root extends ObjectTypeSet> = Root extends {\r\n  __parent__: PathParent<infer Parent, infer L>;\r\n}\r\n  ? // tslint:disable-next-line\r\n    Parent[\"__element__\"][\"__pointers__\"][L] extends LinkDesc<\r\n      any,\r\n      any,\r\n      infer LinkProps,\r\n      any,\r\n      any,\r\n      any,\r\n      any\r\n    >\r\n    ? pathifyLinkProps<LinkProps, Root, PathParent<Parent, L>>\r\n    : {}\r\n  : unknown;\r\n\r\nexport type $pathify<\r\n  Root extends TypeSet\r\n  // Parent extends PathParent | null = null\r\n> = Root extends ObjectTypeSet\r\n  ? ObjectTypeSet extends Root\r\n    ? {} // Root is literally ObjectTypeSet\r\n    : pathifyPointers<Root> & pathifyShape<Root> & $linkPropify<Root>\r\n  : {}; // pathify does nothing on non-object types\r\n\r\nexport type pathifyPointers<\r\n  Root extends ObjectTypeSet\r\n  // Parent extends PathParent | null = null\r\n> = ObjectTypePointers extends Root[\"__element__\"][\"__pointers__\"]\r\n  ? unknown\r\n  : {\r\n      // & string required to avoid typeError on linkName\r\n      [k in keyof Root[\"__element__\"][\"__pointers__\"] &\r\n        string]: Root[\"__element__\"][\"__pointers__\"][k] extends PropertyDesc\r\n        ? $expr_PathLeaf<\r\n            getChildOfObjectTypeSet<Root, k>,\r\n            { type: anonymizeObjectTypeSet<Root>; linkName: k }\r\n            // Root[\"__element__\"][\"__pointers__\"][k][\"exclusive\"]\r\n          >\r\n        : Root[\"__element__\"][\"__pointers__\"][k] extends LinkDesc\r\n        ? getChildOfObjectTypeSet<Root, k> extends ObjectTypeSet\r\n          ? $expr_PathNode<\r\n              getChildOfObjectTypeSet<Root, k>,\r\n              { type: anonymizeObjectTypeSet<Root>; linkName: k }\r\n              // Root[\"__element__\"][\"__pointers__\"][k][\"exclusive\"]\r\n            >\r\n          : unknown\r\n        : unknown;\r\n    };\r\n\r\ntype anonymizeObjectTypeSet<T extends ObjectTypeSet> = typeutil.flatten<{\r\n  __element__: ObjectType<\r\n    T[\"__element__\"][\"__name__\"],\r\n    T[\"__element__\"][\"__pointers__\"],\r\n    { id: true }\r\n  >;\r\n  __cardinality__: T[\"__cardinality__\"];\r\n}>;\r\n\r\nexport type pathifyShape<\r\n  Root extends ObjectTypeSet,\r\n  Shape extends { [k: string]: any } = Root[\"__element__\"][\"__shape__\"]\r\n> = string extends keyof Shape\r\n  ? {}\r\n  : {\r\n      [k in keyof Shape & string]: Shape[k] extends ObjectTypeSet\r\n        ? $expr_PathNode<\r\n            TypeSet<\r\n              Shape[k][\"__element__\"],\r\n              cardutil.multiplyCardinalities<\r\n                Root[\"__cardinality__\"],\r\n                Shape[k][\"__cardinality__\"]\r\n              >\r\n            >,\r\n            { type: Root; linkName: k }\r\n            // false\r\n          >\r\n        : Shape[k] extends TypeSet\r\n        ? $expr_PathLeaf<\r\n            TypeSet<\r\n              Shape[k][\"__element__\"],\r\n              cardutil.multiplyCardinalities<\r\n                Root[\"__cardinality__\"],\r\n                Shape[k][\"__cardinality__\"]\r\n              >\r\n            >,\r\n            { type: Root; linkName: k }\r\n            // false\r\n          >\r\n        : // must be unknown (not never) to avoid overriding\r\n          // a pointer with the same key\r\n          unknown;\r\n    };\r\n\r\ntype pathifyLinkProps<\r\n  Props extends PropertyShape,\r\n  Root extends ObjectTypeSet,\r\n  Parent extends PathParent | null = null\r\n> = {\r\n  [k in keyof Props & string]: Props[k] extends PropertyDesc\r\n    ? $expr_PathLeaf<\r\n        TypeSet<\r\n          Props[k][\"target\"],\r\n          cardutil.multiplyCardinalities<\r\n            Root[\"__cardinality__\"],\r\n            Props[k][\"cardinality\"]\r\n          >\r\n        >,\r\n        { type: $expr_PathNode<Root, Parent>; linkName: k }\r\n        // {type: $expr_PathNode<Root>; linkName: k},\r\n        // Props[k][\"exclusive\"]\r\n      >\r\n    : unknown;\r\n};\r\n\r\nexport type getPropsShape<T extends ObjectType> = typeutil.flatten<\r\n  typeutil.stripNever<{\r\n    [k in keyof T[\"__pointers__\"]]: T[\"__pointers__\"][k][\"__kind__\"] extends \"property\"\r\n      ? true\r\n      : never;\r\n  }>\r\n>;\r\n\r\nexport type $expr_PathNode<\r\n  Root extends ObjectTypeSet = ObjectTypeSet,\r\n  Parent extends PathParent | null = PathParent | null\r\n  // Exclusive extends boolean = boolean\r\n> = Expression<{\r\n  __element__: Root[\"__element__\"];\r\n  __cardinality__: Root[\"__cardinality__\"];\r\n  __parent__: Parent;\r\n  __kind__: ExpressionKind.PathNode;\r\n  // __exclusive__: boolean;\r\n  \"*\": getPropsShape<Root[\"__element__\"]>;\r\n}>;\r\n\r\nexport type $expr_TypeIntersection<\r\n  Card extends Cardinality = Cardinality,\r\n  Intersection extends ObjectType = ObjectType\r\n> = Expression<{\r\n  __element__: Intersection;\r\n  __cardinality__: Card;\r\n  __kind__: ExpressionKind.TypeIntersection;\r\n  __expr__: TypeSet;\r\n}>;\r\n\r\nexport type $expr_PathLeaf<\r\n  Root extends TypeSet = TypeSet,\r\n  Parent extends PathParent = PathParent\r\n  // Exclusive extends boolean = boolean\r\n> = Expression<{\r\n  __element__: Root[\"__element__\"];\r\n  __cardinality__: Root[\"__cardinality__\"];\r\n  __kind__: ExpressionKind.PathLeaf;\r\n  __parent__: Parent;\r\n  // __exclusive__: boolean;\r\n}>;\r\n\r\nexport type ExpressionRoot = {\r\n  __element__: BaseType;\r\n  __cardinality__: Cardinality;\r\n  __kind__: ExpressionKind;\r\n};\r\n\r\nfunction PathLeaf<\r\n  Root extends TypeSet,\r\n  Parent extends PathParent,\r\n  Exclusive extends boolean = boolean\r\n>(\r\n  root: Root,\r\n  parent: Parent,\r\n  exclusive: Exclusive,\r\n  scopeRoot: TypeSet | null = null\r\n): $expr_PathLeaf<Root, Parent> {\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.PathLeaf,\r\n    __element__: root.__element__,\r\n    __cardinality__: root.__cardinality__,\r\n    __parent__: parent,\r\n    // __exclusive__: exclusive,\r\n    __scopeRoot__: scopeRoot,\r\n  }) as any;\r\n}\r\n\r\nfunction getStarShapeFromPointers(pointers: ObjectTypePointers) {\r\n  const shape: any = {};\r\n  for (const [key, ptr] of Object.entries(pointers)) {\r\n    if (ptr.__kind__ === \"property\") {\r\n      shape[key] = true;\r\n    }\r\n  }\r\n  return shape;\r\n}\r\n\r\nfunction PathNode<\r\n  Root extends ObjectTypeSet,\r\n  Parent extends PathParent | null\r\n  // Exclusive extends boolean = boolean\r\n>(\r\n  root: Root,\r\n  parent: Parent,\r\n  // exclusive: boolean,\r\n  scopeRoot: TypeSet | null = null\r\n): $expr_PathNode<Root, Parent> {\r\n  const obj = {\r\n    __kind__: ExpressionKind.PathNode,\r\n    __element__: root.__element__,\r\n    __cardinality__: root.__cardinality__,\r\n    __parent__: parent,\r\n    // __exclusive__: exclusive,\r\n    __scopeRoot__: scopeRoot,\r\n  };\r\n\r\n  Object.defineProperty(obj, \"*\", {\r\n    writable: false,\r\n    value: getStarShapeFromPointers(obj.__element__.__pointers__),\r\n  });\r\n  return $expressionify(obj) as any;\r\n}\r\n\r\nconst _pathCache = Symbol();\r\nconst _pointers = Symbol();\r\n\r\nconst pathifyProxyHandlers: ProxyHandler<any> = {\r\n  get(target: any, prop: string | symbol, proxy: any) {\r\n    const ptr = target[_pointers][prop as any] as LinkDesc | PropertyDesc;\r\n    if (ptr) {\r\n      return (\r\n        target[_pathCache][prop] ??\r\n        (target[_pathCache][prop] = (\r\n          (ptr.__kind__ === \"property\" ? PathLeaf : PathNode) as any\r\n        )(\r\n          {\r\n            __element__: ptr.target,\r\n            __cardinality__: cardutil.multiplyCardinalities(\r\n              target.__cardinality__,\r\n              ptr.cardinality\r\n            ),\r\n          },\r\n          {\r\n            linkName: prop,\r\n            type: proxy,\r\n          },\r\n          ptr.exclusive ?? false,\r\n          target.__scopeRoot__ ?? (scopeRoots.has(proxy) ? proxy : null)\r\n        ))\r\n      );\r\n    }\r\n    return target[prop];\r\n  },\r\n};\r\n\r\nexport function $pathify<Root extends TypeSet, Parent extends PathParent>(\r\n  _root: Root\r\n): $pathify<Root> {\r\n  if (_root.__element__.__kind__ !== TypeKind.object) {\r\n    return _root as any;\r\n  }\r\n\r\n  const root: $expr_PathNode<ObjectTypeSet> = _root as any;\r\n\r\n  let pointers = {\r\n    ...root.__element__.__pointers__,\r\n  };\r\n\r\n  if (root.__parent__) {\r\n    const { type, linkName } = root.__parent__;\r\n    const parentPointer = type.__element__.__pointers__[linkName];\r\n    if (parentPointer?.__kind__ === \"link\") {\r\n      pointers = { ...pointers, ...parentPointer.properties };\r\n    }\r\n  }\r\n\r\n  for (const [key, val] of Object.entries(\r\n    root.__element__.__shape__ || { id: true }\r\n  )) {\r\n    if (pointers[key]) continue;\r\n    const valType: BaseType = (val as any)?.__element__;\r\n    if (!valType) continue;\r\n\r\n    pointers[key] = {\r\n      __kind__: valType.__kind__ === TypeKind.object ? \"link\" : \"property\",\r\n      properties: {},\r\n      target: (val as any).__element__,\r\n      cardinality: (val as any).__cardinality__,\r\n      exclusive: false,\r\n      computed: true,\r\n      readonly: true,\r\n      hasDefault: false,\r\n    };\r\n  }\r\n\r\n  (root as any)[_pointers] = pointers;\r\n  (root as any)[_pathCache] = {};\r\n\r\n  return new Proxy(root, pathifyProxyHandlers);\r\n}\r\n\r\nfunction isFunc(this: any, expr: ObjectTypeSet) {\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.TypeIntersection,\r\n    __cardinality__: this.__cardinality__,\r\n    __element__: {\r\n      ...expr.__element__,\r\n      __shape__: { id: true },\r\n    } as any,\r\n    __expr__: this,\r\n  });\r\n}\r\n\r\nexport function $assert_single(expr: Expression) {\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.Function,\r\n    __element__: expr.__element__,\r\n    __cardinality__: cardutil.overrideUpperBound(expr.__cardinality__, \"One\"),\r\n    __name__: \"std::assert_single\",\r\n    __args__: [expr],\r\n    __namedargs__: {},\r\n  }) as any;\r\n}\r\n\r\nconst jsonDestructureProxyHandlers: ProxyHandler<ExpressionRoot> = {\r\n  get(target: ExpressionRoot, prop: string | symbol, proxy: any) {\r\n    if (typeof prop === \"string\" && !(prop in target)) {\r\n      const parsedProp = Number.isInteger(Number(prop)) ? Number(prop) : prop;\r\n      return jsonDestructure.call(proxy, parsedProp);\r\n    }\r\n    return (target as any)[prop];\r\n  },\r\n};\r\n\r\nfunction jsonDestructure(this: ExpressionRoot, path: any) {\r\n  const pathTypeSet = literalToTypeSet(path);\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.Operator,\r\n    __element__: this.__element__,\r\n    __cardinality__: cardutil.multiplyCardinalities(\r\n      this.__cardinality__,\r\n      pathTypeSet.__cardinality__\r\n    ),\r\n    __name__: \"[]\",\r\n    __opkind__: \"Infix\",\r\n    __args__: [this, pathTypeSet],\r\n  }) as any;\r\n}\r\n\r\nexport function $jsonDestructure(_expr: ExpressionRoot) {\r\n  if (\r\n    _expr.__element__.__kind__ === TypeKind.scalar &&\r\n    _expr.__element__.__name__ === \"std::json\"\r\n  ) {\r\n    const expr = new Proxy(_expr, jsonDestructureProxyHandlers) as any;\r\n\r\n    expr.destructure = jsonDestructure.bind(expr);\r\n\r\n    return expr;\r\n  }\r\n\r\n  return _expr;\r\n}\r\n\r\nexport function $expressionify<T extends ExpressionRoot>(\r\n  _expr: T\r\n): Expression<T> {\r\n  const expr: Expression = $pathify(\r\n    $jsonDestructure($arrayLikeIndexify($tuplePathify(_expr)))\r\n  ) as any;\r\n\r\n  expr.run = $queryFunc.bind(expr) as any;\r\n  expr.runJSON = $queryFuncJSON.bind(expr) as any;\r\n  expr.is = isFunc.bind(expr) as any;\r\n  expr.toEdgeQL = $toEdgeQL.bind(expr);\r\n  expr.assert_single = () => $assert_single(expr) as any;\r\n\r\n  return Object.freeze(expr) as any;\r\n}\r\n\r\nconst scopedExprCache = new WeakMap<ExpressionRoot, Expression>();\r\nconst scopeRoots = new WeakSet<Expression>();\r\n\r\nexport function $getScopedExpr<T extends ExpressionRoot>(\r\n  expr: T,\r\n  existingScopes?: Set<Expression>\r\n): Expression<T> {\r\n  let scopedExpr = scopedExprCache.get(expr);\r\n  if (!scopedExpr || existingScopes?.has(scopedExpr)) {\r\n    // free objects should not be scopified\r\n    const isFreeObject =\r\n      expr.__cardinality__ === Cardinality.One &&\r\n      expr.__element__.__name__ === \"std::FreeObject\";\r\n\r\n    scopedExpr = isFreeObject\r\n      ? (expr as any as Expression<TypeSet<BaseType, Cardinality>>)\r\n      : $expressionify({\r\n          ...expr,\r\n          __cardinality__: Cardinality.One,\r\n          __scopedFrom__: expr,\r\n          ...(expr.__element__.__kind__ === TypeKind.object\r\n            ? {\r\n                \"*\": getStarShapeFromPointers(\r\n                  (expr.__element__ as ObjectType).__pointers__\r\n                ),\r\n              }\r\n            : {}),\r\n        });\r\n    scopeRoots.add(scopedExpr);\r\n    const uncached = !scopedExpr;\r\n    if (uncached) {\r\n      scopedExprCache.set(expr, scopedExpr);\r\n    }\r\n  }\r\n  existingScopes?.add(scopedExpr);\r\n  return scopedExpr as any;\r\n}\r\n\r\nexport { PathLeaf as $PathLeaf, PathNode as $PathNode };\r\n"},{"path":"query.mts","content":"import type * as edgedb from \"edgedb\";\r\nimport { Cardinality, ExpressionKind } from \"edgedb/dist/reflection/index.js\";\r\nimport { jsonifyComplexParams } from \"./json.mjs\";\r\nimport { select } from \"./select.mjs\";\r\n\r\nexport const runnableExpressionKinds = new Set([\r\n  ExpressionKind.Select,\r\n  ExpressionKind.Update,\r\n  ExpressionKind.Insert,\r\n  ExpressionKind.InsertUnlessConflict,\r\n  ExpressionKind.Delete,\r\n  ExpressionKind.Group,\r\n  ExpressionKind.For,\r\n  ExpressionKind.With,\r\n  ExpressionKind.WithParams,\r\n]);\r\n\r\nconst wrappedExprCache = new WeakMap();\r\n\r\nexport async function $queryFunc(this: any, cxn: edgedb.Executor, args: any) {\r\n  const expr = runnableExpressionKinds.has(this.__kind__)\r\n    ? this\r\n    : wrappedExprCache.get(this) ??\r\n      wrappedExprCache.set(this, select(this)).get(this);\r\n\r\n  const _args = jsonifyComplexParams(expr, args);\r\n\r\n  const query = expr.toEdgeQL();\r\n\r\n  if (\r\n    expr.__cardinality__ === Cardinality.One ||\r\n    expr.__cardinality__ === Cardinality.AtMostOne ||\r\n    expr.__cardinality__ === Cardinality.Empty\r\n  ) {\r\n    return cxn.querySingle(query, _args);\r\n  } else {\r\n    return cxn.query(query, _args);\r\n  }\r\n}\r\n\r\nexport async function $queryFuncJSON(\r\n  this: any,\r\n  cxn: edgedb.Executor,\r\n  args: any\r\n) {\r\n  const expr = runnableExpressionKinds.has(this.__kind__)\r\n    ? this\r\n    : wrappedExprCache.get(this) ??\r\n      wrappedExprCache.set(this, select(this)).get(this);\r\n  const _args = jsonifyComplexParams(expr, args);\r\n\r\n  if (\r\n    expr.__cardinality__ === Cardinality.One ||\r\n    expr.__cardinality__ === Cardinality.AtMostOne\r\n  ) {\r\n    return cxn.querySingleJSON(expr.toEdgeQL(), _args);\r\n  } else {\r\n    return cxn.queryJSON(expr.toEdgeQL(), _args);\r\n  }\r\n}\r\n"},{"path":"range.mts","content":"import type { LocalDate, LocalDateTime, Duration } from \"edgedb\";\r\nimport { Range } from \"edgedb\";\r\nimport { TypeKind, ExpressionKind } from \"edgedb/dist/reflection/index.js\";\r\n\r\nimport type { cardutil } from \"./cardinality.mjs\";\r\nimport type {\r\n  RangeType,\r\n  getPrimitiveBaseType,\r\n  TypeSet,\r\n  BaseType,\r\n} from \"./typesystem.mjs\";\r\nimport type { $expr_Literal } from \"./literal.mjs\";\r\n\r\nimport type {\r\n  $number,\r\n  $decimal,\r\n  $datetime,\r\n  $duration,\r\n  $bool,\r\n} from \"./modules/std.mjs\";\r\nimport type { $local_date, $local_datetime } from \"./modules/cal.mjs\";\r\nimport type { literalToScalarType, orScalarLiteral } from \"./castMaps.mjs\";\r\nimport { literalToTypeSet } from \"./castMaps.mjs\";\r\nimport { spec } from \"./__spec__.mjs\";\r\nimport { literal, $nameMapping } from \"./literal.mjs\";\r\nimport { type $expr_Function, $resolveOverload } from \"./funcops.mjs\";\r\nimport { $expressionify } from \"./path.mjs\";\r\n\r\ntype $anypoint =\r\n  | $number\r\n  | $local_date\r\n  | $decimal\r\n  | $datetime\r\n  | $local_datetime\r\n  | $duration;\r\n\r\nfunction range<Element extends $anypoint>(element: Element): RangeType<Element>;\r\nfunction range<T extends number | Date | LocalDate | LocalDateTime | Duration>(\r\n  val: Range<T>\r\n): $expr_Literal<RangeType<getPrimitiveBaseType<literalToScalarType<T>>>>;\r\nfunction range<\r\n  NamedArgs extends {\r\n    inc_lower?: orScalarLiteral<TypeSet<$bool>>;\r\n    inc_upper?: orScalarLiteral<TypeSet<$bool>>;\r\n    empty?: orScalarLiteral<TypeSet<$bool>>;\r\n  },\r\n  P1 extends orScalarLiteral<TypeSet<$anypoint>> | undefined,\r\n  P2 extends\r\n    | orScalarLiteral<\r\n        TypeSet<\r\n          BaseType extends literalToScalarType<P1>\r\n            ? $anypoint\r\n            : getPrimitiveBaseType<literalToScalarType<P1>>\r\n        >\r\n      >\r\n    | undefined\r\n>(\r\n  namedArgs: NamedArgs,\r\n  lower?: P1,\r\n  upper?: P2\r\n): $expr_Function<\r\n  // \"std::range\",\r\n  // mapLiteralToTypeSet<[P1, P2]>,\r\n  // mapLiteralToTypeSet<NamedArgs>,\r\n  // TypeSet<\r\n  RangeType<\r\n    literalToScalarType<P1> extends $anypoint\r\n      ? literalToScalarType<P1>\r\n      : literalToScalarType<P2> extends $anypoint\r\n      ? literalToScalarType<P2>\r\n      : $anypoint\r\n  >,\r\n  cardutil.multiplyCardinalities<\r\n    cardutil.multiplyCardinalities<\r\n      cardutil.multiplyCardinalities<\r\n        cardutil.multiplyCardinalities<\r\n          cardutil.optionalParamCardinality<P1>,\r\n          cardutil.optionalParamCardinality<P2>\r\n        >,\r\n        cardutil.optionalParamCardinality<NamedArgs[\"inc_lower\"]>\r\n      >,\r\n      cardutil.optionalParamCardinality<NamedArgs[\"inc_upper\"]>\r\n    >,\r\n    cardutil.optionalParamCardinality<NamedArgs[\"empty\"]>\r\n  >\r\n  // >\r\n>;\r\nfunction range<\r\n  P1 extends orScalarLiteral<TypeSet<$anypoint>> | undefined,\r\n  P2 extends\r\n    | orScalarLiteral<\r\n        TypeSet<\r\n          BaseType extends literalToScalarType<P1>\r\n            ? $anypoint\r\n            : getPrimitiveBaseType<literalToScalarType<P1>>\r\n        >\r\n      >\r\n    | undefined\r\n>(\r\n  lower?: P1,\r\n  upper?: P2\r\n): $expr_Function<\r\n  // \"std::range\",\r\n  // mapLiteralToTypeSet<[P1, P2]>,\r\n  // {},\r\n  // TypeSet<\r\n  RangeType<\r\n    literalToScalarType<P1> extends $anypoint\r\n      ? literalToScalarType<P1>\r\n      : literalToScalarType<P2> extends $anypoint\r\n      ? literalToScalarType<P2>\r\n      : $anypoint\r\n  >,\r\n  cardutil.multiplyCardinalities<\r\n    cardutil.optionalParamCardinality<P1>,\r\n    cardutil.optionalParamCardinality<P2>\r\n  >\r\n  // >\r\n>;\r\nfunction range(...args: any[]): any {\r\n  if (args.length === 1) {\r\n    const arg = args[0];\r\n    if (arg instanceof Range) {\r\n      if (arg.lower === null && arg.upper === null) {\r\n        throw new Error(\r\n          `Can't create literal expression from unbounded range. Try this instead:\\n\\n  e.range(e.cast(e.int64, e.set()), e.cast(e.int64, e.set()))`\r\n        );\r\n      }\r\n      if (arg.isEmpty) {\r\n        throw new Error(`Can't create literal expression from empty range.`);\r\n      }\r\n      return literal(\r\n        range(literalToTypeSet(arg.lower ?? arg.upper).__element__ as any),\r\n        arg\r\n      );\r\n    }\r\n    if (arg.__kind__ && !arg.__element__) {\r\n      return {\r\n        __kind__: TypeKind.range,\r\n        __name__: `range<${arg.__name__}>`,\r\n        __element__: arg,\r\n      } as any;\r\n    }\r\n  }\r\n  const {\r\n    returnType,\r\n    cardinality,\r\n    args: positionalArgs,\r\n    namedArgs,\r\n  } = $resolveOverload(\"std::range\", args, spec, [\r\n    {\r\n      args: [\r\n        {\r\n          typeId: $nameMapping.get(\"std::anypoint\")!,\r\n          optional: true,\r\n          setoftype: false,\r\n          variadic: false,\r\n        },\r\n        {\r\n          typeId: $nameMapping.get(\"std::anypoint\")!,\r\n          optional: true,\r\n          setoftype: false,\r\n          variadic: false,\r\n        },\r\n      ],\r\n      namedArgs: {\r\n        inc_lower: {\r\n          typeId: $nameMapping.get(\"std::bool\")!,\r\n          optional: true,\r\n          setoftype: false,\r\n          variadic: false,\r\n        },\r\n        inc_upper: {\r\n          typeId: $nameMapping.get(\"std::bool\")!,\r\n          optional: true,\r\n          setoftype: false,\r\n          variadic: false,\r\n        },\r\n        empty: {\r\n          typeId: $nameMapping.get(\"std::bool\")!,\r\n          optional: true,\r\n          setoftype: false,\r\n          variadic: false,\r\n        },\r\n      },\r\n      returnTypeId: $nameMapping.get(\"range<std::anypoint>\")!,\r\n    },\r\n  ]);\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.Function,\r\n    __element__: returnType,\r\n    __cardinality__: cardinality,\r\n    __name__: \"std::range\",\r\n    __args__: positionalArgs,\r\n    __namedargs__: namedArgs,\r\n  }) as any;\r\n}\r\n\r\nexport { range as $range };\r\n"},{"path":"reflection.mts","content":"export * from \"edgedb/dist/reflection/index.js\";\r\nexport * from \"./typesystem.mjs\";\r\nexport { cardutil } from \"./cardinality.mjs\";\r\nexport type { $expr_Literal } from \"./literal.mjs\";\r\nexport type { $expr_PathNode, $expr_PathLeaf } from \"./path.mjs\";\r\nexport type { $expr_Function, $expr_Operator } from \"./funcops.mjs\";\r\nexport { makeType, $mergeObjectTypes } from \"./hydrate.mjs\";\r\nexport type { mergeObjectTypes } from \"./hydrate.mjs\";\r\n"},{"path":"select.mts","content":"import {\r\n  LocalDateTime,\r\n  LocalDate,\r\n  LocalTime,\r\n  Duration,\r\n  RelativeDuration,\r\n  ConfigMemory,\r\n  DateDuration,\r\n} from \"edgedb\";\r\nimport type { $bool, $number } from \"./modules/std.mjs\";\r\n\r\nimport {\r\n  Cardinality,\r\n  ExpressionKind,\r\n  TypeKind,\r\n  OperatorKind,\r\n} from \"edgedb/dist/reflection/index.js\";\r\nimport { makeType } from \"./hydrate.mjs\";\r\n\r\nimport { cardutil } from \"./cardinality.mjs\";\r\nimport type {\r\n  $expr_PolyShapeElement,\r\n  $scopify,\r\n  Expression,\r\n  LinkDesc,\r\n  ObjectType,\r\n  ObjectTypeExpression,\r\n  ObjectTypePointers,\r\n  ObjectTypeSet,\r\n  PrimitiveTypeSet,\r\n  PropertyDesc,\r\n  ScalarType,\r\n  stripSet,\r\n  TypeSet,\r\n  BaseType,\r\n  ExclusiveTuple,\r\n  orLiteralValue,\r\n} from \"./typesystem.mjs\";\r\n\r\nimport {\r\n  $assert_single,\r\n  type $expr_PathLeaf,\r\n  type $expr_PathNode,\r\n  type $linkPropify,\r\n  type ExpressionRoot,\r\n} from \"./path.mjs\";\r\nimport type { anonymizeObject } from \"./casting.mjs\";\r\nimport { $expressionify, $getScopedExpr } from \"./path.mjs\";\r\nimport { $getTypeByName, literal } from \"./literal.mjs\";\r\nimport { spec } from \"./__spec__.mjs\";\r\nimport {\r\n  type scalarLiterals,\r\n  type literalToScalarType,\r\n  literalToTypeSet,\r\n} from \"./castMaps.mjs\";\r\nimport type { $expr_Operator } from \"./funcops.mjs\";\r\n\r\nexport const ASC: \"ASC\" = \"ASC\";\r\nexport const DESC: \"DESC\" = \"DESC\";\r\nexport const EMPTY_FIRST: \"EMPTY FIRST\" = \"EMPTY FIRST\";\r\nexport const EMPTY_LAST: \"EMPTY LAST\" = \"EMPTY LAST\";\r\nexport type OrderByDirection = \"ASC\" | \"DESC\";\r\nexport type OrderByEmpty = \"EMPTY FIRST\" | \"EMPTY LAST\";\r\n\r\nexport type OrderByExpr = TypeSet<ScalarType | ObjectType, Cardinality>;\r\nexport type OrderByObjExpr = {\r\n  expression: OrderByExpr;\r\n  direction?: OrderByDirection;\r\n  empty?: OrderByEmpty;\r\n};\r\n\r\nexport type OrderByExpression =\r\n  | OrderByExpr\r\n  | OrderByObjExpr\r\n  | [OrderByExpr | OrderByObjExpr, ...(OrderByExpr | OrderByObjExpr)[]];\r\n\r\nexport type OffsetExpression = TypeSet<\r\n  $number,\r\n  Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne\r\n>;\r\n\r\nexport type SelectFilterExpression = TypeSet<$bool, Cardinality>;\r\nexport type LimitOffsetExpression = TypeSet<\r\n  $number,\r\n  Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne\r\n>;\r\nexport type LimitExpression = TypeSet<\r\n  $number,\r\n  Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne\r\n>;\r\n\r\nexport type SelectModifierNames =\r\n  | \"filter\"\r\n  | \"filter_single\"\r\n  | \"order_by\"\r\n  | \"offset\"\r\n  | \"limit\";\r\n\r\ntype filterSingle<T extends TypeSet> = T extends ObjectTypeSet\r\n  ? TypeSet<anonymizeObject<T[\"__element__\"]>, T[\"__cardinality__\"]>\r\n  : orLiteralValue<T>;\r\n\r\nexport type exclusivesToFilterSingle<E extends ExclusiveTuple> =\r\n  ExclusiveTuple extends E\r\n    ? never\r\n    : E extends []\r\n    ? never\r\n    : {\r\n        [j in keyof E]: {\r\n          [k in keyof E[j]]: filterSingle<E[j][k]>;\r\n        };\r\n      }[number];\r\nexport type SelectModifiers<T extends ObjectType = ObjectType> = {\r\n  // export type SelectModifiers = {\r\n  filter?: SelectFilterExpression;\r\n  filter_single?: // | Partial<\r\n  //     typeutil.stripNever<{\r\n  //       [k in keyof T[\"__pointers__\"]]: T[\"__pointers__\"][k]\r\n  // extends PropertyDesc\r\n  //         ? orScalarLiteral<{\r\n  //             __element__: T[\"__pointers__\"][k][\"target\"];\r\n  //             __cardinality__: T[\"__pointers__\"][k][\"cardinality\"];\r\n  //           }>\r\n  //         : never;\r\n  //     }>\r\n  //   >\r\n\r\n  // | (ObjectType extends T\r\n  //       ? unknown\r\n  //       : typeutil.stripNever<{\r\n  //           [k in keyof T[\"__pointers__\"]]: T[\"__pointers__\"][k]\r\n  // extends PropertyDesc<\r\n  //             infer T,\r\n  //             infer C,\r\n  //             infer E\r\n  //           >\r\n  //             ? E extends true\r\n  //               ? orScalarLiteral<{\r\n  //                   __element__: T;\r\n  //                   __cardinality__: C;\r\n  //                 }>\r\n  //               : never\r\n  //             : never;\r\n  //         }>)\r\n  exclusivesToFilterSingle<T[\"__exclusives__\"]> | SelectFilterExpression;\r\n\r\n  // | (ObjectType extends T\r\n  //     ? unknown\r\n  //     : typeutil.stripNever<{\r\n  //         [k in keyof T[\"__pointers__\"]]: T[\"__pointers__\"][k]\r\n  // extends PropertyDesc<\r\n  //           infer T,\r\n  //           infer C,\r\n  //           infer E\r\n  //         >\r\n  //           ? E extends true\r\n  //             ? orScalarLiteral<{\r\n  //                 __element__: T;\r\n  //                 __cardinality__: C;\r\n  //               }>\r\n  //             : never\r\n  //           : never;\r\n  //       }>);\r\n  order_by?: OrderByExpression;\r\n  offset?: OffsetExpression | number;\r\n  limit?: LimitExpression | number;\r\n};\r\n\r\nexport type UnknownSelectModifiers = { [k in keyof SelectModifiers]: unknown };\r\n\r\nexport type NormalisedSelectModifiers = {\r\n  filter?: SelectFilterExpression;\r\n  order_by?: OrderByObjExpr[];\r\n  offset?: OffsetExpression;\r\n  limit?: LimitExpression;\r\n  singleton: boolean;\r\n};\r\n\r\n// type NormaliseOrderByModifier<Mods extends OrderByExpression> =\r\n//   Mods extends OrderByExpr\r\n//     ? [{expression: Mods}]\r\n//     : Mods extends OrderByObjExpr\r\n//     ? [Mods]\r\n//     : Mods extends (OrderByExpr | OrderByObjExpr)[]\r\n//     ? {\r\n//         [K in keyof Mods]: Mods[K] extends OrderByExpr\r\n//           ? {expression: Mods[K]}\r\n//           : Mods[K];\r\n//       }\r\n//     : [];\r\n\r\n// type NormaliseSelectModifiers<Mods extends SelectModifiers> = {\r\n//   filter: Mods[\"filter\"];\r\n//   order_by: Mods[\"order_by\"] extends OrderByExpression\r\n//     ? NormaliseOrderByModifier<Mods[\"order_by\"]>\r\n//     : [];\r\n//   offset: Mods[\"offset\"] extends number\r\n//     ? $expr_Literal<ScalarType<\"std::int64\", number, Mods[\"offset\"]>>\r\n//     : Mods[\"offset\"];\r\n//   limit: Mods[\"offset\"] extends number\r\n//     ? $expr_Literal<ScalarType<\"std::int64\", number, Mods[\"offset\"]>>\r\n//     : Mods[\"offset\"];\r\n// };\r\n\r\nexport type $expr_Select<Set extends TypeSet = TypeSet> = Expression<{\r\n  __element__: Set[\"__element__\"];\r\n  __cardinality__: Set[\"__cardinality__\"];\r\n  __expr__: TypeSet;\r\n  __kind__: ExpressionKind.Select;\r\n  __modifiers__: NormalisedSelectModifiers;\r\n  __scope__?: ObjectTypeExpression;\r\n}>;\r\n// Modifier methods removed for now, until we can fix typescript inference\r\n// problems / excessively deep errors\r\n// & SelectModifierMethods<stripSet<Set>>;\r\n\r\nexport interface SelectModifierMethods<Root extends TypeSet> {\r\n  filter<Filter extends SelectFilterExpression>(\r\n    filter:\r\n      | Filter\r\n      | ((\r\n          scope: Root extends ObjectTypeSet\r\n            ? $scopify<Root[\"__element__\"]>\r\n            : stripSet<Root>\r\n        ) => Filter)\r\n  ): this;\r\n  order_by(\r\n    order_by:\r\n      | OrderByExpression\r\n      | ((\r\n          scope: Root extends ObjectTypeSet\r\n            ? $scopify<Root[\"__element__\"]>\r\n            : stripSet<Root>\r\n        ) => OrderByExpression)\r\n  ): this;\r\n  offset(\r\n    offset:\r\n      | OffsetExpression\r\n      | number\r\n      | ((\r\n          scope: Root extends ObjectTypeSet\r\n            ? $scopify<Root[\"__element__\"]>\r\n            : stripSet<Root>\r\n        ) => OffsetExpression | number)\r\n  ): this;\r\n  // $expr_Select<{\r\n  //   __element__: Root[\"__element__\"];\r\n  //   __cardinality__: cardutil.overrideLowerBound<\r\n  //     Root[\"__cardinality__\"],\r\n  //     \"Zero\"\r\n  //   >;\r\n  // }>;\r\n  limit(\r\n    limit:\r\n      | LimitExpression\r\n      | number\r\n      | ((\r\n          scope: Root extends ObjectTypeSet\r\n            ? $scopify<Root[\"__element__\"]>\r\n            : stripSet<Root>\r\n        ) => LimitExpression | number)\r\n  ): this;\r\n  // $expr_Select<{\r\n  //   __element__: Root[\"__element__\"];\r\n  //   __cardinality__: cardutil.overrideLowerBound<\r\n  //     Root[\"__cardinality__\"],\r\n  //     \"Zero\"\r\n  //   >;\r\n  // }>;\r\n}\r\n// Base is ObjectTypeSet &\r\n// Filter is equality &\r\n// Filter.args[0] is PathLeaf\r\n//   Filter.args[0] is __exclusive__ &\r\n//   Filter.args[0].parent.__element__ === Base.__element__\r\n//   Filter.args[1].__cardinality__ is AtMostOne or One\r\n// if Filter.args[0] is PathNode:\r\n//   Filter.args[0] is __exclusive__ &\r\n//   if Filter.args[0].parent === null\r\n//     Filter.args[0].parent.__element__ === Base.__element__\r\n//     Filter.args[1].__cardinality__ is AtMostOne or One\r\n//   else\r\n//     Filter.args[0].type.__element__ === Base.__element__ &\r\n//     Filter.args[1].__cardinality__ is AtMostOne or One\r\n\r\n// type argCardToResultCard<\r\n//   OpCard extends Cardinality,\r\n//   BaseCase extends Cardinality\r\n// > = [OpCard] extends [Cardinality.AtMostOne | Cardinality.One]\r\n//   ? Cardinality.AtMostOne\r\n//   : [OpCard] extends [Cardinality.Empty]\r\n//   ? Cardinality.Empty\r\n//   : BaseCase;\r\n\r\n// export type InferFilterCardinality<\r\n//   Base extends TypeSet,\r\n//   Filter\r\n// > = Filter extends TypeSet\r\n//   ? // Base is ObjectTypeExpression &\r\n//     Base extends ObjectTypeSet // $expr_PathNode\r\n//     ? // Filter is equality\r\n//       Filter extends $expr_Operator<\"=\", any, infer Args, any>\r\n//       ? // Filter.args[0] is PathLeaf\r\n//         Args[0] extends $expr_PathLeaf\r\n//         ? // Filter.args[0] is unique\r\n//           Args[0][\"__exclusive__\"] extends true\r\n//           ? //   Filter.args[0].parent.__element__ === Base.__element__\r\n//             typeutil.assertEqual<InferFilterCardinality\r\n//               Args[0][\"__parent__\"][\"type\"][\"__element__\"][\"__name__\"],\r\n//               Base[\"__element__\"][\"__name__\"]\r\n//             > extends true\r\n//             ? // Filter.args[1].__cardinality__ is AtMostOne or One\r\n//               argCardToResultCard<\r\n//                 Args[1][\"__cardinality__\"],\r\n//                 Base[\"__cardinality__\"]\r\n//               >\r\n//             : Base[\"__cardinality__\"]\r\n//           : Base[\"__cardinality__\"]\r\n//         : Args[0] extends $expr_PathNode<any, any, any>\r\n//         ? Args[0][\"__exclusive__\"] extends true\r\n//           ? //   Filter.args[0].parent.__element__ === Base.__element__\r\n//             Args[0][\"__parent__\"] extends null\r\n//             ? typeutil.assertEqual<\r\n//                 Args[0][\"__element__\"][\"__name__\"],\r\n//                 Base[\"__element__\"][\"__name__\"]\r\n//               > extends true\r\n//               ? // Filter.args[1].__cardinality__ is AtMostOne or One\r\n//                 argCardToResultCard<\r\n//                   Args[1][\"__cardinality__\"],\r\n//                   Base[\"__cardinality__\"]\r\n//                 >\r\n//               : Base[\"__cardinality__\"]\r\n//             : Args[0][\"__parent__\"] extends infer Parent\r\n//             ? Parent extends PathParent\r\n//               ? typeutil.assertEqual<\r\n//                   Parent[\"type\"][\"__element__\"][\"__name__\"],\r\n//                   Base[\"__element__\"][\"__name__\"]\r\n//                 > extends true\r\n//                 ? // Filter.args[1].__cardinality__ is AtMostOne or One\r\n//                   argCardToResultCard<\r\n//                     Args[1][\"__cardinality__\"],\r\n//                     Base[\"__cardinality__\"]\r\n//                   >\r\n//                 : Base[\"__cardinality__\"]\r\n//               : Base[\"__cardinality__\"]\r\n//             : Base[\"__cardinality__\"]\r\n//           : Base[\"__cardinality__\"]\r\n//         : Base[\"__cardinality__\"]\r\n//       : Base[\"__cardinality__\"]\r\n//     : Base[\"__cardinality__\"]\r\n//   : Base[\"__cardinality__\"];\r\n\r\nexport type InferOffsetLimitCardinality<\r\n  Card extends Cardinality,\r\n  Modifiers extends UnknownSelectModifiers\r\n> = Modifiers[\"limit\"] extends number | LimitExpression\r\n  ? cardutil.overrideLowerBound<Card, \"Zero\">\r\n  : Modifiers[\"offset\"] extends number | OffsetExpression\r\n  ? cardutil.overrideLowerBound<Card, \"Zero\">\r\n  : Card;\r\n\r\n// export type ComputeSelectCardinality<\r\n//   Expr extends ObjectTypeExpression,\r\n//   Modifiers extends UnknownSelectModifiers\r\n// > = InferOffsetLimitCardinality<\r\n//   InferFilterCardinality<Expr, Modifiers[\"filter\"]>,\r\n//   Modifiers\r\n// >;\r\nexport type ComputeSelectCardinality<\r\n  Expr extends ObjectTypeExpression,\r\n  Modifiers extends UnknownSelectModifiers\r\n> = InferOffsetLimitCardinality<\r\n  undefined extends Modifiers[\"filter_single\"]\r\n    ? Expr[\"__cardinality__\"]\r\n    : cardutil.overrideUpperBound<Expr[\"__cardinality__\"], \"One\">,\r\n  Modifiers\r\n>;\r\n\r\nexport function is<\r\n  Expr extends ObjectTypeExpression,\r\n  Shape extends objectTypeToSelectShape<Expr[\"__element__\"]>\r\n>(\r\n  expr: Expr,\r\n  shape: Shape\r\n): {\r\n  [k in Exclude<\r\n    keyof Shape,\r\n    SelectModifierNames | \"id\"\r\n  >]: $expr_PolyShapeElement<Expr, normaliseElement<Shape[k]>>;\r\n} {\r\n  const mappedShape: any = {};\r\n  for (const [key, value] of Object.entries(shape)) {\r\n    if (key === \"id\") continue;\r\n    mappedShape[key] = {\r\n      __kind__: ExpressionKind.PolyShapeElement,\r\n      __polyType__: expr,\r\n      __shapeElement__: value,\r\n    };\r\n  }\r\n  return mappedShape;\r\n}\r\n\r\n// function computeFilterCardinality(\r\n//   expr: SelectFilterExpression,\r\n//   cardinality: Cardinality,\r\n//   base: TypeSet\r\n// ) {\r\n//   let card = cardinality;\r\n\r\n//   const filter: any = expr;\r\n//   // Base is ObjectExpression\r\n//   const baseIsObjectExpr = base?.__element__?.__kind__ === TypeKind.object;\r\n//   const filterExprIsEq =\r\n//     filter.__kind__ === ExpressionKind.Operator && filter.__name__ === \"=\";\r\n//   const arg0: $expr_PathLeaf | $expr_PathNode = filter?.__args__?.[0];\r\n//   const arg1: TypeSet = filter?.__args__?.[1];\r\n//   const argsExist = !!arg0 && !!arg1 && !!arg1.__cardinality__;\r\n//   const arg0IsUnique = arg0?.__exclusive__ === true;\r\n\r\n//   if (baseIsObjectExpr && filterExprIsEq && argsExist && arg0IsUnique) {\r\n//     const newCard =\r\n//       arg1.__cardinality__ === Cardinality.One ||\r\n//       arg1.__cardinality__ === Cardinality.AtMostOne\r\n//         ? Cardinality.AtMostOne\r\n//         : arg1.__cardinality__ === Cardinality.Empty\r\n//         ? Cardinality.Empty\r\n//         : cardinality;\r\n\r\n//     if (arg0.__kind__ === ExpressionKind.PathLeaf) {\r\n//       const arg0ParentMatchesBase =\r\n//         arg0.__parent__.type.__element__.__name__ ===\r\n//         base.__element__.__name__;\r\n//       if (arg0ParentMatchesBase) {\r\n//         card = newCard;\r\n//       }\r\n//     } else if (arg0.__kind__ === ExpressionKind.PathNode) {\r\n//       // if Filter.args[0] is PathNode:\r\n//       //   Filter.args[0] is __exclusive__ &\r\n//       //   if Filter.args[0].parent === null\r\n//       //     Filter.args[0].__element__ === Base.__element__\r\n//       //     Filter.args[1].__cardinality__ is AtMostOne or One\r\n//       //   else\r\n//       //     Filter.args[0].type.__element__ === Base.__element__ &\r\n//       //     Filter.args[1].__cardinality__ is AtMostOne or One\r\n//       const parent = arg0.__parent__;\r\n//       if (parent === null) {\r\n//         const arg0MatchesBase =\r\n//           arg0.__element__.__name__ === base.__element__.__name__;\r\n//         if (arg0MatchesBase) {\r\n//           card = newCard;\r\n//         }\r\n//       } else {\r\n//         const arg0ParentMatchesBase =\r\n//           parent?.type.__element__.__name__ === base.__element__.__name__;\r\n//         if (arg0ParentMatchesBase) {\r\n//           card = newCard;\r\n//         }\r\n//       }\r\n//     }\r\n//   }\r\n\r\n//   return card;\r\n// }\r\n\r\nexport function $handleModifiers(\r\n  modifiers: SelectModifiers,\r\n  params: { root: TypeSet; scope: TypeSet }\r\n): {\r\n  modifiers: NormalisedSelectModifiers;\r\n  cardinality: Cardinality;\r\n  needsAssertSingle: boolean;\r\n} {\r\n  const { root, scope } = params;\r\n  const mods: NormalisedSelectModifiers = {\r\n    singleton: !!modifiers[\"filter_single\"],\r\n  };\r\n\r\n  let card = root.__cardinality__;\r\n  let needsAssertSingle = false;\r\n\r\n  if (modifiers.filter) {\r\n    mods.filter = modifiers.filter;\r\n    // card = computeFilterCardinality(mods.filter, card, rootExpr);\r\n  }\r\n\r\n  if (modifiers.filter_single) {\r\n    if (root.__element__.__kind__ !== TypeKind.object) {\r\n      throw new Error(\"filter_single can only be used with object types\");\r\n    }\r\n    card = Cardinality.AtMostOne;\r\n    // mods.filter = modifiers.filter_single;\r\n    const fs: any = modifiers.filter_single;\r\n    if (fs.__element__) {\r\n      mods.filter = modifiers.filter_single as any;\r\n      needsAssertSingle = true;\r\n    } else {\r\n      const exprs = Object.keys(fs).map((key) => {\r\n        const val = fs[key].__element__\r\n          ? fs[key]\r\n          : (literal as any)(\r\n              (root.__element__ as any as ObjectType)[\"__pointers__\"][key]![\r\n                \"target\"\r\n              ],\r\n              fs[key]\r\n            );\r\n        return $expressionify({\r\n          __element__: {\r\n            __name__: \"std::bool\",\r\n            __kind__: TypeKind.scalar,\r\n          } as any,\r\n          __cardinality__: Cardinality.One,\r\n          __kind__: ExpressionKind.Operator,\r\n          __opkind__: OperatorKind.Infix,\r\n          __name__: \"=\",\r\n          __args__: [(scope as any)[key], val],\r\n        }) as $expr_Operator;\r\n      });\r\n      if (exprs.length === 1) {\r\n        mods.filter = exprs[0] as any;\r\n      } else {\r\n        mods.filter = exprs.reduce((a, b) => {\r\n          return $expressionify({\r\n            __element__: {\r\n              __name__: \"std::bool\",\r\n              __kind__: TypeKind.scalar,\r\n            } as any,\r\n            __cardinality__: Cardinality.One,\r\n            __kind__: ExpressionKind.Operator,\r\n            __opkind__: OperatorKind.Infix,\r\n            __name__: \"and\",\r\n            __args__: [a, b],\r\n          }) as $expr_Operator;\r\n        }) as any;\r\n      }\r\n    }\r\n  }\r\n  if (modifiers.order_by) {\r\n    const orderExprs = Array.isArray(modifiers.order_by)\r\n      ? modifiers.order_by\r\n      : [modifiers.order_by];\r\n    mods.order_by = orderExprs.map((expr) =>\r\n      typeof (expr as any).__element__ === \"undefined\"\r\n        ? expr\r\n        : { expression: expr }\r\n    ) as any;\r\n  }\r\n  if (modifiers.offset) {\r\n    mods.offset =\r\n      typeof modifiers.offset === \"number\"\r\n        ? ($getTypeByName(\"std::number\")(modifiers.offset) as any)\r\n        : modifiers.offset;\r\n    card = cardutil.overrideLowerBound(card, \"Zero\");\r\n  }\r\n  if (modifiers.limit) {\r\n    let expr: LimitExpression;\r\n    if (typeof modifiers.limit === \"number\") {\r\n      expr = $getTypeByName(\"std::number\")(modifiers.limit) as any;\r\n    } else {\r\n      const type =\r\n        (modifiers.limit.__element__ as any).__casttype__ ??\r\n        modifiers.limit.__element__;\r\n      if (\r\n        type.__kind__ === TypeKind.scalar &&\r\n        type.__name__ === \"std::number\"\r\n      ) {\r\n        expr = modifiers.limit;\r\n      } else {\r\n        throw new Error(\"Invalid value for `limit` modifier\");\r\n      }\r\n    }\r\n    mods.limit = expr;\r\n    card = cardutil.overrideLowerBound(card, \"Zero\");\r\n  }\r\n\r\n  return {\r\n    modifiers: mods as NormalisedSelectModifiers,\r\n    cardinality: card,\r\n    needsAssertSingle,\r\n  };\r\n}\r\n\r\nexport type $expr_Delete<Root extends ObjectTypeSet = ObjectTypeSet> =\r\n  Expression<{\r\n    __kind__: ExpressionKind.Delete;\r\n    __element__: Root[\"__element__\"];\r\n    __cardinality__: Root[\"__cardinality__\"];\r\n    __expr__: ObjectTypeSet;\r\n  }>;\r\n\r\nfunction deleteExpr<\r\n  Expr extends ObjectTypeExpression,\r\n  Modifiers extends SelectModifiers<Expr[\"__element__\"]>\r\n>(\r\n  expr: Expr,\r\n  modifiers?: (scope: $scopify<Expr[\"__element__\"]>) => Readonly<Modifiers>\r\n): $expr_Delete<{\r\n  __element__: ObjectType<\r\n    Expr[\"__element__\"][\"__name__\"],\r\n    Expr[\"__element__\"][\"__pointers__\"],\r\n    { id: true }\r\n  >;\r\n  __cardinality__: ComputeSelectCardinality<Expr, Modifiers>;\r\n}>;\r\nfunction deleteExpr(expr: any, modifiersGetter: any) {\r\n  const selectExpr = select(expr, modifiersGetter);\r\n\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.Delete,\r\n    __element__: selectExpr.__element__,\r\n    __cardinality__: selectExpr.__cardinality__,\r\n    __expr__: selectExpr,\r\n  }) as any;\r\n}\r\n\r\nexport { deleteExpr as delete };\r\n\r\n// Modifier methods removed for now, until we can fix typescript inference\r\n// problems / excessively deep errors\r\n\r\n// function resolveModifierGetter(parent: any, modGetter: any) {\r\n//   if (typeof modGetter === \"function\" && !modGetter.__kind__) {\r\n//     if (parent.__expr__.__element__.__kind__ === TypeKind.object) {\r\n//       const shape = parent.__element__.__shape__;\r\n//       const _scope =\r\n//         parent.__scope__ ?? $getScopedExpr(parent.__expr__,\r\n//           $existingScopes);\r\n//       const scope = new Proxy(_scope, {\r\n//         get(target: any, prop: string) {\r\n//           if (shape[prop] && shape[prop] !== true) {\r\n//             return shape[prop];\r\n//           }\r\n//           return target[prop];\r\n//         },\r\n//       });\r\n//       return {\r\n//         scope: _scope,\r\n//         modExpr: modGetter(scope),\r\n//       };\r\n//     } else {\r\n//       return {\r\n//         scope: undefined,\r\n//         modExpr: modGetter(parent.__expr__),\r\n//       };\r\n//     }\r\n//   } else {\r\n//     return {scope: parent.__scope__, modExpr: modGetter};\r\n//   }\r\n// }\r\n\r\n// function updateModifier(\r\n//   parent: any,\r\n//   modName: \"filter\" | \"order_by\" | \"offset\" | \"limit\",\r\n//   modGetter: any\r\n// ) {\r\n//   const modifiers = {\r\n//     ...parent.__modifiers__,\r\n//   };\r\n//   const cardinality = parent.__cardinality__;\r\n\r\n//   const {modExpr, scope} = resolveModifierGetter(parent, modGetter);\r\n\r\n//   switch (modName) {\r\n//     case \"filter\":\r\n//       modifiers.filter = modifiers.filter\r\n//         ? op(modifiers.filter, \"and\", modExpr)\r\n//         : modExpr;\r\n\r\n//       // methods no longer change cardinality\r\n//       // cardinality = computeFilterCardinality(\r\n//       //   modExpr,\r\n//       //   cardinality,\r\n//       //   parent.__expr__\r\n//       // );\r\n//       break;\r\n//     case \"order_by\":\r\n//       const ordering =\r\n//         typeof (modExpr as any).__element__ === \"undefined\"\r\n//           ? modExpr\r\n//           : {expression: modExpr};\r\n//       modifiers.order_by = modifiers.order_by\r\n//         ? [...modifiers.order_by, ordering]\r\n//         : [ordering];\r\n//       break;\r\n//     case \"offset\":\r\n//       modifiers.offset =\r\n//         typeof modExpr === \"number\" ? _std.number(modExpr) : modExpr;\r\n//       // methods no longer change cardinality\r\n//       // cardinality = cardutil\r\n//            .overrideLowerBound(cardinality, \"Zero\");\r\n//       break;\r\n//     case \"limit\":\r\n//       modifiers.limit =\r\n//         typeof modExpr === \"number\"\r\n//           ? _std.number(modExpr)\r\n//           : (modExpr as any).__kind__ === ExpressionKind.Set\r\n//           ? (modExpr as any).__exprs__[0]\r\n//           : modExpr;\r\n//       // methods no longer change cardinality\r\n//       // cardinality = cardutil\r\n//            .overrideLowerBound(cardinality, \"Zero\");\r\n//       break;\r\n//   }\r\n\r\n//   return $expressionify(\r\n//     $selectify({\r\n//       __kind__: ExpressionKind.Select,\r\n//       __element__: parent.__element__,\r\n//       __cardinality__: cardinality,\r\n//       __expr__: parent.__expr__,\r\n//       __modifiers__: modifiers,\r\n//       __scope__: scope,\r\n//     })\r\n//   );\r\n// }\r\n\r\nexport function $selectify<Expr extends ExpressionRoot>(expr: Expr) {\r\n  // Object.assign(expr, {\r\n  //   filter: (filter: any) => updateModifier(expr, \"filter\", filter),\r\n  //   order_by: (order_by: any) => updateModifier(expr, \"order_by\", order_by),\r\n  //   offset: (offset: any) => updateModifier(expr, \"offset\", offset),\r\n  //   limit: (limit: any) => updateModifier(expr, \"limit\", limit),\r\n  // });\r\n  return expr;\r\n}\r\n\r\nexport type linkDescToLinkProps<Desc extends LinkDesc> = {\r\n  [k in keyof Desc[\"properties\"] & string]: $expr_PathLeaf<\r\n    TypeSet<\r\n      Desc[\"properties\"][k][\"target\"],\r\n      Desc[\"properties\"][k][\"cardinality\"]\r\n    >\r\n    // {\r\n    //   type: $scopify<Desc[\"target\"]>;\r\n    //   linkName: k;\r\n    // },\r\n    // Desc[\"properties\"][k][\"exclusive\"]\r\n  >;\r\n};\r\n\r\nexport type pointersToObjectType<P extends ObjectTypePointers> = ObjectType<\r\n  string,\r\n  P,\r\n  object\r\n>;\r\n\r\ntype linkDescToShape<L extends LinkDesc> = objectTypeToSelectShape<\r\n  L[\"target\"]\r\n> &\r\n  objectTypeToSelectShape<pointersToObjectType<L[\"properties\"]>> &\r\n  SelectModifiers;\r\n\r\ntype linkDescToSelectElement<L extends LinkDesc> =\r\n  | boolean\r\n  | TypeSet<anonymizeObject<L[\"target\"]>, cardutil.assignable<L[\"cardinality\"]>>\r\n  | linkDescToShape<L>\r\n  | ((\r\n      scope: $scopify<L[\"target\"]> & linkDescToLinkProps<L>\r\n    ) => linkDescToShape<L>);\r\n\r\ntype propDescToSelectElement<P extends PropertyDesc> =\r\n  | boolean\r\n  | TypeSet<P[\"target\"], cardutil.assignable<P[\"cardinality\"]>>\r\n  | $expr_PolyShapeElement;\r\n\r\n// object types -> pointers\r\n// pointers -> links\r\n// links -> target object type\r\n// links -> link properties\r\nexport type objectTypeToSelectShape<\r\n  T extends ObjectType = ObjectType,\r\n  Pointers extends ObjectTypePointers = T[\"__pointers__\"]\r\n> = Partial<{\r\n  [k in keyof Pointers]: Pointers[k] extends PropertyDesc\r\n    ? propDescToSelectElement<Pointers[k]>\r\n    : Pointers[k] extends LinkDesc\r\n    ? linkDescToSelectElement<Pointers[k]>\r\n    : any;\r\n}> & { [k: string]: unknown };\r\n\r\n// incorporate __shape__ (computeds) on selection shapes\r\n// this works but a major rewrite of setToTsType is required\r\n// to incorporate __shape__-based selection shapes into\r\n// result type inference\r\n// & [k in keyof T[\"__shape__\"]]:\r\n//    string | number | symbol extends k //   Partial<{ // &\r\n//       ? unknown\r\n//       : T[\"__shape__\"][k] extends infer U\r\n//       ? U extends ObjectTypeSet\r\n//         ?\r\n//             | boolean\r\n//             | TypeSet<\r\n//                 anonymizeObject<U[\"__element__\"]>,\r\n//                 cardutil.assignable<U[\"__cardinality__\"]>\r\n//               >\r\n//             | objectTypeToSelectShape<U[\"__element__\"]>\r\n//             | ((\r\n//                 scope: $scopify<U[\"__element__\"]>\r\n//               ) => objectTypeToSelectShape<U[\"__element__\"]> &\r\n//                 SelectModifiers)\r\n//         : U extends TypeSet\r\n//         ?\r\n//             | boolean\r\n//             | TypeSet<\r\n//                 U[\"__element__\"],\r\n//                 cardutil.assignable<U[\"__cardinality__\"]>\r\n//               >\r\n//         : unknown\r\n//       : unknown;\r\n//   }>\r\n\r\nexport type normaliseElement<El> = El extends boolean\r\n  ? El\r\n  : El extends TypeSet\r\n  ? stripSet<El>\r\n  : El extends (...scope: any[]) => any\r\n  ? normaliseShape<ReturnType<El>>\r\n  : El extends object\r\n  ? normaliseShape<stripSet<El>>\r\n  : stripSet<El>;\r\n\r\nexport type normaliseShape<\r\n  Shape extends object,\r\n  Strip = SelectModifierNames\r\n> = {\r\n  [k in Exclude<keyof Shape, Strip>]: normaliseElement<Shape[k]>;\r\n};\r\n\r\nconst $FreeObject = makeType(\r\n  spec,\r\n  [...spec.values()].find((s) => s.name === \"std::FreeObject\")!.id,\r\n  literal\r\n);\r\nconst FreeObject: $expr_PathNode = {\r\n  __kind__: ExpressionKind.PathNode,\r\n  __element__: $FreeObject as any,\r\n  __cardinality__: Cardinality.One,\r\n  __parent__: null,\r\n  __exclusive__: true,\r\n  __scopeRoot__: null,\r\n} as any;\r\n\r\nexport const $existingScopes = new Set<\r\n  Expression<TypeSet<BaseType, Cardinality>>\r\n>();\r\n\r\nfunction $shape<\r\n  Expr extends ObjectTypeExpression,\r\n  Element extends Expr[\"__element__\"],\r\n  Shape extends objectTypeToSelectShape<Element> & SelectModifiers<Element>,\r\n  Scope extends $scopify<Element> &\r\n    $linkPropify<{\r\n      [k in keyof Expr]: k extends \"__cardinality__\"\r\n        ? Cardinality.One\r\n        : Expr[k];\r\n    }>\r\n>(\r\n  expr: Expr,\r\n  _shape: (scope: Scope) => Readonly<Shape>\r\n): (scope: unknown) => Readonly<Shape>;\r\nfunction $shape(_a: unknown, b: (...args: any) => any) {\r\n  return b;\r\n}\r\nexport { $shape as shape };\r\n\r\nexport function select<\r\n  Expr extends ObjectTypeExpression,\r\n  Element extends Expr[\"__element__\"],\r\n  ElementName extends `${Element[\"__name__\"]}`,\r\n  ElementPointers extends Element[\"__pointers__\"],\r\n  ElementShape extends Element[\"__shape__\"],\r\n  Card extends Expr[\"__cardinality__\"]\r\n>(\r\n  expr: Expr\r\n): $expr_Select<{\r\n  __element__: ObjectType<ElementName, ElementPointers, ElementShape>;\r\n  __cardinality__: Card;\r\n}>;\r\nexport function select<Expr extends TypeSet>(\r\n  expr: Expr\r\n): $expr_Select<stripSet<Expr>>;\r\nexport function select<\r\n  Expr extends ObjectTypeExpression,\r\n  Element extends Expr[\"__element__\"],\r\n  Shape extends objectTypeToSelectShape<Element> & SelectModifiers<Element>,\r\n  SelectCard extends ComputeSelectCardinality<Expr, Modifiers>,\r\n  SelectShape extends normaliseShape<Shape, SelectModifierNames>,\r\n  Scope extends $scopify<Element> &\r\n    $linkPropify<{\r\n      [k in keyof Expr]: k extends \"__cardinality__\"\r\n        ? Cardinality.One\r\n        : Expr[k];\r\n    }>,\r\n  ElementName extends `${Element[\"__name__\"]}`,\r\n  Modifiers extends UnknownSelectModifiers = Pick<Shape, SelectModifierNames>\r\n>(\r\n  expr: Expr,\r\n  shape: (scope: Scope) => Readonly<Shape>\r\n): $expr_Select<{\r\n  __element__: ObjectType<ElementName, Element[\"__pointers__\"], SelectShape>;\r\n  __cardinality__: SelectCard;\r\n}>;\r\n/*\r\n\r\nFor the moment is isn't possible to implement both closure-based and plain\r\nobject overloads without breaking autocomplete on one or the other.\r\nThis is due to a limitation in TS:\r\n\r\nhttps://github.com/microsoft/TypeScript/issues/26892\r\nhttps://github.com/microsoft/TypeScript/issues/47081\r\n\r\n*/\r\n\r\nexport function select<\r\n  Expr extends PrimitiveTypeSet,\r\n  Modifiers extends SelectModifiers\r\n>(\r\n  expr: Expr,\r\n  modifiers: (expr: Expr) => Readonly<Modifiers>\r\n): $expr_Select<{\r\n  __element__: Expr[\"__element__\"];\r\n  __cardinality__: InferOffsetLimitCardinality<\r\n    Expr[\"__cardinality__\"],\r\n    Modifiers\r\n  >;\r\n}>;\r\nexport function select<Shape extends { [key: string]: TypeSet }>(\r\n  shape: Shape\r\n): $expr_Select<{\r\n  __element__: ObjectType<\r\n    `std::FreeObject`,\r\n    {\r\n      [k in keyof Shape]: Shape[k][\"__element__\"] extends ObjectType\r\n        ? LinkDesc<\r\n            Shape[k][\"__element__\"],\r\n            Shape[k][\"__cardinality__\"],\r\n            {},\r\n            false,\r\n            true,\r\n            true,\r\n            false\r\n          >\r\n        : PropertyDesc<\r\n            Shape[k][\"__element__\"],\r\n            Shape[k][\"__cardinality__\"],\r\n            false,\r\n            true,\r\n            true,\r\n            false\r\n          >;\r\n    },\r\n    Shape\r\n  >; // _shape\r\n  __cardinality__: Cardinality.One;\r\n}>;\r\nexport function select<Expr extends scalarLiterals>(\r\n  expr: Expr\r\n): $expr_Select<{\r\n  __element__: literalToScalarType<Expr>;\r\n  __cardinality__: Cardinality.One;\r\n}>;\r\nexport function select(...args: any[]) {\r\n  const firstArg = args[0];\r\n\r\n  if (\r\n    typeof firstArg !== \"object\" ||\r\n    firstArg instanceof Uint8Array ||\r\n    firstArg instanceof Date ||\r\n    firstArg instanceof Duration ||\r\n    firstArg instanceof LocalDateTime ||\r\n    firstArg instanceof LocalDate ||\r\n    firstArg instanceof LocalTime ||\r\n    firstArg instanceof RelativeDuration ||\r\n    firstArg instanceof DateDuration ||\r\n    firstArg instanceof ConfigMemory ||\r\n    firstArg instanceof Float32Array\r\n  ) {\r\n    const literalExpr = literalToTypeSet(firstArg);\r\n    return $expressionify(\r\n      $selectify({\r\n        __kind__: ExpressionKind.Select,\r\n        __element__: literalExpr.__element__,\r\n        __cardinality__: literalExpr.__cardinality__,\r\n        __expr__: literalExpr,\r\n        __modifiers__: {},\r\n      })\r\n    ) as any;\r\n  }\r\n\r\n  const exprPair: [TypeSet, (scope: any) => any] =\r\n    typeof args[0].__element__ !== \"undefined\"\r\n      ? (args as any)\r\n      : [FreeObject, () => args[0]];\r\n\r\n  let expr = exprPair[0];\r\n  const shapeGetter = exprPair[1];\r\n  if (expr === FreeObject) {\r\n    const freeObjectPtrs: ObjectTypePointers = {};\r\n    for (const [k, v] of Object.entries(args[0]) as [string, TypeSet][]) {\r\n      freeObjectPtrs[k] = {\r\n        __kind__:\r\n          v.__element__.__kind__ === TypeKind.object ? \"link\" : \"property\",\r\n        target: v.__element__,\r\n\r\n        cardinality: v.__cardinality__,\r\n        exclusive: false,\r\n        computed: true,\r\n        readonly: true,\r\n        hasDefault: false,\r\n        properties: {},\r\n      };\r\n    }\r\n    expr = {\r\n      ...FreeObject,\r\n      __element__: {\r\n        ...FreeObject.__element__,\r\n        __pointers__: {\r\n          ...FreeObject.__element__.__pointers__,\r\n          ...freeObjectPtrs,\r\n        },\r\n      } as any,\r\n    };\r\n  }\r\n  if (!shapeGetter) {\r\n    if (expr.__element__.__kind__ === TypeKind.object) {\r\n      const objectExpr: ObjectTypeSet = expr as any;\r\n      return $expressionify(\r\n        $selectify({\r\n          __kind__: ExpressionKind.Select,\r\n          __element__: {\r\n            __kind__: TypeKind.object,\r\n            __name__: `${objectExpr.__element__.__name__}`, // _shape\r\n            __pointers__: objectExpr.__element__.__pointers__,\r\n            __shape__: objectExpr.__element__.__shape__,\r\n          } as any,\r\n          __cardinality__: objectExpr.__cardinality__,\r\n          __expr__: objectExpr,\r\n          __modifiers__: {},\r\n        })\r\n      ) as any;\r\n    } else {\r\n      return $expressionify(\r\n        $selectify({\r\n          __kind__: ExpressionKind.Select,\r\n          __element__: expr.__element__,\r\n          __cardinality__: expr.__cardinality__,\r\n          __expr__: expr,\r\n          __modifiers__: {},\r\n        })\r\n      ) as any;\r\n    }\r\n  }\r\n\r\n  const cleanScopedExprs = $existingScopes.size === 0;\r\n\r\n  const { modifiers: mods, shape, scope } = resolveShape(shapeGetter, expr);\r\n\r\n  if (cleanScopedExprs) {\r\n    $existingScopes.clear();\r\n  }\r\n\r\n  const { modifiers, cardinality, needsAssertSingle } = $handleModifiers(mods, {\r\n    root: expr,\r\n    scope,\r\n  });\r\n  const selectExpr = $selectify({\r\n    __kind__: ExpressionKind.Select,\r\n    __element__:\r\n      expr.__element__.__kind__ === TypeKind.object\r\n        ? {\r\n            __kind__: TypeKind.object,\r\n            __name__: `${expr.__element__.__name__}`, // _shape\r\n            __pointers__: (expr.__element__ as ObjectType).__pointers__,\r\n            __shape__: shape,\r\n          }\r\n        : expr.__element__,\r\n    __cardinality__: cardinality,\r\n    __expr__: expr,\r\n    __modifiers__: modifiers,\r\n    __scope__: expr !== scope ? scope : undefined,\r\n  }) as any;\r\n\r\n  return needsAssertSingle\r\n    ? $assert_single(selectExpr)\r\n    : $expressionify(selectExpr);\r\n}\r\n\r\nfunction resolveShape(\r\n  shapeGetter: ((scope: any) => any) | any,\r\n  expr: TypeSet\r\n): { modifiers: any; shape: any; scope: TypeSet } {\r\n  const modifiers: any = {};\r\n  const shape: any = {};\r\n\r\n  // get scoped object if expression is objecttypeset\r\n  const scope =\r\n    expr.__element__.__kind__ === TypeKind.object\r\n      ? $getScopedExpr(expr as any, $existingScopes)\r\n      : expr;\r\n\r\n  // execute getter with scope\r\n  const selectShape =\r\n    typeof shapeGetter === \"function\" ? shapeGetter(scope) : shapeGetter;\r\n\r\n  for (const [key, value] of Object.entries(selectShape)) {\r\n    // handle modifier keys\r\n    if (\r\n      key === \"filter\" ||\r\n      key === \"filter_single\" ||\r\n      key === \"order_by\" ||\r\n      key === \"offset\" ||\r\n      key === \"limit\"\r\n    ) {\r\n      modifiers[key] = value;\r\n    } else {\r\n      // for scalar expressions, scope === expr\r\n      // shape keys are not allowed\r\n      if (expr.__element__.__kind__ !== TypeKind.object) {\r\n        throw new Error(\r\n          `Invalid select shape key '${key}' on scalar expression, ` +\r\n            `only modifiers are allowed (filter, order_by, offset and limit)`\r\n        );\r\n      }\r\n      shape[key] = resolveShapeElement(key, value, scope);\r\n    }\r\n  }\r\n  return { shape, modifiers, scope };\r\n}\r\n\r\nexport function resolveShapeElement(\r\n  key: any,\r\n  value: any,\r\n  scope: ObjectTypeExpression\r\n): any {\r\n  // if value is a nested closure\r\n  // or a nested shape object\r\n  const isSubshape =\r\n    typeof value === \"object\" && typeof (value as any).__kind__ === \"undefined\";\r\n  const isClosure =\r\n    typeof value === \"function\" &&\r\n    scope.__element__.__pointers__[key]?.__kind__ === \"link\";\r\n  // if (isSubshape) {\r\n  //   // return value;\r\n  //   const childExpr = (scope as any)[key];\r\n  //   const {\r\n  //     shape: childShape,\r\n  //     // scope: childScope,\r\n  //     // modifiers: mods,\r\n  //   } = resolveShape(value as any, childExpr);\r\n  //   return childShape;\r\n  // }\r\n  if (isSubshape || isClosure) {\r\n    // get child node expression\r\n    // this relies on Proxy-based getters\r\n    const childExpr = (scope as any)[key];\r\n    if (!childExpr) {\r\n      throw new Error(\r\n        `Invalid shape element \"${key}\" for type ${scope.__element__.__name__}`\r\n      );\r\n    }\r\n    const {\r\n      shape: childShape,\r\n      scope: childScope,\r\n      modifiers: mods,\r\n    } = resolveShape(value as any, childExpr);\r\n\r\n    // extracts normalized modifiers\r\n    const { modifiers, needsAssertSingle } = $handleModifiers(mods, {\r\n      root: childExpr,\r\n      scope: childScope,\r\n    });\r\n\r\n    const selectExpr = {\r\n      __kind__: ExpressionKind.Select,\r\n      __element__: {\r\n        __kind__: TypeKind.object,\r\n        __name__: `${childExpr.__element__.__name__}`,\r\n        __pointers__: childExpr.__element__.__pointers__,\r\n        __shape__: childShape,\r\n      },\r\n      __cardinality__:\r\n        scope.__element__.__pointers__?.[key]?.cardinality ||\r\n        scope.__element__.__shape__?.[key]?.__cardinality__,\r\n      __expr__: childExpr,\r\n      __modifiers__: modifiers,\r\n      __scope__: childExpr !== childScope ? childScope : undefined,\r\n    };\r\n    return needsAssertSingle ? $assert_single(selectExpr as any) : selectExpr;\r\n  } else if ((value as any)?.__kind__ === ExpressionKind.PolyShapeElement) {\r\n    const polyElement = value as $expr_PolyShapeElement;\r\n\r\n    const polyScope = (scope as any).is(polyElement.__polyType__);\r\n    return {\r\n      __kind__: ExpressionKind.PolyShapeElement,\r\n      __polyType__: polyScope,\r\n      __shapeElement__: resolveShapeElement(\r\n        key,\r\n        polyElement.__shapeElement__,\r\n        polyScope\r\n      ),\r\n    };\r\n  } else if (typeof value === \"boolean\" && key.startsWith(\"@\")) {\r\n    const linkProp = (scope as any)[key];\r\n    if (!linkProp) {\r\n      throw new Error(\r\n        (scope as any).__parent__\r\n          ? `link property '${key}' does not exist on link ${\r\n              (scope as any).__parent__.linkName\r\n            }`\r\n          : `cannot select link property '${key}' on an object (${scope.__element__.__name__})`\r\n      );\r\n    }\r\n    return value ? linkProp : false;\r\n  } else {\r\n    return value;\r\n  }\r\n}\r\n"},{"path":"set.mts","content":"import type { ExpressionKind, Cardinality } from \"edgedb/dist/reflection/index.js\";\r\nimport { TypeKind } from \"edgedb/dist/reflection/index.js\";\r\nimport type {\r\n  ArrayType,\r\n  BaseTypeTuple,\r\n  BaseType,\r\n  NamedTupleType,\r\n  ObjectTypeSet,\r\n  TypeSet,\r\n  TupleType,\r\n  Expression,\r\n  ObjectType,\r\n  getPrimitiveBaseType,\r\n  SomeType,\r\n} from \"./typesystem.mjs\";\r\n\r\nimport { $mergeObjectTypes, type mergeObjectTypes } from \"./hydrate.mjs\";\r\n\r\nimport * as castMaps from \"./castMaps.mjs\";\r\n\r\nexport function getSharedParent(a: SomeType, b: SomeType): SomeType {\r\n  if (a.__kind__ !== b.__kind__) {\r\n    throw new Error(\r\n      `Incompatible array types: ${a.__name__} and ${b.__name__}`\r\n    );\r\n  }\r\n  if (a.__kind__ === TypeKind.scalar && b.__kind__ === TypeKind.scalar) {\r\n    return castMaps.getSharedParentScalar(a, b);\r\n  } else if (a.__kind__ === TypeKind.object && b.__kind__ === TypeKind.object) {\r\n    return $mergeObjectTypes(a, b);\r\n  } else if (a.__kind__ === TypeKind.tuple && b.__kind__ === TypeKind.tuple) {\r\n    if (a.__items__.length !== b.__items__.length) {\r\n      throw new Error(\r\n        `Incompatible tuple types: ${a.__name__} and ${b.__name__}`\r\n      );\r\n    }\r\n    try {\r\n      const items = a.__items__.map((_, i) => {\r\n        if (!a.__items__[i] || !b.__items__[i]) {\r\n          throw new Error();\r\n        }\r\n        return getSharedParent(\r\n          a.__items__[i] as SomeType,\r\n          b.__items__[i] as SomeType\r\n        );\r\n      });\r\n\r\n      return {\r\n        __kind__: TypeKind.tuple,\r\n        __name__: `tuple<${items.map((item) => item.__name__).join(\", \")}>`,\r\n        __items__: items as BaseTypeTuple,\r\n      };\r\n    } catch (err) {\r\n      throw new Error(\r\n        `Incompatible tuple types: ${a.__name__} and ${b.__name__}`\r\n      );\r\n    }\r\n  } else if (\r\n    a.__kind__ === TypeKind.namedtuple &&\r\n    b.__kind__ === TypeKind.namedtuple\r\n  ) {\r\n    const aKeys = Object.keys(a);\r\n    const bKeys = new Set(Object.keys(b));\r\n    const sameKeys =\r\n      aKeys.length === bKeys.size && aKeys.every((k) => bKeys.has(k));\r\n    if (!sameKeys) {\r\n      throw new Error(\r\n        `Incompatible tuple types: ${a.__name__} and ${b.__name__}`\r\n      );\r\n    }\r\n    try {\r\n      const items: { [k: string]: BaseType } = {};\r\n      for (const [i] of Object.entries(a.__shape__)) {\r\n        if (!a.__shape__[i] || !b.__shape__[i]) {\r\n          throw new Error();\r\n        }\r\n        items[i] = getSharedParent(\r\n          a.__shape__[i] as SomeType,\r\n          b.__shape__[i] as SomeType\r\n        );\r\n      }\r\n\r\n      return {\r\n        __kind__: TypeKind.namedtuple,\r\n        __name__: `tuple<${Object.entries(items)\r\n          .map(([key, val]: [string, any]) => `${key}: ${val.__name__}`)\r\n          .join(\", \")}>`,\r\n        __shape__: items,\r\n      };\r\n    } catch (err) {\r\n      throw new Error(\r\n        `Incompatible tuple types: ${a.__name__} and ${b.__name__}`\r\n      );\r\n    }\r\n  } else if (a.__kind__ === TypeKind.array && b.__kind__ === TypeKind.array) {\r\n    try {\r\n      const mergedEl: any = getSharedParent(\r\n        a.__element__ as any,\r\n        b.__element__ as any\r\n      );\r\n      return {\r\n        __kind__: TypeKind.array,\r\n        __name__: a.__name__,\r\n        __element__: mergedEl,\r\n      } as ArrayType;\r\n    } catch (err) {\r\n      throw new Error(\r\n        `Incompatible array types: ${a.__name__} and ${b.__name__}`\r\n      );\r\n    }\r\n  } else if (a.__kind__ === TypeKind.enum && b.__kind__ === TypeKind.enum) {\r\n    if (a.__name__ === b.__name__) return a;\r\n    throw new Error(\r\n      `Incompatible array types: ${a.__name__} and ${b.__name__}`\r\n    );\r\n  } else {\r\n    throw new Error(\r\n      `Incompatible array types: ${a.__name__} and ${b.__name__}`\r\n    );\r\n  }\r\n}\r\n\r\nexport { set } from \"./setImpl.mjs\";\r\n\r\n// export type $expr_Set<Set extends LooseTypeSet = LooseTypeSet> = Expression<\r\nexport type $expr_Set<Set extends LooseTypeSet = LooseTypeSet> = Expression<{\r\n  __element__: Set[\"__element__\"];\r\n  __cardinality__: Set[\"__cardinality__\"];\r\n  __exprs__: TypeSet[];\r\n  __kind__: ExpressionKind.Set;\r\n}>;\r\n\r\ntype mergeTypeTuples<AItems, BItems> = {\r\n  [k in keyof AItems]: k extends keyof BItems\r\n    ? getSharedParentPrimitive<AItems[k], BItems[k]>\r\n    : never;\r\n};\r\n\r\n// find shared parent of two primitives\r\nexport type getSharedParentPrimitive<A, B> = A extends undefined\r\n  ? B extends undefined\r\n    ? undefined\r\n    : B\r\n  : B extends undefined\r\n  ? A\r\n  : A extends ArrayType<infer AEl>\r\n  ? B extends ArrayType<infer BEl>\r\n    ? ArrayType<castMaps.getSharedParentScalar<AEl, BEl>>\r\n    : never\r\n  : A extends NamedTupleType<infer AShape>\r\n  ? B extends NamedTupleType<infer BShape>\r\n    ? NamedTupleType<{\r\n        [k in keyof AShape & keyof BShape]: castMaps.getSharedParentScalar<\r\n          AShape[k],\r\n          BShape[k]\r\n        >;\r\n      }>\r\n    : never\r\n  : A extends TupleType<infer AItems>\r\n  ? B extends TupleType<infer BItems>\r\n    ? mergeTypeTuples<AItems, BItems> extends BaseTypeTuple\r\n      ? TupleType<mergeTypeTuples<AItems, BItems>>\r\n      : never\r\n    : never\r\n  : castMaps.getSharedParentScalar<A, B>;\r\n\r\ntype _getSharedParentPrimitiveVariadic<Types extends [any, ...any[]]> =\r\n  Types extends [infer U]\r\n    ? U\r\n    : Types extends [infer A, infer B, ...infer Rest]\r\n    ? _getSharedParentPrimitiveVariadic<\r\n        [getSharedParentPrimitive<A, B>, ...Rest]\r\n      >\r\n    : never;\r\n\r\nexport type getSharedParentPrimitiveVariadic<Types extends [any, ...any[]]> =\r\n  _getSharedParentPrimitiveVariadic<Types>;\r\n\r\nexport type LooseTypeSet<\r\n  T extends any = any,\r\n  C extends Cardinality = Cardinality\r\n> = {\r\n  __element__: T;\r\n  __cardinality__: C;\r\n};\r\n\r\nexport type { mergeObjectTypes };\r\n\r\ntype _mergeObjectTypesVariadic<Types extends [ObjectType, ...ObjectType[]]> =\r\n  Types extends [infer U]\r\n    ? U\r\n    : Types extends [infer A, infer B, ...infer Rest]\r\n    ? A extends ObjectType\r\n      ? B extends ObjectType\r\n        ? mergeObjectTypes<A, B> extends BaseType\r\n          ? mergeObjectTypesVariadic<[mergeObjectTypes<A, B>, ...Rest]>\r\n          : never\r\n        : never\r\n      : never\r\n    : never;\r\n\r\nexport type mergeObjectTypesVariadic<Types extends [any, ...any[]]> =\r\n  _mergeObjectTypesVariadic<Types>;\r\n\r\nexport type getTypesFromExprs<Exprs extends [TypeSet, ...TypeSet[]]> = {\r\n  [k in keyof Exprs]: Exprs[k] extends TypeSet<infer El, any>\r\n    ? getPrimitiveBaseType<El>\r\n    : never;\r\n};\r\n\r\nexport type getTypesFromObjectExprs<\r\n  Exprs extends [ObjectTypeSet, ...ObjectTypeSet[]]\r\n> = {\r\n  [k in keyof Exprs]: Exprs[k] extends TypeSet<infer El, any> ? El : never;\r\n};\r\n\r\nexport type getCardsFromExprs<Exprs extends [TypeSet, ...TypeSet[]]> = {\r\n  [k in keyof Exprs]: Exprs[k] extends TypeSet<any, infer Card> ? Card : never;\r\n};\r\n"},{"path":"setImpl.mts","content":"export function set(...args: any[]): any {}\r\n"},{"path":"syntax.mts","content":"import type { TypeSet, setToTsType } from \"./typesystem.mjs\";\r\n\r\nexport * from \"./literal.mjs\";\r\nexport * from \"./path.mjs\";\r\nexport * from \"./set.mjs\";\r\nexport * from \"./cast.mjs\";\r\nexport * from \"./select.mjs\";\r\nexport * from \"./update.mjs\";\r\nexport * from \"./insert.mjs\";\r\nexport * from \"./group.mjs\";\r\nexport * from \"./collections.mjs\";\r\nexport * from \"./funcops.mjs\";\r\nexport * from \"./for.mjs\";\r\nexport * from \"./with.mjs\";\r\nexport * from \"./params.mjs\";\r\nexport * from \"./globals.mjs\";\r\nexport * from \"./detached.mjs\";\r\nexport * from \"./toEdgeQL.mjs\";\r\nexport * from \"./range.mjs\";\r\n\r\nexport type $infer<A extends TypeSet> = setToTsType<A>;\r\n"},{"path":"toEdgeQL.mts","content":"import {\r\n  Duration,\r\n  LocalDate,\r\n  LocalDateTime,\r\n  LocalTime,\r\n  RelativeDuration,\r\n  DateDuration,\r\n  Range,\r\n} from \"edgedb\";\r\nimport {\r\n  Cardinality,\r\n  ExpressionKind,\r\n  OperatorKind,\r\n  TypeKind,\r\n  util,\r\n} from \"edgedb/dist/reflection/index.js\";\r\nimport {\r\n  type $expr_Array,\r\n  type $expr_NamedTuple,\r\n  type $expr_Tuple,\r\n  type $expr_TuplePath,\r\n  type BaseType,\r\n  type EnumType,\r\n  isArrayType,\r\n  isNamedTupleType,\r\n  isObjectType,\r\n  isTupleType,\r\n  type ObjectType,\r\n  type ObjectTypeSet,\r\n  type RangeType,\r\n  type TypeSet,\r\n} from \"./typesystem.mjs\";\r\nimport type { $expr_Literal } from \"./literal.mjs\";\r\nimport type {\r\n  $expr_PathLeaf,\r\n  $expr_PathNode,\r\n  $expr_TypeIntersection,\r\n} from \"./path.mjs\";\r\nimport { reservedKeywords } from \"edgedb/dist/reflection/index.js\";\r\nimport type { $expr_Cast } from \"./cast.mjs\";\r\nimport type { $expr_Detached } from \"./detached.mjs\";\r\nimport type { $expr_For, $expr_ForVar } from \"./for.mjs\";\r\nimport type { $expr_Function, $expr_Operator } from \"./funcops.mjs\";\r\nimport type { $expr_Insert, $expr_InsertUnlessConflict } from \"./insert.mjs\";\r\nimport type { $expr_Param, $expr_WithParams } from \"./params.mjs\";\r\nimport type {\r\n  $expr_Delete,\r\n  $expr_Select,\r\n  LimitExpression,\r\n  OffsetExpression,\r\n} from \"./select.mjs\";\r\nimport type { $expr_Set } from \"./set.mjs\";\r\nimport type { $expr_Update } from \"./update.mjs\";\r\nimport type { $expr_Alias, $expr_With } from \"./with.mjs\";\r\nimport type { $expr_Group, GroupingSet } from \"./group.mjs\";\r\nimport type { $expr_Global } from \"./globals.mjs\";\r\n\r\nexport type SomeExpression =\r\n  | $expr_PathNode\r\n  | $expr_PathLeaf\r\n  | $expr_Literal\r\n  | $expr_Set\r\n  | $expr_Array\r\n  | $expr_Tuple\r\n  | $expr_NamedTuple\r\n  | $expr_TuplePath\r\n  | $expr_Cast\r\n  | $expr_Select\r\n  | $expr_Delete\r\n  | $expr_Update\r\n  | $expr_Insert\r\n  | $expr_InsertUnlessConflict\r\n  | $expr_Function\r\n  | $expr_Operator\r\n  | $expr_For\r\n  | $expr_ForVar\r\n  | $expr_TypeIntersection\r\n  | $expr_Alias\r\n  | $expr_With\r\n  | $expr_WithParams\r\n  | $expr_Param\r\n  | $expr_Detached\r\n  | $expr_Group\r\n  | $expr_Global;\r\n\r\ntype WithScopeExpr =\r\n  | $expr_Select\r\n  | $expr_Update\r\n  | $expr_Insert\r\n  | $expr_InsertUnlessConflict\r\n  | $expr_For\r\n  | $expr_Group;\r\n\r\ninterface RenderCtx {\r\n  // mapping withable expr to list of with vars\r\n  withBlocks: Map<WithScopeExpr, Set<SomeExpression>>;\r\n  // metadata about each with var\r\n  withVars: Map<\r\n    SomeExpression,\r\n    {\r\n      name: string;\r\n      scope: WithScopeExpr;\r\n      childExprs: Set<SomeExpression>;\r\n      scopedExpr?: SomeExpression; // scope vars only\r\n    }\r\n  >;\r\n  renderWithVar?: SomeExpression;\r\n  forVars: Map<$expr_ForVar, string>;\r\n  linkProps: Map<SomeExpression, string[]>;\r\n}\r\n\r\nexport function $toEdgeQL(this: any) {\r\n  const walkExprCtx: WalkExprTreeCtx = {\r\n    seen: new Map(),\r\n    rootScope: null,\r\n  };\r\n\r\n  walkExprTree(this, null, walkExprCtx);\r\n\r\n  // get variables by block\r\n  const withBlocks: RenderCtx[\"withBlocks\"] = new Map();\r\n  // get per-variable metadata\r\n  const withVars: RenderCtx[\"withVars\"] = new Map();\r\n  const seen = new Map(walkExprCtx.seen);\r\n  const linkProps: RenderCtx[\"linkProps\"] = new Map();\r\n\r\n  // iterate over all expressions\r\n  for (const [expr, refData] of seen) {\r\n    // delete from seen after visitinng\r\n    seen.delete(expr);\r\n\r\n    // convert referenced link props to simple string array\r\n    if (refData.linkProps.length) {\r\n      linkProps.set(\r\n        expr,\r\n        refData.linkProps.map((linkProp) =>\r\n          linkProp.__parent__.linkName.slice(1)\r\n        )\r\n      );\r\n    }\r\n\r\n    // already extracted\r\n    if (withVars.has(expr)) {\r\n      continue;\r\n    }\r\n\r\n    // ignore unbound leaves, nodes, and intersections\r\n    // these should be rendered as is\r\n    if (\r\n      !refData.boundScope &&\r\n      (expr.__kind__ === ExpressionKind.PathLeaf ||\r\n        expr.__kind__ === ExpressionKind.PathNode ||\r\n        expr.__kind__ === ExpressionKind.TypeIntersection)\r\n    ) {\r\n      continue;\r\n    }\r\n\r\n    // forvars and params should not be hoisted\r\n    if (\r\n      expr.__kind__ === ExpressionKind.ForVar ||\r\n      expr.__kind__ === ExpressionKind.Param\r\n    ) {\r\n      continue;\r\n    }\r\n\r\n    // pull out scope variables\r\n    // from select, update, and group expressions.\r\n    // these are always rendered in with blocks\r\n    if (\r\n      (expr.__kind__ === ExpressionKind.Select ||\r\n        expr.__kind__ === ExpressionKind.Update ||\r\n        expr.__kind__ === ExpressionKind.Group) &&\r\n      expr.__scope__ &&\r\n      // with var not previously registered\r\n      !withVars.has(expr.__scope__ as any)\r\n    ) {\r\n      const withBlock = expr;\r\n      const scopeVar = expr.__scope__ as SomeExpression;\r\n      const scopeVarName = `__scope_${\r\n        withVars.size\r\n      }_${scopeVar.__element__.__name__.replace(/[^A-Za-z]/g, \"\")}`;\r\n\r\n      withVars.set(scopeVar, {\r\n        name: scopeVarName,\r\n        scope: withBlock,\r\n        childExprs: new Set(),\r\n        scopedExpr:\r\n          expr.__element__.__kind__ === TypeKind.object\r\n            ? (expr.__expr__ as any)\r\n            : undefined,\r\n      });\r\n    }\r\n\r\n    // expression should be extracted to with block if\r\n    // - bound with e.with\r\n    // - refcount > 1\r\n    // - aliased with e.alias\r\n    if (\r\n      refData.refCount > 1 ||\r\n      refData.boundScope ||\r\n      refData.aliases.length > 0\r\n    ) {\r\n      // first, check if expr is bound to scope\r\n      let withBlock = refData.boundScope;\r\n\r\n      const parentScopes = [...refData.parentScopes];\r\n\r\n      // if expression is unbound\r\n      if (!withBlock) {\r\n        // if parent scopes haven't all been resolved,\r\n        // re-add current expr to `seen` to be resolved later\r\n        if (\r\n          parentScopes.some(\r\n            (parentScope) => parentScope && seen.has(parentScope)\r\n          )\r\n        ) {\r\n          seen.set(expr, refData);\r\n          continue;\r\n        }\r\n\r\n        if (parentScopes.some((scope) => scope == null)) {\r\n          throw new Error(\r\n            `Cannot extract repeated expression into 'WITH' block, ` +\r\n              `expression used outside of 'WITH'able expression`\r\n          );\r\n        }\r\n\r\n        const [firstParentScopeChain, ...parentScopeChains] = parentScopes.map(\r\n          (scope) => {\r\n            const scopes: WithScopeExpr[] = [scope!];\r\n            const pendingScopes = [scope];\r\n            while (pendingScopes.length) {\r\n              const currentScope = pendingScopes.shift()!;\r\n              pendingScopes.push(\r\n                ...[...walkExprCtx.seen.get(currentScope)!.parentScopes].filter(\r\n                  (s) => s !== null\r\n                )\r\n              );\r\n              if (!scopes.includes(currentScope)) {\r\n                scopes.push(currentScope);\r\n              }\r\n            }\r\n            return scopes;\r\n          }\r\n        );\r\n        const commonParentScope = firstParentScopeChain\r\n          ? firstParentScopeChain.find((scope) =>\r\n              // find the first parent scope in the chain that is shared by\r\n              // the other parent scope chains\r\n              parentScopeChains.every((otherScope) =>\r\n                otherScope.includes(scope)\r\n              )\r\n            )\r\n          : null;\r\n\r\n        withBlock = commonParentScope ?? walkExprCtx.rootScope;\r\n      }\r\n\r\n      if (!withBlock) {\r\n        throw new Error(\r\n          `Cannot extract repeated expression into 'WITH' block, ` +\r\n            `expression does not appear within common 'WITH'able expression`\r\n        );\r\n      }\r\n\r\n      if (!withBlocks.has(withBlock)) {\r\n        withBlocks.set(withBlock, new Set());\r\n      }\r\n\r\n      // check all references and aliases are within this block\r\n      const validScopes = new Set([\r\n        withBlock,\r\n        ...walkExprCtx.seen.get(withBlock)!.childExprs,\r\n      ]);\r\n      for (const scope of [\r\n        ...refData.parentScopes,\r\n        ...util.flatMap(refData.aliases, (alias) => [\r\n          ...walkExprCtx.seen.get(alias)!.parentScopes,\r\n        ]),\r\n      ]) {\r\n        if (scope === null || !validScopes.has(scope)) {\r\n          throw new Error(\r\n            refData.boundScope\r\n              ? `Expr or its aliases used outside of declared 'WITH' block scope`\r\n              : `Cannot extract repeated or aliased expression into 'WITH' block, ` +\r\n                `expression or its aliases appear outside root scope`\r\n          );\r\n        }\r\n      }\r\n\r\n      for (const withVar of [expr, ...refData.aliases]) {\r\n        // withVar is an alias already explicitly bound\r\n        // to an inner WITH block\r\n        const withVarBoundScope = walkExprCtx.seen.get(withVar)!.boundScope;\r\n        if (withVarBoundScope && withVarBoundScope !== refData.boundScope) {\r\n          continue;\r\n        }\r\n\r\n        const withVarName = `__withVar_${withVars.size}`;\r\n\r\n        withBlocks.get(withBlock)!.add(withVar);\r\n        withVars.set(withVar, {\r\n          name: withVarName,\r\n          scope: withBlock,\r\n          childExprs: new Set(walkExprCtx.seen.get(withVar)!.childExprs),\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  let edgeQL = renderEdgeQL(this, {\r\n    withBlocks,\r\n    withVars,\r\n    forVars: new Map(),\r\n    linkProps,\r\n  });\r\n  if (\r\n    edgeQL.startsWith(\"(\") &&\r\n    edgeQL.endsWith(\")\") &&\r\n    !(\r\n      this.__kind__ === ExpressionKind.Tuple ||\r\n      this.__kind__ === ExpressionKind.NamedTuple ||\r\n      this.__kind__ === ExpressionKind.Literal\r\n    )\r\n  ) {\r\n    edgeQL = edgeQL.slice(1, -1);\r\n  }\r\n\r\n  return edgeQL;\r\n}\r\n\r\ninterface WalkExprTreeCtx {\r\n  seen: Map<\r\n    SomeExpression,\r\n    {\r\n      refCount: number;\r\n      // tracks all withable ancestors\r\n      parentScopes: Set<WithScopeExpr | null>;\r\n      // tracks all child exprs\r\n      childExprs: SomeExpression[];\r\n      // tracks bound scope from e.with\r\n      boundScope: WithScopeExpr | null;\r\n      // tracks aliases from e.alias\r\n      aliases: SomeExpression[];\r\n      linkProps: $expr_PathLeaf[];\r\n    }\r\n  >;\r\n  rootScope: WithScopeExpr | null;\r\n}\r\n\r\n// walks entire expression tree\r\n// populates\r\nfunction walkExprTree(\r\n  _expr: TypeSet,\r\n  parentScope: WithScopeExpr | null,\r\n  ctx: WalkExprTreeCtx\r\n): SomeExpression[] {\r\n  if (!(_expr as any).__kind__) {\r\n    throw new Error(\r\n      `Expected a valid querybuilder expression, ` +\r\n        `instead received ${typeof _expr}${\r\n          typeof _expr !== \"undefined\" ? `: '${_expr}'` : \"\"\r\n        }.` +\r\n        getErrorHint(_expr)\r\n    );\r\n  }\r\n\r\n  const expr = _expr as SomeExpression;\r\n\r\n  function walkShape(shape: object) {\r\n    for (let param of Object.values(shape)) {\r\n      if (param.__kind__ === ExpressionKind.PolyShapeElement) {\r\n        param = param.__shapeElement__;\r\n      }\r\n      if (typeof param === \"object\") {\r\n        if (!!(param as any).__kind__) {\r\n          // param is expression\r\n          childExprs.push(...walkExprTree(param as any, expr as any, ctx));\r\n        } else {\r\n          walkShape(param);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // set root scope\r\n  if (!ctx.rootScope && parentScope) {\r\n    ctx.rootScope = parentScope;\r\n  }\r\n\r\n  // return without walking if expression has been seen\r\n  const seenExpr = ctx.seen.get(expr);\r\n  if (seenExpr) {\r\n    seenExpr.refCount += 1;\r\n    // if (seenExpr.refCount > 1) {\r\n    // console.log(`###########\\nSEEN ${seenExpr.refCount} times`);\r\n    // console.log(expr.__kind__);\r\n    // console.log(expr.__element__.__name__);\r\n    // const arg = (expr as any)?.__parent__ || (expr as any)?.__name__;\r\n    // if (arg) console.log(arg);\r\n    // }\r\n    seenExpr.parentScopes.add(parentScope);\r\n    return [expr, ...seenExpr.childExprs];\r\n  }\r\n\r\n  const childExprs: SomeExpression[] = [];\r\n  ctx.seen.set(expr, {\r\n    refCount: 1,\r\n    parentScopes: new Set([parentScope]),\r\n    childExprs,\r\n    boundScope: null,\r\n    aliases: [],\r\n    linkProps: [],\r\n  });\r\n\r\n  switch (expr.__kind__) {\r\n    case ExpressionKind.Alias:\r\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\r\n      ctx.seen.get(expr.__expr__ as any)!.aliases.push(expr);\r\n      break;\r\n    case ExpressionKind.With:\r\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\r\n      for (const refExpr of expr.__refs__) {\r\n        walkExprTree(refExpr, expr.__expr__, ctx);\r\n        const seenRef = ctx.seen.get(refExpr as any)!;\r\n        if (seenRef.boundScope) {\r\n          throw new Error(`Expression bound to multiple 'WITH' blocks`);\r\n        }\r\n        seenRef.boundScope = expr.__expr__;\r\n      }\r\n      break;\r\n    case ExpressionKind.Literal:\r\n    case ExpressionKind.ForVar:\r\n    case ExpressionKind.Param:\r\n      break;\r\n    case ExpressionKind.PathLeaf:\r\n    case ExpressionKind.PathNode:\r\n      if (expr.__parent__) {\r\n        if ((expr.__parent__.type as any).__scopedFrom__) {\r\n          // if parent is scoped expr then don't walk expr\r\n          // since it will already be walked by enclosing select/update\r\n\r\n          childExprs.push(expr.__parent__.type as any);\r\n        } else {\r\n          childExprs.push(\r\n            ...walkExprTree(expr.__parent__.type, parentScope, ctx)\r\n          );\r\n        }\r\n\r\n        if (\r\n          // is link prop\r\n          expr.__kind__ === ExpressionKind.PathLeaf &&\r\n          expr.__parent__.linkName.startsWith(\"@\")\r\n        ) {\r\n          // don't hoist a linkprop that isn't scoped from parentScope\r\n          const parentScopeVar = (parentScope as any).__scope__;\r\n          if (parentScopeVar === expr.__parent__.type) {\r\n            ctx.seen.get(parentScope!)?.linkProps.push(expr);\r\n          }\r\n        }\r\n      }\r\n      break;\r\n    case ExpressionKind.Cast:\r\n      if (expr.__expr__ === null) break;\r\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\r\n      break;\r\n    case ExpressionKind.Set:\r\n      for (const subExpr of expr.__exprs__) {\r\n        childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\r\n      }\r\n      break;\r\n    case ExpressionKind.Array:\r\n      for (const subExpr of expr.__items__) {\r\n        childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\r\n      }\r\n      break;\r\n    case ExpressionKind.Tuple:\r\n      for (const subExpr of expr.__items__) {\r\n        childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\r\n      }\r\n      break;\r\n    case ExpressionKind.NamedTuple:\r\n      for (const subExpr of Object.values(expr.__shape__)) {\r\n        childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\r\n      }\r\n      break;\r\n    case ExpressionKind.TuplePath:\r\n      childExprs.push(...walkExprTree(expr.__parent__, parentScope, ctx));\r\n      break;\r\n    case ExpressionKind.Select:\r\n    case ExpressionKind.Update: {\r\n      const modifiers = expr.__modifiers__;\r\n      if (modifiers.filter) {\r\n        childExprs.push(...walkExprTree(modifiers.filter, expr, ctx));\r\n      }\r\n      if (modifiers.order_by) {\r\n        for (const orderExpr of modifiers.order_by) {\r\n          childExprs.push(...walkExprTree(orderExpr.expression, expr, ctx));\r\n        }\r\n      }\r\n      if (modifiers.offset) {\r\n        childExprs.push(...walkExprTree(modifiers.offset!, expr, ctx));\r\n      }\r\n      if (modifiers.limit) {\r\n        childExprs.push(...walkExprTree(modifiers.limit!, expr, ctx));\r\n      }\r\n\r\n      if (expr.__kind__ === ExpressionKind.Select) {\r\n        if (\r\n          isObjectType(expr.__element__) &&\r\n          // don't walk shape twice if select expr justs wrap another object\r\n          // type expr with the same shape\r\n          expr.__element__.__shape__ !==\r\n            (expr.__expr__ as ObjectTypeSet).__element__.__shape__\r\n        ) {\r\n          walkShape(expr.__element__.__shape__ ?? {});\r\n        }\r\n      } else {\r\n        // Update\r\n        const shape: any = expr.__shape__ ?? {};\r\n\r\n        for (const _element of Object.values(shape)) {\r\n          let element: any = _element;\r\n          if (!element.__element__) {\r\n            if (element[\"+=\"]) element = element[\"+=\"];\r\n            else if (element[\"-=\"]) element = element[\"-=\"];\r\n          }\r\n          childExprs.push(...walkExprTree(element as any, expr, ctx));\r\n        }\r\n      }\r\n\r\n      childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\r\n      break;\r\n    }\r\n    case ExpressionKind.Delete: {\r\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\r\n      break;\r\n    }\r\n    case ExpressionKind.Insert: {\r\n      const shape: any = expr.__shape__ ?? {};\r\n\r\n      for (const element of Object.values(shape)) {\r\n        childExprs.push(...walkExprTree(element as any, expr, ctx));\r\n      }\r\n\r\n      childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\r\n      break;\r\n    }\r\n    case ExpressionKind.InsertUnlessConflict: {\r\n      // InsertUnlessConflict doesn't create a new scope, the parent scope of\r\n      // child expressions is the wrapped Insert expr\r\n      const insertChildExprs: SomeExpression[] = [];\r\n      if (expr.__conflict__.on) {\r\n        insertChildExprs.push(\r\n          ...walkExprTree(\r\n            expr.__conflict__.on,\r\n            expr.__expr__ as $expr_Insert,\r\n            ctx\r\n          )\r\n        );\r\n      }\r\n      if (expr.__conflict__.else) {\r\n        insertChildExprs.push(\r\n          ...walkExprTree(\r\n            expr.__conflict__.else,\r\n            expr.__expr__ as $expr_Insert,\r\n            ctx\r\n          )\r\n        );\r\n      }\r\n\r\n      walkExprTree(expr.__expr__, parentScope, ctx);\r\n      ctx.seen\r\n        .get(expr.__expr__ as $expr_Insert)!\r\n        .childExprs.push(...insertChildExprs);\r\n      break;\r\n    }\r\n    case ExpressionKind.Group: {\r\n      const groupingSet = expr.__modifiers__.by as any as GroupingSet;\r\n      // const groupingSet = expr.__grouping__ as any as GroupingSet;\r\n      for (const [_k, groupExpr] of groupingSet.__exprs__) {\r\n        // this prevents recurring grouping elements from being walked twice\r\n        // this way, these won't get pulled into with blocks,\r\n        // which is good because they need to be rendered in `using`\r\n        const seen: Set<any> = new Set();\r\n        if (!seen.has(expr)) {\r\n          childExprs.push(...walkExprTree(groupExpr, expr, ctx));\r\n          seen.add(expr);\r\n        }\r\n      }\r\n\r\n      if (!expr.__element__.__shape__.elements.__element__.__shape__) {\r\n        throw new Error(\"Missing shape in GROUP statement\");\r\n      }\r\n      walkShape(expr.__element__.__shape__.elements.__element__.__shape__);\r\n      childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\r\n      break;\r\n    }\r\n    case ExpressionKind.TypeIntersection:\r\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\r\n      break;\r\n    case ExpressionKind.Operator:\r\n    case ExpressionKind.Function:\r\n      for (const subExpr of expr.__args__) {\r\n        if (Array.isArray(subExpr)) {\r\n          for (const arg of subExpr) {\r\n            if (arg) childExprs.push(...walkExprTree(arg, parentScope, ctx));\r\n          }\r\n        } else {\r\n          childExprs.push(...walkExprTree(subExpr!, parentScope, ctx));\r\n        }\r\n      }\r\n      if (expr.__kind__ === ExpressionKind.Function) {\r\n        for (const subExpr of Object.values(expr.__namedargs__)) {\r\n          childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\r\n        }\r\n      }\r\n      break;\r\n    case ExpressionKind.For: {\r\n      childExprs.push(...walkExprTree(expr.__iterSet__ as any, expr, ctx));\r\n      childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\r\n      break;\r\n    }\r\n    case ExpressionKind.WithParams: {\r\n      if (parentScope !== null) {\r\n        throw new Error(\r\n          `'withParams' does not support being used as a nested expression`\r\n        );\r\n      }\r\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\r\n      break;\r\n    }\r\n    case ExpressionKind.Detached: {\r\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\r\n      break;\r\n    }\r\n    case ExpressionKind.Global:\r\n      break;\r\n    default:\r\n      util.assertNever(\r\n        expr,\r\n        new Error(`Unrecognized expression kind: \"${(expr as any).__kind__}\"`)\r\n      );\r\n  }\r\n\r\n  return [expr, ...childExprs];\r\n}\r\n\r\nfunction renderEdgeQL(\r\n  _expr: TypeSet,\r\n  ctx: RenderCtx,\r\n  renderShape: boolean = true,\r\n  noImplicitDetached: boolean = false\r\n): string {\r\n  if (!(_expr as any).__kind__) {\r\n    throw new Error(\"Invalid expression.\");\r\n  }\r\n  const expr = _expr as SomeExpression;\r\n\r\n  // if expression is in a with block\r\n  // render its name\r\n  const withVar = ctx.withVars.get(expr);\r\n\r\n  if (withVar && ctx.renderWithVar !== expr) {\r\n    return renderShape &&\r\n      expr.__kind__ === ExpressionKind.Select &&\r\n      isObjectType(expr.__element__)\r\n      ? `(${withVar.name} ${shapeToEdgeQL(\r\n          (expr.__element__.__shape__ || {}) as object,\r\n          ctx,\r\n          null,\r\n          true // render shape only\r\n        )})`\r\n      : withVar.name;\r\n  }\r\n\r\n  // render with block expression\r\n  function renderWithBlockExpr(\r\n    varExpr: SomeExpression,\r\n    _noImplicitDetached?: boolean\r\n  ) {\r\n    const withBlockElement = ctx.withVars.get(varExpr)!;\r\n    let renderedExpr = renderEdgeQL(\r\n      withBlockElement.scopedExpr ?? varExpr,\r\n      {\r\n        ...ctx,\r\n        renderWithVar: varExpr,\r\n      },\r\n      !withBlockElement.scopedExpr, // render shape if no scopedExpr exists\r\n      _noImplicitDetached\r\n    );\r\n    const renderedExprNoDetached = renderEdgeQL(\r\n      withBlockElement.scopedExpr ?? varExpr,\r\n      {\r\n        ...ctx,\r\n        renderWithVar: varExpr,\r\n      },\r\n      !withBlockElement.scopedExpr, // render shape if no scopedExpr exists\r\n      true\r\n    );\r\n\r\n    if (ctx.linkProps.has(expr)) {\r\n      renderedExpr = `(SELECT ${renderedExpr} {\\n${ctx.linkProps\r\n        .get(expr)!\r\n        .map(\r\n          (linkPropName) =>\r\n            `  __linkprop_${linkPropName} := ${renderedExprNoDetached}@${linkPropName}`\r\n        )\r\n        .join(\",\\n\")}\\n})`;\r\n    }\r\n    return `  ${withBlockElement.name} := ${\r\n      renderedExpr.includes(\"\\n\")\r\n        ? `(\\n${indent(\r\n            renderedExpr[0] === \"(\" &&\r\n              renderedExpr[renderedExpr.length - 1] === \")\"\r\n              ? renderedExpr.slice(1, -1)\r\n              : renderedExpr,\r\n            4\r\n          )}\\n  )`\r\n        : renderedExpr\r\n    }`;\r\n  }\r\n\r\n  // extract scope expression from select/update if exists\r\n  const scopeExpr =\r\n    (expr.__kind__ === ExpressionKind.Select ||\r\n      expr.__kind__ === ExpressionKind.Update ||\r\n      expr.__kind__ === ExpressionKind.Group) &&\r\n    ctx.withVars.has(expr.__scope__ as any)\r\n      ? (expr.__scope__ as SomeExpression)\r\n      : undefined;\r\n\r\n  const scopeExprVar: string[] = [];\r\n  const unscopedWithBlock: string[] = [];\r\n  const scopedWithBlock: string[] = [];\r\n\r\n  // generate with block if needed\r\n  if (ctx.withBlocks.has(expr as any) || scopeExpr) {\r\n    // sort associated vars\r\n    const sortedBlockVars = topoSortWithVars(\r\n      ctx.withBlocks.get(expr as any) ?? new Set(),\r\n      ctx\r\n    );\r\n\r\n    if (!scopeExpr) {\r\n      // if no scope expression exists, all variables are unscoped\r\n      unscopedWithBlock.push(\r\n        ...sortedBlockVars.map((blockVar) => renderWithBlockExpr(blockVar))\r\n      );\r\n    }\r\n    // else if (expr.__kind__ === ExpressionKind.Group) {\r\n    //   // add all vars into scoped with block\r\n    //   // this is rendered inside the `using` clause later\r\n    //   // no need for the with/for trick\r\n    //   scopeExprVar.push(renderWithBlockExpr(scopeExpr, noImplicitDetached));\r\n    //   scopedWithBlock.push(\r\n    //     ...sortedBlockVars.map(blockVar => renderWithBlockExpr(blockVar))\r\n    //   );\r\n    // }\r\n    else {\r\n      // get scope variable\r\n      const scopeVar = ctx.withVars.get(scopeExpr)!;\r\n\r\n      // get list of with vars that reference scope\r\n      const scopedVars = sortedBlockVars.filter((blockVarExpr) =>\r\n        ctx.withVars.get(blockVarExpr)?.childExprs.has(scopeExpr)\r\n      );\r\n      // filter blockvars to only include vars that don't reference scope\r\n      unscopedWithBlock.push(\r\n        ...sortedBlockVars\r\n          .filter((blockVar) => !scopedVars.includes(blockVar))\r\n          .map((blockVar) => renderWithBlockExpr(blockVar))\r\n      );\r\n\r\n      // when rendering `with` variables that reference current scope\r\n      // they are extracted into computed properties defining in a for loop\r\n      if (!scopedVars.length) {\r\n        scopeExprVar.push(renderWithBlockExpr(scopeExpr, noImplicitDetached));\r\n      } else {\r\n        const scopeName = scopeVar.name;\r\n\r\n        // render a reference to scoped path (e.g. \".nemesis\")\r\n        scopeVar.name = scopeName + \"_expr\";\r\n        scopeExprVar.push(renderWithBlockExpr(scopeExpr, noImplicitDetached));\r\n        // scopedWithBlock.push(\r\n        //   renderWithBlockExpr(scopeExpr, noImplicitDetached)\r\n        // );\r\n\r\n        // render a for loop containing all scoped block vars\r\n        // as computed properties\r\n        scopeVar.name = scopeName + \"_inner\";\r\n        scopeExprVar.push(\r\n          `  ${scopeName} := (FOR ${scopeVar.name} IN {${\r\n            scopeName + \"_expr\"\r\n          }} UNION (\\n    WITH\\n${indent(\r\n            scopedVars\r\n              .map((blockVar) => renderWithBlockExpr(blockVar))\r\n              .join(\",\\n\"),\r\n            4\r\n          )}\\n    SELECT ${scopeVar.name} {\\n${scopedVars\r\n            .map((blockVar) => {\r\n              const name = ctx.withVars.get(blockVar)!.name;\r\n              return `      ${name} := ${name}`;\r\n            })\r\n            .join(\",\\n\")}\\n    }\\n  ))`\r\n        );\r\n\r\n        // change var name back to original value\r\n        scopeVar.name = scopeName;\r\n\r\n        // reassign name for all scoped block vars\r\n        for (const blockVarExpr of scopedVars) {\r\n          const blockVar = ctx.withVars.get(blockVarExpr)!;\r\n          blockVar.name = `${scopeName}.${blockVar.name}`;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  const withBlockElements = [\r\n    ...unscopedWithBlock,\r\n    ...scopeExprVar,\r\n    ...scopedWithBlock,\r\n  ];\r\n  const withBlock = withBlockElements.length\r\n    ? `WITH\\n${withBlockElements.join(\",\\n\")}\\n`\r\n    : \"\";\r\n\r\n  if (expr.__kind__ === ExpressionKind.With) {\r\n    return renderEdgeQL(expr.__expr__, ctx);\r\n  } else if (expr.__kind__ === ExpressionKind.WithParams) {\r\n    return `(WITH\\n${expr.__params__\r\n      .map((param) => {\r\n        const optional =\r\n          param.__cardinality__ === Cardinality.AtMostOne ? \"OPTIONAL \" : \"\";\r\n        let paramExpr: string;\r\n        if (param.__isComplex__) {\r\n          let cast = param.__element__.__name__;\r\n          cast = cast.includes(\"std::decimal\")\r\n            ? `<${cast}><${cast.replace(/std::decimal/g, \"std::str\")}>`\r\n            : `<${cast}>`;\r\n          paramExpr = `${cast}to_json(<${optional}str>$${param.__name__})`;\r\n        } else {\r\n          paramExpr = `<${optional}${param.__element__.__name__}>$${param.__name__}`;\r\n        }\r\n        return `  __param__${param.__name__} := ${paramExpr}`;\r\n      })\r\n      .join(\",\\n\")}\\nSELECT ${renderEdgeQL(expr.__expr__, ctx)})`;\r\n  } else if (expr.__kind__ === ExpressionKind.Alias) {\r\n    const aliasedExprVar = ctx.withVars.get(expr.__expr__ as any);\r\n    if (!aliasedExprVar) {\r\n      throw new Error(\r\n        `Expression referenced by alias does not exist in 'WITH' block`\r\n      );\r\n    }\r\n    return aliasedExprVar.name;\r\n  } else if (\r\n    expr.__kind__ === ExpressionKind.PathNode ||\r\n    expr.__kind__ === ExpressionKind.PathLeaf\r\n  ) {\r\n    if (!expr.__parent__) {\r\n      return `${noImplicitDetached ? \"\" : \"DETACHED \"}${\r\n        expr.__element__.__name__\r\n      }`;\r\n    } else {\r\n      const isScopedLinkProp =\r\n        expr.__parent__.linkName.startsWith(\"@\") &&\r\n        ctx.withVars.has(expr.__parent__.type as any);\r\n      const linkName = isScopedLinkProp\r\n        ? `__linkprop_${expr.__parent__.linkName.slice(1)}`\r\n        : expr.__parent__.linkName;\r\n      const parent = renderEdgeQL(\r\n        expr.__parent__.type,\r\n        ctx,\r\n        false,\r\n        noImplicitDetached\r\n      );\r\n      return `${parent}${linkName.startsWith(\"@\") ? \"\" : \".\"}${q(linkName)}`;\r\n    }\r\n  } else if (expr.__kind__ === ExpressionKind.Literal) {\r\n    return literalToEdgeQL(expr.__element__, expr.__value__);\r\n  } else if (expr.__kind__ === ExpressionKind.Set) {\r\n    const exprs = expr.__exprs__;\r\n\r\n    if (\r\n      exprs.every((ex) => ex.__element__.__kind__ === TypeKind.object) ||\r\n      exprs.every((ex) => ex.__element__.__kind__ !== TypeKind.object)\r\n    ) {\r\n      if (exprs.length === 0) return `<${expr.__element__.__name__}>{}`;\r\n      return `{ ${exprs.map((ex) => renderEdgeQL(ex, ctx)).join(\", \")} }`;\r\n    } else {\r\n      throw new Error(\r\n        `Invalid arguments to set constructor: ${exprs\r\n          .map((ex) => ex.__element__.__name__)\r\n          .join(\", \")}`\r\n      );\r\n    }\r\n  } else if (expr.__kind__ === ExpressionKind.Array) {\r\n    return `[${expr.__items__\r\n      .map((item) => renderEdgeQL(item, ctx))\r\n      .join(\", \")}]`;\r\n  } else if (expr.__kind__ === ExpressionKind.Tuple) {\r\n    return `(\\n${expr.__items__\r\n      .map(\r\n        (item) =>\r\n          `  ` + renderEdgeQL(item, ctx, renderShape, noImplicitDetached)\r\n      )\r\n      .join(\",\\n\")}${expr.__items__.length === 1 ? \",\" : \"\"}\\n)`;\r\n  } else if (expr.__kind__ === ExpressionKind.NamedTuple) {\r\n    return `(\\n${Object.keys(expr.__shape__)\r\n      .map(\r\n        (key) =>\r\n          `  ${key} := ${renderEdgeQL(\r\n            expr.__shape__[key]!,\r\n            ctx,\r\n            renderShape,\r\n            noImplicitDetached\r\n          )}`\r\n      )\r\n      .join(\",\\n\")}\\n)`;\r\n  } else if (expr.__kind__ === ExpressionKind.TuplePath) {\r\n    return `${renderEdgeQL(expr.__parent__, ctx)}.${expr.__index__}`;\r\n  } else if (expr.__kind__ === ExpressionKind.Cast) {\r\n    const typeName =\r\n      expr.__element__.__name__ === \"std::number\"\r\n        ? \"std::float64\"\r\n        : expr.__element__.__name__;\r\n    if (expr.__expr__ === null) {\r\n      return `<${typeName}>{}`;\r\n    }\r\n    return `<${typeName}>(${renderEdgeQL(expr.__expr__, ctx)})`;\r\n  } else if (expr.__kind__ === ExpressionKind.Select) {\r\n    const lines: string[] = [];\r\n    if (isObjectType(expr.__element__)) {\r\n      const selectionTarget = renderEdgeQL(\r\n        expr.__scope__ ?? expr.__expr__,\r\n        ctx,\r\n        false\r\n      );\r\n\r\n      lines.push(\r\n        `SELECT${\r\n          selectionTarget === \"DETACHED std::FreeObject\"\r\n            ? \"\"\r\n            : ` ${selectionTarget}`\r\n        }`\r\n      );\r\n\r\n      if (\r\n        expr.__element__.__shape__ !==\r\n        (expr.__expr__ as ObjectTypeSet).__element__.__shape__\r\n      ) {\r\n        lines.push(\r\n          shapeToEdgeQL(\r\n            (expr.__element__.__shape__ || {}) as object,\r\n            ctx,\r\n            expr.__element__\r\n          )\r\n        );\r\n      }\r\n    } else {\r\n      // non-object/non-shape select expression\r\n      const needsScalarVar =\r\n        (expr.__modifiers__.filter ||\r\n          expr.__modifiers__.order_by ||\r\n          expr.__modifiers__.offset ||\r\n          expr.__modifiers__.limit) &&\r\n        !ctx.withVars.has(expr.__expr__ as any);\r\n\r\n      lines.push(\r\n        `SELECT ${needsScalarVar ? \"_ := \" : \"\"}${renderEdgeQL(\r\n          expr.__expr__,\r\n          ctx\r\n        )}`\r\n      );\r\n\r\n      if (needsScalarVar) {\r\n        ctx = { ...ctx, withVars: new Map(ctx.withVars) };\r\n        ctx.withVars.set(expr.__expr__ as any, {\r\n          name: \"_\",\r\n          childExprs: new Set(),\r\n          scope: expr,\r\n        });\r\n      }\r\n    }\r\n\r\n    const modifiers: string[] = [];\r\n\r\n    if (expr.__modifiers__.filter) {\r\n      modifiers.push(`FILTER ${renderEdgeQL(expr.__modifiers__.filter, ctx)}`);\r\n    }\r\n    if (expr.__modifiers__.order_by) {\r\n      modifiers.push(\r\n        ...expr.__modifiers__.order_by.map(\r\n          ({ expression, direction, empty }, i) => {\r\n            return `${i === 0 ? \"ORDER BY\" : \"  THEN\"} ${renderEdgeQL(\r\n              expression,\r\n              ctx\r\n            )}${direction ? \" \" + direction : \"\"}${empty ? \" \" + empty : \"\"}`;\r\n          }\r\n        )\r\n      );\r\n    }\r\n    if (expr.__modifiers__.offset) {\r\n      modifiers.push(\r\n        `OFFSET ${renderEdgeQL(\r\n          expr.__modifiers__.offset as OffsetExpression,\r\n          ctx\r\n        )}`\r\n      );\r\n    }\r\n    if (expr.__modifiers__.limit) {\r\n      modifiers.push(\r\n        `LIMIT ${renderEdgeQL(\r\n          expr.__modifiers__.limit as LimitExpression,\r\n          ctx\r\n        )}`\r\n      );\r\n    }\r\n\r\n    // without assert_single, the query will return a more informative\r\n    // CardinalityMismatchError when the query returns more than one result\r\n    return (\r\n      // (expr.__modifiers__.singleton ? `select assert_single((` : ``) +\r\n      \"(\" +\r\n      withBlock +\r\n      lines.join(\" \") +\r\n      (modifiers.length ? \"\\n\" + modifiers.join(\"\\n\") : \"\") +\r\n      \")\"\r\n      // + (expr.__modifiers__.singleton ? `))` : ``)\r\n    );\r\n  } else if (expr.__kind__ === ExpressionKind.Update) {\r\n    return `(${withBlock}UPDATE ${renderEdgeQL(expr.__scope__, ctx, false)}${\r\n      expr.__modifiers__.filter\r\n        ? `\\nFILTER ${renderEdgeQL(expr.__modifiers__.filter, ctx)}\\n`\r\n        : \" \"\r\n    }SET ${shapeToEdgeQL(expr.__shape__, ctx, null, false, false)})`;\r\n  } else if (expr.__kind__ === ExpressionKind.Delete) {\r\n    return `(${withBlock}DELETE ${renderEdgeQL(\r\n      expr.__expr__,\r\n      ctx,\r\n      undefined,\r\n      noImplicitDetached\r\n    )})`;\r\n  } else if (expr.__kind__ === ExpressionKind.Insert) {\r\n    return `(${withBlock}INSERT ${renderEdgeQL(\r\n      expr.__expr__,\r\n      ctx,\r\n      false,\r\n      true\r\n    )} ${shapeToEdgeQL(expr.__shape__, ctx, null, false, false)})`;\r\n  } else if (expr.__kind__ === ExpressionKind.InsertUnlessConflict) {\r\n    const $on = expr.__conflict__.on;\r\n    const $else = expr.__conflict__.else;\r\n    const clause: string[] = [];\r\n    if (!$on) {\r\n      clause.push(\"\\nUNLESS CONFLICT\");\r\n    }\r\n    if ($on) {\r\n      clause.push(\r\n        `\\nUNLESS CONFLICT ON ${renderEdgeQL($on, ctx, false, true)}`\r\n      );\r\n    }\r\n    if ($else) {\r\n      clause.push(`\\nELSE (${renderEdgeQL($else, ctx, true, true)})`);\r\n    }\r\n    return `(${renderEdgeQL(expr.__expr__, ctx, false, true).slice(\r\n      1,\r\n      -1\r\n    )}${clause.join(\"\")})`;\r\n  } else if (expr.__kind__ === ExpressionKind.Group) {\r\n    const groupingSet = expr.__modifiers__.by as any as GroupingSet;\r\n    const elementsShape =\r\n      expr.__element__.__shape__.elements.__element__.__shape__;\r\n\r\n    const selectStatement: string[] = [];\r\n    const groupStatement: string[] = [];\r\n\r\n    const groupTarget = renderEdgeQL(expr.__scope__, ctx, false);\r\n    groupStatement.push(`GROUP ${groupTarget}`);\r\n\r\n    // render scoped withvars in using\r\n    const combinedBlock = [\r\n      // ...scopedWithBlock,\r\n      // this is deduplicated in e.group\r\n      ...groupingSet.__exprs__.map(\r\n        ([k, v]) => `  ${k} := ${renderEdgeQL(v, ctx)}`\r\n      ),\r\n    ];\r\n    groupStatement.push(`USING\\n${combinedBlock.join(\",\\n\")}`);\r\n\r\n    let by = renderGroupingSet(groupingSet).trim();\r\n    if (by[0] === \"(\" && by[by.length - 1] === \")\") {\r\n      by = by.slice(1, by.length - 1);\r\n    }\r\n    groupStatement.push(`BY ` + by);\r\n\r\n    // clause.push(withBlock.trim());\r\n\r\n    // render scope var and any unscoped withVars in with block\r\n    const selectTarget = `${groupTarget}_groups`;\r\n    selectStatement.push(\r\n      `WITH\\n${[\r\n        ...unscopedWithBlock,\r\n        ...scopeExprVar,\r\n        // ...scopedWithBlock,\r\n      ].join(\",\\n\")},\r\n  ${selectTarget} := (\r\n${indent(groupStatement.join(\"\\n\"), 4)}\r\n)`\r\n    );\r\n\r\n    // rename scope var to fix all scope references that\r\n    // occur in the `elements` subshape\r\n    const scopeVar = ctx.withVars.get(expr.__scope__ as any);\r\n\r\n    // replace references to __scope__ with\r\n    // .elements reference\r\n    const elementsShapeQuery = indent(\r\n      shapeToEdgeQL(elementsShape as object, { ...ctx }, expr.__element__),\r\n      2\r\n    )\r\n      .trim()\r\n      .split(scopeVar!.name + \".\")\r\n      .join(`${selectTarget}.elements.`);\r\n\r\n    selectStatement.push(`SELECT ${selectTarget} {\r\n  key: {${groupingSet.__exprs__.map((e) => e[0]).join(\", \")}},\r\n  grouping,\r\n  elements: ${elementsShapeQuery}\r\n}`);\r\n    return `(${selectStatement.join(\"\\n\")})`;\r\n  } else if (expr.__kind__ === ExpressionKind.Function) {\r\n    const args = expr.__args__.map(\r\n      (arg) => `${renderEdgeQL(arg!, ctx, false)}`\r\n    );\r\n    for (const [key, arg] of Object.entries(expr.__namedargs__)) {\r\n      args.push(`${q(key)} := ${renderEdgeQL(arg, ctx, false)}`);\r\n    }\r\n    return `${expr.__name__}(${args.join(\", \")})`;\r\n  } else if (expr.__kind__ === ExpressionKind.Operator) {\r\n    const operator = expr.__name__;\r\n    const args = expr.__args__;\r\n    switch (expr.__opkind__) {\r\n      case OperatorKind.Infix:\r\n        if (operator === \"[]\") {\r\n          let index = \"\";\r\n          if (Array.isArray(args[1])) {\r\n            const [start, end] = args[1];\r\n            if (start) {\r\n              index += renderEdgeQL(start, ctx);\r\n            }\r\n            index += \":\";\r\n            if (end) {\r\n              index += renderEdgeQL(end, ctx);\r\n            }\r\n          } else {\r\n            index = renderEdgeQL(args[1]!, ctx);\r\n          }\r\n\r\n          return `${renderEdgeQL(args[0]!, ctx)}[${index}]`;\r\n        }\r\n        return `(${renderEdgeQL(args[0]!, ctx)} ${operator} ${renderEdgeQL(\r\n          args[1]!,\r\n          ctx\r\n        )})`;\r\n      case OperatorKind.Postfix:\r\n        return `(${renderEdgeQL(args[0]!, ctx)} ${operator})`;\r\n      case OperatorKind.Prefix:\r\n        return `(${operator} ${renderEdgeQL(args[0]!, ctx)})`;\r\n      case OperatorKind.Ternary:\r\n        if (operator === \"if_else\") {\r\n          return `(${renderEdgeQL(args[0]!, ctx)} IF ${renderEdgeQL(\r\n            args[1]!,\r\n            ctx\r\n          )} ELSE ${renderEdgeQL(args[2]!, ctx)})`;\r\n        } else {\r\n          throw new Error(`Unknown operator: ${operator}`);\r\n        }\r\n      default:\r\n        util.assertNever(\r\n          expr.__opkind__,\r\n          new Error(`Unknown operator kind: ${expr.__opkind__}`)\r\n        );\r\n    }\r\n  } else if (expr.__kind__ === ExpressionKind.TypeIntersection) {\r\n    return `${renderEdgeQL(expr.__expr__, ctx)}[IS ${\r\n      expr.__element__.__name__\r\n    }]`;\r\n  } else if (expr.__kind__ === ExpressionKind.For) {\r\n    ctx.forVars.set(expr.__forVar__, `__forVar__${ctx.forVars.size}`);\r\n    return `(${withBlock}FOR ${ctx.forVars.get(\r\n      expr.__forVar__\r\n    )} IN {${renderEdgeQL(expr.__iterSet__, ctx)}}\r\nUNION (\\n${indent(renderEdgeQL(expr.__expr__, ctx), 2)}\\n))`;\r\n  } else if (expr.__kind__ === ExpressionKind.ForVar) {\r\n    const forVar = ctx.forVars.get(expr);\r\n    if (!forVar) {\r\n      throw new Error(`'FOR' loop variable used outside of 'FOR' loop`);\r\n    }\r\n    return forVar;\r\n  } else if (expr.__kind__ === ExpressionKind.Param) {\r\n    return `__param__${expr.__name__}`;\r\n  } else if (expr.__kind__ === ExpressionKind.Detached) {\r\n    return `(DETACHED ${renderEdgeQL(\r\n      expr.__expr__,\r\n      {\r\n        ...ctx,\r\n        renderWithVar: expr.__expr__ as any,\r\n      },\r\n      undefined,\r\n      true\r\n    )})`;\r\n  } else if (expr.__kind__ === ExpressionKind.Global) {\r\n    return `(GLOBAL ${expr.__name__})`;\r\n  } else {\r\n    util.assertNever(\r\n      expr,\r\n      new Error(`Unrecognized expression kind: \"${(expr as any).__kind__}\"`)\r\n    );\r\n  }\r\n}\r\n\r\nfunction isGroupingSet(arg: any): arg is GroupingSet {\r\n  return arg.__kind__ === \"groupingset\";\r\n}\r\n\r\n// recursive renderer\r\nfunction renderGroupingSet(set: GroupingSet): string {\r\n  const contents = Object.entries(set.__elements__)\r\n    .map(([k, v]) => {\r\n      return isGroupingSet(v) ? renderGroupingSet(v) : k;\r\n    })\r\n    .join(\", \");\r\n  if (set.__settype__ === \"tuple\") {\r\n    return `(${contents})`;\r\n  } else if (set.__settype__ === \"set\") {\r\n    return `{${contents}}`;\r\n  } else if (set.__settype__ === \"cube\") {\r\n    return `cube(${contents})`;\r\n  } else if (set.__settype__ === \"rollup\") {\r\n    return `rollup(${contents})`;\r\n  } else {\r\n    throw new Error(`Unrecognized set type: \"${set.__settype__}\"`);\r\n  }\r\n}\r\n\r\nfunction shapeToEdgeQL(\r\n  shape: object | null,\r\n  ctx: RenderCtx,\r\n  type: ObjectType | null = null,\r\n  keysOnly: boolean = false,\r\n  injectImplicitId: boolean = true\r\n) {\r\n  const pointers = type?.__pointers__ || null;\r\n  const isFreeObject = type?.__name__ === \"std::FreeObject\";\r\n  if (shape === null) {\r\n    return ``;\r\n  }\r\n\r\n  const lines: string[] = [];\r\n  const addLine = (line: string) =>\r\n    lines.push(`${keysOnly ? \"\" : \"  \"}${line}`);\r\n\r\n  const seen = new Set();\r\n\r\n  for (const key in shape) {\r\n    if (!shape.hasOwnProperty(key)) continue;\r\n    if (seen.has(key)) {\r\n      // tslint:disable-next-line\r\n      console.warn(`Invalid: duplicate key \"${key}\"`);\r\n      continue;\r\n    }\r\n    seen.add(key);\r\n    let val = (shape as any)[key];\r\n    let operator = \":=\";\r\n    let polyType: SomeExpression | null = null;\r\n\r\n    if (typeof val === \"object\" && !val.__element__) {\r\n      if (!!val[\"+=\"]) {\r\n        operator = \"+=\";\r\n        val = val[\"+=\"];\r\n      } else if (!!val[\"-=\"]) {\r\n        operator = \"-=\";\r\n        val = val[\"-=\"];\r\n      }\r\n    }\r\n    if (val.__kind__ === ExpressionKind.PolyShapeElement) {\r\n      polyType = val.__polyType__;\r\n      val = val.__shapeElement__;\r\n    }\r\n    const polyIntersection = polyType\r\n      ? `[IS ${polyType.__element__.__name__}].`\r\n      : \"\";\r\n\r\n    // For computed properties in select shapes, inject the expected\r\n    // cardinality inferred by the query builder. This ensures the actual\r\n    // type returned by the server matches the inferred return type, or an\r\n    // explicit error is thrown, instead of a silent mismatch between\r\n    // actual and inferred type.\r\n    // Add annotations on FreeObjects, despite the existence of a pointer.\r\n    const ptr = pointers?.[key];\r\n    const addCardinalityAnnotations = pointers && (!ptr || isFreeObject);\r\n\r\n    const expectedCardinality =\r\n      addCardinalityAnnotations && val.hasOwnProperty(\"__cardinality__\")\r\n        ? val.__cardinality__ === Cardinality.Many ||\r\n          val.__cardinality__ === Cardinality.AtLeastOne\r\n          ? \"multi \"\r\n          : \"single \"\r\n        : \"\";\r\n\r\n    // if selecting a required multi link, wrap expr in 'assert_exists'\r\n    const wrapAssertExists = ptr?.cardinality === Cardinality.AtLeastOne;\r\n\r\n    if (typeof val === \"boolean\") {\r\n      if (\r\n        !pointers?.[key] &&\r\n        key[0] !== \"@\" &&\r\n        type &&\r\n        type?.__name__ !== \"std::FreeObject\" &&\r\n        !polyIntersection\r\n      ) {\r\n        throw new Error(`Field \"${key}\" does not exist in ${type?.__name__}`);\r\n      }\r\n      if (val) {\r\n        addLine(`${polyIntersection}${q(key)}`);\r\n      }\r\n      continue;\r\n    }\r\n\r\n    if (typeof val !== \"object\") {\r\n      throw new Error(`Invalid shape element at \"${key}\".`);\r\n    }\r\n\r\n    const valIsExpression = val.hasOwnProperty(\"__kind__\");\r\n\r\n    // is subshape\r\n    if (!valIsExpression) {\r\n      addLine(\r\n        `${polyIntersection}${q(key, false)}: ${indent(\r\n          shapeToEdgeQL(val, ctx, ptr?.target),\r\n          2\r\n        ).trim()}`\r\n      );\r\n      continue;\r\n    }\r\n\r\n    // val is expression\r\n\r\n    // is computed\r\n    if (keysOnly) {\r\n      addLine(\r\n        q(key, false) +\r\n          (isObjectType(val.__element__)\r\n            ? `: ${shapeToEdgeQL(val.__element__.__shape__, ctx, null, true)}`\r\n            : \"\")\r\n      );\r\n      continue;\r\n    }\r\n    const renderedExpr = renderEdgeQL(val, ctx);\r\n\r\n    addLine(\r\n      `${expectedCardinality}${q(key, false)} ${operator} ${\r\n        wrapAssertExists ? \"assert_exists(\" : \"\"\r\n      }${\r\n        renderedExpr.includes(\"\\n\")\r\n          ? `(\\n${indent(\r\n              renderedExpr[0] === \"(\" &&\r\n                renderedExpr[renderedExpr.length - 1] === \")\"\r\n                ? renderedExpr.slice(1, -1)\r\n                : renderedExpr,\r\n              4\r\n            )}\\n  )`\r\n          : renderedExpr\r\n      }${wrapAssertExists ? \")\" : \"\"}`\r\n    );\r\n  }\r\n\r\n  if (lines.length === 0 && injectImplicitId) {\r\n    addLine(\"id\");\r\n  }\r\n  return keysOnly ? `{${lines.join(\", \")}}` : `{\\n${lines.join(\",\\n\")}\\n}`;\r\n}\r\n\r\nfunction topoSortWithVars(\r\n  vars: Set<SomeExpression>,\r\n  ctx: RenderCtx\r\n): SomeExpression[] {\r\n  if (!vars.size) {\r\n    return [];\r\n  }\r\n\r\n  const sorted: SomeExpression[] = [];\r\n\r\n  const unvisited = new Set(vars);\r\n  const visiting = new Set<SomeExpression>();\r\n\r\n  for (const withVar of unvisited) {\r\n    visit(withVar);\r\n  }\r\n\r\n  function visit(withVar: SomeExpression): void {\r\n    if (!unvisited.has(withVar)) {\r\n      return;\r\n    }\r\n    if (visiting.has(withVar)) {\r\n      throw new Error(`'WITH' variables contain a cyclic dependency`);\r\n    }\r\n\r\n    visiting.add(withVar);\r\n\r\n    for (const child of ctx.withVars.get(withVar)!.childExprs) {\r\n      if (vars.has(child)) {\r\n        visit(child);\r\n      }\r\n    }\r\n\r\n    visiting.delete(withVar);\r\n    unvisited.delete(withVar);\r\n\r\n    sorted.push(withVar);\r\n  }\r\n  return sorted;\r\n}\r\n\r\nconst numericalTypes: Record<string, boolean> = {\r\n  \"std::number\": true,\r\n  \"std::int16\": true,\r\n  \"std::int32\": true,\r\n  \"std::int64\": true,\r\n  \"std::float32\": true,\r\n  \"std::float64\": true,\r\n};\r\n\r\nfunction literalToEdgeQL(type: BaseType, val: any): string {\r\n  const typename = (type as any).__casttype__?.__name__ ?? type.__name__;\r\n  let skipCast = false;\r\n  let stringRep;\r\n  if (typename === \"std::json\") {\r\n    skipCast = true;\r\n    stringRep = `to_json($$${JSON.stringify(val)}$$)`;\r\n  } else if (typeof val === \"string\") {\r\n    if (numericalTypes[typename]) {\r\n      skipCast = typename === type.__name__;\r\n      stringRep = val;\r\n    } else if (type.__kind__ === TypeKind.enum) {\r\n      skipCast = true;\r\n      const vals = (type as EnumType).__values__;\r\n      if (vals.includes(val)) {\r\n        skipCast = true;\r\n        if (val.includes(\" \")) {\r\n          stringRep = `<${type.__name__}>\"${val}\"`;\r\n        } else {\r\n          stringRep = `${type.__name__}.${q(val)}`;\r\n        }\r\n      } else {\r\n        throw new Error(\r\n          `Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`\r\n        );\r\n      }\r\n    } else {\r\n      if (typename === \"std::str\") {\r\n        skipCast = true;\r\n      }\r\n      stringRep = JSON.stringify(val);\r\n    }\r\n  } else if (typeof val === \"number\") {\r\n    if (numericalTypes[typename]) {\r\n      skipCast = typename === type.__name__;\r\n    } else {\r\n      throw new Error(`Unknown numerical type: ${type.__name__}!`);\r\n    }\r\n    stringRep = `${val.toString()}`;\r\n  } else if (typeof val === \"boolean\") {\r\n    stringRep = `${val.toString()}`;\r\n    skipCast = true;\r\n  } else if (typeof val === \"bigint\") {\r\n    stringRep = `${val.toString()}n`;\r\n  } else if (Array.isArray(val)) {\r\n    skipCast = val.length !== 0;\r\n    if (isArrayType(type)) {\r\n      stringRep = `[${val\r\n        .map((el) => literalToEdgeQL(type.__element__ as any, el))\r\n        .join(\", \")}]`;\r\n    } else if (isTupleType(type)) {\r\n      stringRep = `( ${val\r\n        .map((el, j) => literalToEdgeQL(type.__items__[j] as any, el))\r\n        .join(\", \")}${type.__items__.length === 1 ? \",\" : \"\"} )`;\r\n    } else {\r\n      throw new Error(\r\n        `Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`\r\n      );\r\n    }\r\n  } else if (val instanceof Date) {\r\n    stringRep = `'${val.toISOString()}'`;\r\n  } else if (\r\n    val instanceof LocalDate ||\r\n    val instanceof LocalDateTime ||\r\n    val instanceof LocalTime ||\r\n    val instanceof Duration ||\r\n    val instanceof RelativeDuration ||\r\n    val instanceof DateDuration\r\n  ) {\r\n    stringRep = `'${val.toString()}'`;\r\n  } else if (val instanceof Uint8Array) {\r\n    stringRep = bufferToStringRep(val);\r\n    skipCast = true;\r\n  } else if (val instanceof Float32Array) {\r\n    stringRep = `[${val.join(\",\")}]`;\r\n  } else if (val instanceof Range) {\r\n    const elType = (type as RangeType).__element__;\r\n\r\n    // actual type will be inferred from\r\n    // defined value\r\n    const elTypeName =\r\n      elType.__name__ === \"std::number\" ? \"std::int64\" : elType.__name__;\r\n\r\n    return `std::range(${\r\n      val.lower === null\r\n        ? `<${elTypeName}>{}`\r\n        : literalToEdgeQL(elType, val.lower)\r\n    }, ${\r\n      val.upper === null\r\n        ? `<${elTypeName}>{}`\r\n        : literalToEdgeQL(elType, val.upper)\r\n    }, inc_lower := ${val.incLower}, inc_upper := ${val.incUpper})`;\r\n  } else if (typeof val === \"object\") {\r\n    if (isNamedTupleType(type)) {\r\n      stringRep = `( ${Object.entries(val).map(\r\n        ([key, value]) =>\r\n          `${key} := ${literalToEdgeQL(type.__shape__[key]!, value)}`\r\n      )} )`;\r\n      skipCast = true;\r\n    } else {\r\n      throw new Error(\r\n        `Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`\r\n      );\r\n    }\r\n  } else {\r\n    throw new Error(\r\n      `Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`\r\n    );\r\n  }\r\n  if (skipCast) {\r\n    return stringRep;\r\n  }\r\n  return `<${type.__name__}>${stringRep}`;\r\n}\r\n\r\nfunction indent(str: string, depth: number) {\r\n  return str\r\n    .split(\"\\n\")\r\n    .map((line) => \" \".repeat(depth) + line)\r\n    .join(\"\\n\");\r\n}\r\n\r\n// backtick quote identifiers if needed\r\n// https://github.com/edgedb/edgedb/blob/master/edb/edgeql/quote.py\r\nfunction q(ident: string, allowBacklinks: boolean = true): string {\r\n  if (\r\n    !ident ||\r\n    ident.startsWith(\"@\") ||\r\n    (allowBacklinks && (ident.startsWith(\"<\") || ident.includes(\"::\")))\r\n  ) {\r\n    return ident;\r\n  }\r\n\r\n  const isAlphaNum = /^([^\\W\\d]\\w*|([1-9]\\d*|0))$/.test(ident);\r\n  if (isAlphaNum) {\r\n    const lident = ident.toLowerCase();\r\n    const isReserved =\r\n      lident !== \"__type__\" &&\r\n      lident !== \"__std__\" &&\r\n      reservedKeywords.has(lident);\r\n\r\n    if (!isReserved) {\r\n      return ident;\r\n    }\r\n  }\r\n\r\n  return \"`\" + ident.replace(/`/g, \"``\") + \"`\";\r\n}\r\n\r\nfunction bufferToStringRep(buf: Uint8Array): string {\r\n  let stringRep = \"\";\r\n  for (const byte of buf) {\r\n    if (byte < 32 || byte > 126) {\r\n      // non printable ascii\r\n      switch (byte) {\r\n        case 8:\r\n          stringRep += \"\\\\b\";\r\n          break;\r\n        case 9:\r\n          stringRep += \"\\\\t\";\r\n          break;\r\n        case 10:\r\n          stringRep += \"\\\\n\";\r\n          break;\r\n        case 12:\r\n          stringRep += \"\\\\f\";\r\n          break;\r\n        case 13:\r\n          stringRep += \"\\\\r\";\r\n          break;\r\n        default:\r\n          stringRep += `\\\\x${byte.toString(16).padStart(2, \"0\")}`;\r\n      }\r\n    } else {\r\n      stringRep +=\r\n        (byte === 39 || byte === 92 ? \"\\\\\" : \"\") + String.fromCharCode(byte);\r\n    }\r\n  }\r\n  return `b'${stringRep}'`;\r\n}\r\n\r\nfunction getErrorHint(expr: any): string {\r\n  let literalConstructor: string | null = null;\r\n  switch (typeof expr) {\r\n    case \"string\":\r\n      literalConstructor = \"e.str()\";\r\n      break;\r\n    case \"number\":\r\n      literalConstructor = Number.isInteger(expr) ? \"e.int64()\" : \"e.float64()\";\r\n      break;\r\n    case \"bigint\":\r\n      literalConstructor = \"e.bigint()\";\r\n      break;\r\n    case \"boolean\":\r\n      literalConstructor = \"e.bool()\";\r\n      break;\r\n  }\r\n  switch (true) {\r\n    case expr instanceof Date:\r\n      literalConstructor = \"e.datetime()\";\r\n      break;\r\n    case expr instanceof Duration:\r\n      literalConstructor = \"e.duration()\";\r\n      break;\r\n    case expr instanceof LocalDate:\r\n      literalConstructor = \"e.cal.local_date()\";\r\n      break;\r\n    case expr instanceof LocalDateTime:\r\n      literalConstructor = \"e.cal.local_datetime()\";\r\n      break;\r\n    case expr instanceof LocalTime:\r\n      literalConstructor = \"e.cal.local_time()\";\r\n      break;\r\n    case expr instanceof RelativeDuration:\r\n      literalConstructor = \"e.cal.relative_duration()\";\r\n      break;\r\n    case expr instanceof DateDuration:\r\n      literalConstructor = \"e.cal.date_duration()\";\r\n      break;\r\n  }\r\n\r\n  return literalConstructor\r\n    ? `\\nHint: Maybe you meant to wrap the value in ` +\r\n        `a '${literalConstructor}' expression?`\r\n    : \"\";\r\n}\r\n"},{"path":"typesystem.mts","content":"import type { Executor } from \"edgedb/dist/ifaces.js\";\r\nimport type { $expr_PathNode, $expr_TypeIntersection, $pathify } from \"./path.mjs\";\r\nimport type { $expr_Literal } from \"./literal.mjs\";\r\nimport type { $expr_Operator } from \"./funcops.mjs\";\r\nimport type {\r\n  typeutil,\r\n  Cardinality,\r\n  ExpressionKind,\r\n} from \"edgedb/dist/reflection/index.js\";\r\nimport { TypeKind } from \"edgedb/dist/reflection/index.js\";\r\nimport type { cardutil } from \"./cardinality.mjs\";\r\nimport type { Range, MultiRange } from \"edgedb\";\r\n\r\n//////////////////\r\n// BASETYPE\r\n//////////////////\r\n\r\nexport interface BaseType {\r\n  __kind__: TypeKind;\r\n  __name__: string;\r\n}\r\nexport type BaseTypeSet = {\r\n  __element__: BaseType;\r\n  __cardinality__: Cardinality;\r\n};\r\nexport type BaseTypeTuple = typeutil.tupleOf<BaseType>;\r\n\r\n//////////////////\r\n// SCALARTYPE\r\n//////////////////\r\n\r\nexport interface ScalarType<\r\n  Name extends string = string,\r\n  TsType = any,\r\n  TsArgType = TsType,\r\n  TsConstType extends TsType = TsType\r\n> extends BaseType {\r\n  __kind__: TypeKind.scalar;\r\n  __tstype__: TsType;\r\n  __tsargtype__: TsArgType;\r\n  __tsconsttype__: TsConstType;\r\n  __name__: Name;\r\n}\r\n\r\nexport type scalarTypeWithConstructor<\r\n  S extends ScalarType,\r\n  ExtraTsTypes = never\r\n> = S & {\r\n  // tslint:disable-next-line\r\n  <T extends S[\"__tstype__\"] | ExtraTsTypes>(val: T): $expr_Literal<\r\n    Omit<S, \"__tsconsttype__\"> & {\r\n      __tsconsttype__: T extends S[\"__tstype__\"] ? T : S[\"__tstype__\"];\r\n    }\r\n  >;\r\n};\r\n\r\ntype $jsonDestructure<Set extends TypeSet> =\r\n  Set[\"__element__\"] extends ScalarType<\"std::json\">\r\n    ? {\r\n        [path: string]: $expr_Operator<\r\n          // \"[]\",\r\n          // OperatorKind.Infix,\r\n          // [Set, TypeSet],\r\n          // TypeSet<\r\n          Set[\"__element__\"],\r\n          Set[\"__cardinality__\"]\r\n          // >\r\n        >;\r\n      } & {\r\n        destructure<T extends TypeSet<ScalarType<\"std::str\">> | string>(\r\n          path: T\r\n        ): $expr_Operator<\r\n          // \"[]\",\r\n          // OperatorKind.Infix,\r\n          // [Set, TypeSet],\r\n          // TypeSet<\r\n          Set[\"__element__\"],\r\n          cardutil.multiplyCardinalities<\r\n            Set[\"__cardinality__\"],\r\n            T extends TypeSet ? T[\"__cardinality__\"] : Cardinality.One\r\n          >\r\n          // >\r\n        >;\r\n      }\r\n    : unknown;\r\n\r\n////////////////////\r\n// SETS AND EXPRESSIONS\r\n////////////////////\r\n\r\nexport interface TypeSet<\r\n  T extends BaseType = BaseType,\r\n  Card extends Cardinality = Cardinality\r\n> {\r\n  __element__: T;\r\n  __cardinality__: Card;\r\n}\r\n\r\n// utility function for creating set\r\nexport function $toSet<Root extends BaseType, Card extends Cardinality>(\r\n  root: Root,\r\n  card: Card\r\n): TypeSet<Root, Card> {\r\n  return {\r\n    __element__: root,\r\n    __cardinality__: card,\r\n  };\r\n}\r\n\r\nexport type Expression<\r\n  Set extends TypeSet = TypeSet,\r\n  Runnable extends boolean = true\r\n> = Set &\r\n  (BaseType extends Set[\"__element__\"] // short-circuit non-specific types\r\n    ? {\r\n        run(cxn: Executor): any;\r\n        runJSON(cxn: Executor): any;\r\n        toEdgeQL(): string;\r\n        is: any;\r\n        assert_single: any;\r\n        // warning: any;\r\n      }\r\n    : $pathify<Set> &\r\n        ExpressionMethods<stripSet<Set>> &\r\n        (Runnable extends true\r\n          ? {\r\n              run(cxn: Executor): Promise<setToTsType<Set>>;\r\n              runJSON(cxn: Executor): Promise<string>;\r\n            }\r\n          : {}) &\r\n        $tuplePathify<Set> &\r\n        $arrayLikeIndexify<Set> &\r\n        $jsonDestructure<Set>);\r\n\r\nexport type stripSet<T> = \"__element__\" extends keyof T\r\n  ? \"__cardinality__\" extends keyof T\r\n    ? {\r\n        __element__: T[\"__element__\"];\r\n        __cardinality__: T[\"__cardinality__\"];\r\n      }\r\n    : T\r\n  : T;\r\n\r\n// export type stripSet<T> = T extends {__element__: any; __cardinality__: any}\r\n//   ? {\r\n//       __element__: T[\"__element__\"];\r\n//       __cardinality__: T[\"__cardinality__\"];\r\n//     }\r\n//   : any;\r\n\r\nexport type stripSetShape<T> = {\r\n  [k in keyof T]: stripSet<T[k]>;\r\n};\r\n\r\n// importing the actual alias from\r\n// generated/modules/std didn't work.\r\n// returned 'any' every time\r\nexport type assert_single<\r\n  El extends BaseType,\r\n  Card extends Cardinality\r\n> = Expression<{\r\n  __element__: El; // [\"__element__\"];\r\n  __cardinality__: Card; // cardutil.overrideUpperBound<\r\n  // Expr[\"__cardinality__\"], \"One\"\r\n  // >;\r\n  __kind__: ExpressionKind.Function;\r\n  __name__: \"std::assert_single\";\r\n  __args__: TypeSet[]; // discard wrapped expression\r\n  __namedargs__: {};\r\n}>;\r\n\r\nexport type ExpressionMethods<Set extends TypeSet> = {\r\n  toEdgeQL(): string;\r\n\r\n  is<T extends ObjectTypeSet>(\r\n    ixn: T\r\n  ): $expr_TypeIntersection<\r\n    Set[\"__cardinality__\"],\r\n    // might cause performance issues\r\n    ObjectType<\r\n      T[\"__element__\"][\"__name__\"],\r\n      T[\"__element__\"][\"__pointers__\"],\r\n      { id: true }\r\n    >\r\n  >;\r\n  assert_single(): assert_single<\r\n    Set[\"__element__\"],\r\n    Cardinality.AtMostOne\r\n    // cardutil.overrideUpperBound<Set[\"__cardinality__\"], \"One\">\r\n  >;\r\n};\r\n\r\n//////////////////\r\n// ENUMTYPE\r\n//////////////////\r\nexport interface EnumType<\r\n  Name extends string = string,\r\n  Values extends [string, ...string[]] = [string, ...string[]]\r\n> extends BaseType {\r\n  __kind__: TypeKind.enum;\r\n  __tstype__: Values[number];\r\n  __name__: Name;\r\n  __values__: Values;\r\n}\r\n\r\n//////////////////\r\n// OBJECTTYPE\r\n//////////////////\r\n\r\nexport type ObjectTypeSet = TypeSet<ObjectType, Cardinality>;\r\nexport type ObjectTypeExpression = TypeSet<ObjectType, Cardinality>;\r\n\r\nexport type ExclusiveTuple = typeutil.tupleOf<{\r\n  [k: string]: TypeSet;\r\n}>;\r\nexport interface ObjectType<\r\n  Name extends string = string,\r\n  Pointers extends ObjectTypePointers = ObjectTypePointers,\r\n  Shape extends object | null = any,\r\n  Exclusives extends ExclusiveTuple = ExclusiveTuple\r\n  // Polys extends Poly[] = any[]\r\n> extends BaseType {\r\n  __kind__: TypeKind.object;\r\n  __name__: Name;\r\n  __pointers__: Pointers;\r\n  __shape__: Shape;\r\n  __exclusives__: Exclusives;\r\n}\r\n\r\nexport type PropertyTypes =\r\n  | ScalarType\r\n  | EnumType\r\n  | ArrayType\r\n  | TupleType\r\n  | NamedTupleType;\r\n\r\nexport type SomeType =\r\n  | ScalarType\r\n  | EnumType\r\n  | ArrayType\r\n  | TupleType\r\n  | ObjectType\r\n  | NamedTupleType\r\n  | RangeType\r\n  | MultiRangeType;\r\n\r\nexport interface PropertyDesc<\r\n  Type extends BaseType = BaseType,\r\n  Card extends Cardinality = Cardinality,\r\n  Exclusive extends boolean = boolean,\r\n  Computed extends boolean = boolean,\r\n  Readonly extends boolean = boolean,\r\n  HasDefault extends boolean = boolean\r\n> {\r\n  __kind__: \"property\";\r\n  target: Type;\r\n  cardinality: Card;\r\n  exclusive: Exclusive;\r\n  computed: Computed;\r\n  readonly: Readonly;\r\n  hasDefault: HasDefault;\r\n}\r\n\r\nexport type $scopify<Type extends ObjectType> = $expr_PathNode<\r\n  TypeSet<Type, Cardinality.One>\r\n  // null,\r\n  // true // exclusivity\r\n>;\r\n\r\nexport type PropertyShape = {\r\n  [k: string]: PropertyDesc;\r\n};\r\n\r\nexport interface LinkDesc<\r\n  Type extends ObjectType = any,\r\n  Card extends Cardinality = Cardinality,\r\n  LinkProps extends PropertyShape = any,\r\n  Exclusive extends boolean = boolean,\r\n  Computed extends boolean = boolean,\r\n  Readonly extends boolean = boolean,\r\n  HasDefault extends boolean = boolean\r\n> {\r\n  __kind__: \"link\";\r\n  target: Type;\r\n  cardinality: Card;\r\n  properties: LinkProps;\r\n  exclusive: Exclusive;\r\n  computed: Computed;\r\n  readonly: Readonly;\r\n  hasDefault: HasDefault;\r\n}\r\n\r\nexport type ObjectTypePointers = {\r\n  [k: string]: PropertyDesc | LinkDesc;\r\n};\r\n\r\nexport type stripBacklinks<T extends ObjectTypePointers> = {\r\n  [k in keyof T]: k extends `<${string}` ? never : T[k];\r\n};\r\n\r\nexport type omitBacklinks<T extends string | number | symbol> =\r\n  T extends `<${string}` ? never : T extends string ? T : never;\r\n\r\nexport type stripNonUpdateables<T extends ObjectTypePointers> = {\r\n  [k in keyof T]: [T[k][\"computed\"]] extends [true]\r\n    ? never\r\n    : [T[k][\"readonly\"]] extends [true]\r\n    ? never\r\n    : k extends \"__type__\"\r\n    ? never\r\n    : k extends \"id\"\r\n    ? never\r\n    : T[k];\r\n};\r\n\r\nexport type stripNonInsertables<T extends ObjectTypePointers> = {\r\n  [k in keyof T]: [T[k][\"computed\"]] extends [true]\r\n    ? never\r\n    : [k] extends [\"__type__\"]\r\n    ? never\r\n    : T[k];\r\n};\r\n\r\ntype shapeElementToTs<Pointer extends PropertyDesc | LinkDesc, Element> = [\r\n  Element\r\n] extends [true]\r\n  ? pointerToTsType<Pointer>\r\n  : [Element] extends [false]\r\n  ? never\r\n  : [Element] extends [boolean]\r\n  ? pointerToTsType<Pointer> | undefined\r\n  : Element extends TypeSet\r\n  ? setToTsType<TypeSet<Element[\"__element__\"], Pointer[\"cardinality\"]>>\r\n  : Pointer extends LinkDesc\r\n  ? Element extends object\r\n    ? computeTsTypeCard<\r\n        computeObjectShape<\r\n          Pointer[\"target\"][\"__pointers__\"] & Pointer[\"properties\"],\r\n          Element\r\n        >,\r\n        Pointer[\"cardinality\"]\r\n      >\r\n    : never\r\n  : never;\r\n\r\n// Element extends (scope: any) => any\r\n// ? Pointer[\"target\"] extends ObjectType\r\n//   ? computeObjectShape<\r\n//       Pointer[\"target\"][\"__pointers__\"],\r\n//       ReturnType<Element>\r\n//     >\r\n//   : never\r\n// : Element extends object\r\n// ? Pointer[\"target\"] extends ObjectType\r\n//   ? computeObjectShape<Pointer[\"target\"][\"__pointers__\"], Element>\r\n//   : never\r\n// : never;\r\n\r\nexport type $expr_PolyShapeElement<\r\n  PolyType extends ObjectTypeSet = ObjectTypeSet,\r\n  ShapeElement extends any = any\r\n> = {\r\n  __kind__: ExpressionKind.PolyShapeElement;\r\n  __polyType__: PolyType;\r\n  __shapeElement__: ShapeElement;\r\n};\r\n\r\nexport type computeObjectShape<\r\n  Pointers extends ObjectTypePointers,\r\n  Shape\r\n> = typeutil.flatten<\r\n  keyof Shape extends never\r\n    ? { id: string }\r\n    : {\r\n        [k in keyof Shape]: Shape[k] extends $expr_PolyShapeElement<\r\n          infer PolyType,\r\n          infer ShapeEl\r\n        >\r\n          ? [k] extends [keyof PolyType[\"__element__\"][\"__pointers__\"]]\r\n            ? shapeElementToTs<\r\n                PolyType[\"__element__\"][\"__pointers__\"][k],\r\n                ShapeEl\r\n              > | null\r\n            : never\r\n          : [k] extends [keyof Pointers]\r\n          ? shapeElementToTs<Pointers[k], Shape[k]>\r\n          : Shape[k] extends TypeSet\r\n          ? setToTsType<Shape[k]>\r\n          : never;\r\n      }\r\n>;\r\n\r\nexport type pointerToTsTypeSimple<El extends PropertyDesc | LinkDesc> =\r\n  El extends PropertyDesc\r\n    ? propToTsType<El>\r\n    : El extends LinkDesc<any, any, any, any>\r\n    ? { id: string }\r\n    : never;\r\n\r\nexport type PrimitiveType =\r\n  | ScalarType\r\n  | EnumType\r\n  | TupleType\r\n  | NamedTupleType\r\n  | ArrayType\r\n  | RangeType\r\n  | MultiRangeType;\r\n\r\nexport type PrimitiveTypeSet = TypeSet<PrimitiveType, Cardinality>;\r\n\r\n/////////////////////////\r\n/// ARRAYTYPE\r\n/////////////////////////\r\n\r\ntype $arrayLikeIndexify<Set extends TypeSet> = Set[\"__element__\"] extends\r\n  | ArrayType\r\n  | ScalarType<\"std::str\">\r\n  | ScalarType<\"std::bytes\">\r\n  ? {\r\n      [index: number]: $expr_Operator<\r\n        // \"[]\",\r\n        // OperatorKind.Infix,\r\n        // [Set, TypeSet],\r\n        // TypeSet<\r\n        getPrimitiveBaseType<\r\n          Set[\"__element__\"] extends ArrayType<infer El>\r\n            ? El\r\n            : Set[\"__element__\"]\r\n        >,\r\n        Set[\"__cardinality__\"]\r\n        // >\r\n      >;\r\n      [slice: `${number}:${number | \"\"}` | `:${number}`]: $expr_Operator<\r\n        // \"[]\",\r\n        // OperatorKind.Infix,\r\n        // [Set, TypeSet],\r\n        // TypeSet<\r\n        getPrimitiveBaseType<Set[\"__element__\"]>,\r\n        Set[\"__cardinality__\"]\r\n        // >\r\n      >;\r\n      index<T extends TypeSet<ScalarType<\"std::number\">> | number>(\r\n        index: T\r\n      ): $expr_Operator<\r\n        // \"[]\",\r\n        // OperatorKind.Infix,\r\n        // [Set, TypeSet],\r\n        // TypeSet<\r\n        getPrimitiveBaseType<\r\n          Set[\"__element__\"] extends ArrayType<infer El>\r\n            ? El\r\n            : Set[\"__element__\"]\r\n        >,\r\n        cardutil.multiplyCardinalities<\r\n          Set[\"__cardinality__\"],\r\n          T extends TypeSet ? T[\"__cardinality__\"] : Cardinality.One\r\n        >\r\n        // >\r\n      >;\r\n      slice<\r\n        S extends TypeSet<ScalarType<\"std::number\">> | number,\r\n        E extends TypeSet<ScalarType<\"std::number\">> | number | undefined | null\r\n      >(\r\n        start: S,\r\n        end: E\r\n      ): $expr_Operator<\r\n        // \"[]\",\r\n        // OperatorKind.Infix,\r\n        // [Set, TypeSet],\r\n        // TypeSet<\r\n        getPrimitiveBaseType<Set[\"__element__\"]>,\r\n        cardutil.multiplyCardinalities<\r\n          cardutil.multiplyCardinalities<\r\n            Set[\"__cardinality__\"],\r\n            S extends TypeSet ? S[\"__cardinality__\"] : Cardinality.One\r\n          >,\r\n          E extends TypeSet<any, infer C> ? C : Cardinality.One\r\n        >\r\n        // >\r\n      >;\r\n      slice<\r\n        E extends TypeSet<ScalarType<\"std::number\">> | number | undefined | null\r\n      >(\r\n        start: undefined | null,\r\n        end: E\r\n      ): $expr_Operator<\r\n        // \"[]\",\r\n        // OperatorKind.Infix,\r\n        // [Set, TypeSet],\r\n        // TypeSet<\r\n        getPrimitiveBaseType<Set[\"__element__\"]>,\r\n        cardutil.multiplyCardinalities<\r\n          Set[\"__cardinality__\"],\r\n          E extends TypeSet<any, infer C> ? C : Cardinality.One\r\n        >\r\n        // >\r\n      >;\r\n    }\r\n  : unknown;\r\n\r\nexport type $expr_Array<\r\n  Type extends ArrayType = ArrayType,\r\n  Card extends Cardinality = Cardinality\r\n  // Items extends typeutil.tupleOf<TypeSet<Type>>\r\n> = Expression<{\r\n  __kind__: ExpressionKind.Array;\r\n  __items__: typeutil.tupleOf<TypeSet<Type[\"__element__\"]>>;\r\n  __element__: Type;\r\n  __cardinality__: Card;\r\n}>;\r\n\r\nexport interface ArrayType<\r\n  Element extends BaseType = BaseType,\r\n  Name extends string = `array<${Element[\"__name__\"]}>`\r\n> extends BaseType {\r\n  __name__: Name;\r\n  __kind__: TypeKind.array;\r\n  __element__: Element;\r\n}\r\n\r\ntype ArrayTypeToTsType<\r\n  Type extends ArrayType,\r\n  isParam extends boolean = false\r\n> = BaseTypeToTsType<Type[\"__element__\"], isParam>[];\r\n\r\n/////////////////////////\r\n/// TUPLE TYPE\r\n/////////////////////////\r\n\r\ntype $tuplePathify<Set extends TypeSet> = Set[\"__element__\"] extends TupleType\r\n  ? addTuplePaths<Set[\"__element__\"][\"__items__\"], Set[\"__cardinality__\"]>\r\n  : Set[\"__element__\"] extends NamedTupleType\r\n  ? addNamedTuplePaths<Set[\"__element__\"][\"__shape__\"], Set[\"__cardinality__\"]>\r\n  : unknown;\r\n\r\nexport type $expr_TuplePath<\r\n  ItemType extends BaseType = BaseType,\r\n  ParentCard extends Cardinality = Cardinality\r\n> = Expression<{\r\n  __kind__: ExpressionKind.TuplePath;\r\n  __element__: ItemType;\r\n  __cardinality__: ParentCard;\r\n  __parent__: $expr_Tuple | $expr_NamedTuple | $expr_TuplePath;\r\n  __index__: string | number;\r\n}>;\r\n\r\nexport type baseTupleElementsToTupleType<T extends typeutil.tupleOf<TypeSet>> =\r\n  {\r\n    [k in keyof T]: T[k] extends TypeSet\r\n      ? getPrimitiveBaseType<T[k][\"__element__\"]>\r\n      : never;\r\n  };\r\nexport type tupleElementsToTupleType<T extends typeutil.tupleOf<TypeSet>> =\r\n  baseTupleElementsToTupleType<T> extends BaseTypeTuple\r\n    ? TupleType<baseTupleElementsToTupleType<T>>\r\n    : never;\r\n\r\nexport type baseTupleElementsToCardTuple<T> = {\r\n  [k in keyof T]: T[k] extends TypeSet<any, infer C> ? C : never;\r\n};\r\n\r\nexport type tupleElementsToCardTuple<T> =\r\n  baseTupleElementsToCardTuple<T> extends [Cardinality, ...Cardinality[]]\r\n    ? baseTupleElementsToCardTuple<T>\r\n    : never;\r\n\r\nexport type $expr_Tuple<\r\n  Items extends typeutil.tupleOf<TypeSet> = typeutil.tupleOf<TypeSet>\r\n> = Expression<{\r\n  __kind__: ExpressionKind.Tuple;\r\n  __items__: typeutil.tupleOf<TypeSet>;\r\n  __element__: tupleElementsToTupleType<Items>;\r\n  __cardinality__: cardutil.multiplyCardinalitiesVariadic<\r\n    tupleElementsToCardTuple<Items>\r\n  >;\r\n}>;\r\n\r\nexport type indexKeys<T> = T extends `${number}` ? T : never;\r\n\r\ntype addTuplePaths<Items extends BaseType[], ParentCard extends Cardinality> = {\r\n  [k in indexKeys<keyof Items>]: Items[k] extends BaseType\r\n    ? $expr_TuplePath<Items[k], ParentCard>\r\n    : never;\r\n};\r\n\r\nexport interface TupleType<Items extends BaseTypeTuple = BaseTypeTuple>\r\n  extends BaseType {\r\n  __name__: string;\r\n  __kind__: TypeKind.tuple;\r\n  __items__: Items;\r\n}\r\n\r\ntype TupleItemsToTsType<\r\n  Items extends BaseTypeTuple,\r\n  isParam extends boolean = false\r\n> = {\r\n  [k in keyof Items]: Items[k] extends BaseType\r\n    ? BaseTypeToTsType<Items[k], isParam>\r\n    : never;\r\n};\r\n\r\n/////////////////////////\r\n/// NAMED TUPLE TYPE\r\n/////////////////////////\r\ntype literalShapeToType<T extends NamedTupleLiteralShape> = NamedTupleType<{\r\n  [k in keyof T]: getPrimitiveBaseType<T[k][\"__element__\"]>;\r\n}>;\r\ntype shapeCardinalities<Shape extends NamedTupleLiteralShape> =\r\n  Shape[keyof Shape][\"__cardinality__\"];\r\ntype inferNamedTupleCardinality<Shape extends NamedTupleLiteralShape> = [\r\n  Cardinality.Many\r\n] extends [shapeCardinalities<Shape>]\r\n  ? Cardinality.Many\r\n  : [Cardinality.Empty] extends [shapeCardinalities<Shape>]\r\n  ? Cardinality.Empty\r\n  : [shapeCardinalities<Shape>] extends [Cardinality.AtMostOne]\r\n  ? Cardinality.AtMostOne\r\n  : [shapeCardinalities<Shape>] extends [\r\n      Cardinality.AtMostOne | Cardinality.One\r\n    ]\r\n  ? Cardinality.One\r\n  : Cardinality.Many;\r\n\r\nexport type $expr_NamedTuple<\r\n  Shape extends NamedTupleLiteralShape = NamedTupleLiteralShape\r\n> = Expression<{\r\n  __kind__: ExpressionKind.NamedTuple;\r\n  __element__: literalShapeToType<Shape>;\r\n  __cardinality__: inferNamedTupleCardinality<Shape>;\r\n  __shape__: Shape;\r\n}>;\r\n\r\ntype addNamedTuplePaths<\r\n  Shape extends NamedTupleShape,\r\n  ParentCard extends Cardinality\r\n> = {\r\n  [k in keyof Shape]: Shape[k] extends BaseType\r\n    ? $expr_TuplePath<Shape[k], ParentCard>\r\n    : never;\r\n};\r\n\r\nexport type NamedTupleLiteralShape = { [k: string]: TypeSet };\r\nexport type NamedTupleShape = { [k: string]: BaseType };\r\nexport interface NamedTupleType<Shape extends NamedTupleShape = NamedTupleShape>\r\n  extends BaseType {\r\n  __name__: string;\r\n  __kind__: TypeKind.namedtuple;\r\n  __shape__: Shape;\r\n}\r\n\r\ntype NamedTupleTypeToTsType<\r\n  Type extends NamedTupleType,\r\n  isParam extends boolean = false\r\n> = {\r\n  [k in keyof Type[\"__shape__\"]]: BaseTypeToTsType<\r\n    Type[\"__shape__\"][k],\r\n    isParam\r\n  >;\r\n};\r\n\r\n/////////////////////////\r\n/// RANGE TYPE\r\n/////////////////////////\r\n\r\nexport interface RangeType<\r\n  Element extends ScalarType = ScalarType,\r\n  Name extends string = `range<${Element[\"__name__\"]}>`\r\n> extends BaseType {\r\n  __name__: Name;\r\n  __kind__: TypeKind.range;\r\n  __element__: Element;\r\n}\r\n\r\n/////////////////////////\r\n/// MULTIRANGE TYPE\r\n/////////////////////////\r\n\r\nexport interface MultiRangeType<\r\n  Element extends ScalarType = ScalarType,\r\n  Name extends string = `multirange<${Element[\"__name__\"]}>`\r\n> extends BaseType {\r\n  __name__: Name;\r\n  __kind__: TypeKind.multirange;\r\n  __element__: Element;\r\n}\r\n\r\n/////////////////////\r\n/// TSTYPE COMPUTATION\r\n/////////////////////\r\nexport type orLiteralValue<Set extends TypeSet> =\r\n  | Set\r\n  | (Set[\"__element__\"] extends ObjectType\r\n      ? never\r\n      : computeTsType<Set[\"__element__\"], Set[\"__cardinality__\"]>);\r\n\r\nexport type BaseTypeToTsType<\r\n  Type extends BaseType,\r\n  isParam extends boolean = false\r\n> = Type extends ScalarType\r\n  ? isParam extends true\r\n    ? Type[\"__tsargtype__\"]\r\n    : Type[\"__tsconsttype__\"]\r\n  : Type extends EnumType\r\n  ? Type[\"__tstype__\"]\r\n  : Type extends ArrayType<any>\r\n  ? ArrayTypeToTsType<Type, isParam>\r\n  : Type extends RangeType\r\n  ? Range<Type[\"__element__\"][\"__tsconsttype__\"]>\r\n  : Type extends MultiRangeType\r\n  ? MultiRange<Type[\"__element__\"][\"__tsconsttype__\"]>\r\n  : Type extends TupleType\r\n  ? TupleItemsToTsType<Type[\"__items__\"], isParam>\r\n  : Type extends NamedTupleType\r\n  ? typeutil.flatten<NamedTupleTypeToTsType<Type, isParam>>\r\n  : Type extends ObjectType\r\n  ? typeutil.flatten<\r\n      computeObjectShape<Type[\"__pointers__\"], Type[\"__shape__\"]>\r\n    >\r\n  : never;\r\n\r\nexport type setToTsType<Set extends TypeSet> = computeTsType<\r\n  Set[\"__element__\"],\r\n  Set[\"__cardinality__\"]\r\n>;\r\n\r\nexport type computeTsTypeCard<\r\n  T extends any,\r\n  C extends Cardinality\r\n> = Cardinality extends C\r\n  ? unknown\r\n  : C extends Cardinality.Empty\r\n  ? null\r\n  : C extends Cardinality.One\r\n  ? T\r\n  : C extends Cardinality.AtLeastOne\r\n  ? [T, ...T[]]\r\n  : C extends Cardinality.AtMostOne\r\n  ? T | null\r\n  : C extends Cardinality.Many\r\n  ? T[]\r\n  : C extends Cardinality\r\n  ? unknown\r\n  : never;\r\n\r\nexport type computeTsType<\r\n  T extends BaseType,\r\n  C extends Cardinality\r\n> = BaseType extends T ? unknown : computeTsTypeCard<BaseTypeToTsType<T>, C>;\r\n\r\nexport type propToTsType<Prop extends PropertyDesc> = Prop extends PropertyDesc<\r\n  infer Type,\r\n  infer Card\r\n>\r\n  ? setToTsType<TypeSet<Type, Card>>\r\n  : never;\r\n\r\nexport type linkToTsType<Link extends LinkDesc> = computeTsType<\r\n  Link[\"target\"],\r\n  Link[\"cardinality\"]\r\n>;\r\n\r\nexport type pointerToTsType<El extends PropertyDesc | LinkDesc> =\r\n  El extends PropertyDesc\r\n    ? propToTsType<El>\r\n    : El extends LinkDesc<any, any, any, any>\r\n    ? linkToTsType<El>\r\n    : never;\r\n\r\n///////////////////\r\n// TYPE HELPERS\r\n///////////////////\r\n\r\nexport type getPrimitiveBaseType<T extends BaseType> = T extends ScalarType\r\n  ? ScalarType<T[\"__name__\"], T[\"__tstype__\"], T[\"__tsargtype__\"]>\r\n  : T;\r\n\r\nexport type getPrimitiveNonArrayBaseType<T extends BaseType> =\r\n  T extends ArrayType ? never : getPrimitiveBaseType<T>;\r\n\r\nexport function isScalarType(type: BaseType): type is ScalarType {\r\n  return type.__kind__ === TypeKind.scalar;\r\n}\r\nexport function isEnumType(type: BaseType): type is EnumType {\r\n  return type.__kind__ === TypeKind.enum;\r\n}\r\nexport function isObjectType(type: BaseType): type is ObjectType {\r\n  return type.__kind__ === TypeKind.object;\r\n}\r\nexport function isTupleType(type: BaseType): type is TupleType {\r\n  return type.__kind__ === TypeKind.tuple;\r\n}\r\nexport function isNamedTupleType(type: BaseType): type is NamedTupleType {\r\n  return type.__kind__ === TypeKind.namedtuple;\r\n}\r\nexport function isArrayType(type: BaseType): type is ArrayType {\r\n  return type.__kind__ === TypeKind.array;\r\n}\r\n\r\nexport type NonArrayType =\r\n  | ScalarType\r\n  | EnumType\r\n  | ObjectType\r\n  | TupleType\r\n  | NamedTupleType\r\n  | RangeType\r\n  | MultiRangeType;\r\n\r\nexport type AnyTupleType = TupleType | NamedTupleType;\r\n\r\nexport type AnyObjectType = ObjectType;\r\n\r\nexport type ParamType =\r\n  | ScalarType\r\n  | EnumType\r\n  | ArrayType<\r\n      | ScalarType\r\n      | TupleType<typeutil.tupleOf<ParamType>>\r\n      | NamedTupleType<{ [k: string]: ParamType }>\r\n      | RangeType\r\n      | MultiRangeType\r\n    >\r\n  | TupleType<typeutil.tupleOf<ParamType>>\r\n  | NamedTupleType<{ [k: string]: ParamType }>\r\n  | RangeType\r\n  | MultiRangeType;\r\n"},{"path":"update.mts","content":"import {\r\n  ExpressionKind,\r\n  type typeutil,\r\n  Cardinality,\r\n} from \"edgedb/dist/reflection/index.js\";\r\nimport type {\r\n  Expression,\r\n  ObjectTypePointers,\r\n  TypeSet,\r\n  ObjectTypeSet,\r\n  stripBacklinks,\r\n  stripNonUpdateables,\r\n  ObjectTypeExpression,\r\n  ObjectType,\r\n  $scopify,\r\n} from \"./typesystem.mjs\";\r\nimport type { pointerToAssignmentExpression } from \"./casting.mjs\";\r\nimport { $expressionify, $getScopedExpr, $assert_single } from \"./path.mjs\";\r\nimport {\r\n  type SelectModifiers,\r\n  type NormalisedSelectModifiers,\r\n  type ComputeSelectCardinality,\r\n  $existingScopes,\r\n  $handleModifiers,\r\n} from \"./select.mjs\";\r\nimport { $normaliseInsertShape, type pointerIsOptional } from \"./insert.mjs\";\r\n\r\n/////////////////\r\n/// UPDATE\r\n/////////////////\r\n\r\nexport type $expr_Update<\r\n  El extends ObjectType = ObjectType,\r\n  Card extends Cardinality = Cardinality\r\n  // Set extends TypeSet = TypeSet,\r\n  // Expr extends ObjectTypeSet = ObjectTypeSet,\r\n  // Shape extends UpdateShape<ObjectTypeSet> = any\r\n> = Expression<{\r\n  __kind__: ExpressionKind.Update;\r\n  __element__: El;\r\n  __cardinality__: Card;\r\n  __expr__: TypeSet;\r\n  __shape__: any;\r\n  __modifiers__: NormalisedSelectModifiers;\r\n  __scope__: ObjectTypeExpression;\r\n}>;\r\n\r\nexport type UpdateShape<Root extends ObjectTypeSet> = typeutil.stripNever<\r\n  stripNonUpdateables<stripBacklinks<Root[\"__element__\"][\"__pointers__\"]>>\r\n> extends infer Shape\r\n  ? Shape extends ObjectTypePointers\r\n    ? {\r\n        [k in keyof Shape]?:\r\n          | (\r\n              | pointerToAssignmentExpression<Shape[k]>\r\n              | (Shape[k][\"cardinality\"] extends\r\n                  | Cardinality.Many\r\n                  | Cardinality.AtLeastOne\r\n                  ?\r\n                      | { \"+=\": pointerToAssignmentExpression<Shape[k], true> }\r\n                      | { \"-=\": pointerToAssignmentExpression<Shape[k], true> }\r\n                  : never)\r\n            )\r\n          | (pointerIsOptional<Shape[k]> extends true\r\n              ? undefined | null\r\n              : never);\r\n      }\r\n    : never\r\n  : never;\r\n\r\nexport function update<\r\n  Expr extends ObjectTypeExpression,\r\n  Shape extends {\r\n    filter?: SelectModifiers[\"filter\"];\r\n    filter_single?: SelectModifiers<Expr[\"__element__\"]>[\"filter_single\"];\r\n    set: UpdateShape<Expr>;\r\n  }\r\n  // SetShape extends UpdateShape<Expr>,\r\n  // Modifiers extends Pick<SelectModifiers, \"filter\">\r\n>(\r\n  expr: Expr,\r\n  shape: (scope: $scopify<Expr[\"__element__\"]>) => Readonly<Shape>\r\n): $expr_Update<Expr[\"__element__\"], ComputeSelectCardinality<Expr, Shape>> {\r\n  const cleanScopedExprs = $existingScopes.size === 0;\r\n\r\n  const scope = $getScopedExpr(expr as any, $existingScopes);\r\n\r\n  const resolvedShape = shape(scope);\r\n\r\n  if (cleanScopedExprs) {\r\n    $existingScopes.clear();\r\n  }\r\n\r\n  const mods: any = {};\r\n  let updateShape: any | null;\r\n  for (const [key, val] of Object.entries(resolvedShape)) {\r\n    if (key === \"filter\" || key === \"filter_single\") {\r\n      mods[key] = val;\r\n    } else if (key === \"set\") {\r\n      updateShape = val;\r\n    } else {\r\n      throw new Error(\r\n        `Invalid update shape key '${key}', only 'filter', 'filter_single', ` +\r\n          `and 'set' are allowed`\r\n      );\r\n    }\r\n  }\r\n\r\n  if (!updateShape) {\r\n    throw new Error(`Update shape must contain 'set' shape`);\r\n  }\r\n\r\n  const { modifiers, cardinality, needsAssertSingle } = $handleModifiers(mods, {\r\n    root: expr,\r\n    scope,\r\n  });\r\n\r\n  const updateExpr = {\r\n    __kind__: ExpressionKind.Update,\r\n    __element__: expr.__element__,\r\n    __cardinality__: cardinality,\r\n    __expr__: expr,\r\n    __shape__: $normaliseInsertShape(expr, updateShape, true),\r\n    __modifiers__: modifiers,\r\n    __scope__: scope,\r\n  } as any;\r\n\r\n  return needsAssertSingle\r\n    ? $assert_single(updateExpr)\r\n    : $expressionify(updateExpr);\r\n}\r\n"},{"path":"with.mts","content":"import { ExpressionKind, Cardinality } from \"edgedb/dist/reflection/index.js\";\r\nimport type { BaseType, Expression, TypeSet } from \"./typesystem.mjs\";\r\nimport type { $expr_Select } from \"./select.mjs\";\r\nimport type { $expr_For } from \"./for.mjs\";\r\nimport type { $expr_Insert } from \"./insert.mjs\";\r\nimport type { $expr_Update } from \"./update.mjs\";\r\nimport type { $expr_Group } from \"./group.mjs\";\r\nimport { $expressionify } from \"./path.mjs\";\r\n\r\nexport type $expr_Alias<\r\n  El extends BaseType = BaseType,\r\n  Card extends Cardinality = Cardinality\r\n> = Expression<{\r\n  __element__: El;\r\n  __cardinality__: Card;\r\n  __kind__: ExpressionKind.Alias;\r\n  __expr__: TypeSet;\r\n}>;\r\n\r\nexport function alias<Expr extends Expression>(\r\n  expr: Expr\r\n): $expr_Alias<Expr[\"__element__\"], Expr[\"__cardinality__\"]> {\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.Alias,\r\n    __element__: expr.__element__,\r\n    __cardinality__: expr.__cardinality__,\r\n    __expr__: expr,\r\n  }) as any;\r\n}\r\n\r\nexport type WithableExpression =\r\n  | $expr_Select\r\n  | $expr_For\r\n  | $expr_Insert\r\n  | $expr_Update\r\n  | $expr_Group;\r\n\r\nexport type $expr_With<\r\n  // Refs extends TypeSet[] = TypeSet[],\r\n  Expr extends WithableExpression = WithableExpression\r\n> = Expression<{\r\n  __element__: Expr[\"__element__\"];\r\n  __cardinality__: Expr[\"__cardinality__\"];\r\n  __kind__: ExpressionKind.With;\r\n  __expr__: Expr;\r\n  __refs__: TypeSet[];\r\n}>;\r\n\r\nfunction _with<Expr extends WithableExpression>(\r\n  refs: Expression[],\r\n  expr: Expr\r\n): $expr_With<Expr> {\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.With,\r\n    __element__: expr.__element__,\r\n    __cardinality__: expr.__cardinality__,\r\n    __refs__: refs,\r\n    __expr__: expr as any,\r\n  }) as any;\r\n}\r\n\r\nexport { _with as with };\r\n"},{"path":"__spec__.mts","content":"import type { TypeKind } from \"./reflection.mjs\";\r\n\r\nexport declare const spec: Map<string, any>;\r\n\r\nexport declare const complexParamKinds: Set<TypeKind>;\r\n"}],"ts":[{"path":"cardinality.ts","content":"import { Cardinality } from \"edgedb/dist/reflection/index\";\r\nimport type { TypeSet } from \"./typesystem\";\r\n\r\n// Computing cardinality of path\r\n// From base set cadinality and pointer cardinality\r\n// Used in path expressions\r\n// Cardinality  Empty  AtMostOne  One         Many  AtLeastOne\r\n// Empty        0      0          0           0     0\r\n// AtMostOne    0      AtMostOne  AtMostOne   Many  Many\r\n// One          0      AtMostOne  One         Many  AtLeastOne\r\n// Many         0      Many       Many        Many  Many\r\n// AtLeastOne   0      Many       AtLeastOne  Many  AtLeastOne\r\nexport namespace cardutil {\r\n  export type multiplyCardinalities<\r\n    C1 extends Cardinality,\r\n    C2 extends Cardinality\r\n  > = C1 extends Cardinality.Empty\r\n    ? Cardinality.Empty\r\n    : C1 extends Cardinality.One\r\n    ? C2\r\n    : C1 extends Cardinality.AtMostOne\r\n    ? C2 extends Cardinality.One\r\n      ? Cardinality.AtMostOne\r\n      : C2 extends Cardinality.AtLeastOne\r\n      ? Cardinality.Many\r\n      : C2\r\n    : C1 extends Cardinality.Many\r\n    ? C2 extends Cardinality.Empty\r\n      ? Cardinality.Empty\r\n      : Cardinality.Many\r\n    : C1 extends Cardinality.AtLeastOne\r\n    ? C2 extends Cardinality.AtMostOne\r\n      ? Cardinality.Many\r\n      : C2 extends Cardinality.One\r\n      ? Cardinality.AtLeastOne\r\n      : C2\r\n    : never;\r\n\r\n  export function multiplyCardinalities(\r\n    c1: Cardinality,\r\n    c2: Cardinality\r\n  ): Cardinality {\r\n    if (c1 === Cardinality.Empty) return Cardinality.Empty;\r\n\r\n    if (c1 === Cardinality.One) return c2;\r\n    if (c1 === Cardinality.AtMostOne) {\r\n      if (c2 === Cardinality.One) return Cardinality.AtMostOne;\r\n      if (c2 === Cardinality.AtLeastOne) return Cardinality.Many;\r\n      return c2;\r\n    }\r\n    if (c1 === Cardinality.Many) {\r\n      if (c2 === Cardinality.Empty) return Cardinality.Empty;\r\n      return Cardinality.Many;\r\n    }\r\n    if (c1 === Cardinality.AtLeastOne) {\r\n      if (c2 === Cardinality.AtMostOne) return Cardinality.Many;\r\n      if (c2 === Cardinality.One) return Cardinality.AtLeastOne;\r\n      return c2;\r\n    }\r\n    throw new Error(`Invalid Cardinality ${c1}`);\r\n  }\r\n\r\n  type _multiplyCardinalitiesVariadic<\r\n    Cards extends [Cardinality, ...Cardinality[]]\r\n  > = Cards extends [infer Card]\r\n    ? Card\r\n    : Cards extends [infer A, infer B, ...infer Rest]\r\n    ? A extends Cardinality\r\n      ? B extends Cardinality\r\n        ? Rest extends Cardinality[]\r\n          ? multiplyCardinalities<A, B> extends Cardinality\r\n            ? _multiplyCardinalitiesVariadic<\r\n                [multiplyCardinalities<A, B>, ...Rest]\r\n              >\r\n            : never\r\n          : never\r\n        : never\r\n      : never\r\n    : never;\r\n\r\n  export type multiplyCardinalitiesVariadic<\r\n    Cards extends [Cardinality, ...Cardinality[]]\r\n  > = _multiplyCardinalitiesVariadic<Cards> extends Cardinality\r\n    ? _multiplyCardinalitiesVariadic<Cards>\r\n    : never;\r\n\r\n  export function multiplyCardinalitiesVariadic<\r\n    Cards extends [Cardinality, ...Cardinality[]]\r\n  >(cards: Cards): multiplyCardinalitiesVariadic<Cards> {\r\n    if (cards.length === 0) throw new Error(\"Empty tuple not allowed\");\r\n    if (cards.length === 1) return cards[0] as any;\r\n    return cards.reduce(\r\n      (product, card) => multiplyCardinalities(product, card),\r\n      Cardinality.One\r\n    ) as any;\r\n  }\r\n\r\n  // Merging two sets\r\n  // Used in set constructor\r\n  // Cardinality  Empty       AtMostOne  One         Many        AtLeastOne\r\n  // Empty        Empty       AtMostOne  One         Many        AtLeastOne\r\n  // AtMostOne    AtMostOne   Many       AtLeastOne  Many        AtLeastOne\r\n  // One          One         AtLeastOne AtLeastOne  AtLeastOne  AtLeastOne\r\n  // Many         Many        Many       AtLeastOne  Many        AtLeastOne\r\n  // AtLeastOne   AtLeastOne  AtLeastOne AtLeastOne  AtLeastOne  AtLeastOne\r\n\r\n  export type mergeCardinalities<\r\n    A extends Cardinality,\r\n    B extends Cardinality\r\n  > = A extends Cardinality.Empty\r\n    ? B\r\n    : B extends Cardinality.Empty\r\n    ? A\r\n    : A extends Cardinality.AtLeastOne\r\n    ? Cardinality.AtLeastOne\r\n    : B extends Cardinality.AtLeastOne\r\n    ? Cardinality.AtLeastOne\r\n    : A extends Cardinality.One\r\n    ? Cardinality.AtLeastOne\r\n    : B extends Cardinality.One\r\n    ? Cardinality.AtLeastOne\r\n    : Cardinality.Many;\r\n\r\n  export function mergeCardinalities<\r\n    A extends Cardinality,\r\n    B extends Cardinality\r\n  >(a: A, b: B): mergeCardinalities<A, B> {\r\n    if (a === Cardinality.Empty) return b as any;\r\n    if (b === Cardinality.Empty) return a as any;\r\n    if (a === Cardinality.AtLeastOne) return Cardinality.AtLeastOne as any;\r\n    if (b === Cardinality.AtLeastOne) return Cardinality.AtLeastOne as any;\r\n    if (a === Cardinality.One) return Cardinality.AtLeastOne as any;\r\n    if (b === Cardinality.One) return Cardinality.AtLeastOne as any;\r\n    return Cardinality.Many as any;\r\n  }\r\n\r\n  type _mergeCardinalitiesVariadic<\r\n    Cards extends [Cardinality, ...Cardinality[]]\r\n  > = Cards extends [infer Card]\r\n    ? Card\r\n    : Cards extends [infer A, infer B, ...infer Rest]\r\n    ? A extends Cardinality\r\n      ? B extends Cardinality\r\n        ? Rest extends Cardinality[]\r\n          ? mergeCardinalities<A, B> extends Cardinality\r\n            ? _mergeCardinalitiesVariadic<[mergeCardinalities<A, B>, ...Rest]>\r\n            : never\r\n          : never\r\n        : never\r\n      : never\r\n    : never;\r\n\r\n  export type mergeCardinalitiesVariadic<\r\n    Cards extends [Cardinality, ...Cardinality[]]\r\n  > = _mergeCardinalitiesVariadic<Cards> extends Cardinality\r\n    ? _mergeCardinalitiesVariadic<Cards>\r\n    : never;\r\n  export function mergeCardinalitiesVariadic<\r\n    Cards extends [Cardinality, ...Cardinality[]]\r\n  >(cards: Cards): mergeCardinalitiesVariadic<Cards> {\r\n    if (cards.length === 0) throw new Error(\"Empty tuple not allowed\");\r\n    if (cards.length === 1) return cards[0] as any;\r\n    const [first, second, ...rest] = cards as unknown as [\r\n      Cardinality,\r\n      Cardinality,\r\n      ...Cardinality[]\r\n    ];\r\n    if (cards.length === 2) return mergeCardinalities(first, second) as any;\r\n    return mergeCardinalitiesVariadic([\r\n      mergeCardinalities(first, second),\r\n      ...rest,\r\n    ]);\r\n  }\r\n\r\n  // 'or' cardinalities together\r\n  // used in the IF ELSE operator, for expr (a IF bool ELSE b)\r\n  // result cardinality is 'a' cardinality *or* 'b' cardinality\r\n  // Cardinality  Empty       AtMostOne   One         Many        AtLeastOne\r\n  // Empty        0           AtMostOne   AtMostOne   Many        Many\r\n  // AtMostOne    AtMostOne   AtMostOne   AtMostOne   Many        Many\r\n  // One          AtMostOne   AtMostOne   One         Many        AtLeastOne\r\n  // Many         Many        Many        Many        Many        Many\r\n  // AtLeastOne   Many        Many        AtLeastOne  Many        AtLeastOne\r\n\r\n  export type orCardinalities<\r\n    C1 extends Cardinality,\r\n    C2 extends Cardinality\r\n  > = C1 extends C2\r\n    ? C1\r\n    : C1 extends Cardinality.Many\r\n    ? C1\r\n    : C1 extends Cardinality.AtMostOne\r\n    ? C2 extends Cardinality.Many\r\n      ? C2\r\n      : C2 extends Cardinality.AtLeastOne\r\n      ? Cardinality.Many\r\n      : C1\r\n    : C1 extends Cardinality.AtLeastOne\r\n    ? C2 extends Cardinality.One\r\n      ? Cardinality.AtLeastOne\r\n      : Cardinality.Many\r\n    : C1 extends Cardinality.Empty\r\n    ? C2 extends Cardinality.AtMostOne\r\n      ? Cardinality.AtMostOne\r\n      : C2 extends Cardinality.One\r\n      ? Cardinality.AtMostOne\r\n      : Cardinality.Many\r\n    : C2 extends Cardinality.Empty\r\n    ? Cardinality.AtMostOne\r\n    : C2;\r\n\r\n  export function orCardinalities(\r\n    c1: Cardinality,\r\n    c2: Cardinality\r\n  ): Cardinality {\r\n    if (c1 === c2 || c1 === Cardinality.Many) return c1;\r\n    if (c1 === Cardinality.AtLeastOne) {\r\n      if (c2 === Cardinality.One) return Cardinality.AtLeastOne;\r\n      return Cardinality.Many;\r\n    }\r\n    if (c1 === Cardinality.AtMostOne) {\r\n      if (c2 === Cardinality.Many || c2 === Cardinality.AtLeastOne) {\r\n        return Cardinality.Many;\r\n      }\r\n      return c1;\r\n    }\r\n    if (c1 === Cardinality.Empty) {\r\n      if (c2 === Cardinality.AtMostOne || c2 === Cardinality.One) {\r\n        return Cardinality.AtMostOne;\r\n      }\r\n      return Cardinality.Many;\r\n    }\r\n    if (c2 === Cardinality.Empty) return Cardinality.AtMostOne;\r\n    return c2;\r\n  }\r\n\r\n  //          Empty  AtMostOne  One         Many        AtLeastOne\r\n  // One      One    One        One         AtLeastOne  AtLeastOne\r\n  // Zero     0      AtMostOne  AtMostOne   Many        Many\r\n\r\n  export type overrideLowerBound<\r\n    C extends Cardinality,\r\n    O extends \"One\" | \"Zero\"\r\n  > = O extends \"One\"\r\n    ? C extends Cardinality.Many\r\n      ? Cardinality.AtLeastOne\r\n      : C extends Cardinality.AtLeastOne\r\n      ? Cardinality.AtLeastOne\r\n      : Cardinality.One\r\n    : C extends Cardinality.Empty\r\n    ? Cardinality.Empty\r\n    : C extends Cardinality.Many\r\n    ? Cardinality.Many\r\n    : C extends Cardinality.AtLeastOne\r\n    ? Cardinality.Many\r\n    : Cardinality.AtMostOne;\r\n\r\n  export function overrideLowerBound<\r\n    C extends Cardinality,\r\n    O extends \"One\" | \"Zero\"\r\n  >(card: C, override: O): overrideLowerBound<C, O> {\r\n    if (override === \"One\") {\r\n      if (card === Cardinality.Many || card === Cardinality.AtLeastOne) {\r\n        return Cardinality.AtLeastOne as any;\r\n      } else {\r\n        return Cardinality.One as any;\r\n      }\r\n    } else {\r\n      if (card === Cardinality.Many || card === Cardinality.AtLeastOne) {\r\n        return Cardinality.Many as any;\r\n      } else if (card === Cardinality.Empty) {\r\n        return Cardinality.Empty as any;\r\n      } else {\r\n        return Cardinality.AtMostOne as any;\r\n      }\r\n    }\r\n  }\r\n\r\n  //          Empty      AtMostOne  One         Many        AtLeastOne\r\n  // One      AtMostOne  AtMostOne  One         AtMostOne   One\r\n  // Many     Many       Many       AtLeastOne  Many        AtLeastOne\r\n\r\n  export type overrideUpperBound<\r\n    C extends Cardinality,\r\n    O extends \"One\" | \"Many\"\r\n  > = O extends \"One\"\r\n    ? C extends Cardinality.Many\r\n      ? Cardinality.AtMostOne\r\n      : C extends Cardinality.AtLeastOne\r\n      ? Cardinality.One\r\n      : C extends Cardinality.Empty\r\n      ? Cardinality.AtMostOne\r\n      : C\r\n    : C extends Cardinality.One\r\n    ? Cardinality.AtLeastOne\r\n    : C extends Cardinality.AtMostOne\r\n    ? Cardinality.Many\r\n    : C extends Cardinality.Empty\r\n    ? Cardinality.Many\r\n    : C;\r\n\r\n  export function overrideUpperBound<\r\n    C extends Cardinality,\r\n    O extends \"One\" | \"Many\"\r\n  >(card: C, override: O): overrideUpperBound<C, O> {\r\n    if (override === \"One\") {\r\n      if (card === Cardinality.One || card === Cardinality.AtLeastOne) {\r\n        return Cardinality.One as any;\r\n      } else {\r\n        return Cardinality.AtMostOne as any;\r\n      }\r\n    } else {\r\n      if (card === Cardinality.One || card === Cardinality.AtLeastOne) {\r\n        return Cardinality.AtLeastOne as any;\r\n      } else {\r\n        return Cardinality.Many as any;\r\n      }\r\n    }\r\n  }\r\n\r\n  export type paramCardinality<P> = [P] extends [TypeSet]\r\n    ? // default to one\r\n      // fixes multiplyCardinalities bug for func with optional args\r\n      [Cardinality] extends [P[\"__cardinality__\"]]\r\n      ? Cardinality.One\r\n      : P[\"__cardinality__\"]\r\n    : Cardinality.One;\r\n\r\n  export type optionalParamCardinality<P> = overrideLowerBound<\r\n    paramCardinality<P>,\r\n    \"One\"\r\n  >;\r\n\r\n  type _paramArrayCardinality<T> = {\r\n    [K in keyof T]: T[K] extends TypeSet\r\n      ? T[K][\"__cardinality__\"]\r\n      : Cardinality.One;\r\n  };\r\n\r\n  export type paramArrayCardinality<T extends [any, ...any[]]> =\r\n    multiplyCardinalitiesVariadic<_paramArrayCardinality<T>>;\r\n\r\n  export type assignable<C extends Cardinality> = C extends Cardinality.Empty\r\n    ? Cardinality.Empty\r\n    : C extends Cardinality.One\r\n    ? Cardinality.One\r\n    : C extends Cardinality.AtMostOne\r\n    ? Cardinality.One | Cardinality.AtMostOne | Cardinality.Empty\r\n    : C extends Cardinality.AtLeastOne\r\n    ? Cardinality.One | Cardinality.AtLeastOne | Cardinality.Many\r\n    : C extends Cardinality.Many\r\n    ? Cardinality\r\n    : never;\r\n}\r\n"},{"path":"cast.ts","content":"import { ExpressionKind, Cardinality } from \"edgedb/dist/reflection/index\";\r\nimport type {\r\n  Expression,\r\n  BaseType,\r\n  TypeSet,\r\n  ObjectTypeExpression,\r\n} from \"./typesystem\";\r\nimport { $expressionify } from \"./path\";\r\nimport type { orScalarLiteral } from \"./castMaps\";\r\nimport { literalToTypeSet } from \"./castMaps\";\r\n\r\nexport function cast<Target extends BaseType | ObjectTypeExpression>(\r\n  target: Target,\r\n  arg: null\r\n): $expr_Cast<\r\n  Target extends BaseType\r\n    ? Target\r\n    : Target extends ObjectTypeExpression\r\n    ? Target[\"__element__\"]\r\n    : never,\r\n  Cardinality.Empty\r\n>;\r\nexport function cast<Target extends BaseType, Expr extends TypeSet>(\r\n  target: Target,\r\n  expr: orScalarLiteral<Expr>\r\n): $expr_Cast<\r\n  Target,\r\n  Cardinality extends Expr[\"__cardinality__\"]\r\n    ? Cardinality.One\r\n    : Expr[\"__cardinality__\"]\r\n>;\r\nexport function cast(target: BaseType, expr: any) {\r\n  const cleanedExpr = expr === null ? null : literalToTypeSet(expr);\r\n  return $expressionify({\r\n    __element__: (target as any).__cardinality__\r\n      ? (target as any).__element__\r\n      : target,\r\n    __cardinality__:\r\n      cleanedExpr === null ? Cardinality.Empty : cleanedExpr.__cardinality__,\r\n    __expr__: cleanedExpr,\r\n    __kind__: ExpressionKind.Cast,\r\n  }) as any;\r\n}\r\n\r\nexport type $expr_Cast<\r\n  Target extends BaseType = BaseType,\r\n  Card extends Cardinality = Cardinality\r\n> = Expression<{\r\n  __element__: Target;\r\n  __cardinality__: Card;\r\n  __kind__: ExpressionKind.Cast;\r\n  __expr__: TypeSet | null;\r\n}>;\r\n"},{"path":"casting.ts","content":"import type { Cardinality } from \"edgedb/dist/reflection/index\";\r\nimport type {\r\n  ArrayType,\r\n  BaseType,\r\n  BaseTypeTuple,\r\n  BaseTypeToTsType,\r\n  EnumType,\r\n  LinkDesc,\r\n  NamedTupleType,\r\n  ObjectType,\r\n  ObjectTypeSet,\r\n  PrimitiveTypeSet,\r\n  PropertyDesc,\r\n  ScalarType,\r\n  TupleType,\r\n  TypeSet,\r\n  RangeType,\r\n  MultiRangeType,\r\n} from \"./typesystem\";\r\nimport type { cardutil } from \"./cardinality\";\r\n\r\nimport type { scalarCastableFrom, scalarAssignableBy } from \"./castMaps\";\r\n\r\nexport type anonymizeObject<T extends ObjectType> = ObjectType<\r\n  string,\r\n  T[\"__pointers__\"],\r\n  any\r\n>;\r\n\r\n////////////////\r\n// ASSIGNABLE\r\n////////////////\r\n\r\ntype assignableTuple<Items extends BaseTypeTuple> = {\r\n  [k in keyof Items]: Items[k] extends BaseType\r\n    ? assignableBy<Items[k]>\r\n    : never;\r\n} extends infer NewItems\r\n  ? NewItems extends BaseTypeTuple\r\n    ? NewItems\r\n    : never\r\n  : never;\r\n\r\nexport type assignableBy<T extends BaseType> = T extends ScalarType\r\n  ? scalarAssignableBy<T>\r\n  : T extends ObjectType\r\n  ? anonymizeObject<T>\r\n  : T extends EnumType\r\n  ? T\r\n  : T extends ArrayType\r\n  ? ArrayType<assignableBy<T[\"__element__\"]>>\r\n  : T extends TupleType\r\n  ? TupleType<assignableTuple<T[\"__items__\"]>>\r\n  : T extends NamedTupleType\r\n  ? NamedTupleType<{\r\n      [k in keyof T[\"__shape__\"]]: assignableBy<T[\"__shape__\"][k]>;\r\n    }>\r\n  : T extends RangeType\r\n  ? RangeType<\r\n      scalarAssignableBy<T[\"__element__\"]> extends ScalarType\r\n        ? scalarAssignableBy<T[\"__element__\"]>\r\n        : never\r\n    >\r\n  : T extends MultiRangeType\r\n  ? MultiRangeType<\r\n      scalarAssignableBy<T[\"__element__\"]> extends ScalarType\r\n        ? scalarAssignableBy<T[\"__element__\"]>\r\n        : never\r\n    >\r\n  : never;\r\n\r\nexport type pointerToAssignmentExpression<\r\n  Pointer extends PropertyDesc | LinkDesc,\r\n  IsSetModifier extends boolean = false\r\n> = setToAssignmentExpression<\r\n  TypeSet<Pointer[\"target\"], Pointer[\"cardinality\"]>,\r\n  IsSetModifier\r\n>;\r\n\r\nexport type setToAssignmentExpression<\r\n  Set extends TypeSet,\r\n  IsSetModifier extends boolean\r\n> = [Set] extends [PrimitiveTypeSet]\r\n  ?\r\n      | TypeSet<\r\n          assignableBy<Set[\"__element__\"]>,\r\n          cardutil.assignable<\r\n            // Set[\"__cardinality__\"]\r\n            cardutil.overrideLowerBound<Set[\"__cardinality__\"], \"Zero\">\r\n          >\r\n        >\r\n      | getAssignmentLiteral<Set, IsSetModifier>\r\n  : [Set] extends [ObjectTypeSet]\r\n  ? TypeSet<\r\n      ObjectType<\r\n        // anonymize the object type\r\n        string,\r\n        Set[\"__element__\"][\"__pointers__\"]\r\n      >,\r\n      cardutil.assignable<\r\n        // Allow expressions with AtMostOne or Many cardinality in\r\n        // insert/update shape even when link is required since EdgeDB will\r\n        // assert cardinality at runtime\r\n        cardutil.overrideLowerBound<Set[\"__cardinality__\"], \"Zero\">\r\n      >\r\n    >\r\n  : never;\r\n\r\ntype getAssignmentLiteral<\r\n  Set extends PrimitiveTypeSet,\r\n  IsSetModifier extends boolean\r\n> = BaseTypeToTsType<Set[\"__element__\"]> extends infer TsType\r\n  ?\r\n      | TsType\r\n      | (Set[\"__cardinality__\"] extends Cardinality.Many\r\n          ? TsType[]\r\n          : Set[\"__cardinality__\"] extends Cardinality.AtLeastOne\r\n          ? IsSetModifier extends true\r\n            ? TsType[]\r\n            : [TsType, ...TsType[]]\r\n          : never)\r\n  : never;\r\n\r\n////////////////\r\n// CASTABLES\r\n////////////////\r\n\r\ntype castableTuple<Items extends BaseTypeTuple> = {\r\n  [k in keyof Items]: Items[k] extends BaseType\r\n    ? castableFrom<Items[k]>\r\n    : never;\r\n} extends infer NewItems\r\n  ? NewItems extends BaseTypeTuple\r\n    ? NewItems\r\n    : never\r\n  : never;\r\n\r\nexport type castableFrom<T extends BaseType> = T extends ScalarType\r\n  ? scalarCastableFrom<T>\r\n  : T extends ObjectType\r\n  ? anonymizeObject<T>\r\n  : T extends ArrayType\r\n  ? ArrayType<castableFrom<T[\"__element__\"]>>\r\n  : T extends TupleType\r\n  ? TupleType<castableTuple<T[\"__items__\"]>>\r\n  : T extends NamedTupleType\r\n  ? NamedTupleType<{\r\n      [k in keyof T[\"__shape__\"]]: castableFrom<T[\"__shape__\"][k]>;\r\n    }>\r\n  : never;\r\n\r\nexport type pointerToCastableExpression<\r\n  Pointer extends PropertyDesc | LinkDesc\r\n> = [Pointer] extends [PropertyDesc]\r\n  ? {\r\n      __element__: castableFrom<Pointer[\"target\"]>;\r\n      __cardinality__: cardutil.assignable<Pointer[\"cardinality\"]>;\r\n    }\r\n  : [Pointer] extends [LinkDesc]\r\n  ? TypeSet<\r\n      ObjectType<\r\n        // anonymize the object type\r\n        string,\r\n        Pointer[\"target\"][\"__pointers__\"]\r\n      >,\r\n      cardutil.assignable<Pointer[\"cardinality\"]>\r\n    >\r\n  : never;\r\n"},{"path":"castMaps.ts","content":"export type scalarCastableFrom<T extends any> = any;\r\nexport type scalarAssignableBy<T extends any> = any;\r\nexport type orScalarLiteral<T extends any> = any;\r\nexport type scalarLiterals = any;\r\nexport type literalToScalarType<T extends any> = any;\r\ntype literalToTypeSet<T extends any> = any;\r\nexport type mapLiteralToTypeSet<T> = {\r\n  [k in keyof T]: literalToTypeSet<T[k]>;\r\n};\r\ndeclare function literalToTypeSet(t: any): any;\r\nexport { literalToTypeSet };\r\nexport declare function isImplicitlyCastableTo(\r\n  from: string,\r\n  to: string\r\n): boolean;\r\nexport function getSharedParentScalar(a: any, b: any): any {}\r\nexport type getSharedParentScalar<A, B> = any;\r\n"},{"path":"collections.ts","content":"import {\r\n  Cardinality,\r\n  ExpressionKind,\r\n  TypeKind,\r\n  type typeutil,\r\n} from \"edgedb/dist/reflection/index\";\r\nimport { cardutil } from \"./cardinality\";\r\nimport type {\r\n  $expr_Array,\r\n  $expr_NamedTuple,\r\n  $expr_Tuple,\r\n  $expr_TuplePath,\r\n  ArrayType,\r\n  BaseType,\r\n  getPrimitiveBaseType,\r\n  NamedTupleLiteralShape,\r\n  NamedTupleShape,\r\n  NamedTupleType,\r\n  NonArrayType,\r\n  ObjectTypeExpression,\r\n  ObjectTypePointers,\r\n  PropertyDesc,\r\n  TupleType,\r\n  TypeSet,\r\n} from \"./typesystem\";\r\n\r\nimport { $expressionify, type ExpressionRoot } from \"./path\";\r\nimport type { getCardsFromExprs } from \"./set\";\r\nimport {\r\n  type literalToScalarType,\r\n  literalToTypeSet,\r\n  type mapLiteralToTypeSet,\r\n  type orScalarLiteral,\r\n  type scalarLiterals,\r\n} from \"./castMaps\";\r\n\r\nconst indexSliceRegx = /^(-?\\d+)(?:(:)(-?\\d+)?)?|:(-?\\d+)$/;\r\n\r\nconst arrayLikeProxyHandlers: ProxyHandler<ExpressionRoot> = {\r\n  get(target: ExpressionRoot, prop: string | symbol, proxy: any) {\r\n    const match = typeof prop === \"string\" ? prop.match(indexSliceRegx) : null;\r\n    if (match) {\r\n      const start = match[1];\r\n      const end = match[3] ?? match[4];\r\n      const isIndex = start && !match[2];\r\n      return $expressionify({\r\n        __kind__: ExpressionKind.Operator,\r\n        __element__:\r\n          target.__element__.__kind__ === TypeKind.array && isIndex\r\n            ? (target.__element__ as ArrayType).__element__\r\n            : target.__element__,\r\n        __cardinality__: target.__cardinality__,\r\n        __name__: \"[]\",\r\n        __opkind__: \"Infix\",\r\n        __args__: [\r\n          proxy,\r\n          isIndex\r\n            ? literalToTypeSet(Number(start))\r\n            : [\r\n                start && literalToTypeSet(Number(start)),\r\n                end && literalToTypeSet(Number(end)),\r\n              ],\r\n        ],\r\n      }) as any;\r\n    }\r\n    return (target as any)[prop];\r\n  },\r\n};\r\n\r\nfunction arrayLikeIndex(this: ExpressionRoot, index: any) {\r\n  const indexTypeSet = literalToTypeSet(index);\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.Operator,\r\n    __element__:\r\n      this.__element__.__kind__ === TypeKind.array\r\n        ? (this.__element__ as ArrayType).__element__\r\n        : this.__element__,\r\n    __cardinality__: cardutil.multiplyCardinalities(\r\n      this.__cardinality__,\r\n      indexTypeSet.__cardinality__\r\n    ),\r\n    __name__: \"[]\",\r\n    __opkind__: \"Infix\",\r\n    __args__: [this, indexTypeSet],\r\n  }) as any;\r\n}\r\n\r\nfunction arrayLikeSlice(this: ExpressionRoot, start: any, end: any) {\r\n  const startTypeSet = start && literalToTypeSet(start);\r\n  const endTypeSet = end && literalToTypeSet(end);\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.Operator,\r\n    __element__: this.__element__,\r\n    __cardinality__: cardutil.multiplyCardinalities(\r\n      cardutil.multiplyCardinalities(\r\n        this.__cardinality__,\r\n        startTypeSet?.__cardinality__ ?? Cardinality.One\r\n      ),\r\n      endTypeSet?.__cardinality__ ?? Cardinality.One\r\n    ),\r\n    __name__: \"[]\",\r\n    __opkind__: \"Infix\",\r\n    __args__: [this, [startTypeSet, endTypeSet]],\r\n  }) as any;\r\n}\r\n\r\nexport function $arrayLikeIndexify(_expr: ExpressionRoot) {\r\n  if (\r\n    _expr.__element__.__kind__ === TypeKind.array ||\r\n    (_expr.__element__.__kind__ === TypeKind.scalar &&\r\n      (_expr.__element__.__name__ === \"std::str\" ||\r\n        _expr.__element__.__name__ === \"std::bytes\"))\r\n  ) {\r\n    const expr = new Proxy(_expr, arrayLikeProxyHandlers) as any;\r\n\r\n    expr.index = arrayLikeIndex.bind(expr);\r\n    expr.slice = arrayLikeSlice.bind(expr);\r\n\r\n    return expr;\r\n  }\r\n\r\n  return _expr;\r\n}\r\n\r\n// ARRAY\r\nexport function array<Element extends NonArrayType>(\r\n  element: Element\r\n): ArrayType<Element>;\r\nexport function array<\r\n  Expr extends TypeSet<NonArrayType> | scalarLiterals,\r\n  Exprs extends orScalarLiteral<\r\n    TypeSet<\r\n      Expr extends TypeSet\r\n        ? getPrimitiveBaseType<Expr[\"__element__\"]>\r\n        : getPrimitiveBaseType<literalToScalarType<Expr>>\r\n    >\r\n  >[]\r\n>(\r\n  arg: [Expr, ...Exprs]\r\n): $expr_Array<\r\n  ArrayType<\r\n    Expr extends TypeSet\r\n      ? getPrimitiveBaseType<Expr[\"__element__\"]>\r\n      : getPrimitiveBaseType<literalToScalarType<Expr>>\r\n  >,\r\n  cardutil.multiplyCardinalitiesVariadic<\r\n    getCardsFromExprs<mapLiteralToTypeSet<[Expr, ...Exprs]>>\r\n  >\r\n>;\r\nexport function array(arg: any) {\r\n  if (Array.isArray(arg)) {\r\n    const items = arg.map((a) => literalToTypeSet(a));\r\n    return $expressionify({\r\n      __kind__: ExpressionKind.Array,\r\n      __cardinality__: cardutil.multiplyCardinalitiesVariadic(\r\n        items.map((item) => item.__cardinality__) as any\r\n      ),\r\n      __element__: {\r\n        __kind__: TypeKind.array,\r\n        __name__: `array<${items[0]!.__element__.__name__}>`,\r\n        __element__: items[0]!.__element__,\r\n      } as any,\r\n      __items__: items,\r\n    });\r\n  }\r\n  if (arg.__kind__) {\r\n    return {\r\n      __kind__: TypeKind.array,\r\n      __name__: `array<${arg.__name__}>`,\r\n      __element__: arg,\r\n    } as any;\r\n  }\r\n\r\n  throw new Error(\"Invalid array input.\");\r\n}\r\n\r\n// TUPLE\r\n\r\nconst tupleProxyHandlers: ProxyHandler<ExpressionRoot> = {\r\n  get(target: ExpressionRoot, prop: string | symbol, proxy: any) {\r\n    const type = target.__element__;\r\n    const items =\r\n      type.__kind__ === TypeKind.tuple\r\n        ? (type as TupleType).__items__\r\n        : type.__kind__ === TypeKind.namedtuple\r\n        ? (type as NamedTupleType).__shape__\r\n        : null;\r\n    return items?.hasOwnProperty(prop)\r\n      ? tuplePath(proxy, (items as any)[prop], prop as any)\r\n      : (target as any)[prop];\r\n  },\r\n};\r\n\r\nexport function $tuplePathify(expr: ExpressionRoot) {\r\n  if (\r\n    expr.__element__.__kind__ !== TypeKind.tuple &&\r\n    expr.__element__.__kind__ !== TypeKind.namedtuple\r\n  ) {\r\n    return expr;\r\n  }\r\n\r\n  return new Proxy(expr, tupleProxyHandlers);\r\n}\r\n\r\nfunction tuplePath(\r\n  parent: $expr_Tuple | $expr_TuplePath,\r\n  itemType: BaseType,\r\n  index: string\r\n): $expr_TuplePath {\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.TuplePath,\r\n    __element__: itemType,\r\n    __cardinality__: parent.__cardinality__,\r\n    __parent__: parent,\r\n    __index__: index,\r\n  }) as any;\r\n}\r\n\r\nfunction makeTupleType(name: string, items: BaseType[]) {\r\n  return {\r\n    __kind__: TypeKind.tuple,\r\n    __name__: name,\r\n    __items__: items,\r\n  } as any;\r\n}\r\n\r\nconst typeKinds = new Set(Object.values(TypeKind));\r\n\r\nexport function tuple<Items extends typeutil.tupleOf<BaseType>>(\r\n  items: Items\r\n): TupleType<Items>;\r\nexport function tuple<\r\n  Item extends TypeSet | scalarLiterals,\r\n  Items extends typeutil.tupleOf<TypeSet | scalarLiterals>\r\n>(\r\n  items: Items\r\n): $expr_Tuple<\r\n  Items extends typeutil.tupleOf<any> ? mapLiteralToTypeSet<Items> : never\r\n>;\r\nexport function tuple<Shape extends NamedTupleShape>(\r\n  shape: Shape\r\n): NamedTupleType<Shape>;\r\nexport function tuple<Shape extends { [k: string]: TypeSet | scalarLiterals }>(\r\n  shape: Shape\r\n): $expr_NamedTuple<mapLiteralToTypeSet<Shape>>;\r\nexport function tuple(input: any) {\r\n  if (Array.isArray(input)) {\r\n    // is tuple\r\n    if (input.every((item) => typeKinds.has(item.__kind__))) {\r\n      const typeItems = input as BaseType[];\r\n      const typeName = `tuple<${typeItems\r\n        .map((item) => item.__name__)\r\n        .join(\", \")}>`;\r\n      return makeTupleType(typeName, typeItems);\r\n    }\r\n\r\n    const items = input.map((item) => literalToTypeSet(item));\r\n    const name = `tuple<${items\r\n      .map((item) => item.__element__.__name__)\r\n      .join(\", \")}>`;\r\n    return $expressionify({\r\n      __kind__: ExpressionKind.Tuple,\r\n      __element__: makeTupleType(\r\n        name,\r\n        items.map((item) => item.__element__)\r\n      ),\r\n      __cardinality__: cardutil.multiplyCardinalitiesVariadic(\r\n        items.map((i) => i.__cardinality__) as any\r\n      ),\r\n      __items__: items,\r\n    }) as any;\r\n  } else {\r\n    // is named tuple\r\n    if (Object.values(input).every((el: any) => typeKinds.has(el.__kind__))) {\r\n      const typeName = `tuple<${Object.entries(input)\r\n        .map(([key, val]: [string, any]) => `${key}: ${val.__name__}`)\r\n        .join(\", \")}>`;\r\n      return {\r\n        __kind__: TypeKind.namedtuple,\r\n        __name__: typeName,\r\n        __shape__: input,\r\n      } as any;\r\n    }\r\n\r\n    const exprShape: NamedTupleLiteralShape = {};\r\n    const typeShape: NamedTupleShape = {};\r\n    for (const [key, val] of Object.entries(input)) {\r\n      const typeSet = literalToTypeSet(val);\r\n      exprShape[key] = typeSet;\r\n      typeShape[key] = typeSet.__element__;\r\n    }\r\n    const name = `tuple<${Object.entries(exprShape)\r\n      .map(([key, val]) => `${key}: ${val.__element__.__name__}`)\r\n      .join(\", \")}>`;\r\n    return $expressionify({\r\n      __kind__: ExpressionKind.NamedTuple,\r\n      __element__: {\r\n        __kind__: TypeKind.namedtuple,\r\n        __name__: name,\r\n        __shape__: typeShape,\r\n      } as any,\r\n      __cardinality__: cardutil.multiplyCardinalitiesVariadic(\r\n        Object.values(exprShape).map((val) => val.__cardinality__) as any\r\n      ),\r\n      __shape__: exprShape,\r\n    }) as any;\r\n  }\r\n}\r\n\r\ntype PropertyNamesFromPointers<Pointers extends ObjectTypePointers> = {\r\n  [k in keyof Pointers as Pointers[k] extends PropertyDesc\r\n    ? Pointers[k][\"computed\"] extends true\r\n      ? never\r\n      : k\r\n    : never]: Pointers[k];\r\n};\r\n\r\nexport function $objectTypeToTupleType<Expr extends ObjectTypeExpression>(\r\n  objectType: Expr\r\n): PropertyNamesFromPointers<\r\n  Expr[\"__element__\"][\"__pointers__\"]\r\n> extends infer Pointers\r\n  ? Pointers extends ObjectTypePointers\r\n    ? NamedTupleType<{\r\n        [k in keyof Pointers as k extends \"id\"\r\n          ? never\r\n          : k]: Pointers[k][\"target\"];\r\n      }>\r\n    : never\r\n  : never;\r\nexport function $objectTypeToTupleType<\r\n  Expr extends ObjectTypeExpression,\r\n  Fields extends keyof PropertyNamesFromPointers<\r\n    Expr[\"__element__\"][\"__pointers__\"]\r\n  >\r\n>(\r\n  objectType: Expr,\r\n  includeFields: Fields[]\r\n): NamedTupleType<{\r\n  [k in Fields]: Expr[\"__element__\"][\"__pointers__\"][k] extends PropertyDesc\r\n    ? Expr[\"__element__\"][\"__pointers__\"][k][\"target\"]\r\n    : never;\r\n}>;\r\nexport function $objectTypeToTupleType(...args: any[]): any {\r\n  const [objExpr, fields] = args as [\r\n    ObjectTypeExpression,\r\n    string[] | undefined\r\n  ];\r\n  const shape = Object.entries(objExpr.__element__.__pointers__).reduce(\r\n    (_shape, [key, val]) => {\r\n      if (\r\n        fields?.length\r\n          ? fields.includes(key)\r\n          : key !== \"id\" && val.__kind__ === \"property\" && !val.computed\r\n      ) {\r\n        _shape[key] = val.target;\r\n      }\r\n      return _shape;\r\n    },\r\n    {} as NamedTupleShape\r\n  );\r\n  return tuple(shape);\r\n}\r\n"},{"path":"detached.ts","content":"import { ExpressionKind } from \"edgedb/dist/reflection/index\";\r\nimport type { Expression, TypeSet } from \"./typesystem\";\r\nimport { $expressionify } from \"./path\";\r\n\r\nexport function detached<Expr extends TypeSet>(\r\n  expr: Expr\r\n): $expr_Detached<Expr> {\r\n  return $expressionify({\r\n    __element__: expr.__element__,\r\n    __cardinality__: expr.__cardinality__,\r\n    __expr__: expr,\r\n    __kind__: ExpressionKind.Detached,\r\n  }) as any;\r\n}\r\n\r\nexport type $expr_Detached<Expr extends TypeSet = TypeSet> = Expression<{\r\n  __element__: Expr[\"__element__\"];\r\n  __cardinality__: Expr[\"__cardinality__\"];\r\n  __kind__: ExpressionKind.Detached;\r\n  __expr__: TypeSet;\r\n}>;\r\n"},{"path":"external.ts","content":"import type { TypeSet, setToTsType } from \"./typesystem\";\r\n\r\nexport { literal } from \"./literal\";\r\nexport {} from \"./path\";\r\nexport { set } from \"./set\";\r\nexport { cast } from \"./cast\";\r\nexport {\r\n  ASC,\r\n  DESC,\r\n  EMPTY_FIRST,\r\n  EMPTY_LAST,\r\n  is,\r\n  delete,\r\n  select,\r\n} from \"./select\";\r\nexport { update } from \"./update\";\r\nexport { insert } from \"./insert\";\r\nexport {\r\n  array,\r\n  tuple,\r\n  $objectTypeToTupleType as objectTypeToTupleType,\r\n} from \"./collections\";\r\nexport {} from \"./funcops\";\r\nexport { for } from \"./for\";\r\nexport { alias, with } from \"./with\";\r\nexport { optional, params } from \"./params\";\r\nexport { detached } from \"./detached\";\r\nexport {} from \"./toEdgeQL\";\r\n\r\nexport type $infer<A extends TypeSet> = setToTsType<A>;\r\n"},{"path":"for.ts","content":"import { Cardinality, ExpressionKind } from \"edgedb/dist/reflection/index\";\r\nimport { cardutil } from \"./cardinality\";\r\nimport type { Expression, BaseType, BaseTypeSet } from \"./typesystem\";\r\nimport { $expressionify } from \"./path\";\r\n\r\nexport type $expr_For<\r\n  El extends BaseType = BaseType,\r\n  Card extends Cardinality = Cardinality\r\n  // IterSet extends BaseTypeSet = BaseTypeSet,\r\n  // Expr extends BaseTypeSet = BaseTypeSet\r\n> = Expression<{\r\n  __element__: El;\r\n  __cardinality__: Card;\r\n  __kind__: ExpressionKind.For;\r\n  __iterSet__: BaseTypeSet;\r\n  __forVar__: $expr_ForVar;\r\n  __expr__: BaseTypeSet;\r\n}>;\r\n\r\nexport type $expr_ForVar<Type extends BaseType = BaseType> = Expression<{\r\n  __element__: Type;\r\n  __cardinality__: Cardinality.One;\r\n  __kind__: ExpressionKind.ForVar;\r\n}>;\r\n\r\nfunction _for<IteratorSet extends BaseTypeSet, Expr extends BaseTypeSet>(\r\n  set: IteratorSet,\r\n  expr: (variable: $expr_ForVar<IteratorSet[\"__element__\"]>) => Expr\r\n): $expr_For<\r\n  Expr[\"__element__\"],\r\n  cardutil.multiplyCardinalities<\r\n    IteratorSet[\"__cardinality__\"],\r\n    Expr[\"__cardinality__\"]\r\n  >\r\n> {\r\n  const forVar = $expressionify({\r\n    __kind__: ExpressionKind.ForVar,\r\n    __element__: set.__element__,\r\n    __cardinality__: Cardinality.One,\r\n  }) as $expr_ForVar<IteratorSet[\"__element__\"]>;\r\n\r\n  const returnExpr = expr(forVar);\r\n\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.For,\r\n    __element__: returnExpr.__element__,\r\n    __cardinality__: cardutil.multiplyCardinalities(\r\n      set.__cardinality__,\r\n      returnExpr.__cardinality__\r\n    ),\r\n    __iterSet__: set,\r\n    __expr__: returnExpr,\r\n    __forVar__: forVar,\r\n  }) as any;\r\n}\r\n\r\nexport { _for as for };\r\n"},{"path":"funcops.ts","content":"import {\r\n  Cardinality,\r\n  type introspect,\r\n  TypeKind,\r\n} from \"edgedb/dist/reflection/index\";\r\nimport { cardutil } from \"./cardinality\";\r\nimport { makeType } from \"./hydrate\";\r\nimport type {\r\n  BaseType,\r\n  BaseTypeSet,\r\n  ArrayType,\r\n  ObjectType,\r\n  TypeSet,\r\n  RangeType,\r\n  Expression,\r\n  MultiRangeType,\r\n} from \"./typesystem\";\r\nimport { cast } from \"./cast\";\r\nimport { isImplicitlyCastableTo, literalToTypeSet } from \"./castMaps\";\r\nimport { literal } from \"./literal\";\r\n\r\nimport type {\r\n  ExpressionKind,\r\n  OperatorKind,\r\n} from \"edgedb/dist/reflection/index\";\r\n\r\nexport type $expr_Function<\r\n  // Name extends string = string,\r\n  // Args extends (BaseTypeSet | undefined)[] = (BaseTypeSet | undefined)[],\r\n  // NamedArgs extends {[key: string]: BaseTypeSet} = {\r\n  //   [key: string]: BaseTypeSet;\r\n  // },\r\n  // ReturnType extends BaseTypeSet = BaseTypeSet,\r\n  El extends BaseType = BaseType,\r\n  Card extends Cardinality = Cardinality\r\n> = Expression<{\r\n  __element__: El;\r\n  __cardinality__: Card;\r\n  __kind__: ExpressionKind.Function;\r\n  __name__: string;\r\n  __args__: (BaseTypeSet | undefined)[];\r\n  __namedargs__: { [key: string]: BaseTypeSet };\r\n}>;\r\n\r\nexport type $expr_Operator<\r\n  // Name extends string = string,\r\n  // OpKind extends OperatorKind = OperatorKind,\r\n  // Args extends TypeSet[] = TypeSet[],\r\n  // ReturnType extends TypeSet = TypeSet,\r\n  El extends BaseType = BaseType,\r\n  Card extends Cardinality = Cardinality\r\n> = Expression<{\r\n  __element__: El;\r\n  __cardinality__: Card;\r\n  __kind__: ExpressionKind.Operator;\r\n  __name__: string;\r\n  __opkind__: OperatorKind;\r\n  __args__: TypeSet[];\r\n}>;\r\n\r\ninterface OverloadFuncArgDef {\r\n  typeId: string;\r\n  optional?: boolean;\r\n  setoftype?: boolean;\r\n  variadic?: boolean;\r\n}\r\n\r\ninterface OverloadFuncDef {\r\n  kind?: string;\r\n  args: OverloadFuncArgDef[];\r\n  namedArgs?: { [key: string]: OverloadFuncArgDef };\r\n  returnTypeId: string;\r\n  returnTypemod?: \"SetOfType\" | \"OptionalType\";\r\n  preservesOptionality?: boolean;\r\n}\r\n\r\nfunction mapLiteralToTypeSet(literals: any[]): TypeSet[];\r\nfunction mapLiteralToTypeSet(literals: { [key: string]: any }): {\r\n  [key: string]: TypeSet;\r\n};\r\nfunction mapLiteralToTypeSet(literals: any[] | { [key: string]: any }) {\r\n  if (Array.isArray(literals)) {\r\n    return literals.map((lit) => (lit != null ? literalToTypeSet(lit) : lit));\r\n  }\r\n  const obj: { [key: string]: TypeSet } = {};\r\n  for (const key of Object.keys(literals)) {\r\n    obj[key] =\r\n      literals[key] != null ? literalToTypeSet(literals[key]) : literals[key];\r\n  }\r\n  return obj;\r\n}\r\n\r\nexport function $resolveOverload(\r\n  funcName: string,\r\n  args: any[],\r\n  typeSpec: introspect.Types,\r\n  funcDefs: OverloadFuncDef[]\r\n) {\r\n  const positionalArgs: (TypeSet | undefined)[] = [];\r\n  let namedArgs: { [key: string]: TypeSet } | undefined;\r\n  if (args.length) {\r\n    if (args[0] !== undefined) {\r\n      try {\r\n        positionalArgs.push(literalToTypeSet(args[0]));\r\n      } catch {\r\n        // first arg is not a expr or literal type, so assume named args object\r\n        namedArgs = mapLiteralToTypeSet(args[0] as object);\r\n      }\r\n    } else {\r\n      positionalArgs.push(undefined);\r\n    }\r\n    positionalArgs.push(...mapLiteralToTypeSet(args.slice(1)));\r\n  }\r\n\r\n  for (const def of funcDefs) {\r\n    const resolvedOverload = _tryOverload(\r\n      funcName,\r\n      positionalArgs,\r\n      namedArgs,\r\n      typeSpec,\r\n      def\r\n    );\r\n    if (resolvedOverload !== null) {\r\n      return resolvedOverload;\r\n    }\r\n  }\r\n\r\n  throw new Error(\r\n    `No function overload found for ${\r\n      funcName.includes(\"::\")\r\n        ? `'e.${funcName.split(\"::\").join(\".\")}()'`\r\n        : `operator '${funcName}'`\r\n    } with args: ${[...positionalArgs, ...Object.values(namedArgs ?? {})]\r\n      .filter(Boolean)\r\n      .map(\r\n        (arg) =>\r\n          `Element: ${arg!.__element__.__name__} (${arg!.__cardinality__})`\r\n      )\r\n      .join(\", \")}`\r\n  );\r\n}\r\n\r\nconst ANYTYPE_ARG = Symbol();\r\n\r\nfunction _tryOverload(\r\n  funcName: string,\r\n  args: (BaseTypeSet | undefined)[],\r\n  namedArgs: { [key: string]: BaseTypeSet } | undefined,\r\n  typeSpec: introspect.Types,\r\n  funcDef: OverloadFuncDef\r\n): {\r\n  kind?: string;\r\n  returnType: BaseType;\r\n  cardinality: Cardinality;\r\n  args: BaseTypeSet[];\r\n  namedArgs: { [key: string]: BaseTypeSet };\r\n} | null {\r\n  if (\r\n    (funcDef.namedArgs === undefined && namedArgs !== undefined) ||\r\n    (namedArgs === undefined &&\r\n      funcDef.namedArgs &&\r\n      Object.values(funcDef.namedArgs).some((arg) => !arg.optional))\r\n  ) {\r\n    return null;\r\n  }\r\n\r\n  const lastParamVariadic = funcDef.args[funcDef.args.length - 1]?.variadic;\r\n  if (!lastParamVariadic && args.length > funcDef.args.length) {\r\n    return null;\r\n  }\r\n\r\n  const paramCardinalities: [Cardinality, ...Cardinality[]] = [Cardinality.One];\r\n\r\n  if (namedArgs) {\r\n    for (const [key, value] of Object.entries(namedArgs)) {\r\n      const argDef = funcDef.namedArgs?.[key];\r\n      if (\r\n        !argDef ||\r\n        !compareType(typeSpec, argDef.typeId, value.__element__).match\r\n      ) {\r\n        return null;\r\n      }\r\n\r\n      paramCardinalities.push(\r\n        argDef.setoftype\r\n          ? funcDef.preservesOptionality\r\n            ? cardutil.overrideUpperBound(value.__cardinality__, \"One\")\r\n            : Cardinality.One\r\n          : argDef.optional\r\n          ? cardutil.overrideLowerBound(value.__cardinality__, \"One\")\r\n          : value.__cardinality__\r\n      );\r\n    }\r\n  }\r\n\r\n  let positionalArgs: BaseTypeSet[] = [];\r\n\r\n  let returnAnytype: BaseType | undefined;\r\n  let needsAnytypeReplacement = false;\r\n\r\n  for (let i = 0; i < funcDef.args.length; i++) {\r\n    const argDef = funcDef.args[i]!;\r\n    const arg = args[i];\r\n\r\n    if (arg === undefined) {\r\n      if (!argDef.optional) {\r\n        return null;\r\n      }\r\n\r\n      if (i < args.length) {\r\n        // arg is explicitly undefined, inject empty set\r\n        const argTypeName = typeSpec.get(argDef.typeId).name;\r\n        if (\r\n          argTypeName.includes(\"anytype\") ||\r\n          argTypeName.includes(\"std::anypoint\")\r\n        ) {\r\n          if (!returnAnytype) {\r\n            positionalArgs.push(ANYTYPE_ARG as any);\r\n            needsAnytypeReplacement = true;\r\n          } else {\r\n            positionalArgs.push(cast(returnAnytype, null));\r\n          }\r\n        } else {\r\n          const argType = makeType<any>(typeSpec, argDef.typeId, literal);\r\n          positionalArgs.push(cast(argType, null));\r\n        }\r\n      }\r\n    } else {\r\n      const { match, anytype } = compareType(\r\n        typeSpec,\r\n        argDef.typeId,\r\n        arg.__element__\r\n      );\r\n\r\n      if (!match) {\r\n        return null;\r\n      }\r\n      if (!returnAnytype && anytype) {\r\n        returnAnytype = anytype;\r\n      }\r\n\r\n      positionalArgs.push(\r\n        ...(argDef.variadic ? (args.slice(i) as BaseTypeSet[]) : [arg])\r\n      );\r\n      if (argDef.setoftype) {\r\n        paramCardinalities.push(\r\n          funcDef.preservesOptionality\r\n            ? cardutil.overrideUpperBound(arg.__cardinality__, \"One\")\r\n            : Cardinality.One\r\n        );\r\n      } else {\r\n        const card = argDef.variadic\r\n          ? cardutil.multiplyCardinalitiesVariadic(\r\n              (args.slice(i) as BaseTypeSet[]).map(\r\n                (el) => el.__cardinality__\r\n              ) as [Cardinality, ...Cardinality[]]\r\n            )\r\n          : arg.__cardinality__;\r\n\r\n        paramCardinalities.push(\r\n          argDef.optional ? cardutil.overrideLowerBound(card, \"One\") : card\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  let cardinality: Cardinality;\r\n  if (funcName === \"if_else\") {\r\n    cardinality = cardutil.multiplyCardinalities(\r\n      cardutil.orCardinalities(\r\n        positionalArgs[0]!.__cardinality__,\r\n        positionalArgs[2]!.__cardinality__\r\n      ),\r\n      positionalArgs[1]!.__cardinality__\r\n    );\r\n  } else if (funcName === \"std::assert_exists\") {\r\n    cardinality = cardutil.overrideLowerBound(\r\n      positionalArgs[0]!.__cardinality__,\r\n      \"One\"\r\n    );\r\n  } else if (funcName === \"union\") {\r\n    cardinality = cardutil.mergeCardinalities(\r\n      positionalArgs[0]!.__cardinality__,\r\n      positionalArgs[1]!.__cardinality__\r\n    );\r\n  } else if (funcName === \"??\") {\r\n    cardinality = cardutil.orCardinalities(\r\n      positionalArgs[0]!.__cardinality__,\r\n      positionalArgs[1]!.__cardinality__\r\n    );\r\n  } else if (funcName === \"distinct\") {\r\n    cardinality = positionalArgs[0]!.__cardinality__;\r\n  } else {\r\n    cardinality =\r\n      funcDef.returnTypemod === \"SetOfType\"\r\n        ? Cardinality.Many\r\n        : cardutil.multiplyCardinalitiesVariadic(paramCardinalities);\r\n\r\n    if (\r\n      funcDef.returnTypemod === \"OptionalType\" &&\r\n      !funcDef.preservesOptionality\r\n    ) {\r\n      cardinality = cardutil.overrideLowerBound(cardinality, \"Zero\");\r\n    }\r\n  }\r\n\r\n  if (needsAnytypeReplacement) {\r\n    if (!returnAnytype) {\r\n      throw new Error(`could not resolve anytype for ${funcName}`);\r\n    }\r\n    positionalArgs = positionalArgs.map((arg) =>\r\n      (arg as any) === ANYTYPE_ARG ? cast(returnAnytype!, null) : arg\r\n    );\r\n  }\r\n\r\n  return {\r\n    kind: funcDef.kind,\r\n    returnType: makeType(\r\n      typeSpec,\r\n      funcDef.returnTypeId,\r\n      literal,\r\n      returnAnytype\r\n    ),\r\n    cardinality,\r\n    args: positionalArgs,\r\n    namedArgs: namedArgs ?? {},\r\n  };\r\n}\r\n\r\nconst nameRemapping: { [key: string]: string } = {\r\n  \"std::int16\": \"std::number\",\r\n  \"std::int32\": \"std::number\",\r\n  \"std::int64\": \"std::number\",\r\n  \"std::float32\": \"std::number\",\r\n  \"std::float64\": \"std::number\",\r\n};\r\nconst descendantCache = new Map<string, string[]>();\r\nfunction getDescendantNames(typeSpec: introspect.Types, typeId: string) {\r\n  if (descendantCache.has(typeId)) {\r\n    return descendantCache.get(typeId)!;\r\n  }\r\n  const descendants: string[] = [\r\n    ...new Set(\r\n      [...typeSpec.values()]\r\n        .filter(\r\n          (type) =>\r\n            type.kind === \"scalar\" && type.bases.some(({ id }) => id === typeId)\r\n        )\r\n        .flatMap((type) =>\r\n          type.is_abstract\r\n            ? getDescendantNames(typeSpec, type.id)\r\n            : [nameRemapping[type.name]!, type.name]\r\n        )\r\n    ),\r\n  ];\r\n  descendantCache.set(typeId, descendants);\r\n  return descendants;\r\n}\r\n\r\nfunction compareType(\r\n  typeSpec: introspect.Types,\r\n  typeId: string,\r\n  arg: BaseType\r\n): { match: boolean; anytype?: BaseType } {\r\n  const type = typeSpec.get(typeId);\r\n\r\n  if (type.name === \"anytype\") {\r\n    return { match: true, anytype: arg };\r\n  }\r\n\r\n  if (type.name === \"anyobject\") {\r\n    return { match: arg.__kind__ === TypeKind.object, anytype: arg };\r\n  }\r\n\r\n  if (type.name === \"std::anypoint\") {\r\n    const descendants = getDescendantNames(typeSpec, typeId);\r\n    if (descendants.includes(arg.__name__)) {\r\n      return { match: true, anytype: arg };\r\n    }\r\n  }\r\n\r\n  if (type.name === \"std::anyenum\") {\r\n    return { match: arg.__kind__ === TypeKind.enum };\r\n  }\r\n\r\n  if (type.kind === \"scalar\") {\r\n    arg = (arg as any).__casttype__ ?? arg;\r\n    return {\r\n      match:\r\n        (arg.__kind__ === TypeKind.scalar || arg.__kind__ === TypeKind.enum) &&\r\n        (arg.__name__ === type.name ||\r\n          isImplicitlyCastableTo(arg.__name__, type.name)),\r\n    };\r\n  }\r\n  if (type.kind === \"array\") {\r\n    if (arg.__kind__ === TypeKind.array) {\r\n      return compareType(\r\n        typeSpec,\r\n        type.array_element_id,\r\n        (arg as any as ArrayType).__element__ as BaseType\r\n      );\r\n    }\r\n  }\r\n  if (type.kind === \"range\") {\r\n    if (arg.__kind__ === TypeKind.range) {\r\n      return compareType(\r\n        typeSpec,\r\n        type.range_element_id,\r\n        (arg as any as RangeType).__element__ as BaseType\r\n      );\r\n    }\r\n  }\r\n  if (type.kind === \"multirange\") {\r\n    if (arg.__kind__ === TypeKind.multirange) {\r\n      return compareType(\r\n        typeSpec,\r\n        type.multirange_element_id,\r\n        (arg as any as MultiRangeType).__element__ as BaseType\r\n      );\r\n    }\r\n  }\r\n  if (type.kind === \"object\") {\r\n    if (arg.__kind__ !== TypeKind.object) return { match: false };\r\n\r\n    const objectArg = arg as ObjectType;\r\n    let match = true;\r\n\r\n    // shape comparison\r\n    for (const ptr of type.pointers) {\r\n      if (objectArg.__pointers__[ptr.name]) {\r\n        const argPtr = objectArg.__pointers__[ptr.name]!;\r\n        const ptrTarget = typeSpec.get(ptr.target_id);\r\n        if (\r\n          ptrTarget.name !== argPtr.target.__name__ ||\r\n          ptr.card !== argPtr.cardinality\r\n        ) {\r\n          match = false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      match,\r\n    };\r\n  }\r\n  if (type.kind === \"tuple\") {\r\n    const items =\r\n      arg.__kind__ === TypeKind.tuple\r\n        ? (arg as any).__items__\r\n        : arg.__kind__ === TypeKind.namedtuple\r\n        ? (arg as any).__shape__\r\n        : null;\r\n    if (items) {\r\n      const keys = Object.keys(items);\r\n\r\n      if (keys.length === type.tuple_elements.length) {\r\n        let anytype: BaseType | undefined;\r\n        for (let i = 0; i < keys.length; i++) {\r\n          if (keys[i] !== type.tuple_elements[i]!.name) {\r\n            return { match: false };\r\n          }\r\n          const { match: m, anytype: a } = compareType(\r\n            typeSpec,\r\n            type.tuple_elements[i]!.target_id,\r\n            (items as any)[keys[i]!]\r\n          );\r\n          if (!m) {\r\n            return { match: false };\r\n          }\r\n          if (a) anytype = a;\r\n        }\r\n        return { match: true, anytype };\r\n      }\r\n    }\r\n  }\r\n\r\n  return { match: false };\r\n}\r\n"},{"path":"globals.ts","content":"import { ExpressionKind, Cardinality } from \"edgedb/dist/reflection/index\";\r\nimport type { Expression, BaseType } from \"./typesystem\";\r\nimport { $expressionify } from \"./path\";\r\n\r\nexport function makeGlobal<\r\n  // Name extends string,\r\n  Type extends BaseType,\r\n  Card extends Cardinality\r\n>(name: string, type: Type, card: Card): $expr_Global<Type, Card> {\r\n  return $expressionify({\r\n    __name__: name,\r\n    __element__: type,\r\n    __cardinality__: card,\r\n    __kind__: ExpressionKind.Global,\r\n  });\r\n}\r\n\r\nexport type $expr_Global<\r\n  // Name extends string = string,\r\n  Type extends BaseType = BaseType,\r\n  Card extends Cardinality = Cardinality\r\n> = Expression<{\r\n  __name__: string;\r\n  __element__: Type;\r\n  __cardinality__: Card;\r\n  __kind__: ExpressionKind.Global;\r\n}>;\r\n"},{"path":"group.ts","content":"import type {\r\n  Expression,\r\n  ObjectType,\r\n  ObjectTypeSet,\r\n  TypeSet,\r\n  BaseType,\r\n  $scopify,\r\n  PropertyDesc,\r\n  LinkDesc,\r\n} from \"./typesystem\";\r\nimport {\r\n  Cardinality,\r\n  ExpressionKind,\r\n  TypeKind,\r\n} from \"edgedb/dist/reflection/index\";\r\nimport { makeType } from \"./hydrate\";\r\n\r\nimport { $expressionify, $getScopedExpr } from \"./path\";\r\n// @ts-ignore\r\nimport type { $FreeObjectλShape, $str } from \"./modules/std\";\r\nimport { spec } from \"./__spec__\";\r\nimport { literal } from \"./literal\";\r\nimport { resolveShapeElement } from \"./select\";\r\nimport type {\r\n  normaliseShape,\r\n  // normaliseElement,\r\n  objectTypeToSelectShape,\r\n} from \"./select\";\r\n\r\ntype SingletonSet = Expression<\r\n  TypeSet<BaseType, Cardinality.One | Cardinality.AtMostOne>\r\n>;\r\ntype SimpleGroupElements = { [k: string]: SingletonSet };\r\ntype GroupModifiers = { by: SimpleGroupElements };\r\ntype NestedGroupElements = {\r\n  [k: string]: SingletonSet | GroupingSet;\r\n};\r\n\r\nexport type GroupingSet = {\r\n  __kind__: \"groupingset\";\r\n  __settype__: \"set\" | \"tuple\" | \"rollup\" | \"cube\";\r\n  __elements__: NestedGroupElements;\r\n  __exprs__: [string, SingletonSet][];\r\n};\r\nexport function isGroupingSet(arg: any): arg is GroupingSet {\r\n  return arg.__kind__ === \"groupingset\";\r\n}\r\n\r\n// result is partial to prevent \"X is specified more than once\" errors\r\n// the return type is a lie, this function returns a grouping set\r\n// but it pretends to return a SimpleGroupElements\r\n// to make the static computatation of `key` easier\r\nconst makeGroupingSet =\r\n  (prefix: string) =>\r\n  <T extends SimpleGroupElements>(grps: T): { [k in keyof T]?: T[k] } => {\r\n    const seenKeys = new Map<string, SingletonSet>();\r\n    const unfiltered = Object.entries(grps as NestedGroupElements).flatMap(\r\n      ([k, grp]) =>\r\n        isGroupingSet(grp)\r\n          ? grp.__exprs__\r\n          : ([[k, grp]] as [string, SingletonSet][])\r\n    );\r\n    const filtered = unfiltered.filter(([k, expr]) => {\r\n      if (!seenKeys.has(k)) {\r\n        seenKeys.set(k, expr);\r\n        return true;\r\n      }\r\n\r\n      if (expr !== seenKeys.get(k)) {\r\n        throw new Error(\r\n          `Cannot override pre-existing expression with key \"${k}\"`\r\n        );\r\n      }\r\n\r\n      return false;\r\n    });\r\n\r\n    return {\r\n      [`${Math.round(1000000 * Math.random())}___`]: {\r\n        __kind__: \"groupingset\",\r\n        __settype__: prefix,\r\n        __elements__: grps,\r\n        __exprs__: filtered,\r\n      } as GroupingSet,\r\n    } as any;\r\n  };\r\nconst set = makeGroupingSet(\"set\");\r\nconst tuple = makeGroupingSet(\"tuple\");\r\nconst rollup = makeGroupingSet(\"rollup\");\r\nconst cube = makeGroupingSet(\"cube\");\r\n\r\nconst setFuncs = { set, tuple, rollup, cube };\r\n\r\nexport type $expr_Group<\r\n  Expr extends ObjectTypeSet = ObjectTypeSet,\r\n  Mods extends GroupModifiers = GroupModifiers,\r\n  Shape extends object = { id: true }\r\n> = Expression<{\r\n  __element__: ObjectType<\r\n    \"std::FreeObject\",\r\n    $FreeObjectλShape & {\r\n      // adding free shape elements into __pointers__\r\n      // because objectTypeToSelectShape doesn't allow shapes on computeds\r\n      // and setToTsType can't handle that currently\r\n      grouping: PropertyDesc<$str, Cardinality.Many, false, true, true, false>;\r\n      key: LinkDesc<\r\n        ObjectType<\r\n          \"std::FreeObject\",\r\n          {\r\n            // tslint:disable-next-line\r\n            [k in keyof Mods[\"by\"]]: Mods[\"by\"][k][\"__element__\"] extends ObjectType\r\n              ? never\r\n              : PropertyDesc<\r\n                  Mods[\"by\"][k][\"__element__\"],\r\n                  Cardinality.AtMostOne\r\n                >;\r\n          }\r\n        >,\r\n        Cardinality.One,\r\n        {},\r\n        false,\r\n        true,\r\n        true,\r\n        false\r\n      >;\r\n      elements: LinkDesc<\r\n        Expr[\"__element__\"],\r\n        Cardinality.Many,\r\n        {},\r\n        false,\r\n        true,\r\n        true,\r\n        false\r\n      >;\r\n    },\r\n    {\r\n      // grouping: true;\r\n      // key: {[k in keyof Mods[\"by\"]]: true};\r\n      // elements: normaliseShape<Shape, \"by\">;\r\n      grouping: TypeSet<$str, Cardinality.Many>;\r\n      key: Expression<{\r\n        __element__: ObjectType<\r\n          \"std::FreeObject\",\r\n          $FreeObjectλShape,\r\n          {\r\n            [k in keyof Mods[\"by\"]]: Expression<{\r\n              __element__: Mods[\"by\"][k][\"__element__\"];\r\n              __cardinality__: Cardinality.AtMostOne;\r\n            }>;\r\n          }\r\n        >;\r\n        __cardinality__: Cardinality.One;\r\n      }>;\r\n      elements: Expression<{\r\n        __element__: ObjectType<\r\n          Expr[\"__element__\"][\"__name__\"],\r\n          Expr[\"__element__\"][\"__pointers__\"],\r\n          // Omit<normaliseShape<Shape>, \"by\">\r\n          normaliseShape<Shape, \"by\">\r\n        >;\r\n        __cardinality__: Cardinality.Many;\r\n      }>;\r\n    }\r\n  >;\r\n  __cardinality__: Cardinality.Many;\r\n  // bit of a lie, this is a GroupingSet at runtime\r\n  __modifiers__: Mods;\r\n  __kind__: ExpressionKind.Group;\r\n  __expr__: ObjectTypeSet;\r\n  __scope__: ObjectTypeSet;\r\n}>;\r\n\r\n// type modifierKeys = \"by\";\r\ntype noUndefined<T> = T extends undefined ? never : T;\r\ntype groupFunc = <\r\n  Expr extends ObjectTypeSet,\r\n  // Shape extends GroupModifiers\r\n  // Grps extends SimpleGroupElements,\r\n  Shape extends { by?: SimpleGroupElements } & objectTypeToSelectShape<\r\n    Expr[\"__element__\"]\r\n  >\r\n  // Mods extends GroupModifiers = {by: Shape[\"by\"]}\r\n>(\r\n  expr: Expr,\r\n  getter: (arg: $scopify<Expr[\"__element__\"]>) => Readonly<Shape>\r\n) => $expr_Group<\r\n  Expr,\r\n  { by: noUndefined<Shape[\"by\"]> },\r\n  normaliseShape<Shape, \"by\">\r\n>;\r\n\r\nconst groupFunc: groupFunc = (expr, getter) => {\r\n  const { shape, scope, modifiers } = resolveShape(getter, expr);\r\n  // const scope = $getScopedExpr(expr as any);\r\n  // const rawGroupings = getter(scope);\r\n  const groupSet = tuple(modifiers.by);\r\n\r\n  // only one key in object returned from makeGroupingSet\r\n  const key = Object.keys(groupSet)[0]!;\r\n  const grouping = groupSet[key] as any as GroupingSet;\r\n  const keyShape: any = {};\r\n  const keyPointers: any = {};\r\n  const keyShapeElement: any = {};\r\n\r\n  for (const [k, e] of grouping.__exprs__) {\r\n    keyShape[k] = $expressionify({\r\n      __element__: e.__element__,\r\n      __cardinality__: Cardinality.AtMostOne,\r\n    } as any);\r\n    keyPointers[k] = {\r\n      __kind__: \"property\",\r\n      target: e.__element__,\r\n      cardinality: Cardinality.AtMostOne,\r\n      exclusive: false,\r\n      computed: false,\r\n      readonly: false,\r\n      hasDefault: false,\r\n    } as PropertyDesc;\r\n    keyShapeElement[k] = true;\r\n  }\r\n\r\n  const $FreeObject = makeType(\r\n    spec,\r\n    [...spec.values()].find((s) => s.name === \"std::FreeObject\")!.id,\r\n    literal\r\n  );\r\n\r\n  const str = makeType(\r\n    spec,\r\n    [...spec.values()].find((s) => s.name === \"std::str\")!.id,\r\n    literal\r\n  );\r\n\r\n  return $expressionify({\r\n    __element__: {\r\n      ...$FreeObject,\r\n      __name__: \"std::FreeObject\",\r\n      __pointers__: {\r\n        ...($FreeObject as any).__pointers__,\r\n        __name__: \"std::FreeObject\",\r\n        grouping: {\r\n          __kind__: \"property\",\r\n          target: str,\r\n          cardinality: Cardinality.Many,\r\n          exclusive: false,\r\n          computed: false,\r\n          readonly: false,\r\n          hasDefault: false,\r\n        } as PropertyDesc,\r\n        key: {\r\n          __kind__: \"link\",\r\n          target: {\r\n            ...$FreeObject,\r\n            __name__: \"std::FreeObject\",\r\n            __pointers__: {\r\n              ...($FreeObject as any).__pointers__,\r\n              ...keyPointers,\r\n            },\r\n            __shape__: keyShape,\r\n          },\r\n          properties: {},\r\n          cardinality: Cardinality.One,\r\n          exclusive: false,\r\n          computed: false,\r\n          readonly: false,\r\n          hasDefault: false,\r\n        } as LinkDesc,\r\n\r\n        elements: {\r\n          __kind__: \"link\",\r\n          target: expr.__element__,\r\n          cardinality: Cardinality.Many,\r\n          properties: {},\r\n          exclusive: false,\r\n          computed: false,\r\n          readonly: false,\r\n          hasDefault: false,\r\n        } as LinkDesc,\r\n      },\r\n      __shape__: {\r\n        grouping: $expressionify({\r\n          __element__: str,\r\n          __cardinality__: Cardinality.Many,\r\n        } as any),\r\n        key: $expressionify({\r\n          __element__: {\r\n            ...$FreeObject,\r\n            __shape__: keyShape,\r\n          },\r\n          __cardinality__: Cardinality.One,\r\n        } as any),\r\n        elements: $expressionify({\r\n          __element__: { ...expr.__element__, __shape__: shape } as any,\r\n          __cardinality__: Cardinality.Many,\r\n        } as any),\r\n      },\r\n    },\r\n\r\n    __cardinality__: Cardinality.Many,\r\n    __expr__: expr,\r\n    __modifiers__: { by: grouping },\r\n    __kind__: ExpressionKind.Group,\r\n    __scope__: scope,\r\n  }) as any;\r\n};\r\nObject.assign(groupFunc, setFuncs);\r\n\r\nfunction resolveShape(\r\n  shapeGetter: ((scope: any) => any) | any,\r\n  expr: TypeSet\r\n): { modifiers: { by: SimpleGroupElements }; shape: any; scope: TypeSet } {\r\n  const modifiers: { by: SimpleGroupElements } = {} as any;\r\n  const shape: any = {};\r\n\r\n  // get scoped object if expression is objecttypeset\r\n  const scope = $getScopedExpr(expr as any) as ObjectTypeSet;\r\n\r\n  // execute getter with scope\r\n  const selectShape =\r\n    typeof shapeGetter === \"function\" ? shapeGetter(scope) : shapeGetter;\r\n\r\n  for (const [key, value] of Object.entries(selectShape)) {\r\n    // handle modifier keys\r\n    if (key === \"by\") {\r\n      modifiers[key] = value as any;\r\n    } else {\r\n      // for scalar expressions, scope === expr\r\n      // shape keys are not allowed\r\n      if (expr.__element__.__kind__ !== TypeKind.object) {\r\n        throw new Error(\r\n          `Invalid select shape key '${key}' on scalar expression, ` +\r\n            `only modifiers are allowed (filter, order_by, offset and limit)`\r\n        );\r\n      }\r\n      shape[key] = resolveShapeElement(key, value, scope);\r\n    }\r\n  }\r\n  if (Object.keys(shape).length === 0) {\r\n    shape.id = true;\r\n  }\r\n  if (!modifiers.by) {\r\n    throw new Error(\"Must provide a `by` key in `e.group`\");\r\n  }\r\n  return { shape, modifiers, scope };\r\n}\r\nexport const group: typeof setFuncs & groupFunc = groupFunc as any;\r\n"},{"path":"hydrate.ts","content":"import type { $ } from \"edgedb\";\r\n\r\nimport type {\r\n  BaseType,\r\n  ObjectType,\r\n  ObjectTypePointers,\r\n  LinkDesc,\r\n  PropertyDesc,\r\n  TupleType,\r\n} from \"./typesystem\";\r\n\r\nimport { util, TypeKind } from \"edgedb/dist/reflection/index\";\r\nimport type { typeutil } from \"edgedb/dist/reflection/index\";\r\n\r\nconst typeCache = new Map<string, BaseType>();\r\n\r\nconst _linkProps = Symbol();\r\n\r\nfunction applySpec(\r\n  spec: $.introspect.Types,\r\n  type: $.introspect.ObjectType,\r\n  shape: any,\r\n  seen: Set<string>,\r\n  literal: any\r\n): void {\r\n  const allPointers = [\r\n    ...type.pointers,\r\n    ...type.backlinks,\r\n    ...type.backlink_stubs,\r\n  ];\r\n  for (const ptr of allPointers) {\r\n    if (seen.has(ptr.name)) {\r\n      continue;\r\n    }\r\n    seen.add(ptr.name);\r\n\r\n    if (ptr.kind === \"link\") {\r\n      shape[ptr.name] = {\r\n        __kind__: \"link\",\r\n        cardinality: ptr.card,\r\n        exclusive: ptr.is_exclusive,\r\n        computed: ptr.is_computed,\r\n        readonly: ptr.is_readonly,\r\n      } as LinkDesc;\r\n      util.defineGetter(shape[ptr.name], \"target\", () =>\r\n        makeType(spec, ptr.target_id, literal)\r\n      );\r\n      util.defineGetter(shape[ptr.name], \"properties\", () => {\r\n        if (!shape[ptr.name][_linkProps]) {\r\n          const linkProperties: { [k: string]: any } = (shape[ptr.name][\r\n            _linkProps\r\n          ] = {});\r\n          for (const linkProp of ptr.pointers ?? []) {\r\n            // We only support \"link properties\" in EdgeDB, currently.\r\n            if (linkProp.kind !== \"property\") {\r\n              return;\r\n            }\r\n            // No use for them reflected, at the moment.\r\n            if (linkProp.name === \"source\" || linkProp.name === \"target\") {\r\n              return;\r\n            }\r\n\r\n            const linkPropObject: any = {\r\n              __kind__: \"property\",\r\n            };\r\n            linkPropObject.cardinality = linkProp.card;\r\n            util.defineGetter(linkPropObject, \"target\", () => {\r\n              return makeType(spec, linkProp.target_id, literal);\r\n            });\r\n            linkProperties[linkProp.name] = linkPropObject;\r\n          }\r\n        }\r\n        return shape[ptr.name][_linkProps];\r\n      });\r\n    } else if (ptr.kind === \"property\") {\r\n      shape[ptr.name] = {\r\n        __kind__: \"property\",\r\n        cardinality: ptr.card,\r\n        exclusive: ptr.is_exclusive,\r\n        computed: ptr.is_computed,\r\n        readonly: ptr.is_readonly,\r\n      } as PropertyDesc;\r\n      util.defineGetter(shape[ptr.name], \"target\", () =>\r\n        makeType(spec, ptr.target_id, literal)\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nexport function makeType<T extends BaseType>(\r\n  spec: $.introspect.Types,\r\n  id: string,\r\n  // should be (type: any, val: any) => any, but causes\r\n  // 'Type instantiation is excessively deep and possibly infinite' error\r\n  // in typescript 4.5\r\n  literal: any,\r\n  anytype?: BaseType\r\n): T {\r\n  const type = spec.get(id);\r\n\r\n  if (type.name === \"anytype\" || type.name === \"std::anypoint\") {\r\n    if (anytype) return anytype as unknown as T;\r\n    throw new Error(\"anytype not provided\");\r\n  }\r\n\r\n  if (typeCache.has(id)) {\r\n    return typeCache.get(id) as T;\r\n  }\r\n\r\n  const obj: any = {};\r\n  obj.__name__ = type.name;\r\n\r\n  if (type.kind === \"object\") {\r\n    obj.__kind__ = TypeKind.object;\r\n\r\n    const pointers: any = {};\r\n    const seen = new Set<string>();\r\n    applySpec(spec, type, pointers, seen, literal);\r\n    const ancestors = [...type.bases];\r\n    for (const anc of ancestors) {\r\n      const ancType = spec.get(anc.id);\r\n      if (ancType.kind === \"object\" || ancType.kind === \"scalar\") {\r\n        ancestors.push(...ancType.bases);\r\n      }\r\n      if (ancType.kind !== \"object\") {\r\n        throw new Error(`Not an object: ${id}`);\r\n      }\r\n      applySpec(spec, ancType, pointers, seen, literal);\r\n    }\r\n\r\n    obj.__pointers__ = pointers;\r\n    obj.__shape__ = {};\r\n    typeCache.set(id, obj);\r\n    return obj;\r\n  } else if (type.kind === \"scalar\") {\r\n    const scalarObj = type.is_abstract\r\n      ? {}\r\n      : type.enum_values\r\n      ? {}\r\n      : // : type.name === \"std::json\"\r\n        // ? (((val: any) => {\r\n        //     return literal(scalarObj, JSON.stringify(val));\r\n        //   }) as any)\r\n        (((val: any) => {\r\n          return literal(scalarObj, val);\r\n        }) as any);\r\n\r\n    if (type.enum_values) {\r\n      scalarObj.__kind__ = TypeKind.enum;\r\n      scalarObj.__values__ = type.enum_values;\r\n      for (const val of type.enum_values) {\r\n        Object.defineProperty(scalarObj, val, {\r\n          get() {\r\n            return literal(scalarObj, val);\r\n          },\r\n        });\r\n      }\r\n    } else {\r\n      scalarObj.__kind__ = TypeKind.scalar;\r\n    }\r\n    scalarObj.__name__ = type.name;\r\n\r\n    if (type.cast_type) {\r\n      scalarObj.__casttype__ = makeType(spec, type.cast_type, literal);\r\n    }\r\n    typeCache.set(id, scalarObj);\r\n    return scalarObj;\r\n  } else if (type.kind === \"array\") {\r\n    obj.__kind__ = TypeKind.array;\r\n    util.defineGetter(obj, \"__element__\", () => {\r\n      return makeType(spec, type.array_element_id, literal, anytype);\r\n    });\r\n    util.defineGetter(obj, \"__name__\", () => {\r\n      return `array<${obj.__element__.__name__}>`;\r\n    });\r\n    return obj;\r\n  } else if (type.kind === \"tuple\") {\r\n    if (type.tuple_elements[0]!.name === \"0\") {\r\n      // unnamed tuple\r\n      obj.__kind__ = TypeKind.tuple;\r\n\r\n      util.defineGetter(obj, \"__items__\", () => {\r\n        return type.tuple_elements.map((el) =>\r\n          makeType(spec, el.target_id, literal, anytype)\r\n        ) as any;\r\n      });\r\n      util.defineGetter(obj, \"__name__\", () => {\r\n        return `tuple<${obj.__items__\r\n          .map((item: any) => item.__name__)\r\n          .join(\", \")}>`;\r\n      });\r\n      return obj;\r\n    } else {\r\n      // named tuple\r\n      obj.__kind__ = TypeKind.namedtuple;\r\n\r\n      util.defineGetter(obj, \"__shape__\", () => {\r\n        const shape: any = {};\r\n        for (const el of type.tuple_elements) {\r\n          shape[el.name] = makeType(spec, el.target_id, literal, anytype);\r\n        }\r\n        return shape;\r\n      });\r\n      util.defineGetter(obj, \"__name__\", () => {\r\n        return `tuple<${Object.entries(obj.__shape__)\r\n          .map(([key, val]: [string, any]) => `${key}: ${val.__name__}`)\r\n          .join(\", \")}>`;\r\n      });\r\n      return obj;\r\n    }\r\n  } else if (type.kind === \"range\") {\r\n    obj.__kind__ = TypeKind.range;\r\n    util.defineGetter(obj, \"__element__\", () => {\r\n      return makeType(spec, type.range_element_id, literal, anytype);\r\n    });\r\n    util.defineGetter(obj, \"__name__\", () => {\r\n      return `range<${obj.__element__.__name__}>`;\r\n    });\r\n    return obj;\r\n  } else if (type.kind === \"multirange\") {\r\n    obj.__kind__ = TypeKind.multirange;\r\n    util.defineGetter(obj, \"__element__\", () => {\r\n      return makeType(spec, type.multirange_element_id, literal, anytype);\r\n    });\r\n    util.defineGetter(obj, \"__name__\", () => {\r\n      return `multirange<${obj.__element__.__name__}>`;\r\n    });\r\n    return obj;\r\n  } else {\r\n    throw new Error(`Invalid type: ${JSON.stringify(type, null, 2)}`);\r\n  }\r\n}\r\nexport type mergeObjectShapes<\r\n  A extends ObjectTypePointers,\r\n  B extends ObjectTypePointers\r\n> = typeutil.flatten<{\r\n  [k in keyof A & keyof B]: A[k] extends B[k] // possible performance issue?\r\n    ? B[k] extends A[k]\r\n      ? A[k]\r\n      : never\r\n    : never;\r\n}>;\r\n\r\nexport type mergeObjectTypes<\r\n  A extends ObjectType | undefined,\r\n  B extends ObjectType | undefined\r\n> = A extends ObjectType\r\n  ? B extends ObjectType\r\n    ? ObjectType<\r\n        `${A[\"__name__\"]} UNION ${B[\"__name__\"]}`,\r\n        mergeObjectShapes<A[\"__pointers__\"], B[\"__pointers__\"]>,\r\n        null\r\n      >\r\n    : A\r\n  : B extends ObjectType\r\n  ? B\r\n  : undefined;\r\n\r\nexport function $mergeObjectTypes<A extends ObjectType, B extends ObjectType>(\r\n  a: A,\r\n  b: B\r\n): mergeObjectTypes<A, B> {\r\n  const obj = {\r\n    __kind__: TypeKind.object,\r\n    __name__: `${a.__name__} UNION ${b.__name__}`,\r\n    get __pointers__() {\r\n      const merged: any = {};\r\n      for (const [akey, aitem] of Object.entries(a.__pointers__)) {\r\n        if (!b.__pointers__[akey]) continue;\r\n\r\n        const bitem = b.__pointers__[akey]!;\r\n        if (aitem.cardinality !== bitem.cardinality) continue;\r\n        // names must reflect full type\r\n        if (aitem.target.__name__ !== bitem.target.__name__) continue;\r\n        merged[akey] = aitem;\r\n      }\r\n      return merged;\r\n    },\r\n    __shape__: {},\r\n  };\r\n  return obj as any;\r\n}\r\n\r\nexport function $mergeTupleTypes<A extends TupleType, B extends TupleType>(\r\n  a: A,\r\n  b: B\r\n): TupleType {\r\n  if (a.__items__.length !== b.__items__.length) {\r\n    throw new Error(\"Incompatible tuple types; lengths differ.\");\r\n  }\r\n  return {} as TupleType;\r\n}\r\n"},{"path":"insert.ts","content":"import {\r\n  Cardinality,\r\n  ExpressionKind,\r\n  type typeutil,\r\n  TypeKind,\r\n} from \"edgedb/dist/reflection/index\";\r\nimport type {\r\n  Expression,\r\n  LinkDesc,\r\n  ObjectTypeSet,\r\n  ObjectTypePointers,\r\n  PropertyDesc,\r\n  stripBacklinks,\r\n  stripNonInsertables,\r\n  $scopify,\r\n  stripSet,\r\n  TypeSet,\r\n  ObjectType,\r\n  NamedTupleType,\r\n} from \"./typesystem\";\r\nimport type { pointerToAssignmentExpression } from \"./casting\";\r\nimport { $expressionify, $getScopedExpr } from \"./path\";\r\nimport { cast } from \"./cast\";\r\nimport { set } from \"./set\";\r\nimport { literal } from \"./literal\";\r\nimport { $getTypeByName } from \"./literal\";\r\nimport type { $expr_PathNode } from \"./path\";\r\nimport type { $Object } from \"./modules/std\";\r\nimport type { scalarLiterals } from \"./castMaps\";\r\n\r\nexport type pointerIsOptional<T extends PropertyDesc | LinkDesc> =\r\n  T[\"cardinality\"] extends\r\n    | Cardinality.Many\r\n    | Cardinality.Empty\r\n    | Cardinality.AtMostOne\r\n    ? true\r\n    : false;\r\n\r\nexport type InsertShape<El extends ObjectType> = typeutil.flatten<\r\n  RawInsertShape<El>\r\n>;\r\n\r\nexport type RawInsertShape<El extends ObjectType> =\r\n  // short-circuit infinitely deep\r\n  ObjectType extends El\r\n    ? never\r\n    : typeutil.stripNever<\r\n        stripNonInsertables<stripBacklinks<El[\"__pointers__\"]>>\r\n      > extends infer Shape\r\n    ? Shape extends ObjectTypePointers\r\n      ? typeutil.addQuestionMarks<{\r\n          [k in keyof Shape]:\r\n            | pointerToAssignmentExpression<Shape[k]>\r\n            | (pointerIsOptional<Shape[k]> extends true\r\n                ? undefined | null\r\n                : never)\r\n            | (Shape[k][\"hasDefault\"] extends true ? undefined : never);\r\n        }> & { [k in `@${string}`]: TypeSet | scalarLiterals }\r\n      : never\r\n    : never;\r\n\r\ninterface UnlessConflict {\r\n  on: TypeSet | null;\r\n  else?: TypeSet;\r\n}\r\n\r\ntype InsertBaseExpression<Root extends TypeSet = TypeSet> = {\r\n  __kind__: ExpressionKind.Insert;\r\n  __element__: Root[\"__element__\"];\r\n  __cardinality__: Cardinality.One;\r\n  __expr__: stripSet<Root>;\r\n  __shape__: any;\r\n};\r\nexport type $expr_Insert<\r\n  // Root extends $expr_PathNode = $expr_PathNode\r\n  El extends ObjectType = ObjectType\r\n  // Conflict = UnlessConflict | null\r\n  // Shape extends InsertShape<Root> = any\r\n> = Expression<{\r\n  __kind__: ExpressionKind.Insert;\r\n  __element__: El;\r\n  __cardinality__: Cardinality.One;\r\n  __expr__: $expr_PathNode;\r\n  __shape__: InsertShape<El>;\r\n\r\n  unlessConflict(): $expr_InsertUnlessConflict<\r\n    El,\r\n    // Expression<{\r\n    //   __kind__: ExpressionKind.Insert;\r\n    //   __element__: El;\r\n    //   __cardinality__: Cardinality.One;\r\n    //   __expr__: $expr_PathNode;\r\n    //   __shape__: InsertShape<El>;\r\n    // }>,\r\n    { on: null }\r\n  >;\r\n  unlessConflict<Conflict extends UnlessConflict>(\r\n    conflictGetter: (scope: $scopify<El>) => Conflict\r\n  ): $expr_InsertUnlessConflict<\r\n    El,\r\n    // Expression<{\r\n    //   __kind__: ExpressionKind.Insert;\r\n    //   __element__: El;\r\n    //   __cardinality__: Cardinality.One;\r\n    //   __expr__: $expr_PathNode;\r\n    //   __shape__: InsertShape<El>;\r\n    // }>,\r\n    Conflict\r\n  >;\r\n}>;\r\n\r\nexport type $expr_InsertUnlessConflict<\r\n  El extends ObjectType = ObjectType,\r\n  // Root extends InsertBaseExpression = InsertBaseExpression,\r\n  Conflict extends UnlessConflict = UnlessConflict\r\n> = Expression<{\r\n  __kind__: ExpressionKind.InsertUnlessConflict;\r\n  __element__: Conflict[\"else\"] extends TypeSet\r\n    ? Conflict[\"else\"][\"__element__\"][\"__name__\"] extends El[\"__name__\"]\r\n      ? El\r\n      : $Object\r\n    : El;\r\n  __cardinality__: Conflict[\"else\"] extends TypeSet\r\n    ? Conflict[\"else\"][\"__cardinality__\"]\r\n    : Cardinality.AtMostOne;\r\n  __expr__: InsertBaseExpression;\r\n  __conflict__: Conflict;\r\n}>;\r\n\r\nfunction unlessConflict(\r\n  this: $expr_Insert,\r\n  conflictGetter?: (scope: TypeSet) => UnlessConflict\r\n) {\r\n  const expr: any = {\r\n    __kind__: ExpressionKind.InsertUnlessConflict,\r\n    __element__: this.__element__,\r\n    __cardinality__: Cardinality.AtMostOne,\r\n    __expr__: this,\r\n    // __conflict__: Conflict;\r\n  };\r\n\r\n  if (!conflictGetter) {\r\n    expr.__conflict__ = { on: null };\r\n    return $expressionify(expr);\r\n  } else {\r\n    const scopedExpr = $getScopedExpr(this.__expr__);\r\n    const conflict = conflictGetter(scopedExpr);\r\n    expr.__conflict__ = conflict;\r\n    if (conflict.else) {\r\n      expr.__cardinality__ = conflict.else.__cardinality__;\r\n      if (this.__element__.__name__ !== conflict.else.__element__.__name__) {\r\n        expr.__element__ = $getTypeByName(\"std::Object\");\r\n      }\r\n    }\r\n    return $expressionify(expr);\r\n  }\r\n}\r\n\r\nexport function $insertify(\r\n  expr: Omit<$expr_Insert, \"unlessConflict\">\r\n): $expr_Insert {\r\n  (expr as any).unlessConflict = unlessConflict.bind(expr as any);\r\n  return expr as any;\r\n}\r\n\r\nexport function $normaliseInsertShape(\r\n  root: ObjectTypeSet,\r\n  shape: { [key: string]: any },\r\n  isUpdate: boolean = false\r\n): { [key: string]: TypeSet | { \"+=\": TypeSet } | { \"-=\": TypeSet } } {\r\n  const newShape: {\r\n    [key: string]: TypeSet | { \"+=\": TypeSet } | { \"-=\": TypeSet };\r\n  } = {};\r\n\r\n  const _shape: [string, any][] =\r\n    shape.__element__?.__kind__ === TypeKind.namedtuple\r\n      ? Object.keys((shape.__element__ as NamedTupleType).__shape__).map(\r\n          (key) => [key, shape[key]]\r\n        )\r\n      : Object.entries(shape);\r\n  for (const [key, _val] of _shape) {\r\n    let val = _val;\r\n    let setModify: string | null = null;\r\n    if (isUpdate && _val != null && typeof _val === \"object\") {\r\n      const valKeys = Object.keys(_val);\r\n      if (\r\n        valKeys.length === 1 &&\r\n        (valKeys[0] === \"+=\" || valKeys[0] === \"-=\")\r\n      ) {\r\n        val = _val[valKeys[0]];\r\n        setModify = valKeys[0];\r\n      }\r\n    }\r\n\r\n    const pointer = root.__element__.__pointers__[key];\r\n\r\n    // no pointer, not a link property\r\n    const isLinkProp = key[0] === \"@\";\r\n    if (!pointer && !isLinkProp) {\r\n      throw new Error(\r\n        `Could not find property pointer for ${\r\n          isUpdate ? \"update\" : \"insert\"\r\n        } shape key: '${key}'`\r\n      );\r\n    }\r\n\r\n    // skip undefined vals\r\n    if (val === undefined) continue;\r\n\r\n    // is val is expression, assign to newShape\r\n    if (val?.__kind__) {\r\n      // ranges can contain null values, so if the type is 'std::number'\r\n      // we need to set the type to the exact number type of the pointer\r\n      // so null casts are correct\r\n      if (\r\n        val.__kind__ === ExpressionKind.Literal &&\r\n        val.__element__.__kind__ === TypeKind.range &&\r\n        val.__element__.__element__.__name__ === \"std::number\"\r\n      ) {\r\n        newShape[key] = (literal as any)(pointer?.target, val.__value__);\r\n      } else {\r\n        newShape[key] = _val;\r\n      }\r\n      continue;\r\n    }\r\n\r\n    // handle link props\r\n    // after this guard, pointer definitely is defined\r\n    if (isLinkProp) {\r\n      throw new Error(\r\n        `Cannot assign plain data to link property '${key}'. Provide an expression instead.`\r\n      );\r\n    }\r\n    // Workaround to tell TypeScript pointer definitely is defined\r\n    if (!pointer) {\r\n      throw new Error(\r\n        \"Code will never reach here, but TypeScript cannot determine\"\r\n      );\r\n    }\r\n\r\n    // trying to assign plain data to a link\r\n    if (pointer.__kind__ !== \"property\" && val !== null) {\r\n      throw new Error(\r\n        `Must provide subquery when assigning to link '${key}' in ${\r\n          isUpdate ? \"update\" : \"insert\"\r\n        } query.`\r\n      );\r\n    }\r\n\r\n    // val is plain data\r\n    // key corresponds to pointer or starts with \"@\"\r\n    const isMulti =\r\n      pointer.cardinality === Cardinality.AtLeastOne ||\r\n      pointer.cardinality === Cardinality.Many;\r\n    if (pointer.__kind__ === \"property\") {\r\n      if (pointer.target.__name__ === \"std::json\") {\r\n      }\r\n    }\r\n\r\n    const wrappedVal =\r\n      val === null\r\n        ? cast(pointer.target, null)\r\n        : isMulti && Array.isArray(val)\r\n        ? val.length === 0\r\n          ? cast(pointer.target, null)\r\n          : set(...val.map((v) => (literal as any)(pointer.target, v)))\r\n        : (literal as any)(pointer.target, val);\r\n    newShape[key] = setModify\r\n      ? ({ [setModify]: wrappedVal } as any)\r\n      : wrappedVal;\r\n  }\r\n  return newShape;\r\n}\r\n\r\nexport function insert<Root extends $expr_PathNode>(\r\n  root: Root,\r\n  shape: InsertShape<Root[\"__element__\"]>\r\n): $expr_Insert<Root[\"__element__\"]> {\r\n  if (typeof shape !== \"object\") {\r\n    throw new Error(\r\n      `invalid insert shape.${\r\n        typeof shape === \"function\"\r\n          ? \" Hint: Insert shape is expected to be an object, \" +\r\n            \"not a function returning a shape object.\"\r\n          : \"\"\r\n      }`\r\n    );\r\n  }\r\n  const expr: any = {\r\n    __kind__: ExpressionKind.Insert,\r\n    __element__: root.__element__,\r\n    __cardinality__: Cardinality.One,\r\n    __expr__: root,\r\n    __shape__: $normaliseInsertShape(root, shape),\r\n  };\r\n  (expr as any).unlessConflict = unlessConflict.bind(expr);\r\n  return $expressionify($insertify(expr)) as any;\r\n}\r\n"},{"path":"json.ts","content":"import { ExpressionKind, TypeKind } from \"edgedb/dist/reflection/index\";\r\nimport type { ParamType } from \"./typesystem\";\r\nimport { encodeB64 } from \"edgedb/dist/primitives/buffer\";\r\nimport type { $expr_WithParams } from \"./params\";\r\n\r\nfunction jsonStringify(type: ParamType, val: any): string {\r\n  if (type.__kind__ === TypeKind.array) {\r\n    if (Array.isArray(val)) {\r\n      return `[${val\r\n        .map((item) => jsonStringify(type.__element__, item))\r\n        .join()}]`;\r\n    }\r\n    throw new Error(`Param with array type is not an array`);\r\n  }\r\n  if (type.__kind__ === TypeKind.tuple) {\r\n    if (!Array.isArray(val)) {\r\n      throw new Error(`Param with tuple type is not an array`);\r\n    }\r\n    if (val.length !== type.__items__.length) {\r\n      throw new Error(\r\n        `Param with tuple type has incorrect number of items. Got ${val.length} expected ${type.__items__.length}`\r\n      );\r\n    }\r\n    return `[${val\r\n      .map((item, i) => jsonStringify(type.__items__[i]!, item))\r\n      .join()}]`;\r\n  }\r\n  if (type.__kind__ === TypeKind.namedtuple) {\r\n    if (typeof val !== \"object\") {\r\n      throw new Error(`Param with named tuple type is not an object`);\r\n    }\r\n    if (Object.keys(val).length !== Object.keys(type.__shape__).length) {\r\n      throw new Error(\r\n        `Param with named tuple type has incorrect number of items. Got ${\r\n          Object.keys(val).length\r\n        } expected ${Object.keys(type.__shape__).length}`\r\n      );\r\n    }\r\n    return `{${Object.entries(val)\r\n      .map(([key, item]) => {\r\n        if (!type.__shape__[key]) {\r\n          throw new Error(\r\n            `Unexpected key in named tuple param: ${key}, expected keys: ${Object.keys(\r\n              type.__shape__\r\n            ).join()}`\r\n          );\r\n        }\r\n        return `\"${key}\": ${jsonStringify(type.__shape__[key]!, item)}`;\r\n      })\r\n      .join()}}`;\r\n  }\r\n  if (\r\n    type.__kind__ === TypeKind.scalar\r\n    // || type.__kind__ === TypeKind.castonlyscalar\r\n  ) {\r\n    switch (type.__name__) {\r\n      case \"std::bigint\":\r\n        return val.toString();\r\n      case \"std::json\":\r\n        return JSON.stringify(val);\r\n      case \"std::bytes\":\r\n        return `\"${encodeB64(val)}\"`;\r\n      case \"cfg::memory\":\r\n        return `\"${val.toString()}\"`;\r\n      default:\r\n        return JSON.stringify(val);\r\n    }\r\n  }\r\n  if (type.__kind__ === TypeKind.enum) {\r\n    return JSON.stringify(val);\r\n  }\r\n  throw new Error(`Invalid param type: ${(type as any).__kind__}`);\r\n}\r\n\r\nexport function jsonifyComplexParams(expr: any, _args: any) {\r\n  if (_args && expr.__kind__ === ExpressionKind.WithParams) {\r\n    const args = { ..._args };\r\n    for (const param of (expr as $expr_WithParams).__params__) {\r\n      if (param.__isComplex__) {\r\n        args[param.__name__] = jsonStringify(\r\n          param.__element__ as any,\r\n          args[param.__name__]\r\n        );\r\n      }\r\n    }\r\n\r\n    return args;\r\n  }\r\n  return _args;\r\n}\r\n"},{"path":"literal.ts","content":"import type {\r\n  Expression,\r\n  BaseType,\r\n  BaseTypeToTsType,\r\n  ScalarType,\r\n} from \"./typesystem\";\r\n\r\n// import {\r\n//   Cardinality,\r\n//   ExpressionKind,\r\n//   BaseType,\r\n//   BaseTypeToTsType,\r\n//   makeType,\r\n//   ScalarType\r\n// } from \"edgedb/dist/reflection/index\";\r\n\r\n// import type {$expr_Literal} from \"./literal\";\r\nimport { $expressionify } from \"./path\";\r\nimport { spec } from \"./__spec__\";\r\nimport { Cardinality, ExpressionKind } from \"edgedb/dist/reflection/index\";\r\nimport { makeType } from \"./hydrate\";\r\n\r\nexport type $expr_Literal<Type extends BaseType = BaseType> = Expression<{\r\n  __element__: Type;\r\n  __cardinality__: Cardinality.One;\r\n  __kind__: ExpressionKind.Literal;\r\n  __value__: any;\r\n}>;\r\n\r\nexport function literal<T extends BaseType>(\r\n  type: T,\r\n  value: BaseTypeToTsType<T>\r\n): $expr_Literal<T> {\r\n  return $expressionify({\r\n    __element__: type,\r\n    __cardinality__: Cardinality.One,\r\n    __kind__: ExpressionKind.Literal,\r\n    __value__: value,\r\n  }) as any;\r\n}\r\n\r\nexport const $nameMapping = new Map<string, string>([\r\n  ...([...spec.values()].map((type) => [type.name, type.id]) as any),\r\n  [\"std::number\", \"00000000-0000-0000-0000-0000000001ff\"],\r\n]);\r\n\r\nexport function $getType(id: string): (val: any) => $expr_Literal<ScalarType> {\r\n  return makeType(spec, id, literal) as any;\r\n}\r\n\r\nexport function $getTypeByName(\r\n  name: string\r\n): (val: any) => $expr_Literal<ScalarType> {\r\n  return makeType(spec, $nameMapping.get(name)!, literal) as any;\r\n}\r\n"},{"path":"operators.ts","content":"export declare function op(...args: any[]): any;\r\n"},{"path":"params.ts","content":"import type { Executor } from \"edgedb\";\r\nimport {\r\n  ExpressionKind,\r\n  Cardinality,\r\n  TypeKind,\r\n} from \"edgedb/dist/reflection/index\";\r\nimport type {\r\n  Expression,\r\n  ParamType,\r\n  setToTsType,\r\n  TypeSet,\r\n  BaseTypeToTsType,\r\n} from \"./typesystem\";\r\nimport { $expressionify } from \"./path\";\r\nimport { runnableExpressionKinds } from \"./query\";\r\nimport { select } from \"./select\";\r\nimport { complexParamKinds } from \"./__spec__\";\r\n\r\ntype Param = ParamType | $expr_OptionalParam;\r\n\r\ntype ParamsRecord = Record<string, Param>;\r\n\r\nexport type $expr_OptionalParam<Type extends ParamType = ParamType> = {\r\n  __kind__: ExpressionKind.OptionalParam;\r\n  __type__: Type;\r\n};\r\n\r\nexport function optional<Type extends ParamType>(\r\n  type: Type\r\n): $expr_OptionalParam<Type> {\r\n  return {\r\n    __kind__: ExpressionKind.OptionalParam,\r\n    __type__: type,\r\n  };\r\n}\r\n\r\nexport type QueryableWithParamsExpression<\r\n  Set extends TypeSet = TypeSet,\r\n  Params extends ParamsRecord = Record<string, never>\r\n> = Expression<Set, false> & {\r\n  run(\r\n    cxn: Executor,\r\n    args: paramsToParamArgs<Params>\r\n  ): Promise<setToTsType<Set>>;\r\n  runJSON(cxn: Executor, args: paramsToParamArgs<Params>): Promise<string>;\r\n};\r\n\r\nexport type $expr_WithParams<\r\n  Params extends ParamsRecord = Record<string, never>,\r\n  Expr extends TypeSet = TypeSet\r\n> = QueryableWithParamsExpression<\r\n  {\r\n    __kind__: ExpressionKind.WithParams;\r\n    __element__: Expr[\"__element__\"];\r\n    __cardinality__: Expr[\"__cardinality__\"];\r\n    __expr__: Expr;\r\n    __params__: $expr_Param[];\r\n  },\r\n  Params\r\n>;\r\n\r\ntype paramsToParamArgs<Params extends ParamsRecord> = {\r\n  [key in keyof Params as Params[key] extends ParamType\r\n    ? key\r\n    : never]: Params[key] extends ParamType\r\n    ? Readonly<BaseTypeToTsType<Params[key], true>>\r\n    : never;\r\n} & {\r\n  [key in keyof Params as Params[key] extends $expr_OptionalParam\r\n    ? key\r\n    : never]?: Params[key] extends $expr_OptionalParam\r\n    ? Readonly<BaseTypeToTsType<Params[key][\"__type__\"], true> | null>\r\n    : never;\r\n};\r\n\r\nexport type $expr_Param<\r\n  Name extends string | number | symbol = string,\r\n  Type extends ParamType = ParamType,\r\n  Optional extends boolean = boolean\r\n> = Expression<{\r\n  __kind__: ExpressionKind.Param;\r\n  __element__: Type;\r\n  __cardinality__: Optional extends true\r\n    ? Cardinality.AtMostOne\r\n    : Cardinality.One;\r\n  __name__: Name;\r\n  __isComplex__: boolean;\r\n}>;\r\n\r\ntype paramsToParamExprs<Params extends ParamsRecord> = {\r\n  [key in keyof Params]: Params[key] extends $expr_OptionalParam\r\n    ? $expr_Param<key, Params[key][\"__type__\"], true>\r\n    : Params[key] extends ParamType\r\n    ? $expr_Param<key, Params[key], false>\r\n    : never;\r\n};\r\n\r\nexport function params<\r\n  Params extends ParamsRecord = Record<string, never>,\r\n  Expr extends Expression = Expression\r\n>(\r\n  paramsDef: Params,\r\n  expr: (params: paramsToParamExprs<Params>) => Expr\r\n): $expr_WithParams<Params, Expr> {\r\n  const paramExprs: { [key: string]: $expr_Param } = {};\r\n  for (const [key, param] of Object.entries(paramsDef)) {\r\n    const paramType =\r\n      param.__kind__ === ExpressionKind.OptionalParam ? param.__type__ : param;\r\n    const isComplex =\r\n      complexParamKinds.has(paramType.__kind__) ||\r\n      (paramType.__kind__ === TypeKind.array &&\r\n        complexParamKinds.has(paramType.__element__.__kind__));\r\n    paramExprs[key] = $expressionify({\r\n      __kind__: ExpressionKind.Param,\r\n      __element__: paramType,\r\n      __cardinality__:\r\n        param.__kind__ === ExpressionKind.OptionalParam\r\n          ? Cardinality.AtMostOne\r\n          : Cardinality.One,\r\n      __name__: key,\r\n      __isComplex__: isComplex,\r\n    }) as any;\r\n  }\r\n\r\n  let returnExpr = expr(paramExprs as any);\r\n\r\n  if (!runnableExpressionKinds.has((returnExpr as any).__kind__)) {\r\n    returnExpr = select(returnExpr) as any;\r\n  }\r\n\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.WithParams,\r\n    __element__: returnExpr.__element__,\r\n    __cardinality__: returnExpr.__cardinality__,\r\n    __expr__: returnExpr,\r\n    __params__: Object.values(paramExprs),\r\n  }) as any;\r\n}\r\n"},{"path":"path.ts","content":"import {\r\n  // cardutil,\r\n  // ObjectTypeSet,\r\n  // TypeSet,\r\n  // Expression,\r\n  ExpressionKind,\r\n  TypeKind,\r\n  // LinkDesc,\r\n  // PropertyDesc,\r\n  Cardinality,\r\n  // BaseType,\r\n  type typeutil,\r\n} from \"edgedb/dist/reflection/index\";\r\n\r\nimport { cardutil } from \"./cardinality\";\r\n\r\nimport { literalToTypeSet } from \"./castMaps\";\r\nimport { $arrayLikeIndexify, $tuplePathify } from \"./collections\";\r\nimport { $toEdgeQL } from \"./toEdgeQL\";\r\nimport { $queryFunc, $queryFuncJSON } from \"./query\";\r\n\r\nimport type {\r\n  BaseType,\r\n  Expression,\r\n  LinkDesc,\r\n  ObjectType,\r\n  ObjectTypePointers,\r\n  ObjectTypeSet,\r\n  PropertyDesc,\r\n  PropertyShape,\r\n  TypeSet,\r\n} from \"./typesystem\";\r\n// import {typeutil} from \"./typeutil\";\r\n// import {cardutil} from \"./cardinality\";\r\n\r\n// get the set representing the result of a path traversal\r\n// including cardinality merging\r\ntype getChildOfObjectTypeSet<\r\n  Root extends ObjectTypeSet,\r\n  ChildKey extends keyof Root[\"__element__\"][\"__pointers__\"]\r\n> = TypeSet<\r\n  Root[\"__element__\"][\"__pointers__\"][ChildKey][\"target\"],\r\n  cardutil.multiplyCardinalities<\r\n    Root[\"__cardinality__\"],\r\n    Root[\"__element__\"][\"__pointers__\"][ChildKey][\"cardinality\"]\r\n  >\r\n>;\r\n\r\n// path parent must be object expression\r\nexport interface PathParent<\r\n  Parent extends ObjectTypeSet = ObjectTypeSet,\r\n  L extends string = string\r\n> {\r\n  type: Parent;\r\n  linkName: L;\r\n}\r\n\r\nexport type $linkPropify<Root extends ObjectTypeSet> = Root extends {\r\n  __parent__: PathParent<infer Parent, infer L>;\r\n}\r\n  ? // tslint:disable-next-line\r\n    Parent[\"__element__\"][\"__pointers__\"][L] extends LinkDesc<\r\n      any,\r\n      any,\r\n      infer LinkProps,\r\n      any,\r\n      any,\r\n      any,\r\n      any\r\n    >\r\n    ? pathifyLinkProps<LinkProps, Root, PathParent<Parent, L>>\r\n    : {}\r\n  : unknown;\r\n\r\nexport type $pathify<\r\n  Root extends TypeSet\r\n  // Parent extends PathParent | null = null\r\n> = Root extends ObjectTypeSet\r\n  ? ObjectTypeSet extends Root\r\n    ? {} // Root is literally ObjectTypeSet\r\n    : pathifyPointers<Root> & pathifyShape<Root> & $linkPropify<Root>\r\n  : {}; // pathify does nothing on non-object types\r\n\r\nexport type pathifyPointers<\r\n  Root extends ObjectTypeSet\r\n  // Parent extends PathParent | null = null\r\n> = ObjectTypePointers extends Root[\"__element__\"][\"__pointers__\"]\r\n  ? unknown\r\n  : {\r\n      // & string required to avoid typeError on linkName\r\n      [k in keyof Root[\"__element__\"][\"__pointers__\"] &\r\n        string]: Root[\"__element__\"][\"__pointers__\"][k] extends PropertyDesc\r\n        ? $expr_PathLeaf<\r\n            getChildOfObjectTypeSet<Root, k>,\r\n            { type: anonymizeObjectTypeSet<Root>; linkName: k }\r\n            // Root[\"__element__\"][\"__pointers__\"][k][\"exclusive\"]\r\n          >\r\n        : Root[\"__element__\"][\"__pointers__\"][k] extends LinkDesc\r\n        ? getChildOfObjectTypeSet<Root, k> extends ObjectTypeSet\r\n          ? $expr_PathNode<\r\n              getChildOfObjectTypeSet<Root, k>,\r\n              { type: anonymizeObjectTypeSet<Root>; linkName: k }\r\n              // Root[\"__element__\"][\"__pointers__\"][k][\"exclusive\"]\r\n            >\r\n          : unknown\r\n        : unknown;\r\n    };\r\n\r\ntype anonymizeObjectTypeSet<T extends ObjectTypeSet> = typeutil.flatten<{\r\n  __element__: ObjectType<\r\n    T[\"__element__\"][\"__name__\"],\r\n    T[\"__element__\"][\"__pointers__\"],\r\n    { id: true }\r\n  >;\r\n  __cardinality__: T[\"__cardinality__\"];\r\n}>;\r\n\r\nexport type pathifyShape<\r\n  Root extends ObjectTypeSet,\r\n  Shape extends { [k: string]: any } = Root[\"__element__\"][\"__shape__\"]\r\n> = string extends keyof Shape\r\n  ? {}\r\n  : {\r\n      [k in keyof Shape & string]: Shape[k] extends ObjectTypeSet\r\n        ? $expr_PathNode<\r\n            TypeSet<\r\n              Shape[k][\"__element__\"],\r\n              cardutil.multiplyCardinalities<\r\n                Root[\"__cardinality__\"],\r\n                Shape[k][\"__cardinality__\"]\r\n              >\r\n            >,\r\n            { type: Root; linkName: k }\r\n            // false\r\n          >\r\n        : Shape[k] extends TypeSet\r\n        ? $expr_PathLeaf<\r\n            TypeSet<\r\n              Shape[k][\"__element__\"],\r\n              cardutil.multiplyCardinalities<\r\n                Root[\"__cardinality__\"],\r\n                Shape[k][\"__cardinality__\"]\r\n              >\r\n            >,\r\n            { type: Root; linkName: k }\r\n            // false\r\n          >\r\n        : // must be unknown (not never) to avoid overriding\r\n          // a pointer with the same key\r\n          unknown;\r\n    };\r\n\r\ntype pathifyLinkProps<\r\n  Props extends PropertyShape,\r\n  Root extends ObjectTypeSet,\r\n  Parent extends PathParent | null = null\r\n> = {\r\n  [k in keyof Props & string]: Props[k] extends PropertyDesc\r\n    ? $expr_PathLeaf<\r\n        TypeSet<\r\n          Props[k][\"target\"],\r\n          cardutil.multiplyCardinalities<\r\n            Root[\"__cardinality__\"],\r\n            Props[k][\"cardinality\"]\r\n          >\r\n        >,\r\n        { type: $expr_PathNode<Root, Parent>; linkName: k }\r\n        // {type: $expr_PathNode<Root>; linkName: k},\r\n        // Props[k][\"exclusive\"]\r\n      >\r\n    : unknown;\r\n};\r\n\r\nexport type getPropsShape<T extends ObjectType> = typeutil.flatten<\r\n  typeutil.stripNever<{\r\n    [k in keyof T[\"__pointers__\"]]: T[\"__pointers__\"][k][\"__kind__\"] extends \"property\"\r\n      ? true\r\n      : never;\r\n  }>\r\n>;\r\n\r\nexport type $expr_PathNode<\r\n  Root extends ObjectTypeSet = ObjectTypeSet,\r\n  Parent extends PathParent | null = PathParent | null\r\n  // Exclusive extends boolean = boolean\r\n> = Expression<{\r\n  __element__: Root[\"__element__\"];\r\n  __cardinality__: Root[\"__cardinality__\"];\r\n  __parent__: Parent;\r\n  __kind__: ExpressionKind.PathNode;\r\n  // __exclusive__: boolean;\r\n  \"*\": getPropsShape<Root[\"__element__\"]>;\r\n}>;\r\n\r\nexport type $expr_TypeIntersection<\r\n  Card extends Cardinality = Cardinality,\r\n  Intersection extends ObjectType = ObjectType\r\n> = Expression<{\r\n  __element__: Intersection;\r\n  __cardinality__: Card;\r\n  __kind__: ExpressionKind.TypeIntersection;\r\n  __expr__: TypeSet;\r\n}>;\r\n\r\nexport type $expr_PathLeaf<\r\n  Root extends TypeSet = TypeSet,\r\n  Parent extends PathParent = PathParent\r\n  // Exclusive extends boolean = boolean\r\n> = Expression<{\r\n  __element__: Root[\"__element__\"];\r\n  __cardinality__: Root[\"__cardinality__\"];\r\n  __kind__: ExpressionKind.PathLeaf;\r\n  __parent__: Parent;\r\n  // __exclusive__: boolean;\r\n}>;\r\n\r\nexport type ExpressionRoot = {\r\n  __element__: BaseType;\r\n  __cardinality__: Cardinality;\r\n  __kind__: ExpressionKind;\r\n};\r\n\r\nfunction PathLeaf<\r\n  Root extends TypeSet,\r\n  Parent extends PathParent,\r\n  Exclusive extends boolean = boolean\r\n>(\r\n  root: Root,\r\n  parent: Parent,\r\n  exclusive: Exclusive,\r\n  scopeRoot: TypeSet | null = null\r\n): $expr_PathLeaf<Root, Parent> {\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.PathLeaf,\r\n    __element__: root.__element__,\r\n    __cardinality__: root.__cardinality__,\r\n    __parent__: parent,\r\n    // __exclusive__: exclusive,\r\n    __scopeRoot__: scopeRoot,\r\n  }) as any;\r\n}\r\n\r\nfunction getStarShapeFromPointers(pointers: ObjectTypePointers) {\r\n  const shape: any = {};\r\n  for (const [key, ptr] of Object.entries(pointers)) {\r\n    if (ptr.__kind__ === \"property\") {\r\n      shape[key] = true;\r\n    }\r\n  }\r\n  return shape;\r\n}\r\n\r\nfunction PathNode<\r\n  Root extends ObjectTypeSet,\r\n  Parent extends PathParent | null\r\n  // Exclusive extends boolean = boolean\r\n>(\r\n  root: Root,\r\n  parent: Parent,\r\n  // exclusive: boolean,\r\n  scopeRoot: TypeSet | null = null\r\n): $expr_PathNode<Root, Parent> {\r\n  const obj = {\r\n    __kind__: ExpressionKind.PathNode,\r\n    __element__: root.__element__,\r\n    __cardinality__: root.__cardinality__,\r\n    __parent__: parent,\r\n    // __exclusive__: exclusive,\r\n    __scopeRoot__: scopeRoot,\r\n  };\r\n\r\n  Object.defineProperty(obj, \"*\", {\r\n    writable: false,\r\n    value: getStarShapeFromPointers(obj.__element__.__pointers__),\r\n  });\r\n  return $expressionify(obj) as any;\r\n}\r\n\r\nconst _pathCache = Symbol();\r\nconst _pointers = Symbol();\r\n\r\nconst pathifyProxyHandlers: ProxyHandler<any> = {\r\n  get(target: any, prop: string | symbol, proxy: any) {\r\n    const ptr = target[_pointers][prop as any] as LinkDesc | PropertyDesc;\r\n    if (ptr) {\r\n      return (\r\n        target[_pathCache][prop] ??\r\n        (target[_pathCache][prop] = (\r\n          (ptr.__kind__ === \"property\" ? PathLeaf : PathNode) as any\r\n        )(\r\n          {\r\n            __element__: ptr.target,\r\n            __cardinality__: cardutil.multiplyCardinalities(\r\n              target.__cardinality__,\r\n              ptr.cardinality\r\n            ),\r\n          },\r\n          {\r\n            linkName: prop,\r\n            type: proxy,\r\n          },\r\n          ptr.exclusive ?? false,\r\n          target.__scopeRoot__ ?? (scopeRoots.has(proxy) ? proxy : null)\r\n        ))\r\n      );\r\n    }\r\n    return target[prop];\r\n  },\r\n};\r\n\r\nexport function $pathify<Root extends TypeSet, Parent extends PathParent>(\r\n  _root: Root\r\n): $pathify<Root> {\r\n  if (_root.__element__.__kind__ !== TypeKind.object) {\r\n    return _root as any;\r\n  }\r\n\r\n  const root: $expr_PathNode<ObjectTypeSet> = _root as any;\r\n\r\n  let pointers = {\r\n    ...root.__element__.__pointers__,\r\n  };\r\n\r\n  if (root.__parent__) {\r\n    const { type, linkName } = root.__parent__;\r\n    const parentPointer = type.__element__.__pointers__[linkName];\r\n    if (parentPointer?.__kind__ === \"link\") {\r\n      pointers = { ...pointers, ...parentPointer.properties };\r\n    }\r\n  }\r\n\r\n  for (const [key, val] of Object.entries(\r\n    root.__element__.__shape__ || { id: true }\r\n  )) {\r\n    if (pointers[key]) continue;\r\n    const valType: BaseType = (val as any)?.__element__;\r\n    if (!valType) continue;\r\n\r\n    pointers[key] = {\r\n      __kind__: valType.__kind__ === TypeKind.object ? \"link\" : \"property\",\r\n      properties: {},\r\n      target: (val as any).__element__,\r\n      cardinality: (val as any).__cardinality__,\r\n      exclusive: false,\r\n      computed: true,\r\n      readonly: true,\r\n      hasDefault: false,\r\n    };\r\n  }\r\n\r\n  (root as any)[_pointers] = pointers;\r\n  (root as any)[_pathCache] = {};\r\n\r\n  return new Proxy(root, pathifyProxyHandlers);\r\n}\r\n\r\nfunction isFunc(this: any, expr: ObjectTypeSet) {\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.TypeIntersection,\r\n    __cardinality__: this.__cardinality__,\r\n    __element__: {\r\n      ...expr.__element__,\r\n      __shape__: { id: true },\r\n    } as any,\r\n    __expr__: this,\r\n  });\r\n}\r\n\r\nexport function $assert_single(expr: Expression) {\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.Function,\r\n    __element__: expr.__element__,\r\n    __cardinality__: cardutil.overrideUpperBound(expr.__cardinality__, \"One\"),\r\n    __name__: \"std::assert_single\",\r\n    __args__: [expr],\r\n    __namedargs__: {},\r\n  }) as any;\r\n}\r\n\r\nconst jsonDestructureProxyHandlers: ProxyHandler<ExpressionRoot> = {\r\n  get(target: ExpressionRoot, prop: string | symbol, proxy: any) {\r\n    if (typeof prop === \"string\" && !(prop in target)) {\r\n      const parsedProp = Number.isInteger(Number(prop)) ? Number(prop) : prop;\r\n      return jsonDestructure.call(proxy, parsedProp);\r\n    }\r\n    return (target as any)[prop];\r\n  },\r\n};\r\n\r\nfunction jsonDestructure(this: ExpressionRoot, path: any) {\r\n  const pathTypeSet = literalToTypeSet(path);\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.Operator,\r\n    __element__: this.__element__,\r\n    __cardinality__: cardutil.multiplyCardinalities(\r\n      this.__cardinality__,\r\n      pathTypeSet.__cardinality__\r\n    ),\r\n    __name__: \"[]\",\r\n    __opkind__: \"Infix\",\r\n    __args__: [this, pathTypeSet],\r\n  }) as any;\r\n}\r\n\r\nexport function $jsonDestructure(_expr: ExpressionRoot) {\r\n  if (\r\n    _expr.__element__.__kind__ === TypeKind.scalar &&\r\n    _expr.__element__.__name__ === \"std::json\"\r\n  ) {\r\n    const expr = new Proxy(_expr, jsonDestructureProxyHandlers) as any;\r\n\r\n    expr.destructure = jsonDestructure.bind(expr);\r\n\r\n    return expr;\r\n  }\r\n\r\n  return _expr;\r\n}\r\n\r\nexport function $expressionify<T extends ExpressionRoot>(\r\n  _expr: T\r\n): Expression<T> {\r\n  const expr: Expression = $pathify(\r\n    $jsonDestructure($arrayLikeIndexify($tuplePathify(_expr)))\r\n  ) as any;\r\n\r\n  expr.run = $queryFunc.bind(expr) as any;\r\n  expr.runJSON = $queryFuncJSON.bind(expr) as any;\r\n  expr.is = isFunc.bind(expr) as any;\r\n  expr.toEdgeQL = $toEdgeQL.bind(expr);\r\n  expr.assert_single = () => $assert_single(expr) as any;\r\n\r\n  return Object.freeze(expr) as any;\r\n}\r\n\r\nconst scopedExprCache = new WeakMap<ExpressionRoot, Expression>();\r\nconst scopeRoots = new WeakSet<Expression>();\r\n\r\nexport function $getScopedExpr<T extends ExpressionRoot>(\r\n  expr: T,\r\n  existingScopes?: Set<Expression>\r\n): Expression<T> {\r\n  let scopedExpr = scopedExprCache.get(expr);\r\n  if (!scopedExpr || existingScopes?.has(scopedExpr)) {\r\n    // free objects should not be scopified\r\n    const isFreeObject =\r\n      expr.__cardinality__ === Cardinality.One &&\r\n      expr.__element__.__name__ === \"std::FreeObject\";\r\n\r\n    scopedExpr = isFreeObject\r\n      ? (expr as any as Expression<TypeSet<BaseType, Cardinality>>)\r\n      : $expressionify({\r\n          ...expr,\r\n          __cardinality__: Cardinality.One,\r\n          __scopedFrom__: expr,\r\n          ...(expr.__element__.__kind__ === TypeKind.object\r\n            ? {\r\n                \"*\": getStarShapeFromPointers(\r\n                  (expr.__element__ as ObjectType).__pointers__\r\n                ),\r\n              }\r\n            : {}),\r\n        });\r\n    scopeRoots.add(scopedExpr);\r\n    const uncached = !scopedExpr;\r\n    if (uncached) {\r\n      scopedExprCache.set(expr, scopedExpr);\r\n    }\r\n  }\r\n  existingScopes?.add(scopedExpr);\r\n  return scopedExpr as any;\r\n}\r\n\r\nexport { PathLeaf as $PathLeaf, PathNode as $PathNode };\r\n"},{"path":"query.ts","content":"import type * as edgedb from \"edgedb\";\r\nimport { Cardinality, ExpressionKind } from \"edgedb/dist/reflection/index\";\r\nimport { jsonifyComplexParams } from \"./json\";\r\nimport { select } from \"./select\";\r\n\r\nexport const runnableExpressionKinds = new Set([\r\n  ExpressionKind.Select,\r\n  ExpressionKind.Update,\r\n  ExpressionKind.Insert,\r\n  ExpressionKind.InsertUnlessConflict,\r\n  ExpressionKind.Delete,\r\n  ExpressionKind.Group,\r\n  ExpressionKind.For,\r\n  ExpressionKind.With,\r\n  ExpressionKind.WithParams,\r\n]);\r\n\r\nconst wrappedExprCache = new WeakMap();\r\n\r\nexport async function $queryFunc(this: any, cxn: edgedb.Executor, args: any) {\r\n  const expr = runnableExpressionKinds.has(this.__kind__)\r\n    ? this\r\n    : wrappedExprCache.get(this) ??\r\n      wrappedExprCache.set(this, select(this)).get(this);\r\n\r\n  const _args = jsonifyComplexParams(expr, args);\r\n\r\n  const query = expr.toEdgeQL();\r\n\r\n  if (\r\n    expr.__cardinality__ === Cardinality.One ||\r\n    expr.__cardinality__ === Cardinality.AtMostOne ||\r\n    expr.__cardinality__ === Cardinality.Empty\r\n  ) {\r\n    return cxn.querySingle(query, _args);\r\n  } else {\r\n    return cxn.query(query, _args);\r\n  }\r\n}\r\n\r\nexport async function $queryFuncJSON(\r\n  this: any,\r\n  cxn: edgedb.Executor,\r\n  args: any\r\n) {\r\n  const expr = runnableExpressionKinds.has(this.__kind__)\r\n    ? this\r\n    : wrappedExprCache.get(this) ??\r\n      wrappedExprCache.set(this, select(this)).get(this);\r\n  const _args = jsonifyComplexParams(expr, args);\r\n\r\n  if (\r\n    expr.__cardinality__ === Cardinality.One ||\r\n    expr.__cardinality__ === Cardinality.AtMostOne\r\n  ) {\r\n    return cxn.querySingleJSON(expr.toEdgeQL(), _args);\r\n  } else {\r\n    return cxn.queryJSON(expr.toEdgeQL(), _args);\r\n  }\r\n}\r\n"},{"path":"range.ts","content":"import type { LocalDate, LocalDateTime, Duration } from \"edgedb\";\r\nimport { Range } from \"edgedb\";\r\nimport { TypeKind, ExpressionKind } from \"edgedb/dist/reflection/index\";\r\n\r\nimport type { cardutil } from \"./cardinality\";\r\nimport type {\r\n  RangeType,\r\n  getPrimitiveBaseType,\r\n  TypeSet,\r\n  BaseType,\r\n} from \"./typesystem\";\r\nimport type { $expr_Literal } from \"./literal\";\r\n\r\nimport type {\r\n  $number,\r\n  $decimal,\r\n  $datetime,\r\n  $duration,\r\n  $bool,\r\n} from \"./modules/std\";\r\nimport type { $local_date, $local_datetime } from \"./modules/cal\";\r\nimport type { literalToScalarType, orScalarLiteral } from \"./castMaps\";\r\nimport { literalToTypeSet } from \"./castMaps\";\r\nimport { spec } from \"./__spec__\";\r\nimport { literal, $nameMapping } from \"./literal\";\r\nimport { type $expr_Function, $resolveOverload } from \"./funcops\";\r\nimport { $expressionify } from \"./path\";\r\n\r\ntype $anypoint =\r\n  | $number\r\n  | $local_date\r\n  | $decimal\r\n  | $datetime\r\n  | $local_datetime\r\n  | $duration;\r\n\r\nfunction range<Element extends $anypoint>(element: Element): RangeType<Element>;\r\nfunction range<T extends number | Date | LocalDate | LocalDateTime | Duration>(\r\n  val: Range<T>\r\n): $expr_Literal<RangeType<getPrimitiveBaseType<literalToScalarType<T>>>>;\r\nfunction range<\r\n  NamedArgs extends {\r\n    inc_lower?: orScalarLiteral<TypeSet<$bool>>;\r\n    inc_upper?: orScalarLiteral<TypeSet<$bool>>;\r\n    empty?: orScalarLiteral<TypeSet<$bool>>;\r\n  },\r\n  P1 extends orScalarLiteral<TypeSet<$anypoint>> | undefined,\r\n  P2 extends\r\n    | orScalarLiteral<\r\n        TypeSet<\r\n          BaseType extends literalToScalarType<P1>\r\n            ? $anypoint\r\n            : getPrimitiveBaseType<literalToScalarType<P1>>\r\n        >\r\n      >\r\n    | undefined\r\n>(\r\n  namedArgs: NamedArgs,\r\n  lower?: P1,\r\n  upper?: P2\r\n): $expr_Function<\r\n  // \"std::range\",\r\n  // mapLiteralToTypeSet<[P1, P2]>,\r\n  // mapLiteralToTypeSet<NamedArgs>,\r\n  // TypeSet<\r\n  RangeType<\r\n    literalToScalarType<P1> extends $anypoint\r\n      ? literalToScalarType<P1>\r\n      : literalToScalarType<P2> extends $anypoint\r\n      ? literalToScalarType<P2>\r\n      : $anypoint\r\n  >,\r\n  cardutil.multiplyCardinalities<\r\n    cardutil.multiplyCardinalities<\r\n      cardutil.multiplyCardinalities<\r\n        cardutil.multiplyCardinalities<\r\n          cardutil.optionalParamCardinality<P1>,\r\n          cardutil.optionalParamCardinality<P2>\r\n        >,\r\n        cardutil.optionalParamCardinality<NamedArgs[\"inc_lower\"]>\r\n      >,\r\n      cardutil.optionalParamCardinality<NamedArgs[\"inc_upper\"]>\r\n    >,\r\n    cardutil.optionalParamCardinality<NamedArgs[\"empty\"]>\r\n  >\r\n  // >\r\n>;\r\nfunction range<\r\n  P1 extends orScalarLiteral<TypeSet<$anypoint>> | undefined,\r\n  P2 extends\r\n    | orScalarLiteral<\r\n        TypeSet<\r\n          BaseType extends literalToScalarType<P1>\r\n            ? $anypoint\r\n            : getPrimitiveBaseType<literalToScalarType<P1>>\r\n        >\r\n      >\r\n    | undefined\r\n>(\r\n  lower?: P1,\r\n  upper?: P2\r\n): $expr_Function<\r\n  // \"std::range\",\r\n  // mapLiteralToTypeSet<[P1, P2]>,\r\n  // {},\r\n  // TypeSet<\r\n  RangeType<\r\n    literalToScalarType<P1> extends $anypoint\r\n      ? literalToScalarType<P1>\r\n      : literalToScalarType<P2> extends $anypoint\r\n      ? literalToScalarType<P2>\r\n      : $anypoint\r\n  >,\r\n  cardutil.multiplyCardinalities<\r\n    cardutil.optionalParamCardinality<P1>,\r\n    cardutil.optionalParamCardinality<P2>\r\n  >\r\n  // >\r\n>;\r\nfunction range(...args: any[]): any {\r\n  if (args.length === 1) {\r\n    const arg = args[0];\r\n    if (arg instanceof Range) {\r\n      if (arg.lower === null && arg.upper === null) {\r\n        throw new Error(\r\n          `Can't create literal expression from unbounded range. Try this instead:\\n\\n  e.range(e.cast(e.int64, e.set()), e.cast(e.int64, e.set()))`\r\n        );\r\n      }\r\n      if (arg.isEmpty) {\r\n        throw new Error(`Can't create literal expression from empty range.`);\r\n      }\r\n      return literal(\r\n        range(literalToTypeSet(arg.lower ?? arg.upper).__element__ as any),\r\n        arg\r\n      );\r\n    }\r\n    if (arg.__kind__ && !arg.__element__) {\r\n      return {\r\n        __kind__: TypeKind.range,\r\n        __name__: `range<${arg.__name__}>`,\r\n        __element__: arg,\r\n      } as any;\r\n    }\r\n  }\r\n  const {\r\n    returnType,\r\n    cardinality,\r\n    args: positionalArgs,\r\n    namedArgs,\r\n  } = $resolveOverload(\"std::range\", args, spec, [\r\n    {\r\n      args: [\r\n        {\r\n          typeId: $nameMapping.get(\"std::anypoint\")!,\r\n          optional: true,\r\n          setoftype: false,\r\n          variadic: false,\r\n        },\r\n        {\r\n          typeId: $nameMapping.get(\"std::anypoint\")!,\r\n          optional: true,\r\n          setoftype: false,\r\n          variadic: false,\r\n        },\r\n      ],\r\n      namedArgs: {\r\n        inc_lower: {\r\n          typeId: $nameMapping.get(\"std::bool\")!,\r\n          optional: true,\r\n          setoftype: false,\r\n          variadic: false,\r\n        },\r\n        inc_upper: {\r\n          typeId: $nameMapping.get(\"std::bool\")!,\r\n          optional: true,\r\n          setoftype: false,\r\n          variadic: false,\r\n        },\r\n        empty: {\r\n          typeId: $nameMapping.get(\"std::bool\")!,\r\n          optional: true,\r\n          setoftype: false,\r\n          variadic: false,\r\n        },\r\n      },\r\n      returnTypeId: $nameMapping.get(\"range<std::anypoint>\")!,\r\n    },\r\n  ]);\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.Function,\r\n    __element__: returnType,\r\n    __cardinality__: cardinality,\r\n    __name__: \"std::range\",\r\n    __args__: positionalArgs,\r\n    __namedargs__: namedArgs,\r\n  }) as any;\r\n}\r\n\r\nexport { range as $range };\r\n"},{"path":"reflection.ts","content":"export * from \"edgedb/dist/reflection/index\";\r\nexport * from \"./typesystem\";\r\nexport { cardutil } from \"./cardinality\";\r\nexport type { $expr_Literal } from \"./literal\";\r\nexport type { $expr_PathNode, $expr_PathLeaf } from \"./path\";\r\nexport type { $expr_Function, $expr_Operator } from \"./funcops\";\r\nexport { makeType, $mergeObjectTypes } from \"./hydrate\";\r\nexport type { mergeObjectTypes } from \"./hydrate\";\r\n"},{"path":"select.ts","content":"import {\r\n  LocalDateTime,\r\n  LocalDate,\r\n  LocalTime,\r\n  Duration,\r\n  RelativeDuration,\r\n  ConfigMemory,\r\n  DateDuration,\r\n} from \"edgedb\";\r\nimport type { $bool, $number } from \"./modules/std\";\r\n\r\nimport {\r\n  Cardinality,\r\n  ExpressionKind,\r\n  TypeKind,\r\n  OperatorKind,\r\n} from \"edgedb/dist/reflection/index\";\r\nimport { makeType } from \"./hydrate\";\r\n\r\nimport { cardutil } from \"./cardinality\";\r\nimport type {\r\n  $expr_PolyShapeElement,\r\n  $scopify,\r\n  Expression,\r\n  LinkDesc,\r\n  ObjectType,\r\n  ObjectTypeExpression,\r\n  ObjectTypePointers,\r\n  ObjectTypeSet,\r\n  PrimitiveTypeSet,\r\n  PropertyDesc,\r\n  ScalarType,\r\n  stripSet,\r\n  TypeSet,\r\n  BaseType,\r\n  ExclusiveTuple,\r\n  orLiteralValue,\r\n} from \"./typesystem\";\r\n\r\nimport {\r\n  $assert_single,\r\n  type $expr_PathLeaf,\r\n  type $expr_PathNode,\r\n  type $linkPropify,\r\n  type ExpressionRoot,\r\n} from \"./path\";\r\nimport type { anonymizeObject } from \"./casting\";\r\nimport { $expressionify, $getScopedExpr } from \"./path\";\r\nimport { $getTypeByName, literal } from \"./literal\";\r\nimport { spec } from \"./__spec__\";\r\nimport {\r\n  type scalarLiterals,\r\n  type literalToScalarType,\r\n  literalToTypeSet,\r\n} from \"./castMaps\";\r\nimport type { $expr_Operator } from \"./funcops\";\r\n\r\nexport const ASC: \"ASC\" = \"ASC\";\r\nexport const DESC: \"DESC\" = \"DESC\";\r\nexport const EMPTY_FIRST: \"EMPTY FIRST\" = \"EMPTY FIRST\";\r\nexport const EMPTY_LAST: \"EMPTY LAST\" = \"EMPTY LAST\";\r\nexport type OrderByDirection = \"ASC\" | \"DESC\";\r\nexport type OrderByEmpty = \"EMPTY FIRST\" | \"EMPTY LAST\";\r\n\r\nexport type OrderByExpr = TypeSet<ScalarType | ObjectType, Cardinality>;\r\nexport type OrderByObjExpr = {\r\n  expression: OrderByExpr;\r\n  direction?: OrderByDirection;\r\n  empty?: OrderByEmpty;\r\n};\r\n\r\nexport type OrderByExpression =\r\n  | OrderByExpr\r\n  | OrderByObjExpr\r\n  | [OrderByExpr | OrderByObjExpr, ...(OrderByExpr | OrderByObjExpr)[]];\r\n\r\nexport type OffsetExpression = TypeSet<\r\n  $number,\r\n  Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne\r\n>;\r\n\r\nexport type SelectFilterExpression = TypeSet<$bool, Cardinality>;\r\nexport type LimitOffsetExpression = TypeSet<\r\n  $number,\r\n  Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne\r\n>;\r\nexport type LimitExpression = TypeSet<\r\n  $number,\r\n  Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne\r\n>;\r\n\r\nexport type SelectModifierNames =\r\n  | \"filter\"\r\n  | \"filter_single\"\r\n  | \"order_by\"\r\n  | \"offset\"\r\n  | \"limit\";\r\n\r\ntype filterSingle<T extends TypeSet> = T extends ObjectTypeSet\r\n  ? TypeSet<anonymizeObject<T[\"__element__\"]>, T[\"__cardinality__\"]>\r\n  : orLiteralValue<T>;\r\n\r\nexport type exclusivesToFilterSingle<E extends ExclusiveTuple> =\r\n  ExclusiveTuple extends E\r\n    ? never\r\n    : E extends []\r\n    ? never\r\n    : {\r\n        [j in keyof E]: {\r\n          [k in keyof E[j]]: filterSingle<E[j][k]>;\r\n        };\r\n      }[number];\r\nexport type SelectModifiers<T extends ObjectType = ObjectType> = {\r\n  // export type SelectModifiers = {\r\n  filter?: SelectFilterExpression;\r\n  filter_single?: // | Partial<\r\n  //     typeutil.stripNever<{\r\n  //       [k in keyof T[\"__pointers__\"]]: T[\"__pointers__\"][k]\r\n  // extends PropertyDesc\r\n  //         ? orScalarLiteral<{\r\n  //             __element__: T[\"__pointers__\"][k][\"target\"];\r\n  //             __cardinality__: T[\"__pointers__\"][k][\"cardinality\"];\r\n  //           }>\r\n  //         : never;\r\n  //     }>\r\n  //   >\r\n\r\n  // | (ObjectType extends T\r\n  //       ? unknown\r\n  //       : typeutil.stripNever<{\r\n  //           [k in keyof T[\"__pointers__\"]]: T[\"__pointers__\"][k]\r\n  // extends PropertyDesc<\r\n  //             infer T,\r\n  //             infer C,\r\n  //             infer E\r\n  //           >\r\n  //             ? E extends true\r\n  //               ? orScalarLiteral<{\r\n  //                   __element__: T;\r\n  //                   __cardinality__: C;\r\n  //                 }>\r\n  //               : never\r\n  //             : never;\r\n  //         }>)\r\n  exclusivesToFilterSingle<T[\"__exclusives__\"]> | SelectFilterExpression;\r\n\r\n  // | (ObjectType extends T\r\n  //     ? unknown\r\n  //     : typeutil.stripNever<{\r\n  //         [k in keyof T[\"__pointers__\"]]: T[\"__pointers__\"][k]\r\n  // extends PropertyDesc<\r\n  //           infer T,\r\n  //           infer C,\r\n  //           infer E\r\n  //         >\r\n  //           ? E extends true\r\n  //             ? orScalarLiteral<{\r\n  //                 __element__: T;\r\n  //                 __cardinality__: C;\r\n  //               }>\r\n  //             : never\r\n  //           : never;\r\n  //       }>);\r\n  order_by?: OrderByExpression;\r\n  offset?: OffsetExpression | number;\r\n  limit?: LimitExpression | number;\r\n};\r\n\r\nexport type UnknownSelectModifiers = { [k in keyof SelectModifiers]: unknown };\r\n\r\nexport type NormalisedSelectModifiers = {\r\n  filter?: SelectFilterExpression;\r\n  order_by?: OrderByObjExpr[];\r\n  offset?: OffsetExpression;\r\n  limit?: LimitExpression;\r\n  singleton: boolean;\r\n};\r\n\r\n// type NormaliseOrderByModifier<Mods extends OrderByExpression> =\r\n//   Mods extends OrderByExpr\r\n//     ? [{expression: Mods}]\r\n//     : Mods extends OrderByObjExpr\r\n//     ? [Mods]\r\n//     : Mods extends (OrderByExpr | OrderByObjExpr)[]\r\n//     ? {\r\n//         [K in keyof Mods]: Mods[K] extends OrderByExpr\r\n//           ? {expression: Mods[K]}\r\n//           : Mods[K];\r\n//       }\r\n//     : [];\r\n\r\n// type NormaliseSelectModifiers<Mods extends SelectModifiers> = {\r\n//   filter: Mods[\"filter\"];\r\n//   order_by: Mods[\"order_by\"] extends OrderByExpression\r\n//     ? NormaliseOrderByModifier<Mods[\"order_by\"]>\r\n//     : [];\r\n//   offset: Mods[\"offset\"] extends number\r\n//     ? $expr_Literal<ScalarType<\"std::int64\", number, Mods[\"offset\"]>>\r\n//     : Mods[\"offset\"];\r\n//   limit: Mods[\"offset\"] extends number\r\n//     ? $expr_Literal<ScalarType<\"std::int64\", number, Mods[\"offset\"]>>\r\n//     : Mods[\"offset\"];\r\n// };\r\n\r\nexport type $expr_Select<Set extends TypeSet = TypeSet> = Expression<{\r\n  __element__: Set[\"__element__\"];\r\n  __cardinality__: Set[\"__cardinality__\"];\r\n  __expr__: TypeSet;\r\n  __kind__: ExpressionKind.Select;\r\n  __modifiers__: NormalisedSelectModifiers;\r\n  __scope__?: ObjectTypeExpression;\r\n}>;\r\n// Modifier methods removed for now, until we can fix typescript inference\r\n// problems / excessively deep errors\r\n// & SelectModifierMethods<stripSet<Set>>;\r\n\r\nexport interface SelectModifierMethods<Root extends TypeSet> {\r\n  filter<Filter extends SelectFilterExpression>(\r\n    filter:\r\n      | Filter\r\n      | ((\r\n          scope: Root extends ObjectTypeSet\r\n            ? $scopify<Root[\"__element__\"]>\r\n            : stripSet<Root>\r\n        ) => Filter)\r\n  ): this;\r\n  order_by(\r\n    order_by:\r\n      | OrderByExpression\r\n      | ((\r\n          scope: Root extends ObjectTypeSet\r\n            ? $scopify<Root[\"__element__\"]>\r\n            : stripSet<Root>\r\n        ) => OrderByExpression)\r\n  ): this;\r\n  offset(\r\n    offset:\r\n      | OffsetExpression\r\n      | number\r\n      | ((\r\n          scope: Root extends ObjectTypeSet\r\n            ? $scopify<Root[\"__element__\"]>\r\n            : stripSet<Root>\r\n        ) => OffsetExpression | number)\r\n  ): this;\r\n  // $expr_Select<{\r\n  //   __element__: Root[\"__element__\"];\r\n  //   __cardinality__: cardutil.overrideLowerBound<\r\n  //     Root[\"__cardinality__\"],\r\n  //     \"Zero\"\r\n  //   >;\r\n  // }>;\r\n  limit(\r\n    limit:\r\n      | LimitExpression\r\n      | number\r\n      | ((\r\n          scope: Root extends ObjectTypeSet\r\n            ? $scopify<Root[\"__element__\"]>\r\n            : stripSet<Root>\r\n        ) => LimitExpression | number)\r\n  ): this;\r\n  // $expr_Select<{\r\n  //   __element__: Root[\"__element__\"];\r\n  //   __cardinality__: cardutil.overrideLowerBound<\r\n  //     Root[\"__cardinality__\"],\r\n  //     \"Zero\"\r\n  //   >;\r\n  // }>;\r\n}\r\n// Base is ObjectTypeSet &\r\n// Filter is equality &\r\n// Filter.args[0] is PathLeaf\r\n//   Filter.args[0] is __exclusive__ &\r\n//   Filter.args[0].parent.__element__ === Base.__element__\r\n//   Filter.args[1].__cardinality__ is AtMostOne or One\r\n// if Filter.args[0] is PathNode:\r\n//   Filter.args[0] is __exclusive__ &\r\n//   if Filter.args[0].parent === null\r\n//     Filter.args[0].parent.__element__ === Base.__element__\r\n//     Filter.args[1].__cardinality__ is AtMostOne or One\r\n//   else\r\n//     Filter.args[0].type.__element__ === Base.__element__ &\r\n//     Filter.args[1].__cardinality__ is AtMostOne or One\r\n\r\n// type argCardToResultCard<\r\n//   OpCard extends Cardinality,\r\n//   BaseCase extends Cardinality\r\n// > = [OpCard] extends [Cardinality.AtMostOne | Cardinality.One]\r\n//   ? Cardinality.AtMostOne\r\n//   : [OpCard] extends [Cardinality.Empty]\r\n//   ? Cardinality.Empty\r\n//   : BaseCase;\r\n\r\n// export type InferFilterCardinality<\r\n//   Base extends TypeSet,\r\n//   Filter\r\n// > = Filter extends TypeSet\r\n//   ? // Base is ObjectTypeExpression &\r\n//     Base extends ObjectTypeSet // $expr_PathNode\r\n//     ? // Filter is equality\r\n//       Filter extends $expr_Operator<\"=\", any, infer Args, any>\r\n//       ? // Filter.args[0] is PathLeaf\r\n//         Args[0] extends $expr_PathLeaf\r\n//         ? // Filter.args[0] is unique\r\n//           Args[0][\"__exclusive__\"] extends true\r\n//           ? //   Filter.args[0].parent.__element__ === Base.__element__\r\n//             typeutil.assertEqual<InferFilterCardinality\r\n//               Args[0][\"__parent__\"][\"type\"][\"__element__\"][\"__name__\"],\r\n//               Base[\"__element__\"][\"__name__\"]\r\n//             > extends true\r\n//             ? // Filter.args[1].__cardinality__ is AtMostOne or One\r\n//               argCardToResultCard<\r\n//                 Args[1][\"__cardinality__\"],\r\n//                 Base[\"__cardinality__\"]\r\n//               >\r\n//             : Base[\"__cardinality__\"]\r\n//           : Base[\"__cardinality__\"]\r\n//         : Args[0] extends $expr_PathNode<any, any, any>\r\n//         ? Args[0][\"__exclusive__\"] extends true\r\n//           ? //   Filter.args[0].parent.__element__ === Base.__element__\r\n//             Args[0][\"__parent__\"] extends null\r\n//             ? typeutil.assertEqual<\r\n//                 Args[0][\"__element__\"][\"__name__\"],\r\n//                 Base[\"__element__\"][\"__name__\"]\r\n//               > extends true\r\n//               ? // Filter.args[1].__cardinality__ is AtMostOne or One\r\n//                 argCardToResultCard<\r\n//                   Args[1][\"__cardinality__\"],\r\n//                   Base[\"__cardinality__\"]\r\n//                 >\r\n//               : Base[\"__cardinality__\"]\r\n//             : Args[0][\"__parent__\"] extends infer Parent\r\n//             ? Parent extends PathParent\r\n//               ? typeutil.assertEqual<\r\n//                   Parent[\"type\"][\"__element__\"][\"__name__\"],\r\n//                   Base[\"__element__\"][\"__name__\"]\r\n//                 > extends true\r\n//                 ? // Filter.args[1].__cardinality__ is AtMostOne or One\r\n//                   argCardToResultCard<\r\n//                     Args[1][\"__cardinality__\"],\r\n//                     Base[\"__cardinality__\"]\r\n//                   >\r\n//                 : Base[\"__cardinality__\"]\r\n//               : Base[\"__cardinality__\"]\r\n//             : Base[\"__cardinality__\"]\r\n//           : Base[\"__cardinality__\"]\r\n//         : Base[\"__cardinality__\"]\r\n//       : Base[\"__cardinality__\"]\r\n//     : Base[\"__cardinality__\"]\r\n//   : Base[\"__cardinality__\"];\r\n\r\nexport type InferOffsetLimitCardinality<\r\n  Card extends Cardinality,\r\n  Modifiers extends UnknownSelectModifiers\r\n> = Modifiers[\"limit\"] extends number | LimitExpression\r\n  ? cardutil.overrideLowerBound<Card, \"Zero\">\r\n  : Modifiers[\"offset\"] extends number | OffsetExpression\r\n  ? cardutil.overrideLowerBound<Card, \"Zero\">\r\n  : Card;\r\n\r\n// export type ComputeSelectCardinality<\r\n//   Expr extends ObjectTypeExpression,\r\n//   Modifiers extends UnknownSelectModifiers\r\n// > = InferOffsetLimitCardinality<\r\n//   InferFilterCardinality<Expr, Modifiers[\"filter\"]>,\r\n//   Modifiers\r\n// >;\r\nexport type ComputeSelectCardinality<\r\n  Expr extends ObjectTypeExpression,\r\n  Modifiers extends UnknownSelectModifiers\r\n> = InferOffsetLimitCardinality<\r\n  undefined extends Modifiers[\"filter_single\"]\r\n    ? Expr[\"__cardinality__\"]\r\n    : cardutil.overrideUpperBound<Expr[\"__cardinality__\"], \"One\">,\r\n  Modifiers\r\n>;\r\n\r\nexport function is<\r\n  Expr extends ObjectTypeExpression,\r\n  Shape extends objectTypeToSelectShape<Expr[\"__element__\"]>\r\n>(\r\n  expr: Expr,\r\n  shape: Shape\r\n): {\r\n  [k in Exclude<\r\n    keyof Shape,\r\n    SelectModifierNames | \"id\"\r\n  >]: $expr_PolyShapeElement<Expr, normaliseElement<Shape[k]>>;\r\n} {\r\n  const mappedShape: any = {};\r\n  for (const [key, value] of Object.entries(shape)) {\r\n    if (key === \"id\") continue;\r\n    mappedShape[key] = {\r\n      __kind__: ExpressionKind.PolyShapeElement,\r\n      __polyType__: expr,\r\n      __shapeElement__: value,\r\n    };\r\n  }\r\n  return mappedShape;\r\n}\r\n\r\n// function computeFilterCardinality(\r\n//   expr: SelectFilterExpression,\r\n//   cardinality: Cardinality,\r\n//   base: TypeSet\r\n// ) {\r\n//   let card = cardinality;\r\n\r\n//   const filter: any = expr;\r\n//   // Base is ObjectExpression\r\n//   const baseIsObjectExpr = base?.__element__?.__kind__ === TypeKind.object;\r\n//   const filterExprIsEq =\r\n//     filter.__kind__ === ExpressionKind.Operator && filter.__name__ === \"=\";\r\n//   const arg0: $expr_PathLeaf | $expr_PathNode = filter?.__args__?.[0];\r\n//   const arg1: TypeSet = filter?.__args__?.[1];\r\n//   const argsExist = !!arg0 && !!arg1 && !!arg1.__cardinality__;\r\n//   const arg0IsUnique = arg0?.__exclusive__ === true;\r\n\r\n//   if (baseIsObjectExpr && filterExprIsEq && argsExist && arg0IsUnique) {\r\n//     const newCard =\r\n//       arg1.__cardinality__ === Cardinality.One ||\r\n//       arg1.__cardinality__ === Cardinality.AtMostOne\r\n//         ? Cardinality.AtMostOne\r\n//         : arg1.__cardinality__ === Cardinality.Empty\r\n//         ? Cardinality.Empty\r\n//         : cardinality;\r\n\r\n//     if (arg0.__kind__ === ExpressionKind.PathLeaf) {\r\n//       const arg0ParentMatchesBase =\r\n//         arg0.__parent__.type.__element__.__name__ ===\r\n//         base.__element__.__name__;\r\n//       if (arg0ParentMatchesBase) {\r\n//         card = newCard;\r\n//       }\r\n//     } else if (arg0.__kind__ === ExpressionKind.PathNode) {\r\n//       // if Filter.args[0] is PathNode:\r\n//       //   Filter.args[0] is __exclusive__ &\r\n//       //   if Filter.args[0].parent === null\r\n//       //     Filter.args[0].__element__ === Base.__element__\r\n//       //     Filter.args[1].__cardinality__ is AtMostOne or One\r\n//       //   else\r\n//       //     Filter.args[0].type.__element__ === Base.__element__ &\r\n//       //     Filter.args[1].__cardinality__ is AtMostOne or One\r\n//       const parent = arg0.__parent__;\r\n//       if (parent === null) {\r\n//         const arg0MatchesBase =\r\n//           arg0.__element__.__name__ === base.__element__.__name__;\r\n//         if (arg0MatchesBase) {\r\n//           card = newCard;\r\n//         }\r\n//       } else {\r\n//         const arg0ParentMatchesBase =\r\n//           parent?.type.__element__.__name__ === base.__element__.__name__;\r\n//         if (arg0ParentMatchesBase) {\r\n//           card = newCard;\r\n//         }\r\n//       }\r\n//     }\r\n//   }\r\n\r\n//   return card;\r\n// }\r\n\r\nexport function $handleModifiers(\r\n  modifiers: SelectModifiers,\r\n  params: { root: TypeSet; scope: TypeSet }\r\n): {\r\n  modifiers: NormalisedSelectModifiers;\r\n  cardinality: Cardinality;\r\n  needsAssertSingle: boolean;\r\n} {\r\n  const { root, scope } = params;\r\n  const mods: NormalisedSelectModifiers = {\r\n    singleton: !!modifiers[\"filter_single\"],\r\n  };\r\n\r\n  let card = root.__cardinality__;\r\n  let needsAssertSingle = false;\r\n\r\n  if (modifiers.filter) {\r\n    mods.filter = modifiers.filter;\r\n    // card = computeFilterCardinality(mods.filter, card, rootExpr);\r\n  }\r\n\r\n  if (modifiers.filter_single) {\r\n    if (root.__element__.__kind__ !== TypeKind.object) {\r\n      throw new Error(\"filter_single can only be used with object types\");\r\n    }\r\n    card = Cardinality.AtMostOne;\r\n    // mods.filter = modifiers.filter_single;\r\n    const fs: any = modifiers.filter_single;\r\n    if (fs.__element__) {\r\n      mods.filter = modifiers.filter_single as any;\r\n      needsAssertSingle = true;\r\n    } else {\r\n      const exprs = Object.keys(fs).map((key) => {\r\n        const val = fs[key].__element__\r\n          ? fs[key]\r\n          : (literal as any)(\r\n              (root.__element__ as any as ObjectType)[\"__pointers__\"][key]![\r\n                \"target\"\r\n              ],\r\n              fs[key]\r\n            );\r\n        return $expressionify({\r\n          __element__: {\r\n            __name__: \"std::bool\",\r\n            __kind__: TypeKind.scalar,\r\n          } as any,\r\n          __cardinality__: Cardinality.One,\r\n          __kind__: ExpressionKind.Operator,\r\n          __opkind__: OperatorKind.Infix,\r\n          __name__: \"=\",\r\n          __args__: [(scope as any)[key], val],\r\n        }) as $expr_Operator;\r\n      });\r\n      if (exprs.length === 1) {\r\n        mods.filter = exprs[0] as any;\r\n      } else {\r\n        mods.filter = exprs.reduce((a, b) => {\r\n          return $expressionify({\r\n            __element__: {\r\n              __name__: \"std::bool\",\r\n              __kind__: TypeKind.scalar,\r\n            } as any,\r\n            __cardinality__: Cardinality.One,\r\n            __kind__: ExpressionKind.Operator,\r\n            __opkind__: OperatorKind.Infix,\r\n            __name__: \"and\",\r\n            __args__: [a, b],\r\n          }) as $expr_Operator;\r\n        }) as any;\r\n      }\r\n    }\r\n  }\r\n  if (modifiers.order_by) {\r\n    const orderExprs = Array.isArray(modifiers.order_by)\r\n      ? modifiers.order_by\r\n      : [modifiers.order_by];\r\n    mods.order_by = orderExprs.map((expr) =>\r\n      typeof (expr as any).__element__ === \"undefined\"\r\n        ? expr\r\n        : { expression: expr }\r\n    ) as any;\r\n  }\r\n  if (modifiers.offset) {\r\n    mods.offset =\r\n      typeof modifiers.offset === \"number\"\r\n        ? ($getTypeByName(\"std::number\")(modifiers.offset) as any)\r\n        : modifiers.offset;\r\n    card = cardutil.overrideLowerBound(card, \"Zero\");\r\n  }\r\n  if (modifiers.limit) {\r\n    let expr: LimitExpression;\r\n    if (typeof modifiers.limit === \"number\") {\r\n      expr = $getTypeByName(\"std::number\")(modifiers.limit) as any;\r\n    } else {\r\n      const type =\r\n        (modifiers.limit.__element__ as any).__casttype__ ??\r\n        modifiers.limit.__element__;\r\n      if (\r\n        type.__kind__ === TypeKind.scalar &&\r\n        type.__name__ === \"std::number\"\r\n      ) {\r\n        expr = modifiers.limit;\r\n      } else {\r\n        throw new Error(\"Invalid value for `limit` modifier\");\r\n      }\r\n    }\r\n    mods.limit = expr;\r\n    card = cardutil.overrideLowerBound(card, \"Zero\");\r\n  }\r\n\r\n  return {\r\n    modifiers: mods as NormalisedSelectModifiers,\r\n    cardinality: card,\r\n    needsAssertSingle,\r\n  };\r\n}\r\n\r\nexport type $expr_Delete<Root extends ObjectTypeSet = ObjectTypeSet> =\r\n  Expression<{\r\n    __kind__: ExpressionKind.Delete;\r\n    __element__: Root[\"__element__\"];\r\n    __cardinality__: Root[\"__cardinality__\"];\r\n    __expr__: ObjectTypeSet;\r\n  }>;\r\n\r\nfunction deleteExpr<\r\n  Expr extends ObjectTypeExpression,\r\n  Modifiers extends SelectModifiers<Expr[\"__element__\"]>\r\n>(\r\n  expr: Expr,\r\n  modifiers?: (scope: $scopify<Expr[\"__element__\"]>) => Readonly<Modifiers>\r\n): $expr_Delete<{\r\n  __element__: ObjectType<\r\n    Expr[\"__element__\"][\"__name__\"],\r\n    Expr[\"__element__\"][\"__pointers__\"],\r\n    { id: true }\r\n  >;\r\n  __cardinality__: ComputeSelectCardinality<Expr, Modifiers>;\r\n}>;\r\nfunction deleteExpr(expr: any, modifiersGetter: any) {\r\n  const selectExpr = select(expr, modifiersGetter);\r\n\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.Delete,\r\n    __element__: selectExpr.__element__,\r\n    __cardinality__: selectExpr.__cardinality__,\r\n    __expr__: selectExpr,\r\n  }) as any;\r\n}\r\n\r\nexport { deleteExpr as delete };\r\n\r\n// Modifier methods removed for now, until we can fix typescript inference\r\n// problems / excessively deep errors\r\n\r\n// function resolveModifierGetter(parent: any, modGetter: any) {\r\n//   if (typeof modGetter === \"function\" && !modGetter.__kind__) {\r\n//     if (parent.__expr__.__element__.__kind__ === TypeKind.object) {\r\n//       const shape = parent.__element__.__shape__;\r\n//       const _scope =\r\n//         parent.__scope__ ?? $getScopedExpr(parent.__expr__,\r\n//           $existingScopes);\r\n//       const scope = new Proxy(_scope, {\r\n//         get(target: any, prop: string) {\r\n//           if (shape[prop] && shape[prop] !== true) {\r\n//             return shape[prop];\r\n//           }\r\n//           return target[prop];\r\n//         },\r\n//       });\r\n//       return {\r\n//         scope: _scope,\r\n//         modExpr: modGetter(scope),\r\n//       };\r\n//     } else {\r\n//       return {\r\n//         scope: undefined,\r\n//         modExpr: modGetter(parent.__expr__),\r\n//       };\r\n//     }\r\n//   } else {\r\n//     return {scope: parent.__scope__, modExpr: modGetter};\r\n//   }\r\n// }\r\n\r\n// function updateModifier(\r\n//   parent: any,\r\n//   modName: \"filter\" | \"order_by\" | \"offset\" | \"limit\",\r\n//   modGetter: any\r\n// ) {\r\n//   const modifiers = {\r\n//     ...parent.__modifiers__,\r\n//   };\r\n//   const cardinality = parent.__cardinality__;\r\n\r\n//   const {modExpr, scope} = resolveModifierGetter(parent, modGetter);\r\n\r\n//   switch (modName) {\r\n//     case \"filter\":\r\n//       modifiers.filter = modifiers.filter\r\n//         ? op(modifiers.filter, \"and\", modExpr)\r\n//         : modExpr;\r\n\r\n//       // methods no longer change cardinality\r\n//       // cardinality = computeFilterCardinality(\r\n//       //   modExpr,\r\n//       //   cardinality,\r\n//       //   parent.__expr__\r\n//       // );\r\n//       break;\r\n//     case \"order_by\":\r\n//       const ordering =\r\n//         typeof (modExpr as any).__element__ === \"undefined\"\r\n//           ? modExpr\r\n//           : {expression: modExpr};\r\n//       modifiers.order_by = modifiers.order_by\r\n//         ? [...modifiers.order_by, ordering]\r\n//         : [ordering];\r\n//       break;\r\n//     case \"offset\":\r\n//       modifiers.offset =\r\n//         typeof modExpr === \"number\" ? _std.number(modExpr) : modExpr;\r\n//       // methods no longer change cardinality\r\n//       // cardinality = cardutil\r\n//            .overrideLowerBound(cardinality, \"Zero\");\r\n//       break;\r\n//     case \"limit\":\r\n//       modifiers.limit =\r\n//         typeof modExpr === \"number\"\r\n//           ? _std.number(modExpr)\r\n//           : (modExpr as any).__kind__ === ExpressionKind.Set\r\n//           ? (modExpr as any).__exprs__[0]\r\n//           : modExpr;\r\n//       // methods no longer change cardinality\r\n//       // cardinality = cardutil\r\n//            .overrideLowerBound(cardinality, \"Zero\");\r\n//       break;\r\n//   }\r\n\r\n//   return $expressionify(\r\n//     $selectify({\r\n//       __kind__: ExpressionKind.Select,\r\n//       __element__: parent.__element__,\r\n//       __cardinality__: cardinality,\r\n//       __expr__: parent.__expr__,\r\n//       __modifiers__: modifiers,\r\n//       __scope__: scope,\r\n//     })\r\n//   );\r\n// }\r\n\r\nexport function $selectify<Expr extends ExpressionRoot>(expr: Expr) {\r\n  // Object.assign(expr, {\r\n  //   filter: (filter: any) => updateModifier(expr, \"filter\", filter),\r\n  //   order_by: (order_by: any) => updateModifier(expr, \"order_by\", order_by),\r\n  //   offset: (offset: any) => updateModifier(expr, \"offset\", offset),\r\n  //   limit: (limit: any) => updateModifier(expr, \"limit\", limit),\r\n  // });\r\n  return expr;\r\n}\r\n\r\nexport type linkDescToLinkProps<Desc extends LinkDesc> = {\r\n  [k in keyof Desc[\"properties\"] & string]: $expr_PathLeaf<\r\n    TypeSet<\r\n      Desc[\"properties\"][k][\"target\"],\r\n      Desc[\"properties\"][k][\"cardinality\"]\r\n    >\r\n    // {\r\n    //   type: $scopify<Desc[\"target\"]>;\r\n    //   linkName: k;\r\n    // },\r\n    // Desc[\"properties\"][k][\"exclusive\"]\r\n  >;\r\n};\r\n\r\nexport type pointersToObjectType<P extends ObjectTypePointers> = ObjectType<\r\n  string,\r\n  P,\r\n  object\r\n>;\r\n\r\ntype linkDescToShape<L extends LinkDesc> = objectTypeToSelectShape<\r\n  L[\"target\"]\r\n> &\r\n  objectTypeToSelectShape<pointersToObjectType<L[\"properties\"]>> &\r\n  SelectModifiers;\r\n\r\ntype linkDescToSelectElement<L extends LinkDesc> =\r\n  | boolean\r\n  | TypeSet<anonymizeObject<L[\"target\"]>, cardutil.assignable<L[\"cardinality\"]>>\r\n  | linkDescToShape<L>\r\n  | ((\r\n      scope: $scopify<L[\"target\"]> & linkDescToLinkProps<L>\r\n    ) => linkDescToShape<L>);\r\n\r\ntype propDescToSelectElement<P extends PropertyDesc> =\r\n  | boolean\r\n  | TypeSet<P[\"target\"], cardutil.assignable<P[\"cardinality\"]>>\r\n  | $expr_PolyShapeElement;\r\n\r\n// object types -> pointers\r\n// pointers -> links\r\n// links -> target object type\r\n// links -> link properties\r\nexport type objectTypeToSelectShape<\r\n  T extends ObjectType = ObjectType,\r\n  Pointers extends ObjectTypePointers = T[\"__pointers__\"]\r\n> = Partial<{\r\n  [k in keyof Pointers]: Pointers[k] extends PropertyDesc\r\n    ? propDescToSelectElement<Pointers[k]>\r\n    : Pointers[k] extends LinkDesc\r\n    ? linkDescToSelectElement<Pointers[k]>\r\n    : any;\r\n}> & { [k: string]: unknown };\r\n\r\n// incorporate __shape__ (computeds) on selection shapes\r\n// this works but a major rewrite of setToTsType is required\r\n// to incorporate __shape__-based selection shapes into\r\n// result type inference\r\n// & [k in keyof T[\"__shape__\"]]:\r\n//    string | number | symbol extends k //   Partial<{ // &\r\n//       ? unknown\r\n//       : T[\"__shape__\"][k] extends infer U\r\n//       ? U extends ObjectTypeSet\r\n//         ?\r\n//             | boolean\r\n//             | TypeSet<\r\n//                 anonymizeObject<U[\"__element__\"]>,\r\n//                 cardutil.assignable<U[\"__cardinality__\"]>\r\n//               >\r\n//             | objectTypeToSelectShape<U[\"__element__\"]>\r\n//             | ((\r\n//                 scope: $scopify<U[\"__element__\"]>\r\n//               ) => objectTypeToSelectShape<U[\"__element__\"]> &\r\n//                 SelectModifiers)\r\n//         : U extends TypeSet\r\n//         ?\r\n//             | boolean\r\n//             | TypeSet<\r\n//                 U[\"__element__\"],\r\n//                 cardutil.assignable<U[\"__cardinality__\"]>\r\n//               >\r\n//         : unknown\r\n//       : unknown;\r\n//   }>\r\n\r\nexport type normaliseElement<El> = El extends boolean\r\n  ? El\r\n  : El extends TypeSet\r\n  ? stripSet<El>\r\n  : El extends (...scope: any[]) => any\r\n  ? normaliseShape<ReturnType<El>>\r\n  : El extends object\r\n  ? normaliseShape<stripSet<El>>\r\n  : stripSet<El>;\r\n\r\nexport type normaliseShape<\r\n  Shape extends object,\r\n  Strip = SelectModifierNames\r\n> = {\r\n  [k in Exclude<keyof Shape, Strip>]: normaliseElement<Shape[k]>;\r\n};\r\n\r\nconst $FreeObject = makeType(\r\n  spec,\r\n  [...spec.values()].find((s) => s.name === \"std::FreeObject\")!.id,\r\n  literal\r\n);\r\nconst FreeObject: $expr_PathNode = {\r\n  __kind__: ExpressionKind.PathNode,\r\n  __element__: $FreeObject as any,\r\n  __cardinality__: Cardinality.One,\r\n  __parent__: null,\r\n  __exclusive__: true,\r\n  __scopeRoot__: null,\r\n} as any;\r\n\r\nexport const $existingScopes = new Set<\r\n  Expression<TypeSet<BaseType, Cardinality>>\r\n>();\r\n\r\nfunction $shape<\r\n  Expr extends ObjectTypeExpression,\r\n  Element extends Expr[\"__element__\"],\r\n  Shape extends objectTypeToSelectShape<Element> & SelectModifiers<Element>,\r\n  Scope extends $scopify<Element> &\r\n    $linkPropify<{\r\n      [k in keyof Expr]: k extends \"__cardinality__\"\r\n        ? Cardinality.One\r\n        : Expr[k];\r\n    }>\r\n>(\r\n  expr: Expr,\r\n  _shape: (scope: Scope) => Readonly<Shape>\r\n): (scope: unknown) => Readonly<Shape>;\r\nfunction $shape(_a: unknown, b: (...args: any) => any) {\r\n  return b;\r\n}\r\nexport { $shape as shape };\r\n\r\nexport function select<\r\n  Expr extends ObjectTypeExpression,\r\n  Element extends Expr[\"__element__\"],\r\n  ElementName extends `${Element[\"__name__\"]}`,\r\n  ElementPointers extends Element[\"__pointers__\"],\r\n  ElementShape extends Element[\"__shape__\"],\r\n  Card extends Expr[\"__cardinality__\"]\r\n>(\r\n  expr: Expr\r\n): $expr_Select<{\r\n  __element__: ObjectType<ElementName, ElementPointers, ElementShape>;\r\n  __cardinality__: Card;\r\n}>;\r\nexport function select<Expr extends TypeSet>(\r\n  expr: Expr\r\n): $expr_Select<stripSet<Expr>>;\r\nexport function select<\r\n  Expr extends ObjectTypeExpression,\r\n  Element extends Expr[\"__element__\"],\r\n  Shape extends objectTypeToSelectShape<Element> & SelectModifiers<Element>,\r\n  SelectCard extends ComputeSelectCardinality<Expr, Modifiers>,\r\n  SelectShape extends normaliseShape<Shape, SelectModifierNames>,\r\n  Scope extends $scopify<Element> &\r\n    $linkPropify<{\r\n      [k in keyof Expr]: k extends \"__cardinality__\"\r\n        ? Cardinality.One\r\n        : Expr[k];\r\n    }>,\r\n  ElementName extends `${Element[\"__name__\"]}`,\r\n  Modifiers extends UnknownSelectModifiers = Pick<Shape, SelectModifierNames>\r\n>(\r\n  expr: Expr,\r\n  shape: (scope: Scope) => Readonly<Shape>\r\n): $expr_Select<{\r\n  __element__: ObjectType<ElementName, Element[\"__pointers__\"], SelectShape>;\r\n  __cardinality__: SelectCard;\r\n}>;\r\n/*\r\n\r\nFor the moment is isn't possible to implement both closure-based and plain\r\nobject overloads without breaking autocomplete on one or the other.\r\nThis is due to a limitation in TS:\r\n\r\nhttps://github.com/microsoft/TypeScript/issues/26892\r\nhttps://github.com/microsoft/TypeScript/issues/47081\r\n\r\n*/\r\n\r\nexport function select<\r\n  Expr extends PrimitiveTypeSet,\r\n  Modifiers extends SelectModifiers\r\n>(\r\n  expr: Expr,\r\n  modifiers: (expr: Expr) => Readonly<Modifiers>\r\n): $expr_Select<{\r\n  __element__: Expr[\"__element__\"];\r\n  __cardinality__: InferOffsetLimitCardinality<\r\n    Expr[\"__cardinality__\"],\r\n    Modifiers\r\n  >;\r\n}>;\r\nexport function select<Shape extends { [key: string]: TypeSet }>(\r\n  shape: Shape\r\n): $expr_Select<{\r\n  __element__: ObjectType<\r\n    `std::FreeObject`,\r\n    {\r\n      [k in keyof Shape]: Shape[k][\"__element__\"] extends ObjectType\r\n        ? LinkDesc<\r\n            Shape[k][\"__element__\"],\r\n            Shape[k][\"__cardinality__\"],\r\n            {},\r\n            false,\r\n            true,\r\n            true,\r\n            false\r\n          >\r\n        : PropertyDesc<\r\n            Shape[k][\"__element__\"],\r\n            Shape[k][\"__cardinality__\"],\r\n            false,\r\n            true,\r\n            true,\r\n            false\r\n          >;\r\n    },\r\n    Shape\r\n  >; // _shape\r\n  __cardinality__: Cardinality.One;\r\n}>;\r\nexport function select<Expr extends scalarLiterals>(\r\n  expr: Expr\r\n): $expr_Select<{\r\n  __element__: literalToScalarType<Expr>;\r\n  __cardinality__: Cardinality.One;\r\n}>;\r\nexport function select(...args: any[]) {\r\n  const firstArg = args[0];\r\n\r\n  if (\r\n    typeof firstArg !== \"object\" ||\r\n    firstArg instanceof Uint8Array ||\r\n    firstArg instanceof Date ||\r\n    firstArg instanceof Duration ||\r\n    firstArg instanceof LocalDateTime ||\r\n    firstArg instanceof LocalDate ||\r\n    firstArg instanceof LocalTime ||\r\n    firstArg instanceof RelativeDuration ||\r\n    firstArg instanceof DateDuration ||\r\n    firstArg instanceof ConfigMemory ||\r\n    firstArg instanceof Float32Array\r\n  ) {\r\n    const literalExpr = literalToTypeSet(firstArg);\r\n    return $expressionify(\r\n      $selectify({\r\n        __kind__: ExpressionKind.Select,\r\n        __element__: literalExpr.__element__,\r\n        __cardinality__: literalExpr.__cardinality__,\r\n        __expr__: literalExpr,\r\n        __modifiers__: {},\r\n      })\r\n    ) as any;\r\n  }\r\n\r\n  const exprPair: [TypeSet, (scope: any) => any] =\r\n    typeof args[0].__element__ !== \"undefined\"\r\n      ? (args as any)\r\n      : [FreeObject, () => args[0]];\r\n\r\n  let expr = exprPair[0];\r\n  const shapeGetter = exprPair[1];\r\n  if (expr === FreeObject) {\r\n    const freeObjectPtrs: ObjectTypePointers = {};\r\n    for (const [k, v] of Object.entries(args[0]) as [string, TypeSet][]) {\r\n      freeObjectPtrs[k] = {\r\n        __kind__:\r\n          v.__element__.__kind__ === TypeKind.object ? \"link\" : \"property\",\r\n        target: v.__element__,\r\n\r\n        cardinality: v.__cardinality__,\r\n        exclusive: false,\r\n        computed: true,\r\n        readonly: true,\r\n        hasDefault: false,\r\n        properties: {},\r\n      };\r\n    }\r\n    expr = {\r\n      ...FreeObject,\r\n      __element__: {\r\n        ...FreeObject.__element__,\r\n        __pointers__: {\r\n          ...FreeObject.__element__.__pointers__,\r\n          ...freeObjectPtrs,\r\n        },\r\n      } as any,\r\n    };\r\n  }\r\n  if (!shapeGetter) {\r\n    if (expr.__element__.__kind__ === TypeKind.object) {\r\n      const objectExpr: ObjectTypeSet = expr as any;\r\n      return $expressionify(\r\n        $selectify({\r\n          __kind__: ExpressionKind.Select,\r\n          __element__: {\r\n            __kind__: TypeKind.object,\r\n            __name__: `${objectExpr.__element__.__name__}`, // _shape\r\n            __pointers__: objectExpr.__element__.__pointers__,\r\n            __shape__: objectExpr.__element__.__shape__,\r\n          } as any,\r\n          __cardinality__: objectExpr.__cardinality__,\r\n          __expr__: objectExpr,\r\n          __modifiers__: {},\r\n        })\r\n      ) as any;\r\n    } else {\r\n      return $expressionify(\r\n        $selectify({\r\n          __kind__: ExpressionKind.Select,\r\n          __element__: expr.__element__,\r\n          __cardinality__: expr.__cardinality__,\r\n          __expr__: expr,\r\n          __modifiers__: {},\r\n        })\r\n      ) as any;\r\n    }\r\n  }\r\n\r\n  const cleanScopedExprs = $existingScopes.size === 0;\r\n\r\n  const { modifiers: mods, shape, scope } = resolveShape(shapeGetter, expr);\r\n\r\n  if (cleanScopedExprs) {\r\n    $existingScopes.clear();\r\n  }\r\n\r\n  const { modifiers, cardinality, needsAssertSingle } = $handleModifiers(mods, {\r\n    root: expr,\r\n    scope,\r\n  });\r\n  const selectExpr = $selectify({\r\n    __kind__: ExpressionKind.Select,\r\n    __element__:\r\n      expr.__element__.__kind__ === TypeKind.object\r\n        ? {\r\n            __kind__: TypeKind.object,\r\n            __name__: `${expr.__element__.__name__}`, // _shape\r\n            __pointers__: (expr.__element__ as ObjectType).__pointers__,\r\n            __shape__: shape,\r\n          }\r\n        : expr.__element__,\r\n    __cardinality__: cardinality,\r\n    __expr__: expr,\r\n    __modifiers__: modifiers,\r\n    __scope__: expr !== scope ? scope : undefined,\r\n  }) as any;\r\n\r\n  return needsAssertSingle\r\n    ? $assert_single(selectExpr)\r\n    : $expressionify(selectExpr);\r\n}\r\n\r\nfunction resolveShape(\r\n  shapeGetter: ((scope: any) => any) | any,\r\n  expr: TypeSet\r\n): { modifiers: any; shape: any; scope: TypeSet } {\r\n  const modifiers: any = {};\r\n  const shape: any = {};\r\n\r\n  // get scoped object if expression is objecttypeset\r\n  const scope =\r\n    expr.__element__.__kind__ === TypeKind.object\r\n      ? $getScopedExpr(expr as any, $existingScopes)\r\n      : expr;\r\n\r\n  // execute getter with scope\r\n  const selectShape =\r\n    typeof shapeGetter === \"function\" ? shapeGetter(scope) : shapeGetter;\r\n\r\n  for (const [key, value] of Object.entries(selectShape)) {\r\n    // handle modifier keys\r\n    if (\r\n      key === \"filter\" ||\r\n      key === \"filter_single\" ||\r\n      key === \"order_by\" ||\r\n      key === \"offset\" ||\r\n      key === \"limit\"\r\n    ) {\r\n      modifiers[key] = value;\r\n    } else {\r\n      // for scalar expressions, scope === expr\r\n      // shape keys are not allowed\r\n      if (expr.__element__.__kind__ !== TypeKind.object) {\r\n        throw new Error(\r\n          `Invalid select shape key '${key}' on scalar expression, ` +\r\n            `only modifiers are allowed (filter, order_by, offset and limit)`\r\n        );\r\n      }\r\n      shape[key] = resolveShapeElement(key, value, scope);\r\n    }\r\n  }\r\n  return { shape, modifiers, scope };\r\n}\r\n\r\nexport function resolveShapeElement(\r\n  key: any,\r\n  value: any,\r\n  scope: ObjectTypeExpression\r\n): any {\r\n  // if value is a nested closure\r\n  // or a nested shape object\r\n  const isSubshape =\r\n    typeof value === \"object\" && typeof (value as any).__kind__ === \"undefined\";\r\n  const isClosure =\r\n    typeof value === \"function\" &&\r\n    scope.__element__.__pointers__[key]?.__kind__ === \"link\";\r\n  // if (isSubshape) {\r\n  //   // return value;\r\n  //   const childExpr = (scope as any)[key];\r\n  //   const {\r\n  //     shape: childShape,\r\n  //     // scope: childScope,\r\n  //     // modifiers: mods,\r\n  //   } = resolveShape(value as any, childExpr);\r\n  //   return childShape;\r\n  // }\r\n  if (isSubshape || isClosure) {\r\n    // get child node expression\r\n    // this relies on Proxy-based getters\r\n    const childExpr = (scope as any)[key];\r\n    if (!childExpr) {\r\n      throw new Error(\r\n        `Invalid shape element \"${key}\" for type ${scope.__element__.__name__}`\r\n      );\r\n    }\r\n    const {\r\n      shape: childShape,\r\n      scope: childScope,\r\n      modifiers: mods,\r\n    } = resolveShape(value as any, childExpr);\r\n\r\n    // extracts normalized modifiers\r\n    const { modifiers, needsAssertSingle } = $handleModifiers(mods, {\r\n      root: childExpr,\r\n      scope: childScope,\r\n    });\r\n\r\n    const selectExpr = {\r\n      __kind__: ExpressionKind.Select,\r\n      __element__: {\r\n        __kind__: TypeKind.object,\r\n        __name__: `${childExpr.__element__.__name__}`,\r\n        __pointers__: childExpr.__element__.__pointers__,\r\n        __shape__: childShape,\r\n      },\r\n      __cardinality__:\r\n        scope.__element__.__pointers__?.[key]?.cardinality ||\r\n        scope.__element__.__shape__?.[key]?.__cardinality__,\r\n      __expr__: childExpr,\r\n      __modifiers__: modifiers,\r\n      __scope__: childExpr !== childScope ? childScope : undefined,\r\n    };\r\n    return needsAssertSingle ? $assert_single(selectExpr as any) : selectExpr;\r\n  } else if ((value as any)?.__kind__ === ExpressionKind.PolyShapeElement) {\r\n    const polyElement = value as $expr_PolyShapeElement;\r\n\r\n    const polyScope = (scope as any).is(polyElement.__polyType__);\r\n    return {\r\n      __kind__: ExpressionKind.PolyShapeElement,\r\n      __polyType__: polyScope,\r\n      __shapeElement__: resolveShapeElement(\r\n        key,\r\n        polyElement.__shapeElement__,\r\n        polyScope\r\n      ),\r\n    };\r\n  } else if (typeof value === \"boolean\" && key.startsWith(\"@\")) {\r\n    const linkProp = (scope as any)[key];\r\n    if (!linkProp) {\r\n      throw new Error(\r\n        (scope as any).__parent__\r\n          ? `link property '${key}' does not exist on link ${\r\n              (scope as any).__parent__.linkName\r\n            }`\r\n          : `cannot select link property '${key}' on an object (${scope.__element__.__name__})`\r\n      );\r\n    }\r\n    return value ? linkProp : false;\r\n  } else {\r\n    return value;\r\n  }\r\n}\r\n"},{"path":"set.ts","content":"import type { ExpressionKind, Cardinality } from \"edgedb/dist/reflection/index\";\r\nimport { TypeKind } from \"edgedb/dist/reflection/index\";\r\nimport type {\r\n  ArrayType,\r\n  BaseTypeTuple,\r\n  BaseType,\r\n  NamedTupleType,\r\n  ObjectTypeSet,\r\n  TypeSet,\r\n  TupleType,\r\n  Expression,\r\n  ObjectType,\r\n  getPrimitiveBaseType,\r\n  SomeType,\r\n} from \"./typesystem\";\r\n\r\nimport { $mergeObjectTypes, type mergeObjectTypes } from \"./hydrate\";\r\n\r\nimport * as castMaps from \"./castMaps\";\r\n\r\nexport function getSharedParent(a: SomeType, b: SomeType): SomeType {\r\n  if (a.__kind__ !== b.__kind__) {\r\n    throw new Error(\r\n      `Incompatible array types: ${a.__name__} and ${b.__name__}`\r\n    );\r\n  }\r\n  if (a.__kind__ === TypeKind.scalar && b.__kind__ === TypeKind.scalar) {\r\n    return castMaps.getSharedParentScalar(a, b);\r\n  } else if (a.__kind__ === TypeKind.object && b.__kind__ === TypeKind.object) {\r\n    return $mergeObjectTypes(a, b);\r\n  } else if (a.__kind__ === TypeKind.tuple && b.__kind__ === TypeKind.tuple) {\r\n    if (a.__items__.length !== b.__items__.length) {\r\n      throw new Error(\r\n        `Incompatible tuple types: ${a.__name__} and ${b.__name__}`\r\n      );\r\n    }\r\n    try {\r\n      const items = a.__items__.map((_, i) => {\r\n        if (!a.__items__[i] || !b.__items__[i]) {\r\n          throw new Error();\r\n        }\r\n        return getSharedParent(\r\n          a.__items__[i] as SomeType,\r\n          b.__items__[i] as SomeType\r\n        );\r\n      });\r\n\r\n      return {\r\n        __kind__: TypeKind.tuple,\r\n        __name__: `tuple<${items.map((item) => item.__name__).join(\", \")}>`,\r\n        __items__: items as BaseTypeTuple,\r\n      };\r\n    } catch (err) {\r\n      throw new Error(\r\n        `Incompatible tuple types: ${a.__name__} and ${b.__name__}`\r\n      );\r\n    }\r\n  } else if (\r\n    a.__kind__ === TypeKind.namedtuple &&\r\n    b.__kind__ === TypeKind.namedtuple\r\n  ) {\r\n    const aKeys = Object.keys(a);\r\n    const bKeys = new Set(Object.keys(b));\r\n    const sameKeys =\r\n      aKeys.length === bKeys.size && aKeys.every((k) => bKeys.has(k));\r\n    if (!sameKeys) {\r\n      throw new Error(\r\n        `Incompatible tuple types: ${a.__name__} and ${b.__name__}`\r\n      );\r\n    }\r\n    try {\r\n      const items: { [k: string]: BaseType } = {};\r\n      for (const [i] of Object.entries(a.__shape__)) {\r\n        if (!a.__shape__[i] || !b.__shape__[i]) {\r\n          throw new Error();\r\n        }\r\n        items[i] = getSharedParent(\r\n          a.__shape__[i] as SomeType,\r\n          b.__shape__[i] as SomeType\r\n        );\r\n      }\r\n\r\n      return {\r\n        __kind__: TypeKind.namedtuple,\r\n        __name__: `tuple<${Object.entries(items)\r\n          .map(([key, val]: [string, any]) => `${key}: ${val.__name__}`)\r\n          .join(\", \")}>`,\r\n        __shape__: items,\r\n      };\r\n    } catch (err) {\r\n      throw new Error(\r\n        `Incompatible tuple types: ${a.__name__} and ${b.__name__}`\r\n      );\r\n    }\r\n  } else if (a.__kind__ === TypeKind.array && b.__kind__ === TypeKind.array) {\r\n    try {\r\n      const mergedEl: any = getSharedParent(\r\n        a.__element__ as any,\r\n        b.__element__ as any\r\n      );\r\n      return {\r\n        __kind__: TypeKind.array,\r\n        __name__: a.__name__,\r\n        __element__: mergedEl,\r\n      } as ArrayType;\r\n    } catch (err) {\r\n      throw new Error(\r\n        `Incompatible array types: ${a.__name__} and ${b.__name__}`\r\n      );\r\n    }\r\n  } else if (a.__kind__ === TypeKind.enum && b.__kind__ === TypeKind.enum) {\r\n    if (a.__name__ === b.__name__) return a;\r\n    throw new Error(\r\n      `Incompatible array types: ${a.__name__} and ${b.__name__}`\r\n    );\r\n  } else {\r\n    throw new Error(\r\n      `Incompatible array types: ${a.__name__} and ${b.__name__}`\r\n    );\r\n  }\r\n}\r\n\r\nexport { set } from \"./setImpl\";\r\n\r\n// export type $expr_Set<Set extends LooseTypeSet = LooseTypeSet> = Expression<\r\nexport type $expr_Set<Set extends LooseTypeSet = LooseTypeSet> = Expression<{\r\n  __element__: Set[\"__element__\"];\r\n  __cardinality__: Set[\"__cardinality__\"];\r\n  __exprs__: TypeSet[];\r\n  __kind__: ExpressionKind.Set;\r\n}>;\r\n\r\ntype mergeTypeTuples<AItems, BItems> = {\r\n  [k in keyof AItems]: k extends keyof BItems\r\n    ? getSharedParentPrimitive<AItems[k], BItems[k]>\r\n    : never;\r\n};\r\n\r\n// find shared parent of two primitives\r\nexport type getSharedParentPrimitive<A, B> = A extends undefined\r\n  ? B extends undefined\r\n    ? undefined\r\n    : B\r\n  : B extends undefined\r\n  ? A\r\n  : A extends ArrayType<infer AEl>\r\n  ? B extends ArrayType<infer BEl>\r\n    ? ArrayType<castMaps.getSharedParentScalar<AEl, BEl>>\r\n    : never\r\n  : A extends NamedTupleType<infer AShape>\r\n  ? B extends NamedTupleType<infer BShape>\r\n    ? NamedTupleType<{\r\n        [k in keyof AShape & keyof BShape]: castMaps.getSharedParentScalar<\r\n          AShape[k],\r\n          BShape[k]\r\n        >;\r\n      }>\r\n    : never\r\n  : A extends TupleType<infer AItems>\r\n  ? B extends TupleType<infer BItems>\r\n    ? mergeTypeTuples<AItems, BItems> extends BaseTypeTuple\r\n      ? TupleType<mergeTypeTuples<AItems, BItems>>\r\n      : never\r\n    : never\r\n  : castMaps.getSharedParentScalar<A, B>;\r\n\r\ntype _getSharedParentPrimitiveVariadic<Types extends [any, ...any[]]> =\r\n  Types extends [infer U]\r\n    ? U\r\n    : Types extends [infer A, infer B, ...infer Rest]\r\n    ? _getSharedParentPrimitiveVariadic<\r\n        [getSharedParentPrimitive<A, B>, ...Rest]\r\n      >\r\n    : never;\r\n\r\nexport type getSharedParentPrimitiveVariadic<Types extends [any, ...any[]]> =\r\n  _getSharedParentPrimitiveVariadic<Types>;\r\n\r\nexport type LooseTypeSet<\r\n  T extends any = any,\r\n  C extends Cardinality = Cardinality\r\n> = {\r\n  __element__: T;\r\n  __cardinality__: C;\r\n};\r\n\r\nexport type { mergeObjectTypes };\r\n\r\ntype _mergeObjectTypesVariadic<Types extends [ObjectType, ...ObjectType[]]> =\r\n  Types extends [infer U]\r\n    ? U\r\n    : Types extends [infer A, infer B, ...infer Rest]\r\n    ? A extends ObjectType\r\n      ? B extends ObjectType\r\n        ? mergeObjectTypes<A, B> extends BaseType\r\n          ? mergeObjectTypesVariadic<[mergeObjectTypes<A, B>, ...Rest]>\r\n          : never\r\n        : never\r\n      : never\r\n    : never;\r\n\r\nexport type mergeObjectTypesVariadic<Types extends [any, ...any[]]> =\r\n  _mergeObjectTypesVariadic<Types>;\r\n\r\nexport type getTypesFromExprs<Exprs extends [TypeSet, ...TypeSet[]]> = {\r\n  [k in keyof Exprs]: Exprs[k] extends TypeSet<infer El, any>\r\n    ? getPrimitiveBaseType<El>\r\n    : never;\r\n};\r\n\r\nexport type getTypesFromObjectExprs<\r\n  Exprs extends [ObjectTypeSet, ...ObjectTypeSet[]]\r\n> = {\r\n  [k in keyof Exprs]: Exprs[k] extends TypeSet<infer El, any> ? El : never;\r\n};\r\n\r\nexport type getCardsFromExprs<Exprs extends [TypeSet, ...TypeSet[]]> = {\r\n  [k in keyof Exprs]: Exprs[k] extends TypeSet<any, infer Card> ? Card : never;\r\n};\r\n"},{"path":"setImpl.ts","content":"export function set(...args: any[]): any {}\r\n"},{"path":"syntax.ts","content":"import type { TypeSet, setToTsType } from \"./typesystem\";\r\n\r\nexport * from \"./literal\";\r\nexport * from \"./path\";\r\nexport * from \"./set\";\r\nexport * from \"./cast\";\r\nexport * from \"./select\";\r\nexport * from \"./update\";\r\nexport * from \"./insert\";\r\nexport * from \"./group\";\r\nexport * from \"./collections\";\r\nexport * from \"./funcops\";\r\nexport * from \"./for\";\r\nexport * from \"./with\";\r\nexport * from \"./params\";\r\nexport * from \"./globals\";\r\nexport * from \"./detached\";\r\nexport * from \"./toEdgeQL\";\r\nexport * from \"./range\";\r\n\r\nexport type $infer<A extends TypeSet> = setToTsType<A>;\r\n"},{"path":"toEdgeQL.ts","content":"import {\r\n  Duration,\r\n  LocalDate,\r\n  LocalDateTime,\r\n  LocalTime,\r\n  RelativeDuration,\r\n  DateDuration,\r\n  Range,\r\n} from \"edgedb\";\r\nimport {\r\n  Cardinality,\r\n  ExpressionKind,\r\n  OperatorKind,\r\n  TypeKind,\r\n  util,\r\n} from \"edgedb/dist/reflection/index\";\r\nimport {\r\n  type $expr_Array,\r\n  type $expr_NamedTuple,\r\n  type $expr_Tuple,\r\n  type $expr_TuplePath,\r\n  type BaseType,\r\n  type EnumType,\r\n  isArrayType,\r\n  isNamedTupleType,\r\n  isObjectType,\r\n  isTupleType,\r\n  type ObjectType,\r\n  type ObjectTypeSet,\r\n  type RangeType,\r\n  type TypeSet,\r\n} from \"./typesystem\";\r\nimport type { $expr_Literal } from \"./literal\";\r\nimport type {\r\n  $expr_PathLeaf,\r\n  $expr_PathNode,\r\n  $expr_TypeIntersection,\r\n} from \"./path\";\r\nimport { reservedKeywords } from \"edgedb/dist/reflection/index\";\r\nimport type { $expr_Cast } from \"./cast\";\r\nimport type { $expr_Detached } from \"./detached\";\r\nimport type { $expr_For, $expr_ForVar } from \"./for\";\r\nimport type { $expr_Function, $expr_Operator } from \"./funcops\";\r\nimport type { $expr_Insert, $expr_InsertUnlessConflict } from \"./insert\";\r\nimport type { $expr_Param, $expr_WithParams } from \"./params\";\r\nimport type {\r\n  $expr_Delete,\r\n  $expr_Select,\r\n  LimitExpression,\r\n  OffsetExpression,\r\n} from \"./select\";\r\nimport type { $expr_Set } from \"./set\";\r\nimport type { $expr_Update } from \"./update\";\r\nimport type { $expr_Alias, $expr_With } from \"./with\";\r\nimport type { $expr_Group, GroupingSet } from \"./group\";\r\nimport type { $expr_Global } from \"./globals\";\r\n\r\nexport type SomeExpression =\r\n  | $expr_PathNode\r\n  | $expr_PathLeaf\r\n  | $expr_Literal\r\n  | $expr_Set\r\n  | $expr_Array\r\n  | $expr_Tuple\r\n  | $expr_NamedTuple\r\n  | $expr_TuplePath\r\n  | $expr_Cast\r\n  | $expr_Select\r\n  | $expr_Delete\r\n  | $expr_Update\r\n  | $expr_Insert\r\n  | $expr_InsertUnlessConflict\r\n  | $expr_Function\r\n  | $expr_Operator\r\n  | $expr_For\r\n  | $expr_ForVar\r\n  | $expr_TypeIntersection\r\n  | $expr_Alias\r\n  | $expr_With\r\n  | $expr_WithParams\r\n  | $expr_Param\r\n  | $expr_Detached\r\n  | $expr_Group\r\n  | $expr_Global;\r\n\r\ntype WithScopeExpr =\r\n  | $expr_Select\r\n  | $expr_Update\r\n  | $expr_Insert\r\n  | $expr_InsertUnlessConflict\r\n  | $expr_For\r\n  | $expr_Group;\r\n\r\ninterface RenderCtx {\r\n  // mapping withable expr to list of with vars\r\n  withBlocks: Map<WithScopeExpr, Set<SomeExpression>>;\r\n  // metadata about each with var\r\n  withVars: Map<\r\n    SomeExpression,\r\n    {\r\n      name: string;\r\n      scope: WithScopeExpr;\r\n      childExprs: Set<SomeExpression>;\r\n      scopedExpr?: SomeExpression; // scope vars only\r\n    }\r\n  >;\r\n  renderWithVar?: SomeExpression;\r\n  forVars: Map<$expr_ForVar, string>;\r\n  linkProps: Map<SomeExpression, string[]>;\r\n}\r\n\r\nexport function $toEdgeQL(this: any) {\r\n  const walkExprCtx: WalkExprTreeCtx = {\r\n    seen: new Map(),\r\n    rootScope: null,\r\n  };\r\n\r\n  walkExprTree(this, null, walkExprCtx);\r\n\r\n  // get variables by block\r\n  const withBlocks: RenderCtx[\"withBlocks\"] = new Map();\r\n  // get per-variable metadata\r\n  const withVars: RenderCtx[\"withVars\"] = new Map();\r\n  const seen = new Map(walkExprCtx.seen);\r\n  const linkProps: RenderCtx[\"linkProps\"] = new Map();\r\n\r\n  // iterate over all expressions\r\n  for (const [expr, refData] of seen) {\r\n    // delete from seen after visitinng\r\n    seen.delete(expr);\r\n\r\n    // convert referenced link props to simple string array\r\n    if (refData.linkProps.length) {\r\n      linkProps.set(\r\n        expr,\r\n        refData.linkProps.map((linkProp) =>\r\n          linkProp.__parent__.linkName.slice(1)\r\n        )\r\n      );\r\n    }\r\n\r\n    // already extracted\r\n    if (withVars.has(expr)) {\r\n      continue;\r\n    }\r\n\r\n    // ignore unbound leaves, nodes, and intersections\r\n    // these should be rendered as is\r\n    if (\r\n      !refData.boundScope &&\r\n      (expr.__kind__ === ExpressionKind.PathLeaf ||\r\n        expr.__kind__ === ExpressionKind.PathNode ||\r\n        expr.__kind__ === ExpressionKind.TypeIntersection)\r\n    ) {\r\n      continue;\r\n    }\r\n\r\n    // forvars and params should not be hoisted\r\n    if (\r\n      expr.__kind__ === ExpressionKind.ForVar ||\r\n      expr.__kind__ === ExpressionKind.Param\r\n    ) {\r\n      continue;\r\n    }\r\n\r\n    // pull out scope variables\r\n    // from select, update, and group expressions.\r\n    // these are always rendered in with blocks\r\n    if (\r\n      (expr.__kind__ === ExpressionKind.Select ||\r\n        expr.__kind__ === ExpressionKind.Update ||\r\n        expr.__kind__ === ExpressionKind.Group) &&\r\n      expr.__scope__ &&\r\n      // with var not previously registered\r\n      !withVars.has(expr.__scope__ as any)\r\n    ) {\r\n      const withBlock = expr;\r\n      const scopeVar = expr.__scope__ as SomeExpression;\r\n      const scopeVarName = `__scope_${\r\n        withVars.size\r\n      }_${scopeVar.__element__.__name__.replace(/[^A-Za-z]/g, \"\")}`;\r\n\r\n      withVars.set(scopeVar, {\r\n        name: scopeVarName,\r\n        scope: withBlock,\r\n        childExprs: new Set(),\r\n        scopedExpr:\r\n          expr.__element__.__kind__ === TypeKind.object\r\n            ? (expr.__expr__ as any)\r\n            : undefined,\r\n      });\r\n    }\r\n\r\n    // expression should be extracted to with block if\r\n    // - bound with e.with\r\n    // - refcount > 1\r\n    // - aliased with e.alias\r\n    if (\r\n      refData.refCount > 1 ||\r\n      refData.boundScope ||\r\n      refData.aliases.length > 0\r\n    ) {\r\n      // first, check if expr is bound to scope\r\n      let withBlock = refData.boundScope;\r\n\r\n      const parentScopes = [...refData.parentScopes];\r\n\r\n      // if expression is unbound\r\n      if (!withBlock) {\r\n        // if parent scopes haven't all been resolved,\r\n        // re-add current expr to `seen` to be resolved later\r\n        if (\r\n          parentScopes.some(\r\n            (parentScope) => parentScope && seen.has(parentScope)\r\n          )\r\n        ) {\r\n          seen.set(expr, refData);\r\n          continue;\r\n        }\r\n\r\n        if (parentScopes.some((scope) => scope == null)) {\r\n          throw new Error(\r\n            `Cannot extract repeated expression into 'WITH' block, ` +\r\n              `expression used outside of 'WITH'able expression`\r\n          );\r\n        }\r\n\r\n        const [firstParentScopeChain, ...parentScopeChains] = parentScopes.map(\r\n          (scope) => {\r\n            const scopes: WithScopeExpr[] = [scope!];\r\n            const pendingScopes = [scope];\r\n            while (pendingScopes.length) {\r\n              const currentScope = pendingScopes.shift()!;\r\n              pendingScopes.push(\r\n                ...[...walkExprCtx.seen.get(currentScope)!.parentScopes].filter(\r\n                  (s) => s !== null\r\n                )\r\n              );\r\n              if (!scopes.includes(currentScope)) {\r\n                scopes.push(currentScope);\r\n              }\r\n            }\r\n            return scopes;\r\n          }\r\n        );\r\n        const commonParentScope = firstParentScopeChain\r\n          ? firstParentScopeChain.find((scope) =>\r\n              // find the first parent scope in the chain that is shared by\r\n              // the other parent scope chains\r\n              parentScopeChains.every((otherScope) =>\r\n                otherScope.includes(scope)\r\n              )\r\n            )\r\n          : null;\r\n\r\n        withBlock = commonParentScope ?? walkExprCtx.rootScope;\r\n      }\r\n\r\n      if (!withBlock) {\r\n        throw new Error(\r\n          `Cannot extract repeated expression into 'WITH' block, ` +\r\n            `expression does not appear within common 'WITH'able expression`\r\n        );\r\n      }\r\n\r\n      if (!withBlocks.has(withBlock)) {\r\n        withBlocks.set(withBlock, new Set());\r\n      }\r\n\r\n      // check all references and aliases are within this block\r\n      const validScopes = new Set([\r\n        withBlock,\r\n        ...walkExprCtx.seen.get(withBlock)!.childExprs,\r\n      ]);\r\n      for (const scope of [\r\n        ...refData.parentScopes,\r\n        ...util.flatMap(refData.aliases, (alias) => [\r\n          ...walkExprCtx.seen.get(alias)!.parentScopes,\r\n        ]),\r\n      ]) {\r\n        if (scope === null || !validScopes.has(scope)) {\r\n          throw new Error(\r\n            refData.boundScope\r\n              ? `Expr or its aliases used outside of declared 'WITH' block scope`\r\n              : `Cannot extract repeated or aliased expression into 'WITH' block, ` +\r\n                `expression or its aliases appear outside root scope`\r\n          );\r\n        }\r\n      }\r\n\r\n      for (const withVar of [expr, ...refData.aliases]) {\r\n        // withVar is an alias already explicitly bound\r\n        // to an inner WITH block\r\n        const withVarBoundScope = walkExprCtx.seen.get(withVar)!.boundScope;\r\n        if (withVarBoundScope && withVarBoundScope !== refData.boundScope) {\r\n          continue;\r\n        }\r\n\r\n        const withVarName = `__withVar_${withVars.size}`;\r\n\r\n        withBlocks.get(withBlock)!.add(withVar);\r\n        withVars.set(withVar, {\r\n          name: withVarName,\r\n          scope: withBlock,\r\n          childExprs: new Set(walkExprCtx.seen.get(withVar)!.childExprs),\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  let edgeQL = renderEdgeQL(this, {\r\n    withBlocks,\r\n    withVars,\r\n    forVars: new Map(),\r\n    linkProps,\r\n  });\r\n  if (\r\n    edgeQL.startsWith(\"(\") &&\r\n    edgeQL.endsWith(\")\") &&\r\n    !(\r\n      this.__kind__ === ExpressionKind.Tuple ||\r\n      this.__kind__ === ExpressionKind.NamedTuple ||\r\n      this.__kind__ === ExpressionKind.Literal\r\n    )\r\n  ) {\r\n    edgeQL = edgeQL.slice(1, -1);\r\n  }\r\n\r\n  return edgeQL;\r\n}\r\n\r\ninterface WalkExprTreeCtx {\r\n  seen: Map<\r\n    SomeExpression,\r\n    {\r\n      refCount: number;\r\n      // tracks all withable ancestors\r\n      parentScopes: Set<WithScopeExpr | null>;\r\n      // tracks all child exprs\r\n      childExprs: SomeExpression[];\r\n      // tracks bound scope from e.with\r\n      boundScope: WithScopeExpr | null;\r\n      // tracks aliases from e.alias\r\n      aliases: SomeExpression[];\r\n      linkProps: $expr_PathLeaf[];\r\n    }\r\n  >;\r\n  rootScope: WithScopeExpr | null;\r\n}\r\n\r\n// walks entire expression tree\r\n// populates\r\nfunction walkExprTree(\r\n  _expr: TypeSet,\r\n  parentScope: WithScopeExpr | null,\r\n  ctx: WalkExprTreeCtx\r\n): SomeExpression[] {\r\n  if (!(_expr as any).__kind__) {\r\n    throw new Error(\r\n      `Expected a valid querybuilder expression, ` +\r\n        `instead received ${typeof _expr}${\r\n          typeof _expr !== \"undefined\" ? `: '${_expr}'` : \"\"\r\n        }.` +\r\n        getErrorHint(_expr)\r\n    );\r\n  }\r\n\r\n  const expr = _expr as SomeExpression;\r\n\r\n  function walkShape(shape: object) {\r\n    for (let param of Object.values(shape)) {\r\n      if (param.__kind__ === ExpressionKind.PolyShapeElement) {\r\n        param = param.__shapeElement__;\r\n      }\r\n      if (typeof param === \"object\") {\r\n        if (!!(param as any).__kind__) {\r\n          // param is expression\r\n          childExprs.push(...walkExprTree(param as any, expr as any, ctx));\r\n        } else {\r\n          walkShape(param);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // set root scope\r\n  if (!ctx.rootScope && parentScope) {\r\n    ctx.rootScope = parentScope;\r\n  }\r\n\r\n  // return without walking if expression has been seen\r\n  const seenExpr = ctx.seen.get(expr);\r\n  if (seenExpr) {\r\n    seenExpr.refCount += 1;\r\n    // if (seenExpr.refCount > 1) {\r\n    // console.log(`###########\\nSEEN ${seenExpr.refCount} times`);\r\n    // console.log(expr.__kind__);\r\n    // console.log(expr.__element__.__name__);\r\n    // const arg = (expr as any)?.__parent__ || (expr as any)?.__name__;\r\n    // if (arg) console.log(arg);\r\n    // }\r\n    seenExpr.parentScopes.add(parentScope);\r\n    return [expr, ...seenExpr.childExprs];\r\n  }\r\n\r\n  const childExprs: SomeExpression[] = [];\r\n  ctx.seen.set(expr, {\r\n    refCount: 1,\r\n    parentScopes: new Set([parentScope]),\r\n    childExprs,\r\n    boundScope: null,\r\n    aliases: [],\r\n    linkProps: [],\r\n  });\r\n\r\n  switch (expr.__kind__) {\r\n    case ExpressionKind.Alias:\r\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\r\n      ctx.seen.get(expr.__expr__ as any)!.aliases.push(expr);\r\n      break;\r\n    case ExpressionKind.With:\r\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\r\n      for (const refExpr of expr.__refs__) {\r\n        walkExprTree(refExpr, expr.__expr__, ctx);\r\n        const seenRef = ctx.seen.get(refExpr as any)!;\r\n        if (seenRef.boundScope) {\r\n          throw new Error(`Expression bound to multiple 'WITH' blocks`);\r\n        }\r\n        seenRef.boundScope = expr.__expr__;\r\n      }\r\n      break;\r\n    case ExpressionKind.Literal:\r\n    case ExpressionKind.ForVar:\r\n    case ExpressionKind.Param:\r\n      break;\r\n    case ExpressionKind.PathLeaf:\r\n    case ExpressionKind.PathNode:\r\n      if (expr.__parent__) {\r\n        if ((expr.__parent__.type as any).__scopedFrom__) {\r\n          // if parent is scoped expr then don't walk expr\r\n          // since it will already be walked by enclosing select/update\r\n\r\n          childExprs.push(expr.__parent__.type as any);\r\n        } else {\r\n          childExprs.push(\r\n            ...walkExprTree(expr.__parent__.type, parentScope, ctx)\r\n          );\r\n        }\r\n\r\n        if (\r\n          // is link prop\r\n          expr.__kind__ === ExpressionKind.PathLeaf &&\r\n          expr.__parent__.linkName.startsWith(\"@\")\r\n        ) {\r\n          // don't hoist a linkprop that isn't scoped from parentScope\r\n          const parentScopeVar = (parentScope as any).__scope__;\r\n          if (parentScopeVar === expr.__parent__.type) {\r\n            ctx.seen.get(parentScope!)?.linkProps.push(expr);\r\n          }\r\n        }\r\n      }\r\n      break;\r\n    case ExpressionKind.Cast:\r\n      if (expr.__expr__ === null) break;\r\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\r\n      break;\r\n    case ExpressionKind.Set:\r\n      for (const subExpr of expr.__exprs__) {\r\n        childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\r\n      }\r\n      break;\r\n    case ExpressionKind.Array:\r\n      for (const subExpr of expr.__items__) {\r\n        childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\r\n      }\r\n      break;\r\n    case ExpressionKind.Tuple:\r\n      for (const subExpr of expr.__items__) {\r\n        childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\r\n      }\r\n      break;\r\n    case ExpressionKind.NamedTuple:\r\n      for (const subExpr of Object.values(expr.__shape__)) {\r\n        childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\r\n      }\r\n      break;\r\n    case ExpressionKind.TuplePath:\r\n      childExprs.push(...walkExprTree(expr.__parent__, parentScope, ctx));\r\n      break;\r\n    case ExpressionKind.Select:\r\n    case ExpressionKind.Update: {\r\n      const modifiers = expr.__modifiers__;\r\n      if (modifiers.filter) {\r\n        childExprs.push(...walkExprTree(modifiers.filter, expr, ctx));\r\n      }\r\n      if (modifiers.order_by) {\r\n        for (const orderExpr of modifiers.order_by) {\r\n          childExprs.push(...walkExprTree(orderExpr.expression, expr, ctx));\r\n        }\r\n      }\r\n      if (modifiers.offset) {\r\n        childExprs.push(...walkExprTree(modifiers.offset!, expr, ctx));\r\n      }\r\n      if (modifiers.limit) {\r\n        childExprs.push(...walkExprTree(modifiers.limit!, expr, ctx));\r\n      }\r\n\r\n      if (expr.__kind__ === ExpressionKind.Select) {\r\n        if (\r\n          isObjectType(expr.__element__) &&\r\n          // don't walk shape twice if select expr justs wrap another object\r\n          // type expr with the same shape\r\n          expr.__element__.__shape__ !==\r\n            (expr.__expr__ as ObjectTypeSet).__element__.__shape__\r\n        ) {\r\n          walkShape(expr.__element__.__shape__ ?? {});\r\n        }\r\n      } else {\r\n        // Update\r\n        const shape: any = expr.__shape__ ?? {};\r\n\r\n        for (const _element of Object.values(shape)) {\r\n          let element: any = _element;\r\n          if (!element.__element__) {\r\n            if (element[\"+=\"]) element = element[\"+=\"];\r\n            else if (element[\"-=\"]) element = element[\"-=\"];\r\n          }\r\n          childExprs.push(...walkExprTree(element as any, expr, ctx));\r\n        }\r\n      }\r\n\r\n      childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\r\n      break;\r\n    }\r\n    case ExpressionKind.Delete: {\r\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\r\n      break;\r\n    }\r\n    case ExpressionKind.Insert: {\r\n      const shape: any = expr.__shape__ ?? {};\r\n\r\n      for (const element of Object.values(shape)) {\r\n        childExprs.push(...walkExprTree(element as any, expr, ctx));\r\n      }\r\n\r\n      childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\r\n      break;\r\n    }\r\n    case ExpressionKind.InsertUnlessConflict: {\r\n      // InsertUnlessConflict doesn't create a new scope, the parent scope of\r\n      // child expressions is the wrapped Insert expr\r\n      const insertChildExprs: SomeExpression[] = [];\r\n      if (expr.__conflict__.on) {\r\n        insertChildExprs.push(\r\n          ...walkExprTree(\r\n            expr.__conflict__.on,\r\n            expr.__expr__ as $expr_Insert,\r\n            ctx\r\n          )\r\n        );\r\n      }\r\n      if (expr.__conflict__.else) {\r\n        insertChildExprs.push(\r\n          ...walkExprTree(\r\n            expr.__conflict__.else,\r\n            expr.__expr__ as $expr_Insert,\r\n            ctx\r\n          )\r\n        );\r\n      }\r\n\r\n      walkExprTree(expr.__expr__, parentScope, ctx);\r\n      ctx.seen\r\n        .get(expr.__expr__ as $expr_Insert)!\r\n        .childExprs.push(...insertChildExprs);\r\n      break;\r\n    }\r\n    case ExpressionKind.Group: {\r\n      const groupingSet = expr.__modifiers__.by as any as GroupingSet;\r\n      // const groupingSet = expr.__grouping__ as any as GroupingSet;\r\n      for (const [_k, groupExpr] of groupingSet.__exprs__) {\r\n        // this prevents recurring grouping elements from being walked twice\r\n        // this way, these won't get pulled into with blocks,\r\n        // which is good because they need to be rendered in `using`\r\n        const seen: Set<any> = new Set();\r\n        if (!seen.has(expr)) {\r\n          childExprs.push(...walkExprTree(groupExpr, expr, ctx));\r\n          seen.add(expr);\r\n        }\r\n      }\r\n\r\n      if (!expr.__element__.__shape__.elements.__element__.__shape__) {\r\n        throw new Error(\"Missing shape in GROUP statement\");\r\n      }\r\n      walkShape(expr.__element__.__shape__.elements.__element__.__shape__);\r\n      childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\r\n      break;\r\n    }\r\n    case ExpressionKind.TypeIntersection:\r\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\r\n      break;\r\n    case ExpressionKind.Operator:\r\n    case ExpressionKind.Function:\r\n      for (const subExpr of expr.__args__) {\r\n        if (Array.isArray(subExpr)) {\r\n          for (const arg of subExpr) {\r\n            if (arg) childExprs.push(...walkExprTree(arg, parentScope, ctx));\r\n          }\r\n        } else {\r\n          childExprs.push(...walkExprTree(subExpr!, parentScope, ctx));\r\n        }\r\n      }\r\n      if (expr.__kind__ === ExpressionKind.Function) {\r\n        for (const subExpr of Object.values(expr.__namedargs__)) {\r\n          childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\r\n        }\r\n      }\r\n      break;\r\n    case ExpressionKind.For: {\r\n      childExprs.push(...walkExprTree(expr.__iterSet__ as any, expr, ctx));\r\n      childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\r\n      break;\r\n    }\r\n    case ExpressionKind.WithParams: {\r\n      if (parentScope !== null) {\r\n        throw new Error(\r\n          `'withParams' does not support being used as a nested expression`\r\n        );\r\n      }\r\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\r\n      break;\r\n    }\r\n    case ExpressionKind.Detached: {\r\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\r\n      break;\r\n    }\r\n    case ExpressionKind.Global:\r\n      break;\r\n    default:\r\n      util.assertNever(\r\n        expr,\r\n        new Error(`Unrecognized expression kind: \"${(expr as any).__kind__}\"`)\r\n      );\r\n  }\r\n\r\n  return [expr, ...childExprs];\r\n}\r\n\r\nfunction renderEdgeQL(\r\n  _expr: TypeSet,\r\n  ctx: RenderCtx,\r\n  renderShape: boolean = true,\r\n  noImplicitDetached: boolean = false\r\n): string {\r\n  if (!(_expr as any).__kind__) {\r\n    throw new Error(\"Invalid expression.\");\r\n  }\r\n  const expr = _expr as SomeExpression;\r\n\r\n  // if expression is in a with block\r\n  // render its name\r\n  const withVar = ctx.withVars.get(expr);\r\n\r\n  if (withVar && ctx.renderWithVar !== expr) {\r\n    return renderShape &&\r\n      expr.__kind__ === ExpressionKind.Select &&\r\n      isObjectType(expr.__element__)\r\n      ? `(${withVar.name} ${shapeToEdgeQL(\r\n          (expr.__element__.__shape__ || {}) as object,\r\n          ctx,\r\n          null,\r\n          true // render shape only\r\n        )})`\r\n      : withVar.name;\r\n  }\r\n\r\n  // render with block expression\r\n  function renderWithBlockExpr(\r\n    varExpr: SomeExpression,\r\n    _noImplicitDetached?: boolean\r\n  ) {\r\n    const withBlockElement = ctx.withVars.get(varExpr)!;\r\n    let renderedExpr = renderEdgeQL(\r\n      withBlockElement.scopedExpr ?? varExpr,\r\n      {\r\n        ...ctx,\r\n        renderWithVar: varExpr,\r\n      },\r\n      !withBlockElement.scopedExpr, // render shape if no scopedExpr exists\r\n      _noImplicitDetached\r\n    );\r\n    const renderedExprNoDetached = renderEdgeQL(\r\n      withBlockElement.scopedExpr ?? varExpr,\r\n      {\r\n        ...ctx,\r\n        renderWithVar: varExpr,\r\n      },\r\n      !withBlockElement.scopedExpr, // render shape if no scopedExpr exists\r\n      true\r\n    );\r\n\r\n    if (ctx.linkProps.has(expr)) {\r\n      renderedExpr = `(SELECT ${renderedExpr} {\\n${ctx.linkProps\r\n        .get(expr)!\r\n        .map(\r\n          (linkPropName) =>\r\n            `  __linkprop_${linkPropName} := ${renderedExprNoDetached}@${linkPropName}`\r\n        )\r\n        .join(\",\\n\")}\\n})`;\r\n    }\r\n    return `  ${withBlockElement.name} := ${\r\n      renderedExpr.includes(\"\\n\")\r\n        ? `(\\n${indent(\r\n            renderedExpr[0] === \"(\" &&\r\n              renderedExpr[renderedExpr.length - 1] === \")\"\r\n              ? renderedExpr.slice(1, -1)\r\n              : renderedExpr,\r\n            4\r\n          )}\\n  )`\r\n        : renderedExpr\r\n    }`;\r\n  }\r\n\r\n  // extract scope expression from select/update if exists\r\n  const scopeExpr =\r\n    (expr.__kind__ === ExpressionKind.Select ||\r\n      expr.__kind__ === ExpressionKind.Update ||\r\n      expr.__kind__ === ExpressionKind.Group) &&\r\n    ctx.withVars.has(expr.__scope__ as any)\r\n      ? (expr.__scope__ as SomeExpression)\r\n      : undefined;\r\n\r\n  const scopeExprVar: string[] = [];\r\n  const unscopedWithBlock: string[] = [];\r\n  const scopedWithBlock: string[] = [];\r\n\r\n  // generate with block if needed\r\n  if (ctx.withBlocks.has(expr as any) || scopeExpr) {\r\n    // sort associated vars\r\n    const sortedBlockVars = topoSortWithVars(\r\n      ctx.withBlocks.get(expr as any) ?? new Set(),\r\n      ctx\r\n    );\r\n\r\n    if (!scopeExpr) {\r\n      // if no scope expression exists, all variables are unscoped\r\n      unscopedWithBlock.push(\r\n        ...sortedBlockVars.map((blockVar) => renderWithBlockExpr(blockVar))\r\n      );\r\n    }\r\n    // else if (expr.__kind__ === ExpressionKind.Group) {\r\n    //   // add all vars into scoped with block\r\n    //   // this is rendered inside the `using` clause later\r\n    //   // no need for the with/for trick\r\n    //   scopeExprVar.push(renderWithBlockExpr(scopeExpr, noImplicitDetached));\r\n    //   scopedWithBlock.push(\r\n    //     ...sortedBlockVars.map(blockVar => renderWithBlockExpr(blockVar))\r\n    //   );\r\n    // }\r\n    else {\r\n      // get scope variable\r\n      const scopeVar = ctx.withVars.get(scopeExpr)!;\r\n\r\n      // get list of with vars that reference scope\r\n      const scopedVars = sortedBlockVars.filter((blockVarExpr) =>\r\n        ctx.withVars.get(blockVarExpr)?.childExprs.has(scopeExpr)\r\n      );\r\n      // filter blockvars to only include vars that don't reference scope\r\n      unscopedWithBlock.push(\r\n        ...sortedBlockVars\r\n          .filter((blockVar) => !scopedVars.includes(blockVar))\r\n          .map((blockVar) => renderWithBlockExpr(blockVar))\r\n      );\r\n\r\n      // when rendering `with` variables that reference current scope\r\n      // they are extracted into computed properties defining in a for loop\r\n      if (!scopedVars.length) {\r\n        scopeExprVar.push(renderWithBlockExpr(scopeExpr, noImplicitDetached));\r\n      } else {\r\n        const scopeName = scopeVar.name;\r\n\r\n        // render a reference to scoped path (e.g. \".nemesis\")\r\n        scopeVar.name = scopeName + \"_expr\";\r\n        scopeExprVar.push(renderWithBlockExpr(scopeExpr, noImplicitDetached));\r\n        // scopedWithBlock.push(\r\n        //   renderWithBlockExpr(scopeExpr, noImplicitDetached)\r\n        // );\r\n\r\n        // render a for loop containing all scoped block vars\r\n        // as computed properties\r\n        scopeVar.name = scopeName + \"_inner\";\r\n        scopeExprVar.push(\r\n          `  ${scopeName} := (FOR ${scopeVar.name} IN {${\r\n            scopeName + \"_expr\"\r\n          }} UNION (\\n    WITH\\n${indent(\r\n            scopedVars\r\n              .map((blockVar) => renderWithBlockExpr(blockVar))\r\n              .join(\",\\n\"),\r\n            4\r\n          )}\\n    SELECT ${scopeVar.name} {\\n${scopedVars\r\n            .map((blockVar) => {\r\n              const name = ctx.withVars.get(blockVar)!.name;\r\n              return `      ${name} := ${name}`;\r\n            })\r\n            .join(\",\\n\")}\\n    }\\n  ))`\r\n        );\r\n\r\n        // change var name back to original value\r\n        scopeVar.name = scopeName;\r\n\r\n        // reassign name for all scoped block vars\r\n        for (const blockVarExpr of scopedVars) {\r\n          const blockVar = ctx.withVars.get(blockVarExpr)!;\r\n          blockVar.name = `${scopeName}.${blockVar.name}`;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  const withBlockElements = [\r\n    ...unscopedWithBlock,\r\n    ...scopeExprVar,\r\n    ...scopedWithBlock,\r\n  ];\r\n  const withBlock = withBlockElements.length\r\n    ? `WITH\\n${withBlockElements.join(\",\\n\")}\\n`\r\n    : \"\";\r\n\r\n  if (expr.__kind__ === ExpressionKind.With) {\r\n    return renderEdgeQL(expr.__expr__, ctx);\r\n  } else if (expr.__kind__ === ExpressionKind.WithParams) {\r\n    return `(WITH\\n${expr.__params__\r\n      .map((param) => {\r\n        const optional =\r\n          param.__cardinality__ === Cardinality.AtMostOne ? \"OPTIONAL \" : \"\";\r\n        let paramExpr: string;\r\n        if (param.__isComplex__) {\r\n          let cast = param.__element__.__name__;\r\n          cast = cast.includes(\"std::decimal\")\r\n            ? `<${cast}><${cast.replace(/std::decimal/g, \"std::str\")}>`\r\n            : `<${cast}>`;\r\n          paramExpr = `${cast}to_json(<${optional}str>$${param.__name__})`;\r\n        } else {\r\n          paramExpr = `<${optional}${param.__element__.__name__}>$${param.__name__}`;\r\n        }\r\n        return `  __param__${param.__name__} := ${paramExpr}`;\r\n      })\r\n      .join(\",\\n\")}\\nSELECT ${renderEdgeQL(expr.__expr__, ctx)})`;\r\n  } else if (expr.__kind__ === ExpressionKind.Alias) {\r\n    const aliasedExprVar = ctx.withVars.get(expr.__expr__ as any);\r\n    if (!aliasedExprVar) {\r\n      throw new Error(\r\n        `Expression referenced by alias does not exist in 'WITH' block`\r\n      );\r\n    }\r\n    return aliasedExprVar.name;\r\n  } else if (\r\n    expr.__kind__ === ExpressionKind.PathNode ||\r\n    expr.__kind__ === ExpressionKind.PathLeaf\r\n  ) {\r\n    if (!expr.__parent__) {\r\n      return `${noImplicitDetached ? \"\" : \"DETACHED \"}${\r\n        expr.__element__.__name__\r\n      }`;\r\n    } else {\r\n      const isScopedLinkProp =\r\n        expr.__parent__.linkName.startsWith(\"@\") &&\r\n        ctx.withVars.has(expr.__parent__.type as any);\r\n      const linkName = isScopedLinkProp\r\n        ? `__linkprop_${expr.__parent__.linkName.slice(1)}`\r\n        : expr.__parent__.linkName;\r\n      const parent = renderEdgeQL(\r\n        expr.__parent__.type,\r\n        ctx,\r\n        false,\r\n        noImplicitDetached\r\n      );\r\n      return `${parent}${linkName.startsWith(\"@\") ? \"\" : \".\"}${q(linkName)}`;\r\n    }\r\n  } else if (expr.__kind__ === ExpressionKind.Literal) {\r\n    return literalToEdgeQL(expr.__element__, expr.__value__);\r\n  } else if (expr.__kind__ === ExpressionKind.Set) {\r\n    const exprs = expr.__exprs__;\r\n\r\n    if (\r\n      exprs.every((ex) => ex.__element__.__kind__ === TypeKind.object) ||\r\n      exprs.every((ex) => ex.__element__.__kind__ !== TypeKind.object)\r\n    ) {\r\n      if (exprs.length === 0) return `<${expr.__element__.__name__}>{}`;\r\n      return `{ ${exprs.map((ex) => renderEdgeQL(ex, ctx)).join(\", \")} }`;\r\n    } else {\r\n      throw new Error(\r\n        `Invalid arguments to set constructor: ${exprs\r\n          .map((ex) => ex.__element__.__name__)\r\n          .join(\", \")}`\r\n      );\r\n    }\r\n  } else if (expr.__kind__ === ExpressionKind.Array) {\r\n    return `[${expr.__items__\r\n      .map((item) => renderEdgeQL(item, ctx))\r\n      .join(\", \")}]`;\r\n  } else if (expr.__kind__ === ExpressionKind.Tuple) {\r\n    return `(\\n${expr.__items__\r\n      .map(\r\n        (item) =>\r\n          `  ` + renderEdgeQL(item, ctx, renderShape, noImplicitDetached)\r\n      )\r\n      .join(\",\\n\")}${expr.__items__.length === 1 ? \",\" : \"\"}\\n)`;\r\n  } else if (expr.__kind__ === ExpressionKind.NamedTuple) {\r\n    return `(\\n${Object.keys(expr.__shape__)\r\n      .map(\r\n        (key) =>\r\n          `  ${key} := ${renderEdgeQL(\r\n            expr.__shape__[key]!,\r\n            ctx,\r\n            renderShape,\r\n            noImplicitDetached\r\n          )}`\r\n      )\r\n      .join(\",\\n\")}\\n)`;\r\n  } else if (expr.__kind__ === ExpressionKind.TuplePath) {\r\n    return `${renderEdgeQL(expr.__parent__, ctx)}.${expr.__index__}`;\r\n  } else if (expr.__kind__ === ExpressionKind.Cast) {\r\n    const typeName =\r\n      expr.__element__.__name__ === \"std::number\"\r\n        ? \"std::float64\"\r\n        : expr.__element__.__name__;\r\n    if (expr.__expr__ === null) {\r\n      return `<${typeName}>{}`;\r\n    }\r\n    return `<${typeName}>(${renderEdgeQL(expr.__expr__, ctx)})`;\r\n  } else if (expr.__kind__ === ExpressionKind.Select) {\r\n    const lines: string[] = [];\r\n    if (isObjectType(expr.__element__)) {\r\n      const selectionTarget = renderEdgeQL(\r\n        expr.__scope__ ?? expr.__expr__,\r\n        ctx,\r\n        false\r\n      );\r\n\r\n      lines.push(\r\n        `SELECT${\r\n          selectionTarget === \"DETACHED std::FreeObject\"\r\n            ? \"\"\r\n            : ` ${selectionTarget}`\r\n        }`\r\n      );\r\n\r\n      if (\r\n        expr.__element__.__shape__ !==\r\n        (expr.__expr__ as ObjectTypeSet).__element__.__shape__\r\n      ) {\r\n        lines.push(\r\n          shapeToEdgeQL(\r\n            (expr.__element__.__shape__ || {}) as object,\r\n            ctx,\r\n            expr.__element__\r\n          )\r\n        );\r\n      }\r\n    } else {\r\n      // non-object/non-shape select expression\r\n      const needsScalarVar =\r\n        (expr.__modifiers__.filter ||\r\n          expr.__modifiers__.order_by ||\r\n          expr.__modifiers__.offset ||\r\n          expr.__modifiers__.limit) &&\r\n        !ctx.withVars.has(expr.__expr__ as any);\r\n\r\n      lines.push(\r\n        `SELECT ${needsScalarVar ? \"_ := \" : \"\"}${renderEdgeQL(\r\n          expr.__expr__,\r\n          ctx\r\n        )}`\r\n      );\r\n\r\n      if (needsScalarVar) {\r\n        ctx = { ...ctx, withVars: new Map(ctx.withVars) };\r\n        ctx.withVars.set(expr.__expr__ as any, {\r\n          name: \"_\",\r\n          childExprs: new Set(),\r\n          scope: expr,\r\n        });\r\n      }\r\n    }\r\n\r\n    const modifiers: string[] = [];\r\n\r\n    if (expr.__modifiers__.filter) {\r\n      modifiers.push(`FILTER ${renderEdgeQL(expr.__modifiers__.filter, ctx)}`);\r\n    }\r\n    if (expr.__modifiers__.order_by) {\r\n      modifiers.push(\r\n        ...expr.__modifiers__.order_by.map(\r\n          ({ expression, direction, empty }, i) => {\r\n            return `${i === 0 ? \"ORDER BY\" : \"  THEN\"} ${renderEdgeQL(\r\n              expression,\r\n              ctx\r\n            )}${direction ? \" \" + direction : \"\"}${empty ? \" \" + empty : \"\"}`;\r\n          }\r\n        )\r\n      );\r\n    }\r\n    if (expr.__modifiers__.offset) {\r\n      modifiers.push(\r\n        `OFFSET ${renderEdgeQL(\r\n          expr.__modifiers__.offset as OffsetExpression,\r\n          ctx\r\n        )}`\r\n      );\r\n    }\r\n    if (expr.__modifiers__.limit) {\r\n      modifiers.push(\r\n        `LIMIT ${renderEdgeQL(\r\n          expr.__modifiers__.limit as LimitExpression,\r\n          ctx\r\n        )}`\r\n      );\r\n    }\r\n\r\n    // without assert_single, the query will return a more informative\r\n    // CardinalityMismatchError when the query returns more than one result\r\n    return (\r\n      // (expr.__modifiers__.singleton ? `select assert_single((` : ``) +\r\n      \"(\" +\r\n      withBlock +\r\n      lines.join(\" \") +\r\n      (modifiers.length ? \"\\n\" + modifiers.join(\"\\n\") : \"\") +\r\n      \")\"\r\n      // + (expr.__modifiers__.singleton ? `))` : ``)\r\n    );\r\n  } else if (expr.__kind__ === ExpressionKind.Update) {\r\n    return `(${withBlock}UPDATE ${renderEdgeQL(expr.__scope__, ctx, false)}${\r\n      expr.__modifiers__.filter\r\n        ? `\\nFILTER ${renderEdgeQL(expr.__modifiers__.filter, ctx)}\\n`\r\n        : \" \"\r\n    }SET ${shapeToEdgeQL(expr.__shape__, ctx, null, false, false)})`;\r\n  } else if (expr.__kind__ === ExpressionKind.Delete) {\r\n    return `(${withBlock}DELETE ${renderEdgeQL(\r\n      expr.__expr__,\r\n      ctx,\r\n      undefined,\r\n      noImplicitDetached\r\n    )})`;\r\n  } else if (expr.__kind__ === ExpressionKind.Insert) {\r\n    return `(${withBlock}INSERT ${renderEdgeQL(\r\n      expr.__expr__,\r\n      ctx,\r\n      false,\r\n      true\r\n    )} ${shapeToEdgeQL(expr.__shape__, ctx, null, false, false)})`;\r\n  } else if (expr.__kind__ === ExpressionKind.InsertUnlessConflict) {\r\n    const $on = expr.__conflict__.on;\r\n    const $else = expr.__conflict__.else;\r\n    const clause: string[] = [];\r\n    if (!$on) {\r\n      clause.push(\"\\nUNLESS CONFLICT\");\r\n    }\r\n    if ($on) {\r\n      clause.push(\r\n        `\\nUNLESS CONFLICT ON ${renderEdgeQL($on, ctx, false, true)}`\r\n      );\r\n    }\r\n    if ($else) {\r\n      clause.push(`\\nELSE (${renderEdgeQL($else, ctx, true, true)})`);\r\n    }\r\n    return `(${renderEdgeQL(expr.__expr__, ctx, false, true).slice(\r\n      1,\r\n      -1\r\n    )}${clause.join(\"\")})`;\r\n  } else if (expr.__kind__ === ExpressionKind.Group) {\r\n    const groupingSet = expr.__modifiers__.by as any as GroupingSet;\r\n    const elementsShape =\r\n      expr.__element__.__shape__.elements.__element__.__shape__;\r\n\r\n    const selectStatement: string[] = [];\r\n    const groupStatement: string[] = [];\r\n\r\n    const groupTarget = renderEdgeQL(expr.__scope__, ctx, false);\r\n    groupStatement.push(`GROUP ${groupTarget}`);\r\n\r\n    // render scoped withvars in using\r\n    const combinedBlock = [\r\n      // ...scopedWithBlock,\r\n      // this is deduplicated in e.group\r\n      ...groupingSet.__exprs__.map(\r\n        ([k, v]) => `  ${k} := ${renderEdgeQL(v, ctx)}`\r\n      ),\r\n    ];\r\n    groupStatement.push(`USING\\n${combinedBlock.join(\",\\n\")}`);\r\n\r\n    let by = renderGroupingSet(groupingSet).trim();\r\n    if (by[0] === \"(\" && by[by.length - 1] === \")\") {\r\n      by = by.slice(1, by.length - 1);\r\n    }\r\n    groupStatement.push(`BY ` + by);\r\n\r\n    // clause.push(withBlock.trim());\r\n\r\n    // render scope var and any unscoped withVars in with block\r\n    const selectTarget = `${groupTarget}_groups`;\r\n    selectStatement.push(\r\n      `WITH\\n${[\r\n        ...unscopedWithBlock,\r\n        ...scopeExprVar,\r\n        // ...scopedWithBlock,\r\n      ].join(\",\\n\")},\r\n  ${selectTarget} := (\r\n${indent(groupStatement.join(\"\\n\"), 4)}\r\n)`\r\n    );\r\n\r\n    // rename scope var to fix all scope references that\r\n    // occur in the `elements` subshape\r\n    const scopeVar = ctx.withVars.get(expr.__scope__ as any);\r\n\r\n    // replace references to __scope__ with\r\n    // .elements reference\r\n    const elementsShapeQuery = indent(\r\n      shapeToEdgeQL(elementsShape as object, { ...ctx }, expr.__element__),\r\n      2\r\n    )\r\n      .trim()\r\n      .split(scopeVar!.name + \".\")\r\n      .join(`${selectTarget}.elements.`);\r\n\r\n    selectStatement.push(`SELECT ${selectTarget} {\r\n  key: {${groupingSet.__exprs__.map((e) => e[0]).join(\", \")}},\r\n  grouping,\r\n  elements: ${elementsShapeQuery}\r\n}`);\r\n    return `(${selectStatement.join(\"\\n\")})`;\r\n  } else if (expr.__kind__ === ExpressionKind.Function) {\r\n    const args = expr.__args__.map(\r\n      (arg) => `${renderEdgeQL(arg!, ctx, false)}`\r\n    );\r\n    for (const [key, arg] of Object.entries(expr.__namedargs__)) {\r\n      args.push(`${q(key)} := ${renderEdgeQL(arg, ctx, false)}`);\r\n    }\r\n    return `${expr.__name__}(${args.join(\", \")})`;\r\n  } else if (expr.__kind__ === ExpressionKind.Operator) {\r\n    const operator = expr.__name__;\r\n    const args = expr.__args__;\r\n    switch (expr.__opkind__) {\r\n      case OperatorKind.Infix:\r\n        if (operator === \"[]\") {\r\n          let index = \"\";\r\n          if (Array.isArray(args[1])) {\r\n            const [start, end] = args[1];\r\n            if (start) {\r\n              index += renderEdgeQL(start, ctx);\r\n            }\r\n            index += \":\";\r\n            if (end) {\r\n              index += renderEdgeQL(end, ctx);\r\n            }\r\n          } else {\r\n            index = renderEdgeQL(args[1]!, ctx);\r\n          }\r\n\r\n          return `${renderEdgeQL(args[0]!, ctx)}[${index}]`;\r\n        }\r\n        return `(${renderEdgeQL(args[0]!, ctx)} ${operator} ${renderEdgeQL(\r\n          args[1]!,\r\n          ctx\r\n        )})`;\r\n      case OperatorKind.Postfix:\r\n        return `(${renderEdgeQL(args[0]!, ctx)} ${operator})`;\r\n      case OperatorKind.Prefix:\r\n        return `(${operator} ${renderEdgeQL(args[0]!, ctx)})`;\r\n      case OperatorKind.Ternary:\r\n        if (operator === \"if_else\") {\r\n          return `(${renderEdgeQL(args[0]!, ctx)} IF ${renderEdgeQL(\r\n            args[1]!,\r\n            ctx\r\n          )} ELSE ${renderEdgeQL(args[2]!, ctx)})`;\r\n        } else {\r\n          throw new Error(`Unknown operator: ${operator}`);\r\n        }\r\n      default:\r\n        util.assertNever(\r\n          expr.__opkind__,\r\n          new Error(`Unknown operator kind: ${expr.__opkind__}`)\r\n        );\r\n    }\r\n  } else if (expr.__kind__ === ExpressionKind.TypeIntersection) {\r\n    return `${renderEdgeQL(expr.__expr__, ctx)}[IS ${\r\n      expr.__element__.__name__\r\n    }]`;\r\n  } else if (expr.__kind__ === ExpressionKind.For) {\r\n    ctx.forVars.set(expr.__forVar__, `__forVar__${ctx.forVars.size}`);\r\n    return `(${withBlock}FOR ${ctx.forVars.get(\r\n      expr.__forVar__\r\n    )} IN {${renderEdgeQL(expr.__iterSet__, ctx)}}\r\nUNION (\\n${indent(renderEdgeQL(expr.__expr__, ctx), 2)}\\n))`;\r\n  } else if (expr.__kind__ === ExpressionKind.ForVar) {\r\n    const forVar = ctx.forVars.get(expr);\r\n    if (!forVar) {\r\n      throw new Error(`'FOR' loop variable used outside of 'FOR' loop`);\r\n    }\r\n    return forVar;\r\n  } else if (expr.__kind__ === ExpressionKind.Param) {\r\n    return `__param__${expr.__name__}`;\r\n  } else if (expr.__kind__ === ExpressionKind.Detached) {\r\n    return `(DETACHED ${renderEdgeQL(\r\n      expr.__expr__,\r\n      {\r\n        ...ctx,\r\n        renderWithVar: expr.__expr__ as any,\r\n      },\r\n      undefined,\r\n      true\r\n    )})`;\r\n  } else if (expr.__kind__ === ExpressionKind.Global) {\r\n    return `(GLOBAL ${expr.__name__})`;\r\n  } else {\r\n    util.assertNever(\r\n      expr,\r\n      new Error(`Unrecognized expression kind: \"${(expr as any).__kind__}\"`)\r\n    );\r\n  }\r\n}\r\n\r\nfunction isGroupingSet(arg: any): arg is GroupingSet {\r\n  return arg.__kind__ === \"groupingset\";\r\n}\r\n\r\n// recursive renderer\r\nfunction renderGroupingSet(set: GroupingSet): string {\r\n  const contents = Object.entries(set.__elements__)\r\n    .map(([k, v]) => {\r\n      return isGroupingSet(v) ? renderGroupingSet(v) : k;\r\n    })\r\n    .join(\", \");\r\n  if (set.__settype__ === \"tuple\") {\r\n    return `(${contents})`;\r\n  } else if (set.__settype__ === \"set\") {\r\n    return `{${contents}}`;\r\n  } else if (set.__settype__ === \"cube\") {\r\n    return `cube(${contents})`;\r\n  } else if (set.__settype__ === \"rollup\") {\r\n    return `rollup(${contents})`;\r\n  } else {\r\n    throw new Error(`Unrecognized set type: \"${set.__settype__}\"`);\r\n  }\r\n}\r\n\r\nfunction shapeToEdgeQL(\r\n  shape: object | null,\r\n  ctx: RenderCtx,\r\n  type: ObjectType | null = null,\r\n  keysOnly: boolean = false,\r\n  injectImplicitId: boolean = true\r\n) {\r\n  const pointers = type?.__pointers__ || null;\r\n  const isFreeObject = type?.__name__ === \"std::FreeObject\";\r\n  if (shape === null) {\r\n    return ``;\r\n  }\r\n\r\n  const lines: string[] = [];\r\n  const addLine = (line: string) =>\r\n    lines.push(`${keysOnly ? \"\" : \"  \"}${line}`);\r\n\r\n  const seen = new Set();\r\n\r\n  for (const key in shape) {\r\n    if (!shape.hasOwnProperty(key)) continue;\r\n    if (seen.has(key)) {\r\n      // tslint:disable-next-line\r\n      console.warn(`Invalid: duplicate key \"${key}\"`);\r\n      continue;\r\n    }\r\n    seen.add(key);\r\n    let val = (shape as any)[key];\r\n    let operator = \":=\";\r\n    let polyType: SomeExpression | null = null;\r\n\r\n    if (typeof val === \"object\" && !val.__element__) {\r\n      if (!!val[\"+=\"]) {\r\n        operator = \"+=\";\r\n        val = val[\"+=\"];\r\n      } else if (!!val[\"-=\"]) {\r\n        operator = \"-=\";\r\n        val = val[\"-=\"];\r\n      }\r\n    }\r\n    if (val.__kind__ === ExpressionKind.PolyShapeElement) {\r\n      polyType = val.__polyType__;\r\n      val = val.__shapeElement__;\r\n    }\r\n    const polyIntersection = polyType\r\n      ? `[IS ${polyType.__element__.__name__}].`\r\n      : \"\";\r\n\r\n    // For computed properties in select shapes, inject the expected\r\n    // cardinality inferred by the query builder. This ensures the actual\r\n    // type returned by the server matches the inferred return type, or an\r\n    // explicit error is thrown, instead of a silent mismatch between\r\n    // actual and inferred type.\r\n    // Add annotations on FreeObjects, despite the existence of a pointer.\r\n    const ptr = pointers?.[key];\r\n    const addCardinalityAnnotations = pointers && (!ptr || isFreeObject);\r\n\r\n    const expectedCardinality =\r\n      addCardinalityAnnotations && val.hasOwnProperty(\"__cardinality__\")\r\n        ? val.__cardinality__ === Cardinality.Many ||\r\n          val.__cardinality__ === Cardinality.AtLeastOne\r\n          ? \"multi \"\r\n          : \"single \"\r\n        : \"\";\r\n\r\n    // if selecting a required multi link, wrap expr in 'assert_exists'\r\n    const wrapAssertExists = ptr?.cardinality === Cardinality.AtLeastOne;\r\n\r\n    if (typeof val === \"boolean\") {\r\n      if (\r\n        !pointers?.[key] &&\r\n        key[0] !== \"@\" &&\r\n        type &&\r\n        type?.__name__ !== \"std::FreeObject\" &&\r\n        !polyIntersection\r\n      ) {\r\n        throw new Error(`Field \"${key}\" does not exist in ${type?.__name__}`);\r\n      }\r\n      if (val) {\r\n        addLine(`${polyIntersection}${q(key)}`);\r\n      }\r\n      continue;\r\n    }\r\n\r\n    if (typeof val !== \"object\") {\r\n      throw new Error(`Invalid shape element at \"${key}\".`);\r\n    }\r\n\r\n    const valIsExpression = val.hasOwnProperty(\"__kind__\");\r\n\r\n    // is subshape\r\n    if (!valIsExpression) {\r\n      addLine(\r\n        `${polyIntersection}${q(key, false)}: ${indent(\r\n          shapeToEdgeQL(val, ctx, ptr?.target),\r\n          2\r\n        ).trim()}`\r\n      );\r\n      continue;\r\n    }\r\n\r\n    // val is expression\r\n\r\n    // is computed\r\n    if (keysOnly) {\r\n      addLine(\r\n        q(key, false) +\r\n          (isObjectType(val.__element__)\r\n            ? `: ${shapeToEdgeQL(val.__element__.__shape__, ctx, null, true)}`\r\n            : \"\")\r\n      );\r\n      continue;\r\n    }\r\n    const renderedExpr = renderEdgeQL(val, ctx);\r\n\r\n    addLine(\r\n      `${expectedCardinality}${q(key, false)} ${operator} ${\r\n        wrapAssertExists ? \"assert_exists(\" : \"\"\r\n      }${\r\n        renderedExpr.includes(\"\\n\")\r\n          ? `(\\n${indent(\r\n              renderedExpr[0] === \"(\" &&\r\n                renderedExpr[renderedExpr.length - 1] === \")\"\r\n                ? renderedExpr.slice(1, -1)\r\n                : renderedExpr,\r\n              4\r\n            )}\\n  )`\r\n          : renderedExpr\r\n      }${wrapAssertExists ? \")\" : \"\"}`\r\n    );\r\n  }\r\n\r\n  if (lines.length === 0 && injectImplicitId) {\r\n    addLine(\"id\");\r\n  }\r\n  return keysOnly ? `{${lines.join(\", \")}}` : `{\\n${lines.join(\",\\n\")}\\n}`;\r\n}\r\n\r\nfunction topoSortWithVars(\r\n  vars: Set<SomeExpression>,\r\n  ctx: RenderCtx\r\n): SomeExpression[] {\r\n  if (!vars.size) {\r\n    return [];\r\n  }\r\n\r\n  const sorted: SomeExpression[] = [];\r\n\r\n  const unvisited = new Set(vars);\r\n  const visiting = new Set<SomeExpression>();\r\n\r\n  for (const withVar of unvisited) {\r\n    visit(withVar);\r\n  }\r\n\r\n  function visit(withVar: SomeExpression): void {\r\n    if (!unvisited.has(withVar)) {\r\n      return;\r\n    }\r\n    if (visiting.has(withVar)) {\r\n      throw new Error(`'WITH' variables contain a cyclic dependency`);\r\n    }\r\n\r\n    visiting.add(withVar);\r\n\r\n    for (const child of ctx.withVars.get(withVar)!.childExprs) {\r\n      if (vars.has(child)) {\r\n        visit(child);\r\n      }\r\n    }\r\n\r\n    visiting.delete(withVar);\r\n    unvisited.delete(withVar);\r\n\r\n    sorted.push(withVar);\r\n  }\r\n  return sorted;\r\n}\r\n\r\nconst numericalTypes: Record<string, boolean> = {\r\n  \"std::number\": true,\r\n  \"std::int16\": true,\r\n  \"std::int32\": true,\r\n  \"std::int64\": true,\r\n  \"std::float32\": true,\r\n  \"std::float64\": true,\r\n};\r\n\r\nfunction literalToEdgeQL(type: BaseType, val: any): string {\r\n  const typename = (type as any).__casttype__?.__name__ ?? type.__name__;\r\n  let skipCast = false;\r\n  let stringRep;\r\n  if (typename === \"std::json\") {\r\n    skipCast = true;\r\n    stringRep = `to_json($$${JSON.stringify(val)}$$)`;\r\n  } else if (typeof val === \"string\") {\r\n    if (numericalTypes[typename]) {\r\n      skipCast = typename === type.__name__;\r\n      stringRep = val;\r\n    } else if (type.__kind__ === TypeKind.enum) {\r\n      skipCast = true;\r\n      const vals = (type as EnumType).__values__;\r\n      if (vals.includes(val)) {\r\n        skipCast = true;\r\n        if (val.includes(\" \")) {\r\n          stringRep = `<${type.__name__}>\"${val}\"`;\r\n        } else {\r\n          stringRep = `${type.__name__}.${q(val)}`;\r\n        }\r\n      } else {\r\n        throw new Error(\r\n          `Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`\r\n        );\r\n      }\r\n    } else {\r\n      if (typename === \"std::str\") {\r\n        skipCast = true;\r\n      }\r\n      stringRep = JSON.stringify(val);\r\n    }\r\n  } else if (typeof val === \"number\") {\r\n    if (numericalTypes[typename]) {\r\n      skipCast = typename === type.__name__;\r\n    } else {\r\n      throw new Error(`Unknown numerical type: ${type.__name__}!`);\r\n    }\r\n    stringRep = `${val.toString()}`;\r\n  } else if (typeof val === \"boolean\") {\r\n    stringRep = `${val.toString()}`;\r\n    skipCast = true;\r\n  } else if (typeof val === \"bigint\") {\r\n    stringRep = `${val.toString()}n`;\r\n  } else if (Array.isArray(val)) {\r\n    skipCast = val.length !== 0;\r\n    if (isArrayType(type)) {\r\n      stringRep = `[${val\r\n        .map((el) => literalToEdgeQL(type.__element__ as any, el))\r\n        .join(\", \")}]`;\r\n    } else if (isTupleType(type)) {\r\n      stringRep = `( ${val\r\n        .map((el, j) => literalToEdgeQL(type.__items__[j] as any, el))\r\n        .join(\", \")}${type.__items__.length === 1 ? \",\" : \"\"} )`;\r\n    } else {\r\n      throw new Error(\r\n        `Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`\r\n      );\r\n    }\r\n  } else if (val instanceof Date) {\r\n    stringRep = `'${val.toISOString()}'`;\r\n  } else if (\r\n    val instanceof LocalDate ||\r\n    val instanceof LocalDateTime ||\r\n    val instanceof LocalTime ||\r\n    val instanceof Duration ||\r\n    val instanceof RelativeDuration ||\r\n    val instanceof DateDuration\r\n  ) {\r\n    stringRep = `'${val.toString()}'`;\r\n  } else if (val instanceof Uint8Array) {\r\n    stringRep = bufferToStringRep(val);\r\n    skipCast = true;\r\n  } else if (val instanceof Float32Array) {\r\n    stringRep = `[${val.join(\",\")}]`;\r\n  } else if (val instanceof Range) {\r\n    const elType = (type as RangeType).__element__;\r\n\r\n    // actual type will be inferred from\r\n    // defined value\r\n    const elTypeName =\r\n      elType.__name__ === \"std::number\" ? \"std::int64\" : elType.__name__;\r\n\r\n    return `std::range(${\r\n      val.lower === null\r\n        ? `<${elTypeName}>{}`\r\n        : literalToEdgeQL(elType, val.lower)\r\n    }, ${\r\n      val.upper === null\r\n        ? `<${elTypeName}>{}`\r\n        : literalToEdgeQL(elType, val.upper)\r\n    }, inc_lower := ${val.incLower}, inc_upper := ${val.incUpper})`;\r\n  } else if (typeof val === \"object\") {\r\n    if (isNamedTupleType(type)) {\r\n      stringRep = `( ${Object.entries(val).map(\r\n        ([key, value]) =>\r\n          `${key} := ${literalToEdgeQL(type.__shape__[key]!, value)}`\r\n      )} )`;\r\n      skipCast = true;\r\n    } else {\r\n      throw new Error(\r\n        `Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`\r\n      );\r\n    }\r\n  } else {\r\n    throw new Error(\r\n      `Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`\r\n    );\r\n  }\r\n  if (skipCast) {\r\n    return stringRep;\r\n  }\r\n  return `<${type.__name__}>${stringRep}`;\r\n}\r\n\r\nfunction indent(str: string, depth: number) {\r\n  return str\r\n    .split(\"\\n\")\r\n    .map((line) => \" \".repeat(depth) + line)\r\n    .join(\"\\n\");\r\n}\r\n\r\n// backtick quote identifiers if needed\r\n// https://github.com/edgedb/edgedb/blob/master/edb/edgeql/quote.py\r\nfunction q(ident: string, allowBacklinks: boolean = true): string {\r\n  if (\r\n    !ident ||\r\n    ident.startsWith(\"@\") ||\r\n    (allowBacklinks && (ident.startsWith(\"<\") || ident.includes(\"::\")))\r\n  ) {\r\n    return ident;\r\n  }\r\n\r\n  const isAlphaNum = /^([^\\W\\d]\\w*|([1-9]\\d*|0))$/.test(ident);\r\n  if (isAlphaNum) {\r\n    const lident = ident.toLowerCase();\r\n    const isReserved =\r\n      lident !== \"__type__\" &&\r\n      lident !== \"__std__\" &&\r\n      reservedKeywords.has(lident);\r\n\r\n    if (!isReserved) {\r\n      return ident;\r\n    }\r\n  }\r\n\r\n  return \"`\" + ident.replace(/`/g, \"``\") + \"`\";\r\n}\r\n\r\nfunction bufferToStringRep(buf: Uint8Array): string {\r\n  let stringRep = \"\";\r\n  for (const byte of buf) {\r\n    if (byte < 32 || byte > 126) {\r\n      // non printable ascii\r\n      switch (byte) {\r\n        case 8:\r\n          stringRep += \"\\\\b\";\r\n          break;\r\n        case 9:\r\n          stringRep += \"\\\\t\";\r\n          break;\r\n        case 10:\r\n          stringRep += \"\\\\n\";\r\n          break;\r\n        case 12:\r\n          stringRep += \"\\\\f\";\r\n          break;\r\n        case 13:\r\n          stringRep += \"\\\\r\";\r\n          break;\r\n        default:\r\n          stringRep += `\\\\x${byte.toString(16).padStart(2, \"0\")}`;\r\n      }\r\n    } else {\r\n      stringRep +=\r\n        (byte === 39 || byte === 92 ? \"\\\\\" : \"\") + String.fromCharCode(byte);\r\n    }\r\n  }\r\n  return `b'${stringRep}'`;\r\n}\r\n\r\nfunction getErrorHint(expr: any): string {\r\n  let literalConstructor: string | null = null;\r\n  switch (typeof expr) {\r\n    case \"string\":\r\n      literalConstructor = \"e.str()\";\r\n      break;\r\n    case \"number\":\r\n      literalConstructor = Number.isInteger(expr) ? \"e.int64()\" : \"e.float64()\";\r\n      break;\r\n    case \"bigint\":\r\n      literalConstructor = \"e.bigint()\";\r\n      break;\r\n    case \"boolean\":\r\n      literalConstructor = \"e.bool()\";\r\n      break;\r\n  }\r\n  switch (true) {\r\n    case expr instanceof Date:\r\n      literalConstructor = \"e.datetime()\";\r\n      break;\r\n    case expr instanceof Duration:\r\n      literalConstructor = \"e.duration()\";\r\n      break;\r\n    case expr instanceof LocalDate:\r\n      literalConstructor = \"e.cal.local_date()\";\r\n      break;\r\n    case expr instanceof LocalDateTime:\r\n      literalConstructor = \"e.cal.local_datetime()\";\r\n      break;\r\n    case expr instanceof LocalTime:\r\n      literalConstructor = \"e.cal.local_time()\";\r\n      break;\r\n    case expr instanceof RelativeDuration:\r\n      literalConstructor = \"e.cal.relative_duration()\";\r\n      break;\r\n    case expr instanceof DateDuration:\r\n      literalConstructor = \"e.cal.date_duration()\";\r\n      break;\r\n  }\r\n\r\n  return literalConstructor\r\n    ? `\\nHint: Maybe you meant to wrap the value in ` +\r\n        `a '${literalConstructor}' expression?`\r\n    : \"\";\r\n}\r\n"},{"path":"typesystem.ts","content":"import type { Executor } from \"edgedb/dist/ifaces\";\r\nimport type { $expr_PathNode, $expr_TypeIntersection, $pathify } from \"./path\";\r\nimport type { $expr_Literal } from \"./literal\";\r\nimport type { $expr_Operator } from \"./funcops\";\r\nimport type {\r\n  typeutil,\r\n  Cardinality,\r\n  ExpressionKind,\r\n} from \"edgedb/dist/reflection/index\";\r\nimport { TypeKind } from \"edgedb/dist/reflection/index\";\r\nimport type { cardutil } from \"./cardinality\";\r\nimport type { Range, MultiRange } from \"edgedb\";\r\n\r\n//////////////////\r\n// BASETYPE\r\n//////////////////\r\n\r\nexport interface BaseType {\r\n  __kind__: TypeKind;\r\n  __name__: string;\r\n}\r\nexport type BaseTypeSet = {\r\n  __element__: BaseType;\r\n  __cardinality__: Cardinality;\r\n};\r\nexport type BaseTypeTuple = typeutil.tupleOf<BaseType>;\r\n\r\n//////////////////\r\n// SCALARTYPE\r\n//////////////////\r\n\r\nexport interface ScalarType<\r\n  Name extends string = string,\r\n  TsType = any,\r\n  TsArgType = TsType,\r\n  TsConstType extends TsType = TsType\r\n> extends BaseType {\r\n  __kind__: TypeKind.scalar;\r\n  __tstype__: TsType;\r\n  __tsargtype__: TsArgType;\r\n  __tsconsttype__: TsConstType;\r\n  __name__: Name;\r\n}\r\n\r\nexport type scalarTypeWithConstructor<\r\n  S extends ScalarType,\r\n  ExtraTsTypes = never\r\n> = S & {\r\n  // tslint:disable-next-line\r\n  <T extends S[\"__tstype__\"] | ExtraTsTypes>(val: T): $expr_Literal<\r\n    Omit<S, \"__tsconsttype__\"> & {\r\n      __tsconsttype__: T extends S[\"__tstype__\"] ? T : S[\"__tstype__\"];\r\n    }\r\n  >;\r\n};\r\n\r\ntype $jsonDestructure<Set extends TypeSet> =\r\n  Set[\"__element__\"] extends ScalarType<\"std::json\">\r\n    ? {\r\n        [path: string]: $expr_Operator<\r\n          // \"[]\",\r\n          // OperatorKind.Infix,\r\n          // [Set, TypeSet],\r\n          // TypeSet<\r\n          Set[\"__element__\"],\r\n          Set[\"__cardinality__\"]\r\n          // >\r\n        >;\r\n      } & {\r\n        destructure<T extends TypeSet<ScalarType<\"std::str\">> | string>(\r\n          path: T\r\n        ): $expr_Operator<\r\n          // \"[]\",\r\n          // OperatorKind.Infix,\r\n          // [Set, TypeSet],\r\n          // TypeSet<\r\n          Set[\"__element__\"],\r\n          cardutil.multiplyCardinalities<\r\n            Set[\"__cardinality__\"],\r\n            T extends TypeSet ? T[\"__cardinality__\"] : Cardinality.One\r\n          >\r\n          // >\r\n        >;\r\n      }\r\n    : unknown;\r\n\r\n////////////////////\r\n// SETS AND EXPRESSIONS\r\n////////////////////\r\n\r\nexport interface TypeSet<\r\n  T extends BaseType = BaseType,\r\n  Card extends Cardinality = Cardinality\r\n> {\r\n  __element__: T;\r\n  __cardinality__: Card;\r\n}\r\n\r\n// utility function for creating set\r\nexport function $toSet<Root extends BaseType, Card extends Cardinality>(\r\n  root: Root,\r\n  card: Card\r\n): TypeSet<Root, Card> {\r\n  return {\r\n    __element__: root,\r\n    __cardinality__: card,\r\n  };\r\n}\r\n\r\nexport type Expression<\r\n  Set extends TypeSet = TypeSet,\r\n  Runnable extends boolean = true\r\n> = Set &\r\n  (BaseType extends Set[\"__element__\"] // short-circuit non-specific types\r\n    ? {\r\n        run(cxn: Executor): any;\r\n        runJSON(cxn: Executor): any;\r\n        toEdgeQL(): string;\r\n        is: any;\r\n        assert_single: any;\r\n        // warning: any;\r\n      }\r\n    : $pathify<Set> &\r\n        ExpressionMethods<stripSet<Set>> &\r\n        (Runnable extends true\r\n          ? {\r\n              run(cxn: Executor): Promise<setToTsType<Set>>;\r\n              runJSON(cxn: Executor): Promise<string>;\r\n            }\r\n          : {}) &\r\n        $tuplePathify<Set> &\r\n        $arrayLikeIndexify<Set> &\r\n        $jsonDestructure<Set>);\r\n\r\nexport type stripSet<T> = \"__element__\" extends keyof T\r\n  ? \"__cardinality__\" extends keyof T\r\n    ? {\r\n        __element__: T[\"__element__\"];\r\n        __cardinality__: T[\"__cardinality__\"];\r\n      }\r\n    : T\r\n  : T;\r\n\r\n// export type stripSet<T> = T extends {__element__: any; __cardinality__: any}\r\n//   ? {\r\n//       __element__: T[\"__element__\"];\r\n//       __cardinality__: T[\"__cardinality__\"];\r\n//     }\r\n//   : any;\r\n\r\nexport type stripSetShape<T> = {\r\n  [k in keyof T]: stripSet<T[k]>;\r\n};\r\n\r\n// importing the actual alias from\r\n// generated/modules/std didn't work.\r\n// returned 'any' every time\r\nexport type assert_single<\r\n  El extends BaseType,\r\n  Card extends Cardinality\r\n> = Expression<{\r\n  __element__: El; // [\"__element__\"];\r\n  __cardinality__: Card; // cardutil.overrideUpperBound<\r\n  // Expr[\"__cardinality__\"], \"One\"\r\n  // >;\r\n  __kind__: ExpressionKind.Function;\r\n  __name__: \"std::assert_single\";\r\n  __args__: TypeSet[]; // discard wrapped expression\r\n  __namedargs__: {};\r\n}>;\r\n\r\nexport type ExpressionMethods<Set extends TypeSet> = {\r\n  toEdgeQL(): string;\r\n\r\n  is<T extends ObjectTypeSet>(\r\n    ixn: T\r\n  ): $expr_TypeIntersection<\r\n    Set[\"__cardinality__\"],\r\n    // might cause performance issues\r\n    ObjectType<\r\n      T[\"__element__\"][\"__name__\"],\r\n      T[\"__element__\"][\"__pointers__\"],\r\n      { id: true }\r\n    >\r\n  >;\r\n  assert_single(): assert_single<\r\n    Set[\"__element__\"],\r\n    Cardinality.AtMostOne\r\n    // cardutil.overrideUpperBound<Set[\"__cardinality__\"], \"One\">\r\n  >;\r\n};\r\n\r\n//////////////////\r\n// ENUMTYPE\r\n//////////////////\r\nexport interface EnumType<\r\n  Name extends string = string,\r\n  Values extends [string, ...string[]] = [string, ...string[]]\r\n> extends BaseType {\r\n  __kind__: TypeKind.enum;\r\n  __tstype__: Values[number];\r\n  __name__: Name;\r\n  __values__: Values;\r\n}\r\n\r\n//////////////////\r\n// OBJECTTYPE\r\n//////////////////\r\n\r\nexport type ObjectTypeSet = TypeSet<ObjectType, Cardinality>;\r\nexport type ObjectTypeExpression = TypeSet<ObjectType, Cardinality>;\r\n\r\nexport type ExclusiveTuple = typeutil.tupleOf<{\r\n  [k: string]: TypeSet;\r\n}>;\r\nexport interface ObjectType<\r\n  Name extends string = string,\r\n  Pointers extends ObjectTypePointers = ObjectTypePointers,\r\n  Shape extends object | null = any,\r\n  Exclusives extends ExclusiveTuple = ExclusiveTuple\r\n  // Polys extends Poly[] = any[]\r\n> extends BaseType {\r\n  __kind__: TypeKind.object;\r\n  __name__: Name;\r\n  __pointers__: Pointers;\r\n  __shape__: Shape;\r\n  __exclusives__: Exclusives;\r\n}\r\n\r\nexport type PropertyTypes =\r\n  | ScalarType\r\n  | EnumType\r\n  | ArrayType\r\n  | TupleType\r\n  | NamedTupleType;\r\n\r\nexport type SomeType =\r\n  | ScalarType\r\n  | EnumType\r\n  | ArrayType\r\n  | TupleType\r\n  | ObjectType\r\n  | NamedTupleType\r\n  | RangeType\r\n  | MultiRangeType;\r\n\r\nexport interface PropertyDesc<\r\n  Type extends BaseType = BaseType,\r\n  Card extends Cardinality = Cardinality,\r\n  Exclusive extends boolean = boolean,\r\n  Computed extends boolean = boolean,\r\n  Readonly extends boolean = boolean,\r\n  HasDefault extends boolean = boolean\r\n> {\r\n  __kind__: \"property\";\r\n  target: Type;\r\n  cardinality: Card;\r\n  exclusive: Exclusive;\r\n  computed: Computed;\r\n  readonly: Readonly;\r\n  hasDefault: HasDefault;\r\n}\r\n\r\nexport type $scopify<Type extends ObjectType> = $expr_PathNode<\r\n  TypeSet<Type, Cardinality.One>\r\n  // null,\r\n  // true // exclusivity\r\n>;\r\n\r\nexport type PropertyShape = {\r\n  [k: string]: PropertyDesc;\r\n};\r\n\r\nexport interface LinkDesc<\r\n  Type extends ObjectType = any,\r\n  Card extends Cardinality = Cardinality,\r\n  LinkProps extends PropertyShape = any,\r\n  Exclusive extends boolean = boolean,\r\n  Computed extends boolean = boolean,\r\n  Readonly extends boolean = boolean,\r\n  HasDefault extends boolean = boolean\r\n> {\r\n  __kind__: \"link\";\r\n  target: Type;\r\n  cardinality: Card;\r\n  properties: LinkProps;\r\n  exclusive: Exclusive;\r\n  computed: Computed;\r\n  readonly: Readonly;\r\n  hasDefault: HasDefault;\r\n}\r\n\r\nexport type ObjectTypePointers = {\r\n  [k: string]: PropertyDesc | LinkDesc;\r\n};\r\n\r\nexport type stripBacklinks<T extends ObjectTypePointers> = {\r\n  [k in keyof T]: k extends `<${string}` ? never : T[k];\r\n};\r\n\r\nexport type omitBacklinks<T extends string | number | symbol> =\r\n  T extends `<${string}` ? never : T extends string ? T : never;\r\n\r\nexport type stripNonUpdateables<T extends ObjectTypePointers> = {\r\n  [k in keyof T]: [T[k][\"computed\"]] extends [true]\r\n    ? never\r\n    : [T[k][\"readonly\"]] extends [true]\r\n    ? never\r\n    : k extends \"__type__\"\r\n    ? never\r\n    : k extends \"id\"\r\n    ? never\r\n    : T[k];\r\n};\r\n\r\nexport type stripNonInsertables<T extends ObjectTypePointers> = {\r\n  [k in keyof T]: [T[k][\"computed\"]] extends [true]\r\n    ? never\r\n    : [k] extends [\"__type__\"]\r\n    ? never\r\n    : T[k];\r\n};\r\n\r\ntype shapeElementToTs<Pointer extends PropertyDesc | LinkDesc, Element> = [\r\n  Element\r\n] extends [true]\r\n  ? pointerToTsType<Pointer>\r\n  : [Element] extends [false]\r\n  ? never\r\n  : [Element] extends [boolean]\r\n  ? pointerToTsType<Pointer> | undefined\r\n  : Element extends TypeSet\r\n  ? setToTsType<TypeSet<Element[\"__element__\"], Pointer[\"cardinality\"]>>\r\n  : Pointer extends LinkDesc\r\n  ? Element extends object\r\n    ? computeTsTypeCard<\r\n        computeObjectShape<\r\n          Pointer[\"target\"][\"__pointers__\"] & Pointer[\"properties\"],\r\n          Element\r\n        >,\r\n        Pointer[\"cardinality\"]\r\n      >\r\n    : never\r\n  : never;\r\n\r\n// Element extends (scope: any) => any\r\n// ? Pointer[\"target\"] extends ObjectType\r\n//   ? computeObjectShape<\r\n//       Pointer[\"target\"][\"__pointers__\"],\r\n//       ReturnType<Element>\r\n//     >\r\n//   : never\r\n// : Element extends object\r\n// ? Pointer[\"target\"] extends ObjectType\r\n//   ? computeObjectShape<Pointer[\"target\"][\"__pointers__\"], Element>\r\n//   : never\r\n// : never;\r\n\r\nexport type $expr_PolyShapeElement<\r\n  PolyType extends ObjectTypeSet = ObjectTypeSet,\r\n  ShapeElement extends any = any\r\n> = {\r\n  __kind__: ExpressionKind.PolyShapeElement;\r\n  __polyType__: PolyType;\r\n  __shapeElement__: ShapeElement;\r\n};\r\n\r\nexport type computeObjectShape<\r\n  Pointers extends ObjectTypePointers,\r\n  Shape\r\n> = typeutil.flatten<\r\n  keyof Shape extends never\r\n    ? { id: string }\r\n    : {\r\n        [k in keyof Shape]: Shape[k] extends $expr_PolyShapeElement<\r\n          infer PolyType,\r\n          infer ShapeEl\r\n        >\r\n          ? [k] extends [keyof PolyType[\"__element__\"][\"__pointers__\"]]\r\n            ? shapeElementToTs<\r\n                PolyType[\"__element__\"][\"__pointers__\"][k],\r\n                ShapeEl\r\n              > | null\r\n            : never\r\n          : [k] extends [keyof Pointers]\r\n          ? shapeElementToTs<Pointers[k], Shape[k]>\r\n          : Shape[k] extends TypeSet\r\n          ? setToTsType<Shape[k]>\r\n          : never;\r\n      }\r\n>;\r\n\r\nexport type pointerToTsTypeSimple<El extends PropertyDesc | LinkDesc> =\r\n  El extends PropertyDesc\r\n    ? propToTsType<El>\r\n    : El extends LinkDesc<any, any, any, any>\r\n    ? { id: string }\r\n    : never;\r\n\r\nexport type PrimitiveType =\r\n  | ScalarType\r\n  | EnumType\r\n  | TupleType\r\n  | NamedTupleType\r\n  | ArrayType\r\n  | RangeType\r\n  | MultiRangeType;\r\n\r\nexport type PrimitiveTypeSet = TypeSet<PrimitiveType, Cardinality>;\r\n\r\n/////////////////////////\r\n/// ARRAYTYPE\r\n/////////////////////////\r\n\r\ntype $arrayLikeIndexify<Set extends TypeSet> = Set[\"__element__\"] extends\r\n  | ArrayType\r\n  | ScalarType<\"std::str\">\r\n  | ScalarType<\"std::bytes\">\r\n  ? {\r\n      [index: number]: $expr_Operator<\r\n        // \"[]\",\r\n        // OperatorKind.Infix,\r\n        // [Set, TypeSet],\r\n        // TypeSet<\r\n        getPrimitiveBaseType<\r\n          Set[\"__element__\"] extends ArrayType<infer El>\r\n            ? El\r\n            : Set[\"__element__\"]\r\n        >,\r\n        Set[\"__cardinality__\"]\r\n        // >\r\n      >;\r\n      [slice: `${number}:${number | \"\"}` | `:${number}`]: $expr_Operator<\r\n        // \"[]\",\r\n        // OperatorKind.Infix,\r\n        // [Set, TypeSet],\r\n        // TypeSet<\r\n        getPrimitiveBaseType<Set[\"__element__\"]>,\r\n        Set[\"__cardinality__\"]\r\n        // >\r\n      >;\r\n      index<T extends TypeSet<ScalarType<\"std::number\">> | number>(\r\n        index: T\r\n      ): $expr_Operator<\r\n        // \"[]\",\r\n        // OperatorKind.Infix,\r\n        // [Set, TypeSet],\r\n        // TypeSet<\r\n        getPrimitiveBaseType<\r\n          Set[\"__element__\"] extends ArrayType<infer El>\r\n            ? El\r\n            : Set[\"__element__\"]\r\n        >,\r\n        cardutil.multiplyCardinalities<\r\n          Set[\"__cardinality__\"],\r\n          T extends TypeSet ? T[\"__cardinality__\"] : Cardinality.One\r\n        >\r\n        // >\r\n      >;\r\n      slice<\r\n        S extends TypeSet<ScalarType<\"std::number\">> | number,\r\n        E extends TypeSet<ScalarType<\"std::number\">> | number | undefined | null\r\n      >(\r\n        start: S,\r\n        end: E\r\n      ): $expr_Operator<\r\n        // \"[]\",\r\n        // OperatorKind.Infix,\r\n        // [Set, TypeSet],\r\n        // TypeSet<\r\n        getPrimitiveBaseType<Set[\"__element__\"]>,\r\n        cardutil.multiplyCardinalities<\r\n          cardutil.multiplyCardinalities<\r\n            Set[\"__cardinality__\"],\r\n            S extends TypeSet ? S[\"__cardinality__\"] : Cardinality.One\r\n          >,\r\n          E extends TypeSet<any, infer C> ? C : Cardinality.One\r\n        >\r\n        // >\r\n      >;\r\n      slice<\r\n        E extends TypeSet<ScalarType<\"std::number\">> | number | undefined | null\r\n      >(\r\n        start: undefined | null,\r\n        end: E\r\n      ): $expr_Operator<\r\n        // \"[]\",\r\n        // OperatorKind.Infix,\r\n        // [Set, TypeSet],\r\n        // TypeSet<\r\n        getPrimitiveBaseType<Set[\"__element__\"]>,\r\n        cardutil.multiplyCardinalities<\r\n          Set[\"__cardinality__\"],\r\n          E extends TypeSet<any, infer C> ? C : Cardinality.One\r\n        >\r\n        // >\r\n      >;\r\n    }\r\n  : unknown;\r\n\r\nexport type $expr_Array<\r\n  Type extends ArrayType = ArrayType,\r\n  Card extends Cardinality = Cardinality\r\n  // Items extends typeutil.tupleOf<TypeSet<Type>>\r\n> = Expression<{\r\n  __kind__: ExpressionKind.Array;\r\n  __items__: typeutil.tupleOf<TypeSet<Type[\"__element__\"]>>;\r\n  __element__: Type;\r\n  __cardinality__: Card;\r\n}>;\r\n\r\nexport interface ArrayType<\r\n  Element extends BaseType = BaseType,\r\n  Name extends string = `array<${Element[\"__name__\"]}>`\r\n> extends BaseType {\r\n  __name__: Name;\r\n  __kind__: TypeKind.array;\r\n  __element__: Element;\r\n}\r\n\r\ntype ArrayTypeToTsType<\r\n  Type extends ArrayType,\r\n  isParam extends boolean = false\r\n> = BaseTypeToTsType<Type[\"__element__\"], isParam>[];\r\n\r\n/////////////////////////\r\n/// TUPLE TYPE\r\n/////////////////////////\r\n\r\ntype $tuplePathify<Set extends TypeSet> = Set[\"__element__\"] extends TupleType\r\n  ? addTuplePaths<Set[\"__element__\"][\"__items__\"], Set[\"__cardinality__\"]>\r\n  : Set[\"__element__\"] extends NamedTupleType\r\n  ? addNamedTuplePaths<Set[\"__element__\"][\"__shape__\"], Set[\"__cardinality__\"]>\r\n  : unknown;\r\n\r\nexport type $expr_TuplePath<\r\n  ItemType extends BaseType = BaseType,\r\n  ParentCard extends Cardinality = Cardinality\r\n> = Expression<{\r\n  __kind__: ExpressionKind.TuplePath;\r\n  __element__: ItemType;\r\n  __cardinality__: ParentCard;\r\n  __parent__: $expr_Tuple | $expr_NamedTuple | $expr_TuplePath;\r\n  __index__: string | number;\r\n}>;\r\n\r\nexport type baseTupleElementsToTupleType<T extends typeutil.tupleOf<TypeSet>> =\r\n  {\r\n    [k in keyof T]: T[k] extends TypeSet\r\n      ? getPrimitiveBaseType<T[k][\"__element__\"]>\r\n      : never;\r\n  };\r\nexport type tupleElementsToTupleType<T extends typeutil.tupleOf<TypeSet>> =\r\n  baseTupleElementsToTupleType<T> extends BaseTypeTuple\r\n    ? TupleType<baseTupleElementsToTupleType<T>>\r\n    : never;\r\n\r\nexport type baseTupleElementsToCardTuple<T> = {\r\n  [k in keyof T]: T[k] extends TypeSet<any, infer C> ? C : never;\r\n};\r\n\r\nexport type tupleElementsToCardTuple<T> =\r\n  baseTupleElementsToCardTuple<T> extends [Cardinality, ...Cardinality[]]\r\n    ? baseTupleElementsToCardTuple<T>\r\n    : never;\r\n\r\nexport type $expr_Tuple<\r\n  Items extends typeutil.tupleOf<TypeSet> = typeutil.tupleOf<TypeSet>\r\n> = Expression<{\r\n  __kind__: ExpressionKind.Tuple;\r\n  __items__: typeutil.tupleOf<TypeSet>;\r\n  __element__: tupleElementsToTupleType<Items>;\r\n  __cardinality__: cardutil.multiplyCardinalitiesVariadic<\r\n    tupleElementsToCardTuple<Items>\r\n  >;\r\n}>;\r\n\r\nexport type indexKeys<T> = T extends `${number}` ? T : never;\r\n\r\ntype addTuplePaths<Items extends BaseType[], ParentCard extends Cardinality> = {\r\n  [k in indexKeys<keyof Items>]: Items[k] extends BaseType\r\n    ? $expr_TuplePath<Items[k], ParentCard>\r\n    : never;\r\n};\r\n\r\nexport interface TupleType<Items extends BaseTypeTuple = BaseTypeTuple>\r\n  extends BaseType {\r\n  __name__: string;\r\n  __kind__: TypeKind.tuple;\r\n  __items__: Items;\r\n}\r\n\r\ntype TupleItemsToTsType<\r\n  Items extends BaseTypeTuple,\r\n  isParam extends boolean = false\r\n> = {\r\n  [k in keyof Items]: Items[k] extends BaseType\r\n    ? BaseTypeToTsType<Items[k], isParam>\r\n    : never;\r\n};\r\n\r\n/////////////////////////\r\n/// NAMED TUPLE TYPE\r\n/////////////////////////\r\ntype literalShapeToType<T extends NamedTupleLiteralShape> = NamedTupleType<{\r\n  [k in keyof T]: getPrimitiveBaseType<T[k][\"__element__\"]>;\r\n}>;\r\ntype shapeCardinalities<Shape extends NamedTupleLiteralShape> =\r\n  Shape[keyof Shape][\"__cardinality__\"];\r\ntype inferNamedTupleCardinality<Shape extends NamedTupleLiteralShape> = [\r\n  Cardinality.Many\r\n] extends [shapeCardinalities<Shape>]\r\n  ? Cardinality.Many\r\n  : [Cardinality.Empty] extends [shapeCardinalities<Shape>]\r\n  ? Cardinality.Empty\r\n  : [shapeCardinalities<Shape>] extends [Cardinality.AtMostOne]\r\n  ? Cardinality.AtMostOne\r\n  : [shapeCardinalities<Shape>] extends [\r\n      Cardinality.AtMostOne | Cardinality.One\r\n    ]\r\n  ? Cardinality.One\r\n  : Cardinality.Many;\r\n\r\nexport type $expr_NamedTuple<\r\n  Shape extends NamedTupleLiteralShape = NamedTupleLiteralShape\r\n> = Expression<{\r\n  __kind__: ExpressionKind.NamedTuple;\r\n  __element__: literalShapeToType<Shape>;\r\n  __cardinality__: inferNamedTupleCardinality<Shape>;\r\n  __shape__: Shape;\r\n}>;\r\n\r\ntype addNamedTuplePaths<\r\n  Shape extends NamedTupleShape,\r\n  ParentCard extends Cardinality\r\n> = {\r\n  [k in keyof Shape]: Shape[k] extends BaseType\r\n    ? $expr_TuplePath<Shape[k], ParentCard>\r\n    : never;\r\n};\r\n\r\nexport type NamedTupleLiteralShape = { [k: string]: TypeSet };\r\nexport type NamedTupleShape = { [k: string]: BaseType };\r\nexport interface NamedTupleType<Shape extends NamedTupleShape = NamedTupleShape>\r\n  extends BaseType {\r\n  __name__: string;\r\n  __kind__: TypeKind.namedtuple;\r\n  __shape__: Shape;\r\n}\r\n\r\ntype NamedTupleTypeToTsType<\r\n  Type extends NamedTupleType,\r\n  isParam extends boolean = false\r\n> = {\r\n  [k in keyof Type[\"__shape__\"]]: BaseTypeToTsType<\r\n    Type[\"__shape__\"][k],\r\n    isParam\r\n  >;\r\n};\r\n\r\n/////////////////////////\r\n/// RANGE TYPE\r\n/////////////////////////\r\n\r\nexport interface RangeType<\r\n  Element extends ScalarType = ScalarType,\r\n  Name extends string = `range<${Element[\"__name__\"]}>`\r\n> extends BaseType {\r\n  __name__: Name;\r\n  __kind__: TypeKind.range;\r\n  __element__: Element;\r\n}\r\n\r\n/////////////////////////\r\n/// MULTIRANGE TYPE\r\n/////////////////////////\r\n\r\nexport interface MultiRangeType<\r\n  Element extends ScalarType = ScalarType,\r\n  Name extends string = `multirange<${Element[\"__name__\"]}>`\r\n> extends BaseType {\r\n  __name__: Name;\r\n  __kind__: TypeKind.multirange;\r\n  __element__: Element;\r\n}\r\n\r\n/////////////////////\r\n/// TSTYPE COMPUTATION\r\n/////////////////////\r\nexport type orLiteralValue<Set extends TypeSet> =\r\n  | Set\r\n  | (Set[\"__element__\"] extends ObjectType\r\n      ? never\r\n      : computeTsType<Set[\"__element__\"], Set[\"__cardinality__\"]>);\r\n\r\nexport type BaseTypeToTsType<\r\n  Type extends BaseType,\r\n  isParam extends boolean = false\r\n> = Type extends ScalarType\r\n  ? isParam extends true\r\n    ? Type[\"__tsargtype__\"]\r\n    : Type[\"__tsconsttype__\"]\r\n  : Type extends EnumType\r\n  ? Type[\"__tstype__\"]\r\n  : Type extends ArrayType<any>\r\n  ? ArrayTypeToTsType<Type, isParam>\r\n  : Type extends RangeType\r\n  ? Range<Type[\"__element__\"][\"__tsconsttype__\"]>\r\n  : Type extends MultiRangeType\r\n  ? MultiRange<Type[\"__element__\"][\"__tsconsttype__\"]>\r\n  : Type extends TupleType\r\n  ? TupleItemsToTsType<Type[\"__items__\"], isParam>\r\n  : Type extends NamedTupleType\r\n  ? typeutil.flatten<NamedTupleTypeToTsType<Type, isParam>>\r\n  : Type extends ObjectType\r\n  ? typeutil.flatten<\r\n      computeObjectShape<Type[\"__pointers__\"], Type[\"__shape__\"]>\r\n    >\r\n  : never;\r\n\r\nexport type setToTsType<Set extends TypeSet> = computeTsType<\r\n  Set[\"__element__\"],\r\n  Set[\"__cardinality__\"]\r\n>;\r\n\r\nexport type computeTsTypeCard<\r\n  T extends any,\r\n  C extends Cardinality\r\n> = Cardinality extends C\r\n  ? unknown\r\n  : C extends Cardinality.Empty\r\n  ? null\r\n  : C extends Cardinality.One\r\n  ? T\r\n  : C extends Cardinality.AtLeastOne\r\n  ? [T, ...T[]]\r\n  : C extends Cardinality.AtMostOne\r\n  ? T | null\r\n  : C extends Cardinality.Many\r\n  ? T[]\r\n  : C extends Cardinality\r\n  ? unknown\r\n  : never;\r\n\r\nexport type computeTsType<\r\n  T extends BaseType,\r\n  C extends Cardinality\r\n> = BaseType extends T ? unknown : computeTsTypeCard<BaseTypeToTsType<T>, C>;\r\n\r\nexport type propToTsType<Prop extends PropertyDesc> = Prop extends PropertyDesc<\r\n  infer Type,\r\n  infer Card\r\n>\r\n  ? setToTsType<TypeSet<Type, Card>>\r\n  : never;\r\n\r\nexport type linkToTsType<Link extends LinkDesc> = computeTsType<\r\n  Link[\"target\"],\r\n  Link[\"cardinality\"]\r\n>;\r\n\r\nexport type pointerToTsType<El extends PropertyDesc | LinkDesc> =\r\n  El extends PropertyDesc\r\n    ? propToTsType<El>\r\n    : El extends LinkDesc<any, any, any, any>\r\n    ? linkToTsType<El>\r\n    : never;\r\n\r\n///////////////////\r\n// TYPE HELPERS\r\n///////////////////\r\n\r\nexport type getPrimitiveBaseType<T extends BaseType> = T extends ScalarType\r\n  ? ScalarType<T[\"__name__\"], T[\"__tstype__\"], T[\"__tsargtype__\"]>\r\n  : T;\r\n\r\nexport type getPrimitiveNonArrayBaseType<T extends BaseType> =\r\n  T extends ArrayType ? never : getPrimitiveBaseType<T>;\r\n\r\nexport function isScalarType(type: BaseType): type is ScalarType {\r\n  return type.__kind__ === TypeKind.scalar;\r\n}\r\nexport function isEnumType(type: BaseType): type is EnumType {\r\n  return type.__kind__ === TypeKind.enum;\r\n}\r\nexport function isObjectType(type: BaseType): type is ObjectType {\r\n  return type.__kind__ === TypeKind.object;\r\n}\r\nexport function isTupleType(type: BaseType): type is TupleType {\r\n  return type.__kind__ === TypeKind.tuple;\r\n}\r\nexport function isNamedTupleType(type: BaseType): type is NamedTupleType {\r\n  return type.__kind__ === TypeKind.namedtuple;\r\n}\r\nexport function isArrayType(type: BaseType): type is ArrayType {\r\n  return type.__kind__ === TypeKind.array;\r\n}\r\n\r\nexport type NonArrayType =\r\n  | ScalarType\r\n  | EnumType\r\n  | ObjectType\r\n  | TupleType\r\n  | NamedTupleType\r\n  | RangeType\r\n  | MultiRangeType;\r\n\r\nexport type AnyTupleType = TupleType | NamedTupleType;\r\n\r\nexport type AnyObjectType = ObjectType;\r\n\r\nexport type ParamType =\r\n  | ScalarType\r\n  | EnumType\r\n  | ArrayType<\r\n      | ScalarType\r\n      | TupleType<typeutil.tupleOf<ParamType>>\r\n      | NamedTupleType<{ [k: string]: ParamType }>\r\n      | RangeType\r\n      | MultiRangeType\r\n    >\r\n  | TupleType<typeutil.tupleOf<ParamType>>\r\n  | NamedTupleType<{ [k: string]: ParamType }>\r\n  | RangeType\r\n  | MultiRangeType;\r\n"},{"path":"update.ts","content":"import {\r\n  ExpressionKind,\r\n  type typeutil,\r\n  Cardinality,\r\n} from \"edgedb/dist/reflection/index\";\r\nimport type {\r\n  Expression,\r\n  ObjectTypePointers,\r\n  TypeSet,\r\n  ObjectTypeSet,\r\n  stripBacklinks,\r\n  stripNonUpdateables,\r\n  ObjectTypeExpression,\r\n  ObjectType,\r\n  $scopify,\r\n} from \"./typesystem\";\r\nimport type { pointerToAssignmentExpression } from \"./casting\";\r\nimport { $expressionify, $getScopedExpr, $assert_single } from \"./path\";\r\nimport {\r\n  type SelectModifiers,\r\n  type NormalisedSelectModifiers,\r\n  type ComputeSelectCardinality,\r\n  $existingScopes,\r\n  $handleModifiers,\r\n} from \"./select\";\r\nimport { $normaliseInsertShape, type pointerIsOptional } from \"./insert\";\r\n\r\n/////////////////\r\n/// UPDATE\r\n/////////////////\r\n\r\nexport type $expr_Update<\r\n  El extends ObjectType = ObjectType,\r\n  Card extends Cardinality = Cardinality\r\n  // Set extends TypeSet = TypeSet,\r\n  // Expr extends ObjectTypeSet = ObjectTypeSet,\r\n  // Shape extends UpdateShape<ObjectTypeSet> = any\r\n> = Expression<{\r\n  __kind__: ExpressionKind.Update;\r\n  __element__: El;\r\n  __cardinality__: Card;\r\n  __expr__: TypeSet;\r\n  __shape__: any;\r\n  __modifiers__: NormalisedSelectModifiers;\r\n  __scope__: ObjectTypeExpression;\r\n}>;\r\n\r\nexport type UpdateShape<Root extends ObjectTypeSet> = typeutil.stripNever<\r\n  stripNonUpdateables<stripBacklinks<Root[\"__element__\"][\"__pointers__\"]>>\r\n> extends infer Shape\r\n  ? Shape extends ObjectTypePointers\r\n    ? {\r\n        [k in keyof Shape]?:\r\n          | (\r\n              | pointerToAssignmentExpression<Shape[k]>\r\n              | (Shape[k][\"cardinality\"] extends\r\n                  | Cardinality.Many\r\n                  | Cardinality.AtLeastOne\r\n                  ?\r\n                      | { \"+=\": pointerToAssignmentExpression<Shape[k], true> }\r\n                      | { \"-=\": pointerToAssignmentExpression<Shape[k], true> }\r\n                  : never)\r\n            )\r\n          | (pointerIsOptional<Shape[k]> extends true\r\n              ? undefined | null\r\n              : never);\r\n      }\r\n    : never\r\n  : never;\r\n\r\nexport function update<\r\n  Expr extends ObjectTypeExpression,\r\n  Shape extends {\r\n    filter?: SelectModifiers[\"filter\"];\r\n    filter_single?: SelectModifiers<Expr[\"__element__\"]>[\"filter_single\"];\r\n    set: UpdateShape<Expr>;\r\n  }\r\n  // SetShape extends UpdateShape<Expr>,\r\n  // Modifiers extends Pick<SelectModifiers, \"filter\">\r\n>(\r\n  expr: Expr,\r\n  shape: (scope: $scopify<Expr[\"__element__\"]>) => Readonly<Shape>\r\n): $expr_Update<Expr[\"__element__\"], ComputeSelectCardinality<Expr, Shape>> {\r\n  const cleanScopedExprs = $existingScopes.size === 0;\r\n\r\n  const scope = $getScopedExpr(expr as any, $existingScopes);\r\n\r\n  const resolvedShape = shape(scope);\r\n\r\n  if (cleanScopedExprs) {\r\n    $existingScopes.clear();\r\n  }\r\n\r\n  const mods: any = {};\r\n  let updateShape: any | null;\r\n  for (const [key, val] of Object.entries(resolvedShape)) {\r\n    if (key === \"filter\" || key === \"filter_single\") {\r\n      mods[key] = val;\r\n    } else if (key === \"set\") {\r\n      updateShape = val;\r\n    } else {\r\n      throw new Error(\r\n        `Invalid update shape key '${key}', only 'filter', 'filter_single', ` +\r\n          `and 'set' are allowed`\r\n      );\r\n    }\r\n  }\r\n\r\n  if (!updateShape) {\r\n    throw new Error(`Update shape must contain 'set' shape`);\r\n  }\r\n\r\n  const { modifiers, cardinality, needsAssertSingle } = $handleModifiers(mods, {\r\n    root: expr,\r\n    scope,\r\n  });\r\n\r\n  const updateExpr = {\r\n    __kind__: ExpressionKind.Update,\r\n    __element__: expr.__element__,\r\n    __cardinality__: cardinality,\r\n    __expr__: expr,\r\n    __shape__: $normaliseInsertShape(expr, updateShape, true),\r\n    __modifiers__: modifiers,\r\n    __scope__: scope,\r\n  } as any;\r\n\r\n  return needsAssertSingle\r\n    ? $assert_single(updateExpr)\r\n    : $expressionify(updateExpr);\r\n}\r\n"},{"path":"with.ts","content":"import { ExpressionKind, Cardinality } from \"edgedb/dist/reflection/index\";\r\nimport type { BaseType, Expression, TypeSet } from \"./typesystem\";\r\nimport type { $expr_Select } from \"./select\";\r\nimport type { $expr_For } from \"./for\";\r\nimport type { $expr_Insert } from \"./insert\";\r\nimport type { $expr_Update } from \"./update\";\r\nimport type { $expr_Group } from \"./group\";\r\nimport { $expressionify } from \"./path\";\r\n\r\nexport type $expr_Alias<\r\n  El extends BaseType = BaseType,\r\n  Card extends Cardinality = Cardinality\r\n> = Expression<{\r\n  __element__: El;\r\n  __cardinality__: Card;\r\n  __kind__: ExpressionKind.Alias;\r\n  __expr__: TypeSet;\r\n}>;\r\n\r\nexport function alias<Expr extends Expression>(\r\n  expr: Expr\r\n): $expr_Alias<Expr[\"__element__\"], Expr[\"__cardinality__\"]> {\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.Alias,\r\n    __element__: expr.__element__,\r\n    __cardinality__: expr.__cardinality__,\r\n    __expr__: expr,\r\n  }) as any;\r\n}\r\n\r\nexport type WithableExpression =\r\n  | $expr_Select\r\n  | $expr_For\r\n  | $expr_Insert\r\n  | $expr_Update\r\n  | $expr_Group;\r\n\r\nexport type $expr_With<\r\n  // Refs extends TypeSet[] = TypeSet[],\r\n  Expr extends WithableExpression = WithableExpression\r\n> = Expression<{\r\n  __element__: Expr[\"__element__\"];\r\n  __cardinality__: Expr[\"__cardinality__\"];\r\n  __kind__: ExpressionKind.With;\r\n  __expr__: Expr;\r\n  __refs__: TypeSet[];\r\n}>;\r\n\r\nfunction _with<Expr extends WithableExpression>(\r\n  refs: Expression[],\r\n  expr: Expr\r\n): $expr_With<Expr> {\r\n  return $expressionify({\r\n    __kind__: ExpressionKind.With,\r\n    __element__: expr.__element__,\r\n    __cardinality__: expr.__cardinality__,\r\n    __refs__: refs,\r\n    __expr__: expr as any,\r\n  }) as any;\r\n}\r\n\r\nexport { _with as with };\r\n"},{"path":"__spec__.ts","content":"import type { TypeKind } from \"./reflection\";\r\n\r\nexport declare const spec: Map<string, any>;\r\n\r\nexport declare const complexParamKinds: Set<TypeKind>;\r\n"}]}